<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Croissant2097</title>
  
  <subtitle>Record &amp; Share &amp; Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-15T06:35:10.846Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>休眠排序</title>
    <link href="http://yoursite.com/2020/07/15/%E4%BC%91%E7%9C%A0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/休眠排序/</id>
    <published>2020-07-15T06:34:20.000Z</published>
    <updated>2020-07-15T06:35:10.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="史上“最强”排序-–-休眠排序"><a href="#史上“最强”排序-–-休眠排序" class="headerlink" title="史上“最强”排序 – 休眠排序"></a>史上“最强”排序 – 休眠排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepSort</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(value);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">60</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array) &#123;</span><br><span class="line">            <span class="keyword">new</span> SleepSort(item).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;史上“最强”排序-–-休眠排序&quot;&gt;&lt;a href=&quot;#史上“最强”排序-–-休眠排序&quot; class=&quot;headerlink&quot; title=&quot;史上“最强”排序 – 休眠排序&quot;&gt;&lt;/a&gt;史上“最强”排序 – 休眠排序&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="http://yoursite.com/2020/07/15/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/桶排序/</id>
    <published>2020-07-15T06:00:39.000Z</published>
    <updated>2020-07-15T06:33:20.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><h2 id="什么是桶排序"><a href="#什么是桶排序" class="headerlink" title="什么是桶排序"></a>什么是桶排序</h2><p>执行流程</p><p>① 创建一定数量的桶（比如用数组、链表作为桶）</p><p>② 按照一定的规则（不同类型的数据，规则不同），将序列中的元素均匀分配到对应的桶</p><p>③ 分别对每个桶进行单独排序</p><p>④ 将所有非空桶的元素合并成有序序列</p><p>元素在桶中的索引</p><p>元素值 * 元素数量</p><p><img src="/2020/07/15/桶排序/1.png" alt></p><h2 id="桶排序-–-实现"><a href="#桶排序-–-实现" class="headerlink" title="桶排序 – 实现"></a>桶排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] array = &#123;<span class="number">0.34</span>,<span class="number">0.47</span>,<span class="number">0.29</span>,<span class="number">0.84</span>,<span class="number">0.45</span>,<span class="number">0.38</span>,<span class="number">0.35</span>,<span class="number">0.76</span>&#125;;</span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line">List&lt;Double&gt;[] buckets = <span class="keyword">new</span> List[array.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> v : array) &#123;</span><br><span class="line">    <span class="keyword">int</span> bucketIndex = (<span class="keyword">int</span>) (v * array.length);</span><br><span class="line">    List&lt;Double&gt; bucket = buckets[bucketIndex];</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bucket = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        buckets[bucketIndex] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket.add(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每个桶进行排序</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (List&lt;Double&gt; bucket : buckets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    bucket.sort(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (Double d : bucket) &#123;</span><br><span class="line">        array[index++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n + m)$，$m$ 是桶的数量</p><p>时间复杂度：$O(n) + m ∗ O( \frac{n} {m} ∗ log\frac{n}{m}) = O(n + n ∗ log\frac{n}{m}) = O(n + n ∗ logn − n ∗ logm)$</p><p>因 此 为 $O(n + k)$ ，$k$ 为 $n ∗ logn − n ∗ logm$</p><p>属于稳定排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序（Bucket-Sort）&quot;&gt;&lt;a href=&quot;#桶排序（Bucket-Sort）&quot; class=&quot;headerlink&quot; title=&quot;桶排序（Bucket Sort）&quot;&gt;&lt;/a&gt;桶排序（Bucket Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是桶排序&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://yoursite.com/2020/07/15/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/基数排序/</id>
    <published>2020-07-15T06:00:22.000Z</published>
    <updated>2020-07-15T06:21:11.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="什么是基数排序"><a href="#什么是基数排序" class="headerlink" title="什么是基数排序"></a>什么是基数排序</h2><p>基数排序非常适合用于整数排序（尤其是非负整数），因此本课程只演示对非负整数进行基数排序</p><p>执行流程：依次对个位数、十位数、百位数、千位数、万位数…进行排序（从低位到高位）</p><p><img src="/2020/07/15/基数排序/1.png" alt></p><p>个位数、十位数、百位数的取值范围都是固定的 $0$ ~ $9$，可以使用计数排序对它们进行排序</p><p><strong>如果先对高位排序，再对低位排序，是不可行的</strong></p><h2 id="基数排序-–-实现"><a href="#基数排序-–-实现" class="headerlink" title="基数排序 – 实现"></a>基数排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 个位数: array[i] / 1 % 10 = 3</span></span><br><span class="line">    <span class="comment">// 十位数：array[i] / 10 % 10 = 9</span></span><br><span class="line">    <span class="comment">// 百位数：array[i] / 100 % 10 = 5</span></span><br><span class="line">    <span class="comment">// 千位数：array[i] / 1000 % 10 = ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> divider = <span class="number">1</span>; divider &lt;= max; divider *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(divider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> divider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer / divider % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累加次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newArray[--counts[array[i] / divider % <span class="number">10</span>]] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">        array[i] = newArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好、最坏、平均时间复杂度：$O(d ∗ (n + k))$ ，$d$ 是最大值的位数，$k$ 是进制。属于稳定排序</p><p>空间复杂度：$O(n + k)$，$k$ 是进制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基数排序（Radix-Sort）&quot;&gt;&lt;a href=&quot;#基数排序（Radix-Sort）&quot; class=&quot;headerlink&quot; title=&quot;基数排序（Radix Sort）&quot;&gt;&lt;/a&gt;基数排序（Radix Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是基数排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/计数排序/</id>
    <published>2020-07-15T06:00:02.000Z</published>
    <updated>2020-07-15T06:16:25.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p>冒泡、选择、插入、归并、快速、希尔、堆排序，都是基于比较的排序</p><p>平均时间复杂度目前最低是 $O(nlogn)$ </p><p>计数排序、桶排序、基数排序，都不是基于比较的排序</p><p>它们是典型的用空间换时间，在某些时候，平均时间复杂度可以比 $O(nlogn)$ 更低</p><h2 id="什么是计数排序"><a href="#什么是计数排序" class="headerlink" title="什么是计数排序"></a>什么是计数排序</h2><p>计数排序于1954年由Harold H. Seward提出，适合对一定范围内的整数进行排序</p><p>计数排序的核心思想：</p><p><strong>统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引</strong></p><h2 id="计数排序-–-最简单的实现"><a href="#计数排序-–-最简单的实现" class="headerlink" title="计数排序 – 最简单的实现"></a>计数排序 – 最简单的实现</h2><p><img src="/2020/07/15/计数排序/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间，存储每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> + max];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer]++;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据整数的出现次数，对整数进行排序</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的实现存在以下问题</p><ul><li><p><strong>无法对负整数进行排序</strong></p></li><li><p><strong>极其浪费内存空间</strong></p></li><li><p><strong>是个不稳定的排序</strong></p></li></ul><h2 id="计数排序-–-改进思路"><a href="#计数排序-–-改进思路" class="headerlink" title="计数排序 – 改进思路"></a>计数排序 – 改进思路</h2><p>假设 $array$ 中的最小值是 $min$</p><p>$array$ 中的元素 $k$ 对应的 $counts$ 索引是 $k – min$</p><p>$array$ 中的元素 $k$ 在有序序列中的索引</p><p>$counts[k – min] – p$</p><p>$p$ 代表着是倒数第几个 $k$</p><p><img src="/2020/07/15/计数排序/2.png" alt></p><p><img src="/2020/07/15/计数排序/3.png" alt></p><p><img src="/2020/07/15/计数排序/4.png" alt></p><p><img src="/2020/07/15/计数排序/5.png" alt></p><p><img src="/2020/07/15/计数排序/6.png" alt></p><h2 id="计数排序-–-改进实现"><a href="#计数排序-–-改进实现" class="headerlink" title="计数排序 – 改进实现"></a>计数排序 – 改进实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累加次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newArray[--counts[array[i] - min]] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">        array[i] = newArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好、最坏、平均时间复杂度：$O(n + k)$</strong></p><p><strong>空间复杂度：$O(n + k)$</strong></p><p><strong>$k$ 是整数的取值范围</strong></p><p><strong>属于稳定排序</strong></p><h2 id="计数排序-–-对自定义对象进行排序"><a href="#计数排序-–-对自定义对象进行排序" class="headerlink" title="计数排序 – 对自定义对象进行排序"></a>计数排序 – 对自定义对象进行排序</h2><p>如果自定义对象可以提供用以排序的整数类型，依然可以使用计数排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [age="</span> + age </span><br><span class="line">            + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person[] persons = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">"A"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(-<span class="number">13</span>, <span class="string">"B"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">17</span>, <span class="string">"C"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">"D"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(-<span class="number">13</span>, <span class="string">"E"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">"F"</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最值</span></span><br><span class="line"><span class="keyword">int</span> max = persons[<span class="number">0</span>].age;</span><br><span class="line"><span class="keyword">int</span> min = persons[<span class="number">0</span>].age;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (persons[i].age &gt; max) &#123;</span><br><span class="line">        max = persons[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (persons[i].age &lt; min) &#123;</span><br><span class="line">        min = persons[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    counts[person.age - min]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 累加次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">    counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">Person[] newArray = <span class="keyword">new</span> Person[persons.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = persons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    newArray[--counts[persons[i].age - min]] = persons[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">System.arraycopy(newArray, <span class="number">0</span>, persons, <span class="number">0</span>, newArray.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序之后的结果</p><p>① $Person [age=-13, name=B]$</p><p>② $Person [age=-13, name=E]$</p><p>③ $Person [age=12, name=D]$</p><p>④ $Person [age=17, name=C]$</p><p>⑤ $Person [age=20, name=A]$</p><p>⑥ $Person [age=20, name=F]$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数排序（Counting-Sort）&quot;&gt;&lt;a href=&quot;#计数排序（Counting-Sort）&quot; class=&quot;headerlink&quot; title=&quot;计数排序（Counting Sort）&quot;&gt;&lt;/a&gt;计数排序（Counting Sort）&lt;/h1&gt;&lt;p&gt;冒泡
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/希尔排序/</id>
    <published>2020-07-14T11:06:42.000Z</published>
    <updated>2020-07-14T11:32:07.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="什么是希尔排序"><a href="#什么是希尔排序" class="headerlink" title="什么是希尔排序"></a>什么是希尔排序</h2><ol><li><p>1959年由唐纳德·希尔（Donald Shell）提出</p></li><li><p>希尔排序把序列看作是一个矩阵，分成 𝑚 列，逐列进行排序</p><p>𝑚 从某个整数逐渐减为1</p><p>当 𝑚 为1时，整个序列将完全有序</p></li><li><p>因此，希尔排序也被称为递减增量排序（Diminishing Increment Sort）</p></li><li><p>矩阵的列数取决于步长序列（step sequence）</p><p>比如，如果步长序列为 ${1,5,19,41,109,…}$，就代表依次分成109列、41列、19列、5列、1列进行排序</p><p>不同的步长序列，执行效率也不同</p></li></ol><h2 id="希尔排序-–-实例"><a href="#希尔排序-–-实例" class="headerlink" title="希尔排序 – 实例"></a>希尔排序 – 实例</h2><p>希尔本人给出的步长序列是 $𝑛/2^𝑘$，比如 $𝑛$ 为 $16$ 时，步长序列是 {$1, 2, 4, 8$}</p><p><strong>分成8列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/1.png" alt></p><p><strong>分成4列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/2.png" alt></p><p><strong>分成2列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/3.png" alt></p><p><strong>分成1列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/4.png" alt></p><p><strong>不难看出来，从8列变为1列的过程中，逆序对的数量在逐渐减少</strong></p><p>因此希尔排序底层一般使用插入排序对每一列进行排序，很多资料认为希尔排序是插入排序的改进版</p><h2 id="假设有11个元素，步长序列是-1-2-5"><a href="#假设有11个元素，步长序列是-1-2-5" class="headerlink" title="假设有11个元素，步长序列是{1, 2, 5}"></a>假设有11个元素，步长序列是{1, 2, 5}</h2><p><img src="/2020/07/14/希尔排序/5.png" alt></p><p>假设元素在第 $col$ 列、第 $row$ 行，步长（总列数）是 $step$</p><p>那么这个元素在数组中的索引是 $col + row * step$</p><p>比如 $9$ 在排序前是第 $2$ 列、第 $0$ 行，那么它排序前的索引是 $2 + 0 * 5 = 2$</p><p>比如 $4$ 在排序前是第 $2$ 列、第 $1$ 行，那么它排序前的索引是 $2 + 1 * 5 = 7$</p><h2 id="希尔排序-–-实现"><a href="#希尔排序-–-实现" class="headerlink" title="希尔排序 – 实现"></a>希尔排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; shellSequence = shellStepSequence();</span><br><span class="line">    <span class="keyword">for</span> (Integer shell : shellSequence) &#123;</span><br><span class="line">        sort(shell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分成step列进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; step; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">        <span class="comment">// col、col+step、col+2*step、col+3*step</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = col + step; begin &lt; array.length; begin += step) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = begin;</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(cur, cur - step);</span><br><span class="line">                cur -= step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况是步长序列只有 $1$，且序列几乎有序，时间复杂度为 $O(n)$</p><p>空间复杂度为 $O(1)$，属于不稳定排序</p><h3 id="希尔排序-–-步长序列"><a href="#希尔排序-–-步长序列" class="headerlink" title="希尔排序 – 步长序列"></a>希尔排序 – 步长序列</h3><p>希尔本人给出的步长序列，最坏情况时间复杂度是 $O(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">shellStepSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> step = array.length;</span><br><span class="line">    <span class="keyword">while</span> ((step &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stepSequence.add(step);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stepSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前已知的最好的步长序列，最坏情况时间复杂度是 $O(n^{4/3})$ ，1986年由<strong>Robert Sedgewick</strong>提出</p><script type="math/tex; mode=display">\begin{cases}9 \left(2^k - 2^{\frac{k}{2}}\right) +1, & \text {k even} \\8 \cdot 2^k - 6 \cdot 2^{\frac{(k+1)}{2}} + 1, & \text {k odd} \\\end{cases} \\1,5,19,41,109,...</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">SedgewickStepSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pow = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            step = <span class="number">1</span> + <span class="number">9</span> * (pow * pow - pow);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pow1 = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, (k - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pow2 = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            step = <span class="number">1</span> + <span class="number">8</span> * pow1 * pow2 - <span class="number">6</span> * pow2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt;= array.length) <span class="keyword">break</span>;</span><br><span class="line">        stepSequence.add(<span class="number">0</span>, step);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stepSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;希尔排序（Shell-Sort）&quot;&gt;&lt;a href=&quot;#希尔排序（Shell-Sort）&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell Sort）&quot;&gt;&lt;/a&gt;希尔排序（Shell Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是希尔排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/快速排序/</id>
    <published>2020-07-14T10:53:40.000Z</published>
    <updated>2020-07-14T11:05:38.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick    Sort）"></a>快速排序（Quick    Sort）</h1><h2 id="什么是快速排序"><a href="#什么是快速排序" class="headerlink" title="什么是快速排序"></a>什么是快速排序</h2><p>1960年由查尔斯·安东尼·理查德·霍尔（Charles Antony Richard Hoare，缩写为C. A. R. Hoare）提出</p><p>昵称为东尼·霍尔（Tony Hoare）</p><h2 id="快速排序-–-执行流程"><a href="#快速排序-–-执行流程" class="headerlink" title="快速排序 – 执行流程"></a>快速排序 – 执行流程</h2><p>① 从序列中选择一个轴点元素（pivot）</p><p>​    假设每次选择 0 位置的元素为轴点元素</p><p>② 利用 pivot 将序列分割成 2 个子序列</p><p>​    将小于 pivot 的元素放在pivot前面（左侧）</p><p>​    将大于 pivot 的元素放在pivot后面（右侧）</p><p>​    等于pivot的元素放哪边都可以</p><p>③ 对子序列进行 ① ② 操作</p><p>​    直到不能再分割（子序列中只剩下1个元素）</p><p><img src="/2020/07/14/快速排序/1.png" alt></p><p><strong>快速排序的本质</strong></p><p><strong>逐渐将每一个元素都转换成轴点元素</strong></p><h2 id="快速排序-–-轴点构造"><a href="#快速排序-–-轴点构造" class="headerlink" title="快速排序 – 轴点构造"></a>快速排序 – 轴点构造</h2><p><img src="/2020/07/14/快速排序/2.png" alt></p><h2 id="快速排序-–-时间复杂度"><a href="#快速排序-–-时间复杂度" class="headerlink" title="快速排序 – 时间复杂度"></a>快速排序 – 时间复杂度</h2><ol><li><p>在轴点左右元素数量比较均匀的情况下，同时也是最好的情况</p><p>$T(n) = 2 ∗ T(n/2) + O(n) = O(nlogn)$</p></li><li><p>如果轴点左右元素数量极度不均匀，最坏情况</p><p>$T(n) = T(n − 1) + O(n) = O(n^2)$</p></li><li><p>为了降低最坏情况的出现概率，一般采取的做法是</p><p>随机选择轴点元素</p></li><li><p>最好、平均时间复杂度：$O(nlogn)$</p><p>最坏时间复杂度：$O(n^2)$</p><p>由于递归调用的缘故，空间复杂度：$O(logn)$</p><p>属于不稳定排序</p></li></ol><p><img src="/2020/07/14/快速排序/3.png" alt></p><h2 id="快速排序-–-实现"><a href="#快速排序-–-实现" class="headerlink" title="快速排序 – 实现"></a>快速排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(<span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 [begin, end) 范围的元素进行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定轴点位置 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> mid = pivotIndex(begin, end);</span><br><span class="line">    <span class="comment">// 对子序列进行快速排序</span></span><br><span class="line">    sort(begin, mid); </span><br><span class="line">    sort(mid + <span class="number">1</span>, end); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造出 [begin, end) 范围的轴点元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 轴点元素的最终位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择一个元素跟begin位置进行交换</span></span><br><span class="line">    swap(begin, begin + (<span class="keyword">int</span>)(Math.random() * (end - begin)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份begin位置的元素</span></span><br><span class="line">    T pivot = array[begin];</span><br><span class="line">    <span class="comment">// end指向最后一个元素</span></span><br><span class="line">    end--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(pivot, array[end]) &lt; <span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">                array[begin++] = array[end];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(pivot, array[begin]) &gt; <span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">                begin++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">                array[end--] = array[begin];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将轴点元素放入最终的位置</span></span><br><span class="line">    array[begin] = pivot;</span><br><span class="line">    <span class="comment">// 返回轴点元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序-–-与轴点相等的元素"><a href="#快速排序-–-与轴点相等的元素" class="headerlink" title="快速排序 – 与轴点相等的元素"></a>快速排序 – 与轴点相等的元素</h3><p><img src="/2020/07/14/快速排序/4.png" alt></p><p>如果序列中的所有元素都与轴点元素相等，利用目前的算法实现，轴点元素可以将序列分割成 2 个均匀的子序列</p><p><strong>思考：cmp 位置的判断分别改为 ≤、≥ 会起到什么效果？</strong></p><p><img src="/2020/07/14/快速排序/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(pivot, array[end]) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">            end--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">            array[begin++] = array[end];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(pivot, array[begin]) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">            array[end--] = array[begin];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>轴点元素分割出来的子序列极度不均匀</strong></p><p><strong>导致出现最坏时间复杂度</strong> $O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序（Quick-Sort）&quot;&gt;&lt;a href=&quot;#快速排序（Quick-Sort）&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quick    Sort）&quot;&gt;&lt;/a&gt;快速排序（Quick    Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/归并排序/</id>
    <published>2020-07-14T10:11:09.000Z</published>
    <updated>2020-07-14T10:52:34.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="什么是归并排序"><a href="#什么是归并排序" class="headerlink" title="什么是归并排序"></a>什么是归并排序</h2><p>1945年由约翰·冯·诺伊曼（John von Neumann）首次提出</p><p>执行流程</p><p>① 不断地将当前序列平均分割成2个子序列</p><p>​    直到不能再分割（序列中只剩1个元素）</p><p>② 不断地将2个子序列合并成一个有序序列</p><p>​    直到最终只剩下1个有序序列</p><p><img src="/2020/07/14/归并排序/1.png" alt></p><h2 id="归并排序-–-divide实现"><a href="#归并排序-–-divide实现" class="headerlink" title="归并排序 – divide实现"></a>归并排序 – divide实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一段临时的数组空间，在merge操作中使用</span></span><br><span class="line">    leftArray = (T[]) <span class="keyword">new</span> Comparable[array.length &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    sort(<span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sort(begin, mid);</span><br><span class="line">    sort(mid, end);</span><br><span class="line">    merge(begin, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-–-merge"><a href="#归并排序-–-merge" class="headerlink" title="归并排序 – merge"></a>归并排序 – merge</h2><h3 id="归并排序-–-merge细节"><a href="#归并排序-–-merge细节" class="headerlink" title="归并排序 – merge细节"></a>归并排序 – merge细节</h3><p><img src="/2020/07/14/归并排序/2.png" alt></p><p>需要 merge 的 2 组序列存在于同一个数组中，并且是挨在一起的</p><p><img src="/2020/07/14/归并排序/3.png" alt></p><p>为了更好地完成 merge 操作，最好将其中 1 组序列备份出来，比如 $[begin, mid)$</p><p><img src="/2020/07/14/归并排序/4.png" alt></p><p>$li == 0，le == mid – begin$</p><p>$ri == mid，re == end$</p><h3 id="归并排序-–-merge-–-左边先结束"><a href="#归并排序-–-merge-–-左边先结束" class="headerlink" title="归并排序 – merge – 左边先结束"></a>归并排序 – merge – 左边先结束</h3><p><img src="/2020/07/14/归并排序/5.png" alt></p><h3 id="归并排序-–-merge-–-右边先结束"><a href="#归并排序-–-merge-–-右边先结束" class="headerlink" title="归并排序 – merge – 右边先结束"></a>归并排序 – merge – 右边先结束</h3><p><img src="/2020/07/14/归并排序/6.png" alt></p><h3 id="归并排序-–-merge实现"><a href="#归并排序-–-merge实现" class="headerlink" title="归并排序 – merge实现"></a>归并排序 – merge实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> li = <span class="number">0</span>, le = mid - begin;</span><br><span class="line">    <span class="keyword">int</span> ri = mid, re = end;</span><br><span class="line">    <span class="keyword">int</span> ai = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份左边数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = li; i &lt; le; i++) &#123;</span><br><span class="line">        leftArray[i] = array[begin + i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左边还没有结束</span></span><br><span class="line">    <span class="keyword">while</span> (li &lt; le) &#123; </span><br><span class="line">        <span class="keyword">if</span> (ri &lt; re &amp;&amp; cmp(array[ri], leftArray[li]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[ai++] = array[ri++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array[ai++] = leftArray[li++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-–-复杂度分析"><a href="#归并排序-–-复杂度分析" class="headerlink" title="归并排序 – 复杂度分析"></a>归并排序 – 复杂度分析</h2><p>归并排序花费的时间</p><p>$T(n) = 2 ∗ T (n/2) + O(n)$</p><p>$T(1) = O(1)$</p><p>$T(n) /n = T(n/2) / (n/2) + O(1)$</p><p>令 $S(n) = T(n) /n$</p><p>$S(1) = O(1)$</p><p>$S(n) = S(n/2) + O(1) = S(n/4)+ O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)$</p><p>$T(n) = n ∗ S(n) = O(nlogn)$</p><p>由于归并排序总是平均分割子序列，所以最好、最坏、平均时间复杂度都是 $O(nlogn)$ ，属于稳定排序</p><p>从代码中不难看出：归并排序的空间复杂度是 $O(n/2 + logn) = O(n)$</p><p>$n/2$ 用于临时存放左侧数组，$logn$ 是因为递归调用</p><h2 id="常见的递推式与复杂度"><a href="#常见的递推式与复杂度" class="headerlink" title="常见的递推式与复杂度"></a>常见的递推式与复杂度</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>递推式</strong></th><th style="text-align:center"><strong>复杂度</strong></th></tr></thead><tbody><tr><td style="text-align:center">$T(n) = T(n/2) + O(1)$</td><td style="text-align:center">$O(logn)$</td></tr><tr><td style="text-align:center">$T(n) = T(n − 1) + O(1)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = T(n/2) + O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n/2) + O(1)  $</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n/2) + O(n)$</td><td style="text-align:center">$O(nlogn)$</td></tr><tr><td style="text-align:center">$T(n) = T(n − 1) + O(n)$</td><td style="text-align:center">$O(n^2)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n − 1) + O(1)$</td><td style="text-align:center">$O(2^n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n − 1) + O(n)$</td><td style="text-align:center">$O(2^n)$</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序（Merge-Sort）&quot;&gt;&lt;a href=&quot;#归并排序（Merge-Sort）&quot; class=&quot;headerlink&quot; title=&quot;归并排序（Merge Sort）&quot;&gt;&lt;/a&gt;归并排序（Merge Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是归并排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2020/07/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/插入排序/</id>
    <published>2020-07-14T09:32:46.000Z</published>
    <updated>2020-07-14T10:06:40.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><h2 id="什么是插入排序"><a href="#什么是插入排序" class="headerlink" title="什么是插入排序"></a>什么是插入排序</h2><p>插入排序非常类似于扑克牌的排序</p><p>执行流程</p><p>① 在执行过程中，插入排序会将序列分为2部分</p><p>​    头部是已经排好序的，尾部是待排序的</p><p>② 从头开始扫描每一个元素</p><p>​    每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序</p><p><img src="/2020/07/14/插入排序/1.png" alt></p><h2 id="插入排序-实现-无优化"><a href="#插入排序-实现-无优化" class="headerlink" title="插入排序 - 实现(无优化)"></a>插入排序 - 实现(无优化)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = begin;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(cur, cur - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(cur, cur - <span class="number">1</span>);</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-–-逆序对（Inversion）"><a href="#插入排序-–-逆序对（Inversion）" class="headerlink" title="插入排序 – 逆序对（Inversion）"></a>插入排序 – 逆序对（Inversion）</h2><ul><li><p><strong>什么是逆序对？</strong></p><p>数组 <2,3,8,6,1> 的逆序对为：<2,1> <3,1> <8,1> <8,6> <6,1>，共5个逆序对</6,1></8,6></8,1></3,1></2,1></2,3,8,6,1></p><p>插入排序的时间复杂度与逆序对的数量成正比关系</p><p>逆序对的数量越多，插入排序的时间复杂度越高</p></li><li><p>最坏、平均时间复杂度：$O(n^2)$</p><p>最好时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p><p>属于稳定排序</p></li><li><p>当逆序对的数量极少时，插入排序的效率特别高</p><p>甚至速度比 $O(nlogn)$级别的快速排序还要快</p><p>数据量不是特别大的时候，插入排序的效率也是非常好的</p></li></ul><p><img src="/2020/07/14/插入排序/2.png" alt></p><h2 id="插入排序-–-优化"><a href="#插入排序-–-优化" class="headerlink" title="插入排序 – 优化"></a>插入排序 – 优化</h2><p>思路是将【交换】转为【挪动】</p><p>① 先将待插入的元素备份</p><p>② 头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置</p><p>③ 将待插入元素放到最终的合适位置</p><p><img src="/2020/07/14/插入排序/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = begin;</span><br><span class="line">    T v = array[cur];</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(v, array[cur - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        array[cur] = array[cur - <span class="number">1</span>];</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    array[cur] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-–-二分搜索优化"><a href="#插入排序-–-二分搜索优化" class="headerlink" title="插入排序 – 二分搜索优化"></a>插入排序 – 二分搜索优化</h2><h3 id="二分搜索（Binary-Search）"><a href="#二分搜索（Binary-Search）" class="headerlink" title="二分搜索（Binary Search）"></a>二分搜索（Binary Search）</h3><p>如何确定一个元素在数组中的位置？（假设数组里面全都是整数）</p><p>如果是无序数组，从第 0 个位置开始遍历搜索，平均时间复杂度：$O(n)$</p><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">31</td><td style="text-align:center">66</td><td style="text-align:center">17</td><td style="text-align:center">15</td><td style="text-align:center">28</td><td style="text-align:center">20</td><td style="text-align:center">59</td><td style="text-align:center">88</td><td style="text-align:center">45</td><td style="text-align:center">56</td></tr></tbody></table></div><p>如果是有序数组，可以使用二分搜索，最坏时间复杂度：$O(logn)$</p><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">20</td><td style="text-align:center">28</td><td style="text-align:center">31</td><td style="text-align:center">45</td><td style="text-align:center">56</td><td style="text-align:center">59</td><td style="text-align:center">66</td><td style="text-align:center">88</td></tr></tbody></table></div><h3 id="二分搜索-–-思路"><a href="#二分搜索-–-思路" class="headerlink" title="二分搜索 – 思路"></a>二分搜索 – 思路</h3><p>假设在 $[begin, end)$ 范围内搜索某个元素 v，$mid == (begin + end) /2$</p><p>如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索</p><p>如果 $v &gt; m$，去 $[mid + 1, end)$ 范围内二分搜索</p><p>如果 $v == m$，直接返回 mid</p><p><img src="/2020/07/14/插入排序/4.png" alt></p><h3 id="二分搜索-–-实例"><a href="#二分搜索-–-实例" class="headerlink" title="二分搜索 – 实例"></a>二分搜索 – 实例</h3><p><img src="/2020/07/14/插入排序/5.png" alt></p><h3 id="二分搜索-–-实现"><a href="#二分搜索-–-实现" class="headerlink" title="二分搜索 – 实现"></a>二分搜索 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; array[mid]) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序-–-二分搜索优化-1"><a href="#插入排序-–-二分搜索优化-1" class="headerlink" title="插入排序 – 二分搜索优化"></a>插入排序 – 二分搜索优化</h3><p>在元素 v 的插入过程中，可以先二分搜索出合适的插入位置，然后再将元素 v 插入</p><p><img src="/2020/07/14/插入排序/6.png" alt></p><p>要求二分搜索返回的插入位置：第1个大于 v 的元素位置</p><ul><li><p>如果 v 是 5，返回 2</p></li><li><p>如果 v 是 1，返回 0</p></li><li><p>如果 v 是 15，返回 7</p></li><li><p>如果 v 是 8，返回 5</p></li></ul><h3 id="插入排序-–-二分搜索优化-–-思路"><a href="#插入排序-–-二分搜索优化-–-思路" class="headerlink" title="插入排序 – 二分搜索优化 – 思路"></a>插入排序 – 二分搜索优化 – 思路</h3><p>假设在 $[begin, end)$ 范围内搜索某个元素 $v$，$mid == (begin + end) /2$</p><p>如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索</p><p>如果 $v ≥ m$，去 $[mid + 1, end)$ 范围内二分搜索</p><p><img src="/2020/07/14/插入排序/7.png" alt></p><h3 id="插入排序-–-二分搜索优化-–-实例"><a href="#插入排序-–-二分搜索优化-–-实例" class="headerlink" title="插入排序 – 二分搜索优化 – 实例"></a>插入排序 – 二分搜索优化 – 实例</h3><p><img src="/2020/07/14/插入排序/8.png" alt></p><p><img src="/2020/07/14/插入排序/9.png" alt></p><h3 id="插入排序-–-二分搜索优化-–-实现"><a href="#插入排序-–-二分搜索优化-–-实现" class="headerlink" title="插入排序 – 二分搜索优化 – 实现"></a>插入排序 – 二分搜索优化 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    insert(begin, search(begin));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将source位置的元素插入到dest位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    T v = array[source];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = source; i &gt; dest; i--) &#123;</span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    array[dest] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二分搜索找到 index 位置元素的待插入位置</span></span><br><span class="line"><span class="comment">// 已经排好序数组的区间范围是 [0, index)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = index;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmp(array[index], array[mid]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用了二分搜索后，只是减少了比较次数，但插入排序的平均时间复杂度依然是 $O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插入排序（Insertion-Sort）&quot;&gt;&lt;a href=&quot;#插入排序（Insertion-Sort）&quot; class=&quot;headerlink&quot; title=&quot;插入排序（Insertion Sort）&quot;&gt;&lt;/a&gt;插入排序（Insertion Sort）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/堆排序/</id>
    <published>2020-07-14T09:32:36.000Z</published>
    <updated>2020-07-14T09:39:41.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><h2 id="什么是堆排序"><a href="#什么是堆排序" class="headerlink" title="什么是堆排序"></a>什么是堆排序</h2><p><strong>堆排序可以认为是对选择排序的一种优化</strong></p><p><strong><a href="/2020/07/14/选择排序/" title="选择排序的实现">选择排序的实现</a></strong>  / <strong><a href="/2020/07/14/二叉堆/" title="二叉堆的实现">二叉堆的实现</a></strong></p><p>执行流程</p><p>① 对序列进行原地建堆（heapify）</p><p>② 重复执行以下操作，直到堆的元素数量为 1</p><p>​    交换堆顶元素与尾元素</p><p>​    堆的元素数量减 1</p><p>​    对 0 位置进行 1 次 siftDown 操作</p><p><img src="/2020/07/14/堆排序/1.png" alt></p><h2 id="堆排序-实现"><a href="#堆排序-实现" class="headerlink" title="堆排序 - 实现"></a>堆排序 - 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地建堆</span></span><br><span class="line">heapSize = array.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (heapSize &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    siftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 交换堆顶元素和尾部元素</span></span><br><span class="line">    swap(<span class="number">0</span>, --heapSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对0位置进行siftDown（恢复堆的性质）</span></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    T element = array[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> half = heapSize &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; half) &#123; <span class="comment">// index必须是非叶子节点</span></span><br><span class="line">        <span class="comment">// 默认是左边跟父节点比</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        T child = array[childIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightIndex = childIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点比左子节点大</span></span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; heapSize &amp;&amp; </span><br><span class="line">            cmp(array[rightIndex], child) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            child = array[childIndex = rightIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大于等于子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cmp(element, child) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        array[index] = child;</span><br><span class="line">        index = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    array[index] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好、最坏、平均时间复杂度：O(nlogn)，空间复杂度：O(1)，属于不稳定排序</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆排序（Heap-Sort）&quot;&gt;&lt;a href=&quot;#堆排序（Heap-Sort）&quot; class=&quot;headerlink&quot; title=&quot;堆排序（Heap Sort）&quot;&gt;&lt;/a&gt;堆排序（Heap Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是堆排序&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2020/07/14/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/选择排序/</id>
    <published>2020-07-14T09:30:04.000Z</published>
    <updated>2020-07-14T10:07:57.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><p>执行流程</p><p>① 从序列中找出最大的那个元素，然后与最末尾的元素交换位置</p><p>​    执行完一轮后，最末尾的那个元素就是最大的元素</p><p>② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(max, begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = begin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(max, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序的交换次数要远远少于冒泡排序，平均性能优于冒泡排序</p><p>最好、最坏、平均时间复杂度：$O(n^2)$，空间复杂度：$O(1)$，属于不稳定排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序（Selection-Sort）&quot;&gt;&lt;a href=&quot;#选择排序（Selection-Sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序（Selection Sort）&quot;&gt;&lt;/a&gt;选择排序（Selection Sort）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/冒泡排序/</id>
    <published>2020-07-14T09:16:27.000Z</published>
    <updated>2020-07-14T10:09:09.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><h2 id="冒泡排序（无优化实现）"><a href="#冒泡排序（无优化实现）" class="headerlink" title="冒泡排序（无优化实现）"></a>冒泡排序（无优化实现）</h2><p>冒泡排序也叫做起泡排序</p><p>执行流程（统一以升序为例子）</p><p>① 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置</p><p>​    执行完一轮后，最末尾那个元素就是最大的元素</p><p>② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①，直到全部元素有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="comment">// 比大小</span></span><br><span class="line">        <span class="keyword">if</span> (cmp(begin, begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            swap(begin, begin - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-–-优化①"><a href="#冒泡排序-–-优化①" class="headerlink" title="冒泡排序 – 优化①"></a>冒泡排序 – 优化①</h2><p>如果序列已经完全有序，可以提前终止冒泡排序</p><p><img src="/2020/07/14/冒泡排序/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(begin, begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(begin, begin - <span class="number">1</span>);</span><br><span class="line">            sorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-–-优化②"><a href="#冒泡排序-–-优化②" class="headerlink" title="冒泡排序 – 优化②"></a>冒泡排序 – 优化②</h2><p>如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数</p><p><img src="/2020/07/14/冒泡排序/2.png" alt></p><p><strong>最后1次交换的位置是 6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">int</span> sortedIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="comment">// if (array[begin] &lt; array[begin - 1]) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (cmp(begin, begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(begin, begin - <span class="number">1</span>);</span><br><span class="line">            sortedIndex = begin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = sortedIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最坏、平均时间复杂度：$O(n^2)$</strong></p><p><strong>最好时间复杂度：</strong>$O(n)$</p><p><strong>空间复杂度：</strong>$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;&lt;a href=&quot;#冒泡排序（Bubble-Sort）&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序（Bubble Sort）&quot;&gt;&lt;/a&gt;冒泡排序（Bubble Sort）&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序（
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>10大排序算法</title>
    <link href="http://yoursite.com/2020/07/14/10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/14/10大排序算法/</id>
    <published>2020-07-14T09:10:41.000Z</published>
    <updated>2020-07-14T09:29:11.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10大排序算法"><a href="#10大排序算法" class="headerlink" title="10大排序算法"></a>10大排序算法</h1><p>以下表格是基于数组进行排序的一般性结论</p><p>冒泡、选择、插入、归并、快速、希尔、堆排序，属于比较排序（Comparison Sorting）</p><p><img src="/2020/07/14/10大排序算法/1.png" alt></p><h2 id="排序算法的稳定性（Stability）"><a href="#排序算法的稳定性（Stability）" class="headerlink" title="排序算法的稳定性（Stability）"></a>排序算法的稳定性（Stability）</h2><p>如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法</p><p>排序前：5, 1, 3𝑎, 4, 7, 3𝑏</p><p>稳定的排序： 1, 3𝑎, 3𝑏, 4, 5, 7</p><p>不稳定的排序：1, 3𝑏, 3𝑎, 4,  5, 7</p><h2 id="原地算法（In-place-Algorithm）"><a href="#原地算法（In-place-Algorithm）" class="headerlink" title="原地算法（In-place Algorithm）"></a>原地算法（In-place Algorithm）</h2><p>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</p><p>空间复杂度为𝑂(1) 的都可以认为是原地算法</p><p>非原地算法，称为 Not-in-place 或者 Out-of-place</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10大排序算法&quot;&gt;&lt;a href=&quot;#10大排序算法&quot; class=&quot;headerlink&quot; title=&quot;10大排序算法&quot;&gt;&lt;/a&gt;10大排序算法&lt;/h1&gt;&lt;p&gt;以下表格是基于数组进行排序的一般性结论&lt;/p&gt;
&lt;p&gt;冒泡、选择、插入、归并、快速、希尔、堆排序，属
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://yoursite.com/2020/07/14/Trie/"/>
    <id>http://yoursite.com/2020/07/14/Trie/</id>
    <published>2020-07-14T07:22:50.000Z</published>
    <updated>2020-07-14T08:42:37.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树</p><p>Trie 搜索字符串的效率主要跟字符串的长度有关</p><p>假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词</p><p><img src="/2020/07/14/Trie/1.png" alt></p><h2 id="Trie代码实现"><a href="#Trie代码实现" class="headerlink" title="Trie代码实现"></a>Trie代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node&lt;V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.word ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">add</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> len = key.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = key.charAt(i); </span><br><span class="line"><span class="keyword">boolean</span> emptyChildren = node.children == <span class="keyword">null</span>;</span><br><span class="line">Node&lt;V&gt; childNode = emptyChildren ? <span class="keyword">null</span> : node.children.get(c);</span><br><span class="line"><span class="keyword">if</span> (childNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">childNode = <span class="keyword">new</span> Node&lt;&gt;(node);</span><br><span class="line">childNode.character = c;</span><br><span class="line">node.children = emptyChildren ? <span class="keyword">new</span> HashMap&lt;&gt;() : node.children;</span><br><span class="line">node.children.put(c, childNode);</span><br><span class="line">&#125;</span><br><span class="line">node = childNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.word) &#123; <span class="comment">// 已经存在这个单词</span></span><br><span class="line">V oldValue = node.value;</span><br><span class="line">node.value = value;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个单词</span></span><br><span class="line">node.word = <span class="keyword">true</span>;</span><br><span class="line">node.value = value;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 找到最后一个节点</span></span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="comment">// 如果不是单词结尾，不用作任何处理</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || !node.word) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line">V oldValue = node.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果还有子节点</span></span><br><span class="line"><span class="keyword">if</span> (node.children != <span class="keyword">null</span> &amp;&amp; !node.children.isEmpty()) &#123;</span><br><span class="line">node.word = <span class="keyword">false</span>;</span><br><span class="line">node.value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有子节点</span></span><br><span class="line">Node&lt;V&gt; parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((parent = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">parent.children.remove(node.character);</span><br><span class="line"><span class="keyword">if</span> (parent.word || !parent.children.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">node = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node(prefix) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;V&gt; <span class="title">node</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> len = key.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || node.children == <span class="keyword">null</span> || node.children.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">char</span> c = key.charAt(i); </span><br><span class="line">node = node.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyCheck</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span> || key.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key must not be empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">Node&lt;V&gt; parent;</span><br><span class="line">HashMap&lt;Character, Node&lt;V&gt;&gt; children;</span><br><span class="line">Character character;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">boolean</span> word; <span class="comment">// 是否为单词的结尾（是否为一个完整的单词）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Trie 的优点：搜索前缀的效率主要跟前缀的长度有关</strong></p><p><strong>Trie 的缺点：需要耗费大量的内存，因此还有待改进</strong></p><p>更多Trie 相关的数据结构和算法</p><p>Double-array Trie、Suffix Tree、Patricia Tree、Crit-bit Tree、AC自动机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Trie&quot;&gt;&lt;a href=&quot;#Trie&quot; class=&quot;headerlink&quot; title=&quot;Trie&quot;&gt;&lt;/a&gt;Trie&lt;/h1&gt;&lt;p&gt;Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树&lt;/p&gt;
&lt;p&gt;Trie 搜索字符串的效率主要跟字符串的
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://yoursite.com/2020/07/14/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/14/哈夫曼树/</id>
    <published>2020-07-14T07:13:27.000Z</published>
    <updated>2020-07-14T08:43:25.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼编码（Huffman-Coding）"><a href="#哈夫曼编码（Huffman-Coding）" class="headerlink" title="哈夫曼编码（Huffman Coding）"></a>哈夫曼编码（Huffman Coding）</h1><p>哈夫曼编码，又称为霍夫曼编码，它是现代压缩算法的基础</p><p>假设要把字符串【ABBBCCCCCCCCDDDDDDEE】转成二进制编码进行传输</p><p>可以转成ASCII编码（65 ~ 69，1000001~1000101），但是有点冗长，如果希望编码更短呢？</p><p>可以先约定5个字母对应的二进制</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">001</td><td style="text-align:center">010</td><td style="text-align:center">011</td><td style="text-align:center">100</td></tr></tbody></table></div><p>对应的二进制编码：000001001001010010010010010010010010011011011011011011100100</p><p>一共20个字母，转成了60个二进制位</p><p>如果使用哈夫曼编码，可以压缩至41个二进制位，约为原来长度的68.3%</p><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>先计算出每个字母的出现频率（权值，这里直接用出现次数），【ABBBCCCCCCCCDDDDDDEE】</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table></div><p>利用这些权值，构建一棵哈夫曼树（又称为霍夫曼树、最优二叉树）</p><p>如何构建一棵哈夫曼树？（假设有 n 个权值）</p><ol><li><p>以权值作为根节点构建 n 棵二叉树，组成森林</p></li><li><p>在森林中选出 2 个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点为其左右子树根节点之和</p></li><li><p>从森林中删除刚才选取的 2 棵树，并将新树加入森林</p></li><li><p>重复 2、3 步骤，直到森林只剩一棵树为止，该树即为哈夫曼树</p></li></ol><h2 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h2><p><img src="/2020/07/14/哈夫曼树/1.png" alt></p><p>left为0，right为1，可以得出5个字母对应的哈夫曼编码</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">1110</td><td style="text-align:center">110</td><td style="text-align:center">0</td><td style="text-align:center">10</td><td style="text-align:center">1111</td></tr></tbody></table></div><p>【ABBBCCCCCCCCDDDDDDEE】的哈夫曼编码是</p><p>1110110110110000000001010101010101111</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>n 个权值构建出来的哈夫曼树拥有 n 个叶子节点</p><p>每个哈夫曼编码都不是另一个哈夫曼编码的前缀</p><p>哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近</p><p>带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径长度。与最终的哈夫曼编码总长度成正比关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈夫曼编码（Huffman-Coding）&quot;&gt;&lt;a href=&quot;#哈夫曼编码（Huffman-Coding）&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼编码（Huffman Coding）&quot;&gt;&lt;/a&gt;哈夫曼编码（Huffman Coding）&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>优先级队列</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/14/优先级队列/</id>
    <published>2020-07-14T07:04:06.000Z</published>
    <updated>2020-07-14T08:44:58.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列（Priority-Queue）"><a href="#优先级队列（Priority-Queue）" class="headerlink" title="优先级队列（Priority Queue）"></a>优先级队列（Priority Queue）</h1><p><strong><a href="/2020/07/11/队列/" title="队列实现">队列实现</a></strong></p><h2 id="优先级队列的接口设计"><a href="#优先级队列的接口设计" class="headerlink" title="优先级队列的接口设计"></a>优先级队列的接口设计</h2><p>普通的队列是 FIFO 原则，也就是先进先出</p><p><strong>优先级队列则是按照优先级高低进行出队，比如将优先级最高的元素作为队头优先出队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> BinaryHeap&lt;E&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">heap.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先级队列的应用场景举例"><a href="#优先级队列的应用场景举例" class="headerlink" title="优先级队列的应用场景举例"></a>优先级队列的应用场景举例</h2><ol><li><p>医院的夜间门诊</p><p>队列元素是病人</p><p>优先级是病情的严重情况、挂号时间</p></li><li><p>操作系统的多任务调度</p><p>队列元素是任务</p><p>优先级是任务类型</p></li></ol><h2 id="优先队列的底层实现"><a href="#优先队列的底层实现" class="headerlink" title="优先队列的底层实现"></a>优先队列的底层实现</h2><p>根据优先队列的特点，很容易想到：可以直接利用二叉堆作为优先队列的底层实现</p><p> <strong><a href="/2020/07/14/二叉堆/" title="二叉堆实现">二叉堆实现</a></strong></p><p>可以通过 Comparator 或 Comparable 去自定义优先级高低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> boneBreak;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> boneBreak)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.boneBreak = boneBreak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.boneBreak - person.boneBreak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", boneBreak="</span> + boneBreak + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Person&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">2</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Rose"</span>, <span class="number">10</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Jake"</span>, <span class="number">5</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"James"</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">System.out.println(queue.deQueue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先级队列（Priority-Queue）&quot;&gt;&lt;a href=&quot;#优先级队列（Priority-Queue）&quot; class=&quot;headerlink&quot; title=&quot;优先级队列（Priority Queue）&quot;&gt;&lt;/a&gt;优先级队列（Priority Queue）&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉堆</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>http://yoursite.com/2020/07/14/二叉堆/</id>
    <published>2020-07-14T06:07:31.000Z</published>
    <updated>2020-07-14T08:43:03.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>设计一种数据结构，用来存放整数，要求提供 3 个接口</p><ol><li><p><strong>添加元素</strong></p></li><li><p><strong>获取最大值</strong></p></li><li><p><strong>删除最大值</strong></p></li></ol><p><img src="/2020/07/14/二叉堆/1.png" alt></p><p>有没有更优的数据结构？</p><p><strong>堆</strong>：获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)</p><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>堆（Heap）也是一种树状的数据结构（不要跟内存模型中的“堆空间”混淆），常见的堆实现有</p><ul><li><p>二叉堆（Binary Heap，完全二叉堆）</p></li><li><p>多叉堆（D-heap、D-ary Heap）</p></li><li><p>索引堆（Index Heap）</p></li><li><p>二项堆（Binomial Heap）</p></li><li><p>斐波那契堆（Fibonacci Heap）</p></li><li><p>左倾堆（Leftist Heap，左式堆）</p></li><li><p>斜堆（Skew Heap）</p></li></ul><p><img src="/2020/07/14/二叉堆/2.png" alt></p><p>堆的一个重要性质：<strong>任意节点的值总是 ≥（ ≤ ）子节点的值</strong></p><p>如果任意节点的值总是 ≥ 子节点的值，称为：<strong>最大堆、大根堆、大顶堆</strong></p><p>如果任意节点的值总是 ≤ 子节点的值，称为：<strong>最小堆、小根堆、小顶堆</strong></p><p>由此可见，堆中的元素必须具备可比较性（跟二叉搜索树一样）</p><h2 id="堆的基本接口设计"><a href="#堆的基本接口设计" class="headerlink" title="堆的基本接口设计"></a>堆的基本接口设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Heap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">// 元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">// 清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">// 添加元素</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">()</span></span>;<span class="comment">// 获得堆顶元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="function">E <span class="title">replace</span><span class="params">(E element)</span></span>; <span class="comment">// 删除堆顶元素的同时插入一个新元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHeap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Heap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">protected</span> Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHeap</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> comparator != <span class="keyword">null</span> ? comparator.compare(e1, e2) </span><br><span class="line">: ((Comparable&lt;E&gt;)e1).compareTo(e2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉堆（Binary-Heap）"><a href="#二叉堆（Binary-Heap）" class="headerlink" title="二叉堆（Binary Heap）"></a>二叉堆（Binary Heap）</h2><p><strong>二叉堆的逻辑结构就是一棵完全二叉树</strong>，所以也叫完全二叉堆</p><p>鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）一般用数组实现即可</p><p>索引 i 的规律（ n 是元素数量）</p><ul><li><p>如果 i = 0 ，它是根节点</p></li><li><p>如果 i &gt; 0 ，它的父节点的索引为 floor( (i – 1) / 2 )</p></li><li><p>如果 2i + 1 ≤ n – 1，它的左子节点的索引为 2i + 1</p></li><li><p>如果 2i + 1 &gt; n – 1 ，它无左子节点</p></li><li><p>如果 2i + 2 ≤ n – 1 ，它的右子节点的索引为 2i + 2</p></li><li><p>如果 2i + 2 &gt; n – 1 ，它无右子节点</p></li></ul><p><img src="/2020/07/14/二叉堆/3.png" alt></p><h3 id="二叉堆获取最大值"><a href="#二叉堆获取最大值" class="headerlink" title="二叉堆获取最大值"></a>二叉堆获取最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    emptyCheck();</span><br><span class="line">    <span class="keyword">return</span> elements[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emptyCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Heap is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-添加"><a href="#最大堆-–-添加" class="headerlink" title="最大堆 – 添加"></a>最大堆 – 添加</h3><p><img src="/2020/07/14/二叉堆/4.png" alt></p><p>循环执行以下操作（图中的 80 简称为 node）</p><ol><li><p><strong>如果 node ＞ 父节点</strong></p><p><strong>与父节点交换位置</strong></p></li><li><p><strong>如果 node ≤ 父节点，或者 node 没有父节点</strong></p><p><strong>退出循环</strong></p></li></ol><p>这个过程，叫做<strong>上滤（Sift Up）</strong></p><p>时间复杂度：O(logn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">    elements[size++] = element;</span><br><span class="line">    siftUp(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E e = elements[index];</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pindex = (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        E p = elements[pindex];</span><br><span class="line">        <span class="keyword">if</span> (compare(e, p) &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换index、pindex位置的内容</span></span><br><span class="line">        E tmp = elements[index];</span><br><span class="line">        elements[index] = elements[pindex];</span><br><span class="line">        elements[pindex] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新赋值index</span></span><br><span class="line">        index = pindex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-添加-–-交换位置的优化"><a href="#最大堆-–-添加-–-交换位置的优化" class="headerlink" title="最大堆 – 添加 – 交换位置的优化"></a>最大堆 – 添加 – 交换位置的优化</h3><p>一般交换位置需要3行代码，可以进一步优化</p><p>将新添加节点备份，确定最终位置才摆放上去</p><p><img src="/2020/07/14/二叉堆/5.png" alt></p><p>仅从交换位置的代码角度看</p><p>可以由大概的 3  O(logn) 优化到 1  O(logn) + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E element = elements[index];</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        E parent = elements[parentIndex];</span><br><span class="line">        <span class="keyword">if</span> (compare(element, parent) &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将父元素存储在index位置</span></span><br><span class="line">        elements[index] = parent;</span><br><span class="line">        <span class="comment">// 重新赋值index</span></span><br><span class="line">        index = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-删除"><a href="#最大堆-–-删除" class="headerlink" title="最大堆 – 删除"></a>最大堆 – 删除</h3><p><img src="/2020/07/14/二叉堆/6.png" alt></p><ol><li><p><strong>用最后一个节点覆盖根节点</strong></p></li><li><p><strong>删除最后一个节点</strong></p></li><li><p><strong>循环执行以下操作（图中的 43 简称为 node）</strong></p><ul><li><p><strong>如果 node &lt; 最大的子节点，与最大的子节点交换位置</strong></p></li><li><p><strong>如果 node ≥ 最大的子节点， 或者 node 没有子节点，退出循环</strong></p></li></ul></li></ol><p>这个过程，叫做<strong>下滤（Sift Down）</strong>，时间复杂度：O(logn)</p><p>同样的，交换位置的操作可以像添加那样进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    emptyCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastIndex = --size;</span><br><span class="line">    E root = elements[<span class="number">0</span>];</span><br><span class="line">    elements[<span class="number">0</span>] = elements[lastIndex];</span><br><span class="line">    elements[lastIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E element = elements[index];</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第一个叶子节点的索引 == 非叶子节点的数量</span></span><br><span class="line">    <span class="comment">// index &lt; 第一个叶子节点的索引</span></span><br><span class="line">    <span class="comment">// 必须保证index位置是非叶子节点</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; half) &#123; </span><br><span class="line">        <span class="comment">// index的节点有2种情况</span></span><br><span class="line">        <span class="comment">// 1.只有左子节点</span></span><br><span class="line">        <span class="comment">// 2.同时有左右子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为左子节点跟它进行比较</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        E child = elements[childIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="keyword">int</span> rightIndex = childIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选出左右子节点最大的那个</span></span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; size &amp;&amp; compare(elements[rightIndex], child) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            child = elements[childIndex = rightIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compare(element, child) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点存放到index位置</span></span><br><span class="line">        elements[index] = child;</span><br><span class="line">        <span class="comment">// 重新设置index</span></span><br><span class="line">        index = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-替换堆顶"><a href="#最大堆-替换堆顶" class="headerlink" title="最大堆 - 替换堆顶"></a>最大堆 - 替换堆顶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line"></span><br><span class="line">    E root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elements[<span class="number">0</span>] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = elements[<span class="number">0</span>];</span><br><span class="line">        elements[<span class="number">0</span>] = element;</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-批量建堆（Heapify）"><a href="#最大堆-–-批量建堆（Heapify）" class="headerlink" title="最大堆 – 批量建堆（Heapify）"></a>最大堆 – 批量建堆（Heapify）</h3><p>批量建堆，有 2 种做法</p><ol><li><p><strong>自上而下的上滤</strong></p></li><li><p><strong>自下而上的下滤</strong></p></li></ol><h4 id="最大堆-–-批量建堆-–-自上而下的上滤"><a href="#最大堆-–-批量建堆-–-自上而下的上滤" class="headerlink" title="最大堆 – 批量建堆 – 自上而下的上滤"></a>最大堆 – 批量建堆 – 自上而下的上滤</h4><p><img src="/2020/07/14/二叉堆/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自上而下的上滤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        siftUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大堆-–-批量建堆-–-自下而上的下滤"><a href="#最大堆-–-批量建堆-–-自下而上的下滤" class="headerlink" title="最大堆 – 批量建堆 – 自下而上的下滤"></a>最大堆 – 批量建堆 – 自下而上的下滤</h4><p><img src="/2020/07/14/二叉堆/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自下而上的下滤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大堆-–-批量建堆-–-效率对比"><a href="#最大堆-–-批量建堆-–-效率对比" class="headerlink" title="最大堆 – 批量建堆 – 效率对比"></a>最大堆 – 批量建堆 – 效率对比</h4><p><img src="/2020/07/14/二叉堆/9.png" alt><strong>所有节点的深度之和</strong></p><ul><li><p>仅仅是叶子节点，就有近 n/2 个，而且每一个叶子节点的深度都是 O(logn) 级别的</p></li><li><p>因此，在叶子节点这一块，就达到了 O(nlogn) 级别</p></li><li><p>O(nlogn) 的时间复杂度足以利用排序算法对所有节点进行全排序</p></li></ul><p><strong>所有节点的高度之和</strong></p><ul><li><p>假设是满树，节点总个数为 $n$，树高为 $h$，那么 $n = 2h − 1$</p></li><li><p>所有节点的树高之和 $H(n) = 2^0 ∗ (h − 0) + 2^1 ∗ (h − 1) + 2^2 ∗ (h − 2) + ⋯ + 2^{h −1}  ∗ [h − (h − 1)]$</p></li><li><p>$H(n) = h ∗ (2^0 + 2^1 + 2^2 + ⋯ + 2^{h −1}) − [1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 1)∗ 2^{h−1}]$</p></li><li><p>$H(n) = h ∗ (2^h − 1) − [(h − 2) ∗ 2^h + 2]$</p></li><li><p>$H(n) = h ∗ 2^h − h − h ∗ 2^h + 2^{h+1} − 2$</p></li><li><p>$H(n) = 2^{h+1} − h − 2 = 2 ∗ (2^h − 1) − h = 2n − h = 2n − log_2(n + 1) = O(n)$</p></li></ul><p><strong>公式推导</strong></p><ul><li><p>$S(h) = 1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 2) ∗ 2^{h−2} + (h − 1) * 2^{h−1}$</p></li><li><p>$2S(h) = 1 ∗ 2^2 + 2 ∗ 2^3 + 3 ∗ 2^4 + ⋯ + (h − 2) ∗ 2^{h−1} +(h − 1) ∗ 2^h$</p></li><li><p>$S(h) – 2S(h) = [2^1 + 2^2 + 2^3 + ⋯ + 2^{h−1}] − (h − 1) ∗ 2^h = (2^h − 2) − (h − 1) ∗ 2^h$</p></li><li><p>$S(h) = (h − 1) ∗ 2^h − (2^h − 2) = (h − 2) ∗ 2^h + 2$</p></li></ul><h3 id="批量建堆"><a href="#批量建堆" class="headerlink" title="批量建堆"></a>批量建堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(E[] elements, Comparator&lt;E&gt; comparator)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(comparator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="keyword">null</span> || elements.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size = elements.length;</span><br><span class="line">        <span class="keyword">int</span> capacity = Math.max(elements.length, DEFAULT_CAPACITY);</span><br><span class="line">        <span class="keyword">this</span>.elements = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elements[i] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自下而上的下滤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何构建一个小顶堆？"><a href="#如何构建一个小顶堆？" class="headerlink" title="如何构建一个小顶堆？"></a>如何构建一个小顶堆？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">88</span>, <span class="number">44</span>, <span class="number">53</span>, <span class="number">41</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">70</span>, <span class="number">18</span>, <span class="number">85</span>, <span class="number">98</span>, <span class="number">81</span>, <span class="number">23</span>, <span class="number">36</span>, <span class="number">43</span>, <span class="number">37</span>&#125;;</span><br><span class="line">BinaryHeap&lt;Integer&gt; heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(data, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">BinaryTrees.println(heap);</span><br></pre></td></tr></table></figure><h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><p>从 n 个整数中，找出最大的前 k 个数（ k 远远小于 n ）</p><p>如果使用排序算法进行全排序，需要 O(nlogn) 的时间复杂度</p><p>如果使用二叉堆来解决，可以使用 O(nlogk) 的时间复杂度来解决</p><ol><li><p>新建一个小顶堆</p></li><li><p>扫描 n 个整数</p><p>先将遍历到的前 k 个数放入堆中</p><p>从第 k + 1 个数开始，如果大于堆顶元素，就使用 replace 操作（删除堆顶元素，将第 k + 1 个数添加到堆中）</p></li><li><p>扫描完毕后，堆中剩下的就是最大的前 k 个数</p></li><li><p>如果是找出最小的前 k 个数呢？</p><p>用大顶堆</p><p>如果小于堆顶元素，就使用 replace 操作</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个小顶堆</span></span><br><span class="line">    BinaryHeap&lt;Integer&gt; heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最大的前k个数</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    Integer[] data = &#123;<span class="number">51</span>, <span class="number">30</span>, <span class="number">39</span>, <span class="number">92</span>, <span class="number">74</span>, <span class="number">25</span>, <span class="number">16</span>, <span class="number">93</span>, </span><br><span class="line">                      <span class="number">91</span>, <span class="number">19</span>, <span class="number">54</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">62</span>, <span class="number">76</span>, <span class="number">63</span>, <span class="number">35</span>, <span class="number">18</span>, </span><br><span class="line">                      <span class="number">90</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">49</span>, <span class="number">3</span>, <span class="number">26</span>, <span class="number">61</span>, <span class="number">21</span>, <span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; k) &#123; <span class="comment">// 前k个数添加到小顶堆</span></span><br><span class="line">            heap.add(data[i]); <span class="comment">// logk</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i] &gt; heap.get()) &#123; <span class="comment">// 如果是第k + 1个数，并且大于堆顶元素</span></span><br><span class="line">            heap.replace(data[i]); <span class="comment">// logk</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(nlogk)</span></span><br><span class="line">    BinaryTrees.println(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉堆&quot;&gt;&lt;a href=&quot;#二叉堆&quot; class=&quot;headerlink&quot; title=&quot;二叉堆&quot;&gt;&lt;/a&gt;二叉堆&lt;/h1&gt;&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉堆" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://yoursite.com/2020/07/13/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/13/哈希表/</id>
    <published>2020-07-13T06:35:39.000Z</published>
    <updated>2020-07-14T08:45:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表（HashTable）"><a href="#哈希表（HashTable）" class="headerlink" title="哈希表（HashTable）"></a>哈希表（HashTable）</h1><h2 id="先来分析TreeMap（）"><a href="#先来分析TreeMap（）" class="headerlink" title="先来分析TreeMap（）"></a>先来分析TreeMap（<a href="/2020/07/13/映射/" title="红黑树映射实现">红黑树映射实现</a>）</h2><ul><li><p>时间复杂度（平均）</p></li><li><p>添加、删除、搜索：O(logn)</p></li></ul><p><strong>特点</strong></p><ul><li><p>Key 必须具备可比较性</p></li><li><p>元素的分布是有顺序的</p></li></ul><p><strong>在实际应用中，很多时候的需求</strong></p><ul><li><p>Map 中存储的元素不需要讲究顺序</p></li><li><p>Map 中的 Key 不需要具备可比较性</p></li></ul><p>不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)，那就是<strong>采取哈希表来实现 Map</strong></p><h2 id="什么是哈希表（HashTable）"><a href="#什么是哈希表（HashTable）" class="headerlink" title="什么是哈希表（HashTable）"></a>什么是哈希表（HashTable）</h2><p>哈希表也叫做散列表（ hash 有“剁碎”的意思）</p><p>添加、搜索、删除的流程都是类似的</p><ol><li><p><strong>利用哈希函数生成 key 对应的 index【O(1)】</strong></p></li><li><p><strong>根据 index 操作定位数组元素【O(1)】</strong></p></li></ol><p>哈希表是【<strong>空间换时间</strong>】的典型应用</p><p>哈希函数，也叫做散列函数</p><p>哈希表内部的数组元素，很多地方也叫 Bucket（桶），整个数组叫 Buckets 或者 Bucket Array</p><p><img src="/2020/07/13/哈希表/1.png" alt></p><h2 id="哈希冲突（Hash-Collision）"><a href="#哈希冲突（Hash-Collision）" class="headerlink" title="哈希冲突（Hash Collision）"></a>哈希冲突（Hash Collision）</h2><p>哈希冲突也叫做哈希碰撞</p><p>2 个不同的 key，经过哈希函数计算出相同的结果</p><p><strong>key1 ≠ key2 ，hash(key1) = hash(key2)</strong></p><p><img src="/2020/07/13/哈希表/2.png" alt></p><p><strong>解决哈希冲突的常见方法</strong></p><ol><li><p>开放定址法（Open Addressing）</p><p>按照一定规则向其他地址探测，直到遇到空桶</p></li><li><p>再哈希法（Re-Hashing）</p><p>设计多个哈希函数</p></li><li><p>链地址法（Separate Chaining）</p><p>比如通过链表将同一index的元素串起来</p></li></ol><h2 id="JDK1-8的哈希冲突解决方案"><a href="#JDK1-8的哈希冲突解决方案" class="headerlink" title="JDK1.8的哈希冲突解决方案"></a>JDK1.8的哈希冲突解决方案</h2><p><strong>JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突</strong></p><ol><li><p>默认使用单向链表将元素串起来</p></li><li><p>在添加元素时，可能会<strong>由单向链表转为红黑树来存储元素</strong></p><p>比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时</p><p>当红黑树节点数量少到一定程度时，又会转为单向链表</p></li></ol><p><img src="/2020/07/13/哈希表/3.png" alt></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希表中哈希函数的实现步骤大概如下</p><ol><li><p>先生成 key 的哈希值（必须是整数）</p></li><li><p>再让 key 的哈希值跟数组的大小进行相关运算，生成一个索引值</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_code(key) % table.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为了提高效率，可以使用 &amp; 位运算取代 % 运算【前提：将数组的长度设计为 2 的幂（2n）】</strong></p><div class="table-container"><table><thead><tr><th style="text-align:right"><strong>1100  1010</strong></th><th style="text-align:right"><strong>1011  1100</strong></th></tr></thead><tbody><tr><td style="text-align:right"><strong>&amp;  1111</strong></td><td style="text-align:right"><strong>&amp;  1111</strong></td></tr><tr><td style="text-align:right"><strong>1010</strong></td><td style="text-align:right"><strong>1100</strong></td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_code(key) % (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>良好的哈希函数</strong></p><p>让哈希值更加均匀分布 → 减少哈希冲突次数 → 提升哈希表的性能</p><h2 id="如何生成key的哈希值"><a href="#如何生成key的哈希值" class="headerlink" title="如何生成key的哈希值"></a>如何生成key的哈希值</h2><p>key 的常见种类可能有</p><p><strong>整数、浮点数、字符串、自定义对象</strong></p><p>不同种类的 key，哈希值的生成方式不一样，但目标是一致的</p><p>尽量让每个 key 的哈希值是唯一的</p><p>尽量让 key 的所有信息参与运算</p><p><strong>在Java中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null</strong></p><h3 id="整数的哈希值"><a href="#整数的哈希值" class="headerlink" title="整数的哈希值"></a>整数的哈希值</h3><p>整数值当做哈希值</p><p>比如 10 的哈希值就是 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数的哈希值"><a href="#浮点数的哈希值" class="headerlink" title="浮点数的哈希值"></a>浮点数的哈希值</h3><p>将存储的二进制格式转为整数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Long和Double的哈希值"><a href="#Long和Double的哈希值" class="headerlink" title="Long和Double的哈希值"></a>Long和Double的哈希值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">double</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bits = doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>>&gt;&gt; 和 ^ 的作用是？</strong></p><p><strong>高32bit 和 低32bit 混合计算出 32bit 的哈希值</strong></p><p><strong>充分利用所有信息计算出哈希值</strong></p><p><img src="/2020/07/13/哈希表/4.png" alt></p><h3 id="字符串的哈希值"><a href="#字符串的哈希值" class="headerlink" title="字符串的哈希值"></a>字符串的哈希值</h3><p>字符串是由若干个字符组成的</p><p>比如字符串 jack，由 j、a、c、k 四个字符组成（字符的本质就是一个整数）</p><p>因此，jack 的哈希值可以表示为 $ j ∗ n^3 + a ∗ n^2 + c ∗ n^1 + k ∗ n^0$，等价于 $[ ( j ∗ n + a ) ∗ n + c ] ∗ n + k$</p><p>在JDK中，乘数 n 为 31，为什么使用 31？</p><p><strong>31 是一个奇素数，JVM会将 31 * i 优化成 (i &lt;&lt; 5) – i</strong></p><script type="math/tex; mode=display">31 * i = (2^5 - 1) * i = i * 2^5 - i = (i << 5) -i</script><p>31不仅仅是符合$2^n – 1$，它是个<strong>奇素数（既是奇数，又是素数，也就是质数）</strong></p><p><strong>素数和其他数相乘的结果比其他方式更容易产成唯一性，减少哈希冲突</strong></p><p>最终选择31是经过观测分布结果后的选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">"jack"</span>;</span><br><span class="line"><span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = string.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = string.charAt(i);</span><br><span class="line">    <span class="comment">// hashCode = 31 * hashCode + c;</span></span><br><span class="line">    hashCode = (hashCode &lt;&lt; <span class="number">5</span>) - hashCode + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义对象的哈希值"><a href="#自定义对象的哈希值" class="headerlink" title="自定义对象的哈希值"></a>自定义对象的哈希值</h3><p>自定义对象作为 key，最好同时<strong>重写 hashCode 、equals 方法</strong></p><ol><li><p>equals ：用以判断 2 个 key 是否为同一个 key</p><ul><li><p><strong>自反性</strong>：对于任何非 null 的 x，x.equals(x)必须返回true</p></li><li><p><strong>对称性</strong>：对于任何非 null 的 x、y，如果 y.equals(x) 返回 true，x.equals(y) 必须返回 true</p></li><li><p><strong>传递性</strong>：对于任何非 null 的 x、y、z，如果 x.equals(y)、y.equals(z) 返回 true，那么x.equals(z) 必须 返回 true</p></li><li><p><strong>一致性</strong>：对于任何非 null 的 x、y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用</p></li><li><p>x.equals(y) 就会一致地返回 true，或者一致地返回 false</p></li><li><p>对于任何非 null 的 x，x.equals(null) 必须返回 false</p></li></ul></li><li><p>hashCode ：必须保证 equals 为 true 的 2 个 key 的哈希值一样</p></li><li><p>反过来 hashCode 相等的 key，不一定 equals 为 true</p></li><li><p>不重写 hashCode 方法只重写 equals 会有什么后果？</p><p>可能会导致 2 个 equals 为 true 的 key 同时存在哈希表中</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> height;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">float</span> height, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.height = height;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来比较2个对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内存地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span> || obj.getClass() != getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// if (obj == null || !(obj instanceof Person)) return false;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较成员变量</span></span><br><span class="line">Person person = (Person) obj;</span><br><span class="line"><span class="keyword">return</span> person.age == age</span><br><span class="line">&amp;&amp; person.height == height</span><br><span class="line">&amp;&amp; (person.name == <span class="keyword">null</span> ? name == <span class="keyword">null</span> : person.name.equals(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hashCode = Integer.hashCode(age);</span><br><span class="line">hashCode = hashCode * <span class="number">31</span> + Float.hashCode(height);</span><br><span class="line">hashCode = hashCode * <span class="number">31</span> + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age - o.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希值的进一步处理：扰动计算"><a href="#哈希值的进一步处理：扰动计算" class="headerlink" title="哈希值的进一步处理：扰动计算"></a>哈希值的进一步处理：扰动计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h2><p>装填因子（Load Factor）：节点总数量 / 哈希表桶数组长度，也叫做负载因子</p><p>在JDK1.8的HashMap中，如果装填因子超过0.75，就扩容为原来的2倍</p><h2 id="TreeMap-vs-HashMap"><a href="#TreeMap-vs-HashMap" class="headerlink" title="TreeMap vs HashMap"></a>TreeMap vs HashMap</h2><p><strong>何时选择TreeMap：元素具备可比较性且要求升序遍历（按照元素从小到大）</strong></p><p><strong>何时选择HashMap：无序遍历</strong></p><h2 id="HashMap代码实现"><a href="#HashMap代码实现" class="headerlink" title="HashMap代码实现"></a>HashMap代码实现</h2><h3 id="Map接口定义"><a href="#Map接口定义" class="headerlink" title="Map接口定义"></a>Map接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> stop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些简单的函数"><a href="#一些简单的函数" class="headerlink" title="一些简单的函数"></a>一些简单的函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 初始容量 2^4</span></span><br><span class="line">    <span class="comment">// 装填因子，大于0.75扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">new</span> Node[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 清空哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            table[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(key, value, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 红黑树节点左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; parent = grand.right;</span><br><span class="line">        Node&lt;K, V&gt; child = parent.left;</span><br><span class="line">        grand.right = child;</span><br><span class="line">        parent.left = grand;</span><br><span class="line">        afterRotate(grand, parent, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点右旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; parent = grand.left;</span><br><span class="line">        Node&lt;K, V&gt; child = parent.right;</span><br><span class="line">        grand.left = child;</span><br><span class="line">        parent.right = grand;</span><br><span class="line">        afterRotate(grand, parent, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点选择之后的修复</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRotate</span><span class="params">(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让parent称为子树的根节点</span></span><br><span class="line">        parent.parent = grand.parent;</span><br><span class="line">        <span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">            grand.parent.left = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">            grand.parent.right = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// grand是root节点</span></span><br><span class="line">            table[index(grand)] = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新child的parent</span></span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.parent = grand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新grand的parent</span></span><br><span class="line">        grand.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">color</span><span class="params">(Node&lt;K, V&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        node.color = color;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">red</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color(node, RED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">black</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : node.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成Hash值"><a href="#生成Hash值" class="headerlink" title="生成Hash值"></a>生成Hash值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash(key) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash节点定义"><a href="#Hash节点定义" class="headerlink" title="Hash节点定义"></a>Hash节点定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">boolean</span> color = RED;</span><br><span class="line">    Node&lt;K, V&gt; left;</span><br><span class="line">    Node&lt;K, V&gt; right;</span><br><span class="line">    Node&lt;K, V&gt; parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">int</span> hash = key == <span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode();</span><br><span class="line">        <span class="keyword">this</span>.hash = hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node_"</span> + key + <span class="string">"_"</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(key, value, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="node函数查找节点"><a href="#node函数查找节点" class="headerlink" title="node函数查找节点"></a>node函数查找节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">node</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; root = table[index(key)];</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">null</span> : node(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">node</span><span class="params">(Node&lt;K, V&gt; node, K k1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1 = hash(k1);</span><br><span class="line">    <span class="comment">// 存储查找结果</span></span><br><span class="line">    Node&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        K k2 = node.key;</span><br><span class="line">        <span class="keyword">int</span> h2 = node.hash;</span><br><span class="line">        <span class="comment">// 先比较哈希值</span></span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">            node = cmp &gt; <span class="number">0</span> ? node.right : node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; (result = node(node.right, k1)) != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只能往左边找</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash添加-put-K-key-V-value"><a href="#Hash添加-put-K-key-V-value" class="headerlink" title="Hash添加 put(K key, V value)"></a>Hash添加 put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    resize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = index(key);</span><br><span class="line">    <span class="comment">// 取出index位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = createNode(key, value, <span class="keyword">null</span>);</span><br><span class="line">        table[index] = root;</span><br><span class="line">        size++;</span><br><span class="line">        fixAfterPut(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树上面</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    K k1 = key;</span><br><span class="line">    <span class="keyword">int</span> h1 = hash(k1);</span><br><span class="line">    Node&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>; <span class="comment">// 是否已经搜索过这个key</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;</span><br><span class="line">        K k2 = node.key;</span><br><span class="line">        <span class="keyword">int</span> h2 = node.hash;</span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            cmp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searched) &#123; <span class="comment">// 已经扫描了</span></span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// searched == false; 还没有扫描，然后再根据内存地址大小决定左右</span></span><br><span class="line">            <span class="keyword">if</span> ((node.left != <span class="keyword">null</span> &amp;&amp; (result = node(node.left, k1)) != <span class="keyword">null</span>)</span><br><span class="line">                || (node.right != <span class="keyword">null</span> &amp;&amp; (result = node(node.right, k1)) != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 已经存在这个key</span></span><br><span class="line">                node = result;</span><br><span class="line">                cmp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在这个key</span></span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            V oldValue = node.value;</span><br><span class="line">            node.key = key;</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.hash = h1;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = createNode(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">    fixAfterPut(newNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash添加后修复红黑树"><a href="#Hash添加后修复红黑树" class="headerlink" title="Hash添加后修复红黑树"></a>Hash添加后修复红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterPut</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        black(node);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叔父节点</span></span><br><span class="line">    Node&lt;K, V&gt; uncle = parent.sibling();</span><br><span class="line">    <span class="comment">// 祖父节点</span></span><br><span class="line">    Node&lt;K, V&gt; grand = red(parent.parent);</span><br><span class="line">    <span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">        black(parent);</span><br><span class="line">        black(uncle);</span><br><span class="line">        <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">        fixAfterPut(grand);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叔父节点不是红色</span></span><br><span class="line">    <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">            black(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">            black(node);</span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        rotateRight(grand);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">            black(node);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">            black(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        rotateLeft(grand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash删除-key、节点"><a href="#Hash删除-key、节点" class="headerlink" title="Hash删除(key、节点)"></a>Hash删除(key、节点)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(node(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> V <span class="title">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; willNode = node;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    V oldValue = node.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line">        <span class="comment">// 找到后继节点</span></span><br><span class="line">        Node&lt;K, V&gt; s = successor(node);</span><br><span class="line">        <span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">        node.key = s.key;</span><br><span class="line">        node.value = s.value;</span><br><span class="line">        node.hash = s.hash;</span><br><span class="line">        <span class="comment">// 删除后继节点</span></span><br><span class="line">        node = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除node节点（node的度必然是1或者0）</span></span><br><span class="line">    Node&lt;K, V&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line">    <span class="keyword">int</span> index = index(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点</span></span><br><span class="line">        <span class="comment">// 更改parent</span></span><br><span class="line">        replacement.parent = node.parent;</span><br><span class="line">        <span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">            table[index] = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">            node.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">        fixAfterRemove(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是叶子节点并且是根节点</span></span><br><span class="line">        table[index] = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">            node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">        fixAfterRemove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交给子类去处理</span></span><br><span class="line">    afterRemove(willNode, node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash删除后修复红黑树"><a href="#Hash删除后修复红黑树" class="headerlink" title="Hash删除后修复红黑树"></a>Hash删除后修复红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterRemove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">    <span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">        black(node);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;K, V&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">            <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">            <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">            black(parent);</span><br><span class="line">            red(sibling);</span><br><span class="line">            <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                fixAfterRemove(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">                rotateRight(sibling);</span><br><span class="line">                sibling = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            color(sibling, colorOf(parent));</span><br><span class="line">            black(sibling.right);</span><br><span class="line">            black(parent);</span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">            <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">            <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">            black(parent);</span><br><span class="line">            red(sibling);</span><br><span class="line">            <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                fixAfterRemove(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">                rotateLeft(sibling);</span><br><span class="line">                sibling = parent.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            color(sibling, colorOf(parent));</span><br><span class="line">            black(sibling.left);</span><br><span class="line">            black(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树后继节点"><a href="#红黑树后继节点" class="headerlink" title="红黑树后继节点"></a>红黑树后继节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">successor</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点在左子树当中（right.left.left.left....）</span></span><br><span class="line">    Node&lt;K, V&gt; p = node.right;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash查找（key、vaule）"><a href="#Hash查找（key、vaule）" class="headerlink" title="Hash查找（key、vaule）"></a>Hash查找（key、vaule）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 得到key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; node = node(key);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="keyword">null</span> ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        queue.offer(table[i]);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(value, node.value)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash扩容"><a href="#Hash扩容" class="headerlink" title="Hash扩容"></a>Hash扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装填因子 &lt;= 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (size / table.length &lt;= DEFAULT_LOAD_FACTOR) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">    table = <span class="keyword">new</span> Node[oldTable.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldTable.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldTable[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        queue.offer(oldTable[i]);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挪动代码得放到最后面</span></span><br><span class="line">            moveNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动节点"><a href="#移动节点" class="headerlink" title="移动节点"></a>移动节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveNode</span><span class="params">(Node&lt;K, V&gt; newNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    newNode.parent = <span class="keyword">null</span>;</span><br><span class="line">    newNode.left = <span class="keyword">null</span>;</span><br><span class="line">    newNode.right = <span class="keyword">null</span>;</span><br><span class="line">    newNode.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = index(newNode);</span><br><span class="line">    <span class="comment">// 取出index位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">        table[index] = root;</span><br><span class="line">        fixAfterPut(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树上面</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    K k1 = newNode.key;</span><br><span class="line">    <span class="keyword">int</span> h1 = newNode.hash;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;</span><br><span class="line">        K k2 = node.key;</span><br><span class="line">        <span class="keyword">int</span> h2 = node.hash;</span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    newNode.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">    fixAfterPut(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>在HashMap的基础上维护元素的添加顺序，使得遍历的结果是遵从添加顺序的</p><p>假设添加顺序是：37、21、31、41、97、95、52、42、83</p><p><img src="/2020/07/13/哈希表/5.png" alt></p><h4 id="LinkedHashMap-–-删除注意点"><a href="#LinkedHashMap-–-删除注意点" class="headerlink" title="LinkedHashMap – 删除注意点"></a>LinkedHashMap – 删除注意点</h4><p>删除度为2的节点node时（比如删除31）</p><p>需要注意更换 node 与 前驱/后继节点的连接位置</p><p><img src="/2020/07/13/哈希表/6.png" alt></p><h4 id="LinkedHashMap-–-更换节点的连接位置"><a href="#LinkedHashMap-–-更换节点的连接位置" class="headerlink" title="LinkedHashMap – 更换节点的连接位置"></a>LinkedHashMap – 更换节点的连接位置</h4><p><img src="/2020/07/13/哈希表/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换prev</span></span><br><span class="line">LinkedNode&lt;K, V&gt; tmp = node1.prev;</span><br><span class="line">node1.prev = node2.prev;</span><br><span class="line">node2.prev = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node1.prev.next = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node2.prev.next = node2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换next</span></span><br><span class="line">tmp = node1.next;</span><br><span class="line">node1.next = node2.next;</span><br><span class="line">node2.next = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node1.next.prev = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node2.next.prev = node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap代码实现"><a href="#LinkedHashMap代码实现" class="headerlink" title="LinkedHashMap代码实现"></a>LinkedHashMap代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> LinkedNode&lt;K, V&gt; first;</span><br><span class="line"><span class="keyword">private</span> LinkedNode&lt;K, V&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.clear();</span><br><span class="line">first = <span class="keyword">null</span>;</span><br><span class="line">last = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">LinkedNode&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (Objects.equals(value, node.value)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visitor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">LinkedNode&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (visitor.visit(node.key, node.value)) <span class="keyword">return</span>;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;K, V&gt; willNode, Node&lt;K, V&gt; removedNode)</span> </span>&#123;</span><br><span class="line">LinkedNode&lt;K, V&gt; node1 = (LinkedNode&lt;K, V&gt;) willNode;</span><br><span class="line">LinkedNode&lt;K, V&gt; node2 = (LinkedNode&lt;K, V&gt;) removedNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node1 != node2) &#123;</span><br><span class="line"><span class="comment">// 交换linkedWillNode和linkedRemovedNode在链表中的位置</span></span><br><span class="line"><span class="comment">// 交换prev</span></span><br><span class="line">LinkedNode&lt;K, V&gt; tmp = node1.prev;</span><br><span class="line">node1.prev = node2.prev;</span><br><span class="line">node2.prev = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node1.prev.next = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node2.prev.next = node2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换next</span></span><br><span class="line">tmp = node1.next;</span><br><span class="line">node1.next = node2.next;</span><br><span class="line">node2.next = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">last = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node1.next.prev = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">last = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node2.next.prev = node2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedNode&lt;K, V&gt; prev = node2.prev;</span><br><span class="line">LinkedNode&lt;K, V&gt; next = node2.next;</span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">last = prev;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next.prev = prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">LinkedNode node = <span class="keyword">new</span> LinkedNode(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = last = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">last.next = node;</span><br><span class="line">node.prev = last;</span><br><span class="line">last = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">LinkedNode&lt;K, V&gt; prev;</span><br><span class="line">LinkedNode&lt;K, V&gt; next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(key, value, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希表（HashTable）&quot;&gt;&lt;a href=&quot;#哈希表（HashTable）&quot; class=&quot;headerlink&quot; title=&quot;哈希表（HashTable）&quot;&gt;&lt;/a&gt;哈希表（HashTable）&lt;/h1&gt;&lt;h2 id=&quot;先来分析TreeMap（）&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="映射" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%98%A0%E5%B0%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="映射" scheme="http://yoursite.com/tags/%E6%98%A0%E5%B0%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>映射</title>
    <link href="http://yoursite.com/2020/07/13/%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/13/映射/</id>
    <published>2020-07-13T06:23:56.000Z</published>
    <updated>2020-07-14T08:44:51.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h1><p>Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C、Swift 等）</p><p><img src="/2020/07/13/映射/1.png" alt></p><p><strong>Map 的每一个 key 是唯一的</strong></p><h2 id="Map的接口设计"><a href="#Map的接口设计" class="headerlink" title="Map的接口设计"></a>Map的接口设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> stop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现</p><h2 id="Map利用红黑树实现"><a href="#Map利用红黑树实现" class="headerlink" title="Map利用红黑树实现"></a>Map利用红黑树实现</h2><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;K&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">keyNotNullCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加第一个节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> Node&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">afterPut(root);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加的不是第一个节点</span></span><br><span class="line"><span class="comment">// 找到父节点</span></span><br><span class="line">Node&lt;K, V&gt; parent = root;</span><br><span class="line">Node&lt;K, V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">cmp = compare(key, node.key);</span><br><span class="line">parent = node;</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.right;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">node.key = key;</span><br><span class="line">V oldValue = node.value;</span><br><span class="line">node.value = value;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">parent.right = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent.left = newNode;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">afterPut(newNode);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> remove(node(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.offer(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (valEquals(value, node.value)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visitor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">traversal(root, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node&lt;K, V&gt; node, Visitor&lt;K, V&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || visitor.stop) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">traversal(node.left, visitor);</span><br><span class="line"><span class="keyword">if</span> (visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">visitor.visit(node.key, node.value);</span><br><span class="line">traversal(node.right, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valEquals</span><span class="params">(V v1, V v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 == <span class="keyword">null</span> ? v2 == <span class="keyword">null</span> : v1.equals(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">size--;</span><br><span class="line"></span><br><span class="line">V oldValue = node.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line"><span class="comment">// 找到后继节点</span></span><br><span class="line">Node&lt;K, V&gt; s = successor(node);</span><br><span class="line"><span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">node.key = s.key;</span><br><span class="line">node.value = s.value;</span><br><span class="line"><span class="comment">// 删除后继节点</span></span><br><span class="line">node = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除node节点（node的度必然是1或者0）</span></span><br><span class="line">Node&lt;K, V&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点</span></span><br><span class="line"><span class="comment">// 更改parent</span></span><br><span class="line">replacement.parent = node.parent;</span><br><span class="line"><span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line"><span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">root = replacement;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">node.parent.left = replacement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">node.parent.right = replacement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点之后的处理</span></span><br><span class="line">afterRemove(replacement);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是叶子节点并且是根节点</span></span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line"><span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点之后的处理</span></span><br><span class="line">afterRemove(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果删除的节点是红色</span></span><br><span class="line"><span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line"><span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">black(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line"><span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line"><span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">Node&lt;K, V&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line"><span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line"><span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">black(sibling);</span><br><span class="line">red(parent);</span><br><span class="line">rotateLeft(parent);</span><br><span class="line"><span class="comment">// 更换兄弟</span></span><br><span class="line">sibling = parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line"><span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line"><span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">black(parent);</span><br><span class="line">red(sibling);</span><br><span class="line"><span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">afterRemove(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line"><span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">rotateRight(sibling);</span><br><span class="line">sibling = parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color(sibling, colorOf(parent));</span><br><span class="line">black(sibling.right);</span><br><span class="line">black(parent);</span><br><span class="line">rotateLeft(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line"><span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">black(sibling);</span><br><span class="line">red(parent);</span><br><span class="line">rotateRight(parent);</span><br><span class="line"><span class="comment">// 更换兄弟</span></span><br><span class="line">sibling = parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line"><span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line"><span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">black(parent);</span><br><span class="line">red(sibling);</span><br><span class="line"><span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">afterRemove(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line"><span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">rotateLeft(sibling);</span><br><span class="line">sibling = parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color(sibling, colorOf(parent));</span><br><span class="line">black(sibling.left);</span><br><span class="line">black(parent);</span><br><span class="line">rotateRight(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">predecessor</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点在左子树当中（left.right.right.right....）</span></span><br><span class="line">Node&lt;K, V&gt; p = node.left;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">p = p.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line"><span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.left) &#123;</span><br><span class="line">node = node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node.parent == null</span></span><br><span class="line"><span class="comment">// node == node.parent.right</span></span><br><span class="line"><span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">successor</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点在左子树当中（right.left.left.left....）</span></span><br><span class="line">Node&lt;K, V&gt; p = node.right;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">p = p.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line"><span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">node = node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">node</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; node = root;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = compare(key, node.key);</span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// cmp &lt; 0</span></span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterPut</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">black(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;K, V&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;K, V&gt; grand = red(parent.parent);</span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">black(parent);</span><br><span class="line">black(uncle);</span><br><span class="line"><span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">afterPut(grand);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line"><span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">black(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">black(node);</span><br><span class="line">rotateLeft(parent);</span><br><span class="line">&#125;</span><br><span class="line">rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line"><span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">black(node);</span><br><span class="line">rotateRight(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">black(parent);</span><br><span class="line">&#125;</span><br><span class="line">rotateLeft(grand);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; parent = grand.right;</span><br><span class="line">Node&lt;K, V&gt; child = parent.left;</span><br><span class="line">grand.right = child;</span><br><span class="line">parent.left = grand;</span><br><span class="line">afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; parent = grand.left;</span><br><span class="line">Node&lt;K, V&gt; child = parent.right;</span><br><span class="line">grand.left = child;</span><br><span class="line">parent.right = grand;</span><br><span class="line">afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRotate</span><span class="params">(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 让parent称为子树的根节点</span></span><br><span class="line">parent.parent = grand.parent;</span><br><span class="line"><span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">grand.parent.left = parent;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">grand.parent.right = parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// grand是root节点</span></span><br><span class="line">root = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新child的parent</span></span><br><span class="line"><span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">child.parent = grand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新grand的parent</span></span><br><span class="line">grand.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">color</span><span class="params">(Node&lt;K, V&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">node.color = color;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">red</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color(node, RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">black</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : node.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(K e1, K e2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> comparator.compare(e1, e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ((Comparable&lt;K&gt;)e1).compareTo(e2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyNotNullCheck</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key must not be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">boolean</span> color = RED;</span><br><span class="line">Node&lt;K, V&gt; left;</span><br><span class="line">Node&lt;K, V&gt; right;</span><br><span class="line">Node&lt;K, V&gt; parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line"><span class="keyword">return</span> parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line"><span class="keyword">return</span> parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;映射（Map）&quot;&gt;&lt;a href=&quot;#映射（Map）&quot; class=&quot;headerlink&quot; title=&quot;映射（Map）&quot;&gt;&lt;/a&gt;映射（Map）&lt;/h1&gt;&lt;p&gt;Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="映射" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%98%A0%E5%B0%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="映射" scheme="http://yoursite.com/tags/%E6%98%A0%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="http://yoursite.com/2020/07/13/%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/07/13/集合/</id>
    <published>2020-07-13T06:14:53.000Z</published>
    <updated>2020-07-14T08:43:48.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h1><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p><strong>不存放重复的元素，常用于去重</strong></p><p>存放新增 IP，统计新增 IP 量</p><p>存放词汇，统计词汇量</p><h2 id="集合接口定义"><a href="#集合接口定义" class="headerlink" title="集合接口定义"></a>集合接口定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;E&gt; visitor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> stop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合的内部实现直接利用学过的数据结构实现<strong>（链表，动态数组，红黑树、AVL树）</strong></p><h2 id="集合利用链表实现"><a href="#集合利用链表实现" class="headerlink" title="集合利用链表实现"></a>集合利用链表实现</h2><a href="/2020/07/11/链表/" title="链表的实现">链表的实现</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.contains(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = list.indexOf(element);</span><br><span class="line"><span class="keyword">if</span> (index != List.ELEMENT_NOT_FOUND) &#123; <span class="comment">// 存在就覆盖</span></span><br><span class="line">list.set(index, element);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在就添加</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = list.indexOf(element);</span><br><span class="line"><span class="keyword">if</span> (index != List.ELEMENT_NOT_FOUND) &#123;</span><br><span class="line">list.remove(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合利用红黑树实现"><a href="#集合利用红黑树实现" class="headerlink" title="集合利用红黑树实现"></a>集合利用红黑树实现</h2><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> RBTree&lt;E&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">tree = <span class="keyword">new</span> RBTree&lt;&gt;(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tree.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tree.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tree.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tree.contains(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">tree.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">tree.remove(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合（Set）&quot;&gt;&lt;a href=&quot;#集合（Set）&quot; class=&quot;headerlink&quot; title=&quot;集合（Set）&quot;&gt;&lt;/a&gt;集合（Set）&lt;/h1&gt;&lt;h2 id=&quot;集合的特点&quot;&gt;&lt;a href=&quot;#集合的特点&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="集合" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2020/07/12/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/红黑树/</id>
    <published>2020-07-12T05:44:00.000Z</published>
    <updated>2020-07-14T08:43:41.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red Black Tree）"></a>红黑树（Red Black Tree）</h1><h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>红黑树也是一种<strong>自平衡的二叉搜索树</strong></p><p>以前也叫做平衡二叉B树（Symmetric Binary B-tree）</p><p>红黑树必须满足以下 <strong>5 条性质</strong></p><ol><li><p>节点是 <strong>RED</strong> 或者 <strong>BLACK</strong></p></li><li><p>根节点是 <strong>BLACK</strong></p></li><li><p>叶子节点（外部节点，空节点）都是 <strong>BLACK</strong></p></li><li><p><strong>RED</strong> 节点的子节点都是 <strong>BLACK</strong></p><p><strong>RED</strong> 节点的 parent 都是 <strong>BLACK</strong></p><p>从根节点到叶子节点的所有路径上不能有 2 个连续的 <strong>RED</strong> 节点</p></li><li><p>从任一节点到叶子节点的所有路径都包含相同数目的 <strong>BLACK</strong> 节点</p></li></ol><p><img src="/2020/07/12/红黑树/1.png" alt></p><h2 id="红黑树的等价变换"><a href="#红黑树的等价变换" class="headerlink" title="红黑树的等价变换"></a>红黑树的等价变换</h2><p>红黑树 和 4阶B树（2-3-4树）具有等价性</p><p><strong>BLACK</strong> 节点与它的 <strong>RED</strong> 子节点融合在一起，形成1个B树节点</p><p>红黑树的 <strong>BLACK</strong> 节点个数 与 4阶B树的节点总个数相等</p><p><strong>注意：后面展示的红黑树都会省略 NULL 节点</strong></p><p><img src="/2020/07/12/红黑树/2.png" alt></p><h2 id="红黑树-vs-2-3-4树"><a href="#红黑树-vs-2-3-4树" class="headerlink" title="红黑树 vs 2-3-4树"></a>红黑树 vs 2-3-4树</h2><p><img src="/2020/07/12/红黑树/3.png" alt></p><p>如果上图最底层的 <strong>BLACK</strong> 节点是不存在的，在B树中是什么样的情形？</p><p><strong>整棵B树只有1个节点，而且是超级节点</strong></p><h2 id="一些辅助函数"><a href="#一些辅助函数" class="headerlink" title="一些辅助函数"></a>一些辅助函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent：父节点</span></span><br><span class="line"><span class="comment">// sibling：兄弟节点</span></span><br><span class="line"><span class="comment">// uncle：叔父节点（parent 的兄弟节点）</span></span><br><span class="line"><span class="comment">// grand：祖父节点（parent 的父节点）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">color</span><span class="params">(Node&lt;E&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">   ((RBNode&lt;E&gt;)node).color = color;</span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染红</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">red</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> color(node, RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染黑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">black</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : ((RBNode&lt;E&gt;)node).color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是黑色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是红色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否有兄弟节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的添加"><a href="#红黑树的添加" class="headerlink" title="红黑树的添加"></a>红黑树的添加</h2><p>已知</p><ol><li><p>B树中，新元素必定是添加到叶子节点中</p></li><li><p>4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3</p></li></ol><p><strong>建议新添加的节点默认为 RED</strong>，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定）</p><h3 id="有-4-种情况满足红黑树的性质-4-：parent-为BLACK"><a href="#有-4-种情况满足红黑树的性质-4-：parent-为BLACK" class="headerlink" title="有 4 种情况满足红黑树的性质 4 ：parent 为BLACK"></a>有 4 种情况满足红黑树的性质 4 ：parent 为BLACK</h3><p>同样也满足4阶B树的性质</p><p>因此不用做任何额外处理</p><p><img src="/2020/07/12/红黑树/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h3 id="有-8-种情况不满足红黑树的性质-4-：parent-为-RED（-Double-Red-）"><a href="#有-8-种情况不满足红黑树的性质-4-：parent-为-RED（-Double-Red-）" class="headerlink" title="有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）"></a>有 8 种情况不满足红黑树的性质 4 ：parent 为 <strong>RED</strong>（ <strong>Double</strong> <strong>Red</strong> ）</h3><p>其中前 4 种属于B树节点上溢的情况</p><p><img src="/2020/07/12/红黑树/5.png" alt></p><h4 id="添加-–-修复性质4-–-LL-RR"><a href="#添加-–-修复性质4-–-LL-RR" class="headerlink" title="添加 – 修复性质4 – LL\RR"></a>添加 – 修复性质4 – LL\RR</h4><p>判定条件：uncle 不是 <strong>RED</strong></p><p>1.parent 染成 <strong>BLACK</strong>，grand 染成 <strong>RED</strong></p><p>2.grand 进行单旋操作</p><p>LL：右旋转</p><p>RR：左旋转</p><p><img src="/2020/07/12/红黑树/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点染成红色</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">    <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">        black(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">    <span class="keyword">if</span> (!node.isLeftChild()) &#123; <span class="comment">// RR</span></span><br><span class="line">        black(parent);</span><br><span class="line">    &#125; </span><br><span class="line">    rotateLeft(grand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-LR-RL"><a href="#添加-–-修复性质4-–-LR-RL" class="headerlink" title="添加 – 修复性质4 – LR\RL"></a>添加 – 修复性质4 – LR\RL</h4><p>判定条件：uncle 不是 <strong>RED</strong></p><ol><li><p>自己染成 <strong>BLACK</strong>，grand 染成 <strong>RED</strong></p></li><li><p>进行双旋操作</p></li></ol><p>LR：parent 左旋转， grand 右旋转</p><p>RL：parent 右旋转， grand 左旋转</p><p><img src="/2020/07/12/红黑树/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点染成红色</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">   <span class="keyword">if</span> (!node.isLeftChild()) &#123; <span class="comment">// LR</span></span><br><span class="line">      black(node);</span><br><span class="line">      rotateLeft(parent);</span><br><span class="line">   &#125;</span><br><span class="line">   rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">   <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">      black(node);</span><br><span class="line">      rotateRight(parent);</span><br><span class="line">   &#125;</span><br><span class="line">   rotateLeft(grand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-LL"><a href="#添加-–-修复性质4-–-上溢-–-LL" class="headerlink" title="添加 – 修复性质4 – 上溢 – LL"></a>添加 – 修复性质4 – 上溢 – LL</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p>grand 向上合并时，可能继续发生上溢</p><p>若上溢持续到根节点，只需将根节点染成 <strong>BLACK</strong></p><p><img src="/2020/07/12/红黑树/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    black(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">   black(parent);</span><br><span class="line">   black(uncle);</span><br><span class="line">   <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">   afterAdd(grand);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-RR"><a href="#添加-–-修复性质4-–-上溢-–-RR" class="headerlink" title="添加 – 修复性质4 – 上溢 – RR"></a>添加 – 修复性质4 – 上溢 – RR</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">   black(parent);</span><br><span class="line">   black(uncle);</span><br><span class="line">   <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">   afterAdd(grand);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-LR"><a href="#添加-–-修复性质4-–-上溢-–-LR" class="headerlink" title="添加 – 修复性质4 – 上溢 – LR"></a>添加 – 修复性质4 – 上溢 – LR</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/10.png" alt></p><h4 id="添加-–-修复性质4-–-上溢-–-RL"><a href="#添加-–-修复性质4-–-上溢-–-RL" class="headerlink" title="添加 – 修复性质4 – 上溢 – RL"></a>添加 – 修复性质4 – 上溢 – RL</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/11.png" alt></p><h2 id="红黑树添加后完整修复的代码"><a href="#红黑树添加后完整修复的代码" class="headerlink" title="红黑树添加后完整修复的代码"></a>红黑树添加后完整修复的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterAdd</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   Node&lt;E&gt; parent = node.parent;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">      black(node);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 叔父节点</span></span><br><span class="line">   Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line">   <span class="comment">// 祖父节点</span></span><br><span class="line">   Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line">   <span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">      black(parent);</span><br><span class="line">      black(uncle);</span><br><span class="line">      <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">      afterAdd(grand);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 叔父节点不是红色</span></span><br><span class="line">   <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">         black(parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">         black(node);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">      &#125;</span><br><span class="line">      rotateRight(grand);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">         black(node);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">         black(parent);</span><br><span class="line">      &#125;</span><br><span class="line">      rotateLeft(grand);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p><strong>B树中，最后真正被删除的元素都在叶子节点中</strong></p><p><img src="/2020/07/12/红黑树/12.png" alt></p><h3 id="删除-–-RED节点"><a href="#删除-–-RED节点" class="headerlink" title="删除 – RED节点"></a>删除 – RED节点</h3><p>直接删除，不用作任何调整</p><p><img src="/2020/07/12/红黑树/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node)) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-–-BLACK节点"><a href="#删除-–-BLACK节点" class="headerlink" title="删除 – BLACK节点"></a>删除 – BLACK节点</h3><p>有 3 种情况</p><ol><li><p>拥有 2 个 <strong>RED</strong> 子节点的 <strong>BLACK</strong> 节点</p><p>不可能被直接删除，因为会找它的子节点替代删除</p><p>因此不用考虑这种情况</p></li><li><p>拥有 1 个 <strong>RED</strong> 子节点的 <strong>BLACK</strong> 节点</p></li><li><p><strong>BLACK</strong> 叶子节点</p></li></ol><p><strong>下文举例采用: 被删除的节点在右边，兄弟节点在左边，（反之交换左右方向即可）</strong></p><p><img src="/2020/07/12/红黑树/14.png" alt></p><h4 id="删除-拥有-1-个-RED-子节点的-BLACK-节点"><a href="#删除-拥有-1-个-RED-子节点的-BLACK-节点" class="headerlink" title="删除 - 拥有 1 个 RED 子节点的 BLACK 节点"></a>删除 - 拥有 1 个 RED 子节点的 BLACK 节点</h4><p>判定条件：用以替代的子节点是 <strong>RED</strong></p><p>将替代的子节点染成 <strong>BLACK</strong> 即可保持红黑树性质</p><p><img src="/2020/07/12/红黑树/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用以取代node的子节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(replacement)) &#123;</span><br><span class="line">        black(replacement);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为BLACK-sibling-至少有-1-个-RED-子节点"><a href="#删除-BLACK-叶子节点-sibling为BLACK-sibling-至少有-1-个-RED-子节点" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 RED 子节点"></a>删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 <strong>RED</strong> 子节点</h4><p><strong>BLACK</strong> 叶子节点被删除后，会导致B树节点下溢（比如删除88）</p><p>如果 sibling 至少有 1 个 <strong>RED</strong> 子节点<strong>（一个或两个RED子节点）</strong></p><p><strong>兄弟节点的左边是黑色，(没有子节点也算是黑色)</strong></p><ol><li><p>兄弟节点左旋</p></li><li><p>改变兄弟节点为parent的左边</p></li><li><p>后续再按<strong>兄弟节点的左边是红色</strong>执行即可</p></li></ol><p><img src="/2020/07/12/红黑树/17.png" alt></p><p><strong>兄弟节点的左边是红色</strong></p><ol><li><p>兄弟节点继承 parent 的颜色</p></li><li><p>兄弟节点的左边变成黑色</p></li><li><p>parent节点变成黑色</p></li><li><p>parent右旋</p></li></ol><p><img src="/2020/07/12/红黑树/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line">            </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling)) &#123; <span class="comment">// 兄弟节点是黑色</span></span><br><span class="line">            <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(sibling.left) || isRed(sibling.right)) &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">                    rotateLeft(sibling);</span><br><span class="line">                    sibling = parent.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 兄弟节点的左边是红色或兄弟旋转后</span></span><br><span class="line">                color(sibling, colorOf(parent));</span><br><span class="line">                black(sibling.left);</span><br><span class="line">                black(parent);</span><br><span class="line">                rotateRight(parent);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为BLACK-sibling-没有-1-个-RED-子节点"><a href="#删除-BLACK-叶子节点-sibling为BLACK-sibling-没有-1-个-RED-子节点" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 RED 子节点"></a>删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 <strong>RED</strong> 子节点</h4><p>判定条件：sibling 没有 1 个 <strong>RED</strong> 子节点</p><p>将 sibling 染成 <strong>RED</strong>、parent 染成 <strong>BLACK</strong> 即可修复红黑树性质</p><p>如果 parent 是 <strong>BLACK</strong></p><p>会导致 parent 也下溢</p><p>这时只需要把 parent 当做被删除的节点处理即可</p><p><img src="/2020/07/12/红黑树/18.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="comment">// 兄弟节点是黑色</span></span><br><span class="line">        <span class="keyword">if</span>(isBlack(sibling))&#123;</span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">                <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">                black(parent);</span><br><span class="line">                red(sibling);</span><br><span class="line">                <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                    afterRemove(parent, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为RED"><a href="#删除-BLACK-叶子节点-sibling为RED" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为RED"></a>删除 - BLACK 叶子节点 - sibling为RED</h4><p>如果 sibling 是 <strong>RED</strong></p><p>sibling 染成 <strong>BLACK</strong>，parent 染成 <strong>RED</strong>，进行旋转</p><p>于是又回到 sibling 是 <strong>BLACK</strong> 的情况</p><p><img src="/2020/07/12/红黑树/19.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树删除后完整修复的代码"><a href="#红黑树删除后完整修复的代码" class="headerlink" title="红黑树删除后完整修复的代码"></a>红黑树删除后完整修复的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">   <span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line">   <span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">      black(node);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Node&lt;E&gt; parent = node.parent;</span><br><span class="line">   <span class="comment">// 删除的是根节点</span></span><br><span class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">   <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">   <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">   Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">   <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">         black(sibling);</span><br><span class="line">         red(parent);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">         <span class="comment">// 更换兄弟</span></span><br><span class="line">         sibling = parent.right;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">      <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">         <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">         <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">         black(parent);</span><br><span class="line">         red(sibling);</span><br><span class="line">         <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">            afterRemove(parent);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">         <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">         <span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">            rotateRight(sibling);</span><br><span class="line">            sibling = parent.right;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         color(sibling, colorOf(parent));</span><br><span class="line">         black(sibling.right);</span><br><span class="line">         black(parent);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">         black(sibling);</span><br><span class="line">         red(parent);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">         <span class="comment">// 更换兄弟</span></span><br><span class="line">         sibling = parent.left;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">      <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">         <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">         <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">         black(parent);</span><br><span class="line">         red(sibling);</span><br><span class="line">         <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">            afterRemove(parent);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">         <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">         <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">            rotateLeft(sibling);</span><br><span class="line">            sibling = parent.left;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         color(sibling, colorOf(parent));</span><br><span class="line">         black(sibling.left);</span><br><span class="line">         black(parent);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的平衡"><a href="#红黑树的平衡" class="headerlink" title="红黑树的平衡"></a>红黑树的平衡</h2><p>为何那5条性质，就能保证红黑树是平衡的？</p><p>那5条性质，可以保证红黑树等价于4阶B树</p><p><img src="/2020/07/12/红黑树/20.png" alt></p><p>相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍</p><p>是一种弱平衡、黑高度平衡</p><p>红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是 O(logn) 级别</p><h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h2><p>搜索：O(logn)</p><p>添加：O(logn)，O(1) 次的旋转操作</p><p>删除：O(logn)，O(1) 次的旋转操作</p><h2 id="AVL树-vs-红黑树"><a href="#AVL树-vs-红黑树" class="headerlink" title="AVL树 vs 红黑树"></a>AVL树 vs 红黑树</h2><p><strong>AVL树</strong>  <a href="/2020/07/12/AVL树/" title="AVL树的实现">AVL树的实现</a></p><p>平衡标准比较严格：<strong>每个左右子树的高度差不超过1</strong></p><p>最大高度是 1.44  ∗ log2  n + 2 − 1.328（100W个节点，AVL树最大树高28）</p><p>搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整</p><p><strong>红黑树</strong></p><p>平衡标准比较宽松：<strong>没有一条路径会大于其他路径的2倍</strong></p><p>最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40）</p><p>搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整</p><p><strong>总结</strong></p><p>搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树</p><p>相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树</p><p>红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树</p><h2 id="BST-vs-AVL-Tree-vs-Red-Black-Tree"><a href="#BST-vs-AVL-Tree-vs-Red-Black-Tree" class="headerlink" title="BST vs AVL Tree vs Red Black Tree"></a>BST vs AVL Tree vs Red Black Tree</h2><p>10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96</p><p><img src="/2020/07/12/红黑树/21.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红黑树（Red-Black-Tree）&quot;&gt;&lt;a href=&quot;#红黑树（Red-Black-Tree）&quot; class=&quot;headerlink&quot; title=&quot;红黑树（Red Black Tree）&quot;&gt;&lt;/a&gt;红黑树（Red Black Tree）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
