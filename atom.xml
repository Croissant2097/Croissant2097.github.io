<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Croissant2097</title>
  
  <subtitle>Record &amp; Share &amp; Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-23T05:09:20.643Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>B+树</title>
    <link href="http://yoursite.com/2020/07/23/B-%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/23/B-树/</id>
    <published>2020-07-23T05:01:56.000Z</published>
    <updated>2020-07-23T05:09:20.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>$B+$树是 $B$ 树的变体，常用于数据库和操作系统的文件系统中</p><p>$MySQL$ 数据库的索引就是基于 $B+$ 树实现的</p><p><img src="/2020/07/23/B-树/1.png" alt></p><p><strong>B+树的特点</strong></p><ol><li><p>分为内部节点（非叶子）、叶子节点 $2$ 种节点</p><p><strong>内部节点只存储 $key$，不存储具体数据</strong></p><p><strong>叶子节点存储 $key$ 和具体数据 $value$</strong></p></li><li><p>所有的叶子节点形成一条有序链表</p></li><li><p>$m$ 阶 $B+$ 树非根节点的元素数量 $x$</p><p>$┌ m/2 ┐ ≤ x ≤ m$</p></li></ol><h2 id="MySQL的索引底层为何使用B-树？"><a href="#MySQL的索引底层为何使用B-树？" class="headerlink" title="MySQL的索引底层为何使用B+树？"></a>MySQL的索引底层为何使用B+树？</h2><ol><li><p>为了减小 $IO$ 操作数量，一般把一个节点的大小设计成最小读写单位的大小</p><p>$MySQL$ 的存储引擎 $InnoDB$ 的最小读写单位是 $16K$</p></li><li><p>对比 $B$ 树，$B+$ 树的优势是</p><p>每个节点存储的 $key$ 数量更多，树的高度更低</p><p>所有的具体数据都存在叶子节点上，所以每次查询都要查到叶子节点，查询速度比较稳定</p><p>所有的叶子节点构成了一个有序链表，做区间查询时更方便</p></li></ol><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>$B*$ 树是 $B+$ 树的变体：给内部节点增加了指向兄弟节点的指针</p><p>$m$ 阶 $B*$ 树非根节点的元素数量 $x$</p><p>$┌ 2m/3 ┐ ≤ x ≤ m$</p><p><img src="/2020/07/23/B-树/2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B+树&quot;&gt;&lt;/a&gt;B+树&lt;/h1&gt;&lt;p&gt;$B+$树是 $B$ 树的变体，常用于数据库和操作系统的文件系统中&lt;/p&gt;
&lt;p&gt;$MySQL$ 数据库的索引就是基于 $B+$ 树
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="B+树" scheme="http://yoursite.com/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>串</title>
    <link href="http://yoursite.com/2020/07/22/%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/07/22/串/</id>
    <published>2020-07-22T07:48:44.000Z</published>
    <updated>2020-07-23T04:58:47.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串（Sequence）"><a href="#串（Sequence）" class="headerlink" title="串（Sequence）"></a>串（Sequence）</h1><p>字符串 $thank$ 的前缀（ $prefix$ ）、真前缀（ $proper prefix$ ）、后缀（ $suffix$ ）、真后缀（ $proper suffix$）</p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">t, th, tha, than, thank</th></tr></thead><tbody><tr><td style="text-align:center">真前缀</td><td style="text-align:center">t, th, tha, than</td></tr><tr><td style="text-align:center">后缀</td><td style="text-align:center">thank, hank, ank, nk, k</td></tr><tr><td style="text-align:center">真后缀</td><td style="text-align:center">hank, ank, nk, k</td></tr></tbody></table></div><h2 id="串匹配算法"><a href="#串匹配算法" class="headerlink" title="串匹配算法"></a>串匹配算法</h2><p>查找一个模式串（ $pattern$ ）在文本串（ $text$ ）中的位置</p><p><strong>几个经典的串匹配算法</strong></p><ol><li><p>蛮力（ $Brute Force$ ）</p></li><li><p>$KMP$</p></li><li><p>$Boyer-Moore$</p></li><li><p>$Karp-Rabin$</p></li><li><p>$Sunday$</p></li></ol><p>用 $tlen$ 代表文本串 $text$ 的长度，$plen$ 代表模式串 $pattern$ 的长度</p><h2 id="蛮力（Brute-Force）"><a href="#蛮力（Brute-Force）" class="headerlink" title="蛮力（Brute Force）"></a>蛮力（Brute Force）</h2><p>以字符为单位，从左到右移动模式串，直到匹配成功</p><p><img src="/2020/07/22/串/1.png" alt></p><p>蛮力算法有 $2$ 种常见实现思路</p><h3 id="蛮力1-–-执行过程"><a href="#蛮力1-–-执行过程" class="headerlink" title="蛮力1 – 执行过程"></a>蛮力1 – 执行过程</h3><p>$pi$  的取值范围 $[0, plen)$</p><p>$ti$  的取值范围  $[0, tlen)$</p><p><img src="/2020/07/22/串/2.png" alt></p><ol><li><p><strong>当匹配的两个字符不相等时：</strong> $textChars[ti] != patternChars[pi]$</p><p>$pi = 0$</p><p>$ti –= pi – 1$</p></li><li><p><strong>当匹配的两个字符相等时：</strong> $textChars[ti] == patternChars[pi]$</p><p>$pi ++$</p><p>$ti ++$</p><p><strong>继续向后匹配</strong></p></li><li><p><strong>当 $pi == plen$：代表匹配成功</strong></p></li></ol><p><img src="/2020/07/22/串/3.png" alt></p><h3 id="蛮力1-–-实现"><a href="#蛮力1-–-实现" class="headerlink" title="蛮力1 – 实现"></a>蛮力1 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf01</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断合法性</span></span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] textChars = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> tlen = textChars.length;</span><br><span class="line">    <span class="keyword">if</span> (tlen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] patternChars = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> plen = patternChars.length;</span><br><span class="line">    <span class="keyword">if</span> (plen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tlen &lt; plen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pi = <span class="number">0</span>, ti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pi &lt; plen &amp;&amp; ti &lt; tlen)&#123;</span><br><span class="line">        <span class="keyword">if</span> (textChars[ti] == patternChars[pi])&#123;</span><br><span class="line">            ti++;</span><br><span class="line">            pi++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ti -= pi - <span class="number">1</span>;</span><br><span class="line">            pi = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pi == plen) ? (ti - pi) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛮力1-–-优化"><a href="#蛮力1-–-优化" class="headerlink" title="蛮力1 – 优化"></a>蛮力1 – 优化</h3><p> 此前实现的蛮力算法，在恰当的时候可以提前退出，减少比较次数</p><p><img src="/2020/07/22/串/4.png" alt></p><p>因此，$ti$ 的退出条件可以从 $ti &lt; tlen$ 改为</p><p>$ti – pi &lt;= tlen – plen$</p><p>$ti – pi$ 是指每一轮比较中 $text$ 首个比较字符的位置</p><h3 id="蛮力1-–-优化实现"><a href="#蛮力1-–-优化实现" class="headerlink" title="蛮力1 – 优化实现"></a>蛮力1 – 优化实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf02</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] textChars = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> tlen = textChars.length;</span><br><span class="line">    <span class="keyword">if</span> (tlen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] patternChars = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> plen = patternChars.length;</span><br><span class="line">    <span class="keyword">if</span> (plen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tlen &lt; plen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pi = <span class="number">0</span>, ti = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ti - pi 文本串正在匹配的子串的开始索引</span></span><br><span class="line">    <span class="comment">// tlen - plen 开始索引的临界值</span></span><br><span class="line">    <span class="keyword">int</span> lenDelta = tlen - plen;</span><br><span class="line">    <span class="keyword">while</span> (pi &lt; plen &amp;&amp; ti - pi &lt;= lenDelta)&#123;</span><br><span class="line">        <span class="keyword">if</span> (textChars[ti] == patternChars[pi])&#123;</span><br><span class="line">            ti++;</span><br><span class="line">            pi++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ti -= pi - <span class="number">1</span>;</span><br><span class="line">            pi = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pi == plen) ? (ti - pi) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛮力2-–-执行过程"><a href="#蛮力2-–-执行过程" class="headerlink" title="蛮力2 – 执行过程"></a>蛮力2 – 执行过程</h3><p>$pi$ 的取值范围 $[0, plen)$</p><p>$ti$ 的取值范围 $[0, tlen – plen]$</p><p><img src="/2020/07/22/串/5.png" alt></p><ol><li><p><strong>当匹配的两个字符相等时：</strong> $textChars[ti]==patternChars[pi]$</p><p>$pi ++$</p><p>$ti += pi$</p></li><li><p><strong>当匹配的两个字符不相等时：</strong> $textChars[ti]==patternChars[pi]$</p><p>$pi = 0$ </p><p>$ti++$</p></li><li><p><strong>当 $pi == plen$：代表匹配成功</strong></p></li></ol><p><img src="/2020/07/22/串/6.png" alt></p><h3 id="蛮力2-–-实现"><a href="#蛮力2-–-实现" class="headerlink" title="蛮力2 – 实现"></a>蛮力2 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] textChars = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> tlen = textChars.length;</span><br><span class="line">    <span class="keyword">if</span> (tlen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] patternChars = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> plen = patternChars.length;</span><br><span class="line">    <span class="keyword">if</span> (plen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tlen &lt; plen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tiMax = tlen - plen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">0</span>; ti &lt;= tiMax; ti++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; pi &lt; plen; pi++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (textChars[ti + pi] != patternChars[pi]) <span class="keyword">break</span>;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pi == plen) <span class="keyword">return</span> ti;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蛮力-–-性能分析"><a href="#蛮力-–-性能分析" class="headerlink" title="蛮力 – 性能分析"></a>蛮力 – 性能分析</h3><p>$n$ 是文本串长度，$m$ 是模式串长度</p><p><img src="/2020/07/22/串/7.png" alt></p><p>最好情况</p><p>只需一轮比较就完全匹配成功，比较 $m$ 次（ $m$ 是模式串的长度）</p><p>时间复杂度为 $O(m)$</p><p><img src="/2020/07/22/串/8.png" alt></p><p>最坏情况（字符集越大，出现概率越低）</p><p>执行了 $n – m + 1$ 轮比较（ $n$ 是文本串的长度）</p><p>每轮都比较至模式串的末字符后失败（ $m – 1$ 次成功，$1$ 次失败）</p><p>时间复杂度为 $O(m ∗ (n − m + 1))$，由于一般 $m$ 远小于 $n$，所以为 $O(mn)$</p><p><img src="/2020/07/22/串/9.png" alt></p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>$KMP$ 是 $Knuth–Morris–Pratt$ 的简称（取名自 $3$ 位发明人的名字），于 $1977$ 年发布</p><h3 id="KMP-–-next表的使用"><a href="#KMP-–-next表的使用" class="headerlink" title="KMP – next表的使用"></a>KMP – next表的使用</h3><p>$KMP$ 会预先根据模式串的内容生成一张 $next$ 表（一般是个数组）</p><p>后面再讲怎么生成 $next$ 表（先学会使用）</p><p><img src="/2020/07/22/串/11.png" alt></p><p><strong>举例：</strong></p><p>当在 $E(ti = 8，pi = 7)$ 发生失配时，$ti$ 不变，$pi$ 变成 $next$ 表中的值</p><p><img src="/2020/07/22/串/12.png" alt></p><p>当在 $D(ti = 5，pi = 3)$ 发生失配时，$ti$ 不变，$pi$ 变成 $next$ 表中的值</p><h3 id="KMP-–-核心原理"><a href="#KMP-–-核心原理" class="headerlink" title="KMP – 核心原理"></a>KMP – 核心原理</h3><p><strong>$A、B$ 是个子串（有多个字符）</strong></p><p><strong>$c、d、e$ 是单个字符</strong></p><p><img src="/2020/07/22/串/13.png" alt></p><p>当 $d、e$ 失配时，如果希望 $pattern$ 能够<strong>一次性向右移动一大段距离</strong>，然后直接比较 $d、c$ 字符</p><p><strong>前提条件是子串 $A$ 必须等于子串 $B$</strong></p><p>所以 $KMP$ 必须在失配字符 $e$ 左边的子串中找出符合条件的子串 $A 、B$，从而得知向右移动的距离</p><p>向右移动的距离：$e$ 左边子串的长度 $– A$ 的长度（也等于 $-B$ 的长度），等价于：$e$ 的索引 $– c$ 的索引</p><p>且 $c$ 的索引 == $next[$ $e$ 的索引 $]$，所以向右移动的距离：$e$ 的索引 $– next$ [ $e$ 的索引 ]</p><p><strong>举例：</strong></p><p>$text: \underbrace{abc}_{\rm A}$  $c$  $\underbrace{abc}_{\rm B}$  $d$</p><p>$pattern：abce$</p><p>当 $A = \underbrace{abc}_{\rm A} 、B = \underbrace{abc}_{\rm B}$</p><p>$pi$ 一次性向右移动的距离：$7 - 3 = 4$ </p><p><strong>总结</strong></p><p>如果在 $pi$ 位置失配，向右移动的距离是 $pi – next[pi]$，所以 <strong>$next[pi]$ 越小，移动距离越大</strong></p><p>$next[pi]$ 是 $pi$ 左边子串的<strong>真前缀后缀的最大公共子串长度</strong></p><h3 id="KMP-–-真前缀后缀的最大公共子串长度"><a href="#KMP-–-真前缀后缀的最大公共子串长度" class="headerlink" title="KMP – 真前缀后缀的最大公共子串长度"></a>KMP – 真前缀后缀的最大公共子串长度</h3><p><img src="/2020/07/22/串/14.png" alt></p><h3 id="KMP-–-得到next表"><a href="#KMP-–-得到next表" class="headerlink" title="KMP – 得到next表"></a>KMP – 得到next表</h3><p><img src="/2020/07/22/串/15.png" alt></p><p>将最大公共子串长度都向后移动 $1$ 位，首字符设置为 负 $1$，就得到了 $next$ 表</p><p><img src="/2020/07/22/串/16.png" alt></p><h3 id="KMP-–-负1的精妙之处"><a href="#KMP-–-负1的精妙之处" class="headerlink" title="KMP – 负1的精妙之处"></a>KMP – 负1的精妙之处</h3><p><strong>如果：</strong>$pi = next[pi] → (-1)$</p><p>$(pi++) → (-1) → 0$</p><p>$(ti++) → 2 → 3$</p><p><img src="/2020/07/22/串/17.png" alt></p><p>相当于在负 $1$ 位置有个假想的通配字符（哨兵）</p><p>匹配成功后 $ti++、pi++$</p><h3 id="KMP-–-主算法实现"><a href="#KMP-–-主算法实现" class="headerlink" title="KMP – 主算法实现"></a>KMP – 主算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断合法性</span></span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] textChars = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> tlen = textChars.length;</span><br><span class="line">    <span class="keyword">if</span> (tlen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] patternChars = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> plen = patternChars.length;</span><br><span class="line">    <span class="keyword">if</span> (plen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tlen &lt; plen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next表</span></span><br><span class="line">    <span class="keyword">int</span>[] next = next(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pi = <span class="number">0</span>, ti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenDelta = tlen - plen;</span><br><span class="line">    <span class="keyword">while</span> (pi &lt; plen &amp;&amp; ti - pi &lt;= lenDelta)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pi &lt; <span class="number">0</span> || textChars[ti] == patternChars[pi])&#123;</span><br><span class="line">            ti++;</span><br><span class="line">            pi++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// pi 一次性向右移动的距离</span></span><br><span class="line">            pi = next[pi];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (pi == plen) ? (ti - pi) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-–-为什么是“最大“公共子串长度？"><a href="#KMP-–-为什么是“最大“公共子串长度？" class="headerlink" title="KMP – 为什么是“最大“公共子串长度？"></a>KMP – 为什么是“最大“公共子串长度？</h3><p>假设文本串是 $AAAAABCDEF$，模式串是 $AAAAB$</p><p><img src="/2020/07/22/串/18.png" alt></p><p>应该将 $1、2、3$ 中的哪个值赋值给 $pi$ 是正确的？</p><ol><li><p>将 $3$ 赋值给 $pi$</p><p>向右移动了 $1$ 个字符单位，最后成功匹配</p></li><li><p>将 $1$ 赋值给 $pi$</p><p>向右移动了 $3$ 个字符单位，错过了成功匹配的机会</p></li></ol><p><strong>公共子串长度越小，向右移动的距离越大，越不安全</strong></p><p><strong>公共子串长度越大，向右移动的距离越小，越安全</strong></p><h3 id="KMP-–-next表的构造思路"><a href="#KMP-–-next表的构造思路" class="headerlink" title="KMP – next表的构造思路"></a>KMP – next表的构造思路</h3><p>假设(<strong>已知</strong>) $next[i] == n$ （数组下标为 $i$ 左边子串的<strong>真前缀后缀的最大公共子串长度</strong>有 $n$ 个）</p><p><strong>让下标为 $i$ 与下标为 $n$ 位置的值做比较</strong></p><p>① 如 果 $pattern.charAt(i) == pattern.charAt(n)$</p><p><img src="/2020/07/22/串/24.png" alt></p><p>​    那么 $next[i + 1] == n + 1$</p><p>② 如 果 $pattern.charAt(i) != pattern.charAt(n)$</p><p>​    已知 $next[n] == k$，$k$ （左边子串的真前缀后缀的最大公共子串长度）</p><p>​    <strong>也就是再去 $n$ 的左边寻找真前缀后缀的最大公共子串长度</strong></p><p><img src="/2020/07/22/串/19.png" alt></p><ol><li><p>如果 $pattern.charAt(i) == pattern.charAt(k)$</p><p>那么 $next[i + 1] == k + 1$</p></li><li><p>如果 $pattern.charAt(i) != pattern.charAt(k)$</p><p>将 $k$ 代入 $n$， $（n = next[n]）$，重复执行 ②</p></li></ol><h3 id="KMP-–-next表的代码实现"><a href="#KMP-–-next表的代码实现" class="headerlink" title="KMP – next表的代码实现"></a>KMP – next表的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] next(String pattern)&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next[i] 第 i 项左边子串的真前缀后缀的最大公共子串长度</span></span><br><span class="line">    <span class="comment">// 已知 n == next[i]</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = next[i] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iMax = chars.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; iMax)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> || chars[i] == chars[n])&#123;</span><br><span class="line">            next[++i] = ++n;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            n = next[n]; <span class="comment">// 图示为 n = k</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-–-next表的不足之处"><a href="#KMP-–-next表的不足之处" class="headerlink" title="KMP – next表的不足之处"></a>KMP – next表的不足之处</h3><p>假设文本串是 $AAABAAAAB$ ，模式串是 $AAAAB$</p><p><img src="/2020/07/22/串/20.png" alt></p><p>在这种情况下，$KMP$ 显得比较笨拙</p><h3 id="KMP-–-next表的优化思路"><a href="#KMP-–-next表的优化思路" class="headerlink" title="KMP – next表的优化思路"></a>KMP – next表的优化思路</h3><p>已知：$next[i] == n，next[n] == k$</p><p><img src="/2020/07/22/串/21.png" alt></p><p>如果 $pattern[i] != d$，就让模式串滑动到 $next[i]$（也就是 $n$ ）位置跟 $d$ 进行比较</p><p>如果 $pattern[n] != d$，就让模式串滑动到 $next[n]$（也就是 $k$ ）位置跟 $d$ 进行比较</p><p>如果 $pattern[i] == pattern[n]$，那么当 $i$ 位置失配时，模式串最终必然会滑到 $k$ 位置跟 $d$ 进行比较</p><p>所以 $next[i]$ 直接存储 $next[n]$（也就是 $k$ ）即可</p><h3 id="KMP-–-next表的优化实现"><a href="#KMP-–-next表的优化实现" class="headerlink" title="KMP – next表的优化实现"></a>KMP – next表的优化实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] next(String pattern)&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next[i] 第 i 项左边子串的真前缀后缀的最大公共子串长度</span></span><br><span class="line">    <span class="comment">// 已知 n == next[i]</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = next[i] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iMax = chars.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; iMax)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> || chars[i] == chars[n])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++n;</span><br><span class="line">            <span class="comment">// ++后，先比较，相等，直接跳到下一个，上图中可认为是k</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[n])&#123;</span><br><span class="line">                next[i] = next[n];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                next[i] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            n = next[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-–-next表的优化效果"><a href="#KMP-–-next表的优化效果" class="headerlink" title="KMP – next表的优化效果"></a>KMP – next表的优化效果</h3><p><img src="/2020/07/22/串/22.png" alt></p><h3 id="KMP-–-性能分析"><a href="#KMP-–-性能分析" class="headerlink" title="KMP – 性能分析"></a>KMP – 性能分析</h3><ol><li><p>$KMP$ 主逻辑</p><p>最好时间复杂度：$O(m)$</p><p>最坏时间复杂度：$O(n)$，不超过 $O(2n)$</p></li><li><p>$next$ 表的构造过程跟 $KMP$ 主体逻辑类似</p><p>时间复杂度：$O(m)$</p></li></ol><p>$KMP$ 整体</p><p>最好时间复杂度：$O(m)$</p><p>最坏时间复杂度：$O(n + m)$</p><p>空间复杂度： $O(m)$</p><p><img src="/2020/07/22/串/23.png" alt></p><h2 id="蛮力-vs-KMP"><a href="#蛮力-vs-KMP" class="headerlink" title="蛮力 vs KMP"></a>蛮力 vs KMP</h2><p>蛮力算法为何低效？</p><p>当字符失配时</p><ol><li><p>蛮力算法</p><p>$ti$ 回溯到左边位置</p><p>$pi$ 回溯到 $0$</p></li><li><p>KMP 算法</p><p>$ti$ 不必回溯</p><p>$pi$ 不一定要回溯到 $0$</p></li></ol><p><img src="/2020/07/22/串/10.png" alt></p><p>对比蛮力算法，$KMP$ 的精妙之处：充分利用了此前比较过的内容，可以很聪明地跳过一些不必要的比较位置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;串（Sequence）&quot;&gt;&lt;a href=&quot;#串（Sequence）&quot; class=&quot;headerlink&quot; title=&quot;串（Sequence）&quot;&gt;&lt;/a&gt;串（Sequence）&lt;/h1&gt;&lt;p&gt;字符串 $thank$ 的前缀（ $prefix$ ）、真前缀（ $
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP" scheme="http://yoursite.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="http://yoursite.com/2020/07/21/%E8%B7%B3%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/21/跳表/</id>
    <published>2020-07-21T11:08:48.000Z</published>
    <updated>2020-07-23T06:16:41.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跳表（SkipList）"><a href="#跳表（SkipList）" class="headerlink" title="跳表（SkipList）"></a>跳表（SkipList）</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>一个有序链表搜索、添加、删除的平均时间复杂度是多少？</p><p>$O(n)$</p><p><img src="/2020/07/21/跳表/1.png" alt></p><p>能否利用二分搜索优化有序链表，将搜索、添加、删除的平均时间复杂度降低至 $O(logn)$？</p><p>链表没有像数组那样的高效随机访问（$O(1)$ 时间复杂度），所以不能像有序数组那样直接进行二分搜索优化</p><p>那有没有其他办法让有序链表搜索、添加、删除的平均时间复杂度降低至 $O(logn)$？</p><p>使用跳表（$SkipList$）</p><h2 id="跳表是什么"><a href="#跳表是什么" class="headerlink" title="跳表是什么"></a>跳表是什么</h2><ol><li><p>跳表，又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能</p><p>由 $William Pugh$于 $1990$ 年发布，设计的初衷是为了取代平衡树（比如红黑树）</p></li><li><p>$Redis$ 中 的 $SortedSet、LevelDB$ 中的 $MemTable$ 都用到了跳表</p><p>$Redis、LevelDB$ 都是著名的 $Key-Value$ 数据库</p></li><li><p>对比平衡树</p><p>跳表的实现和维护会更加简单</p><p>跳表的搜索、删除、添加的平均时间复杂度是 $O(logn)$</p></li></ol><h2 id="使用跳表优化链表"><a href="#使用跳表优化链表" class="headerlink" title="使用跳表优化链表"></a>使用跳表优化链表</h2><p><img src="/2020/07/21/跳表/2.png" alt></p><h2 id="跳表的基本定义"><a href="#跳表的基本定义" class="headerlink" title="跳表的基本定义"></a>跳表的基本定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最高层数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="comment">// 新增层数的概率</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> P = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有效层数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line"><span class="comment">// 首节点，不存放任何K-V</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">(Comparator&lt;K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    first = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, MAX_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机返回新增节点的层数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyCheck</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(K k1, K k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator != <span class="keyword">null</span> </span><br><span class="line">        ? comparator.compare(k1, k2)</span><br><span class="line">        : ((Comparable&lt;K&gt;)k1).compareTo(k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">"一共"</span> + level + <span class="string">"层"</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Node&lt;K, V&gt; node = first;</span><br><span class="line">        <span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(node.nexts[i]);</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">            node = node.nexts[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳表节点的定义"><a href="#跳表节点的定义" class="headerlink" title="跳表节点的定义"></a>跳表节点的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 节点指向的下一个节点（多个）</span></span><br><span class="line">    Node&lt;K, V&gt;[] nexts;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        nexts = <span class="keyword">new</span> Node[level];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">":"</span> + value + <span class="string">"_"</span> + nexts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳表的搜索"><a href="#跳表的搜索" class="headerlink" title="跳表的搜索"></a>跳表的搜索</h2><p>① 从顶层链表的首元素开始，从左往右搜索，直至找到一个大于或等于目标的元素，或者到达当前层链表的尾部</p><p>② 如果该元素等于目标元素，则表明该元素已被找到</p><p>③ 如果该元素大于目标元素或已到达链表的尾部，则退回到当前层的前一个元素，然后转入下一层进行搜索</p><p><img src="/2020/07/21/跳表/4.png" alt></p><p><strong>举例：</strong></p><ol><li><p><strong>查找存在的 $17$</strong></p><p>从首节点 $first$ 的<strong>顶层</strong>链表开始，找到 $21$，$21&gt;17$，退回到上一个节点 $first$ ，层数 $-1$，</p><p>从 $first$ 出发,找到 $9$，$9 &lt; 17$，继续往后找，找到 $21$，$21 &gt; 17$，退回到上一个节点 $9$ ，层数 $-1$,</p><p>从 $9$ 出发，找到 $17$，$17==17$，找到了该元素</p></li><li><p><strong>查找不存在的</strong> $18$</p><p>从首节点 $first$ 的<strong>顶层</strong>链表开始，找到 $21$，$21&gt;18$，退回到上一个节点 $first$ ，层数 $-1$，</p><p>从 $first$ 出发,找到 $9$，$9 &lt; 18$，继续往后找，找到 $21$，$21 &gt; 18$，退回到上一个节点 $9$ ，层数 $-1$,</p><p>从 $9$ 出发，找到 $17$，$17 &lt; 18$，继续往后找，找到 $21$，$21&gt;18$，退回到上一个节点 $17$，层数 $-1$,</p><p>从 $17$ 出发，找到 $19$，$19 &gt; 18$，退回到上一个节点 $17$，层数 $-1$,</p><p>发现是在最后一层，返回 $false$，没有找到</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">   keyCheck(key);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 举例：</span></span><br><span class="line">   <span class="comment">// first.nexts[3] == 21节点</span></span><br><span class="line">   <span class="comment">// first.nexts[2] == 9节点</span></span><br><span class="line">   <span class="comment">// first.nexts[1] == 6节点</span></span><br><span class="line">   <span class="comment">// first.nexts[0] == 3节点</span></span><br><span class="line">   <span class="comment">// level = 4</span></span><br><span class="line">   </span><br><span class="line">   Node&lt;K, V&gt; node = first;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 一个技巧：</span></span><br><span class="line">       <span class="comment">// 直接让node的下一个节点跟传入的值做比较</span></span><br><span class="line">       <span class="comment">// 传入的值较小时，就不用退回到上一个节点</span></span><br><span class="line">      <span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         node = node.nexts[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到key值了，可以不用先退出，层数会不断-1</span></span><br><span class="line">      <span class="comment">// 例如 17，在level == 1 时 就找到了</span></span><br><span class="line">      <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node.nexts[i].value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳表的添加"><a href="#跳表的添加" class="headerlink" title="跳表的添加"></a>跳表的添加</h2><p><img src="/2020/07/21/跳表/3.png" alt></p><p><strong>添加的细节</strong></p><ol><li><p><strong>随机决定新添加元素的层数</strong></p></li><li><p><strong>寻找节点是否存在时，一定要遍历完所有层数，找到新添加节点的所有前驱节点</strong></p></li><li><strong>前驱节点可以认为是层数 $-1$ 时，当时的节点就是前驱节点</strong></li></ol><p><strong>举例：</strong></p><ol><li><p><strong>添加不存在的节点 $17$</strong></p><p>从首节点 $first[3]$ 的<strong>顶层</strong>链表开始，找到 $6$，$6 &lt; 17$，继续往后找，找到 $NULL$，退回到上一个节点 $6$ ，层数 $-1$，<strong>保存前驱节点 $6[3]$</strong></p><p>从 $6[2]$ 出发,找到 $25$，$25 &gt; 17$，退回到上一个节点 $6 [2]$ ，层数 $-1$，<strong>保存前驱节点 $6[2]$</strong></p><p>从 $6[1]$ 出发，找到 $9$，$9 &lt; 17$，继续往后找，找到$25$，$25 &gt; 17$，退回到上一个节点 $9$，层数 $-1$，<strong>保存前驱节点 $9[1]$</strong></p><p>从 $9[0]$ 出发，找到 $12$，$12 &lt; 17$，继续往后找，找到 $19$，$19 &gt; 17$，退回到上一个节点 $12$，层数 $-1$，<strong>保存前驱节点 $12[0]$</strong></p><p>发现层数为 $0$ 了，找到 $17$ 添加的位置了，前驱节点分别为 $6[3],6[2],9[1],12[0]$</p><p>下面只需更改前驱节点和新节点的指向就行</p></li><li><p><strong>添加存在的节点 $9$</strong></p><p>方法与上面类似，找到该节点的位置，更改该节点的 $value$，返回 $oldvalue$ 就行</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   keyCheck(key);</span><br><span class="line">   </span><br><span class="line">   Node&lt;K, V&gt; node = first;</span><br><span class="line">   <span class="comment">// 前驱节点的个数就是层数 $level</span></span><br><span class="line">   Node&lt;K, V&gt;[] prevs = <span class="keyword">new</span> Node[level];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">            &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         node = node.nexts[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123; <span class="comment">// 节点是存在的</span></span><br><span class="line">         V oldV = node.nexts[i].value;</span><br><span class="line">         node.nexts[i].value = value;</span><br><span class="line">         <span class="keyword">return</span> oldV;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保存前驱节点</span></span><br><span class="line">      prevs[i] = node;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 随机产生新节点的层数</span></span><br><span class="line">   <span class="keyword">int</span> newLevel = randomLevel();</span><br><span class="line">   <span class="comment">// 添加新节点</span></span><br><span class="line">   Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value, newLevel);</span><br><span class="line">   <span class="comment">// 设置前驱和后继</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newLevel; i++) &#123;</span><br><span class="line">      <span class="comment">// 新节点的层数可能比原来的大</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= level) &#123;</span><br><span class="line">         first.nexts[i] = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         newNode.nexts[i] = prevs[i].nexts[i];</span><br><span class="line">         prevs[i].nexts[i] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 节点数量增加</span></span><br><span class="line">   size++;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 计算跳表的最终层数</span></span><br><span class="line">   level = Math.max(level, newLevel);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳表的删除"><a href="#跳表的删除" class="headerlink" title="跳表的删除"></a>跳表的删除</h2><p><strong>删除的细节</strong></p><ol><li><p><strong>删除一个元素后，整个跳表的层数可能会降低</strong></p></li><li><p><strong>找到元素后，不能提前退出，要找到要删除节点的全部前驱节点</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">   keyCheck(key);</span><br><span class="line">   </span><br><span class="line">   Node&lt;K, V&gt; node = first;</span><br><span class="line">   Node&lt;K, V&gt;[] prevs = <span class="keyword">new</span> Node[level];</span><br><span class="line">   <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">            &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         node = node.nexts[i];</span><br><span class="line">      &#125;</span><br><span class="line">      prevs[i] = node;</span><br><span class="line">      <span class="keyword">if</span> (cmp == <span class="number">0</span>) exist = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!exist) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 需要被删除的节点</span></span><br><span class="line">   Node&lt;K, V&gt; removedNode = node.nexts[<span class="number">0</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数量减少</span></span><br><span class="line">   size--;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 设置后继</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; removedNode.nexts.length; i++) &#123;</span><br><span class="line">      prevs[i].nexts[i] = removedNode.nexts[i];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 更新跳表的层数</span></span><br><span class="line">   <span class="keyword">int</span> newLevel = level;</span><br><span class="line">   <span class="keyword">while</span> (--newLevel &gt;= <span class="number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="keyword">null</span>) &#123;</span><br><span class="line">      level = newLevel;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> removedNode.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳表的层数"><a href="#跳表的层数" class="headerlink" title="跳表的层数"></a>跳表的层数</h2><p>跳表是按层构造的，底层是一个普通的有序链表，高层相当于是低层的 <strong>“快速通道”</strong></p><p>在第 $i$ 层中的元素按某个固定的概率 $p$（通常为 $\frac{1}{2}$ 或 $\frac{1}{4}$ 出现在第 $i + 1$层中，产生越高的层数，概率越低</p><ul><li><p>元素层数恰好等于 $1$ 的概率为 $1 – p$</p></li><li><p>元素层数大于等于 $2$ 的概率为 $p$，而元素层数恰好等于 $2$ 的概率为 $p * (1 – p)$</p></li><li><p>元素层数大于等于 $3$ 的概率为 $p^2$，而元素层数恰好等于 $3$ 的概率为 $p^2 * (1 – p)$</p></li><li><p>元素层数大于等于 $4$ 的概率为 $p^3$，而元素层数恰好等于 $4$ 的概率为 $p^3 * (1 – p)$</p></li><li><p>$\ldots\ldots$</p></li></ul><p>一个元素的平均层数是 $\frac{1}{(1 – p)}$</p><script type="math/tex; mode=display">1\times(1-p)+2p(1-p)+3p^2(1-p)+4p^3(1-p)+\ldots=(1-p)\sum_{k=1}^{+\infty}kp^{k-1}=(1-p)\cdot \frac{1}{(1-p)^2}= \frac{1}{1-p}</script><p>当 $p = \frac12$ 时，每个元素所包含的平均指针数量是 $2$</p><p>当 $p = \frac14$ 时，每个元素所包含的平均指针数量是 $1.33$</p><h2 id="跳表的复杂度分析"><a href="#跳表的复杂度分析" class="headerlink" title="跳表的复杂度分析"></a>跳表的复杂度分析</h2><p>每一层的元素数量</p><ul><li><p>第 $1$ 层链表固定有 $n$ 个元素</p></li><li><p>第 $2$ 层链表平均有 $n * p$ 个元素</p></li><li><p>第 $3$ 层链表平均有 $n * p^2$ 个元素</p></li><li><p>第 $k$ 层链表平均有 $n * p^k$ 个元素</p></li><li><p>$\ldots\ldots$</p></li></ul><p>另外</p><p>最高层的层数是 $log_\frac1p n$，平均有个 $\frac1p$ 元素</p><p>在搜索时，每一层链表的预期查找步数最多是 $\frac1p$，所以总的查找步数是 $–(log_p\frac np)$，时间复杂度是 $O(logn)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跳表（SkipList）&quot;&gt;&lt;a href=&quot;#跳表（SkipList）&quot; class=&quot;headerlink&quot; title=&quot;跳表（SkipList）&quot;&gt;&lt;/a&gt;跳表（SkipList）&lt;/h1&gt;&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="跳表" scheme="http://yoursite.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
      <category term="SkipList" scheme="http://yoursite.com/tags/SkipList/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yoursite.com/2020/07/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/21/布隆过滤器/</id>
    <published>2020-07-21T07:25:20.000Z</published>
    <updated>2020-07-23T06:56:49.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><p>如果要经常判断 1 个元素是否存在，你会怎么做？</p><p>很容易想到使用哈希表（$HashSet、HashMap$），将元素作为 $key$ 去查找</p><p>时间复杂度：$O(1)$，但是空间利用率不高，需要占用比较多的内存资源</p></li><li><p>如果需要编写一个网络爬虫去爬 $10亿$ 个网站数据，为了避免爬到重复的网站，如何判断某个网站是否爬过？</p><p>很显然，$HashSet、HashMap$ 并不是非常好的选择</p></li><li><p>是否存在时间复杂度低、占用内存较少的方案？</p><p>布隆过滤器$（Bloom Filter）$</p></li></ol><h2 id="布隆过滤器-是什么"><a href="#布隆过滤器-是什么" class="headerlink" title="布隆过滤器 - 是什么"></a>布隆过滤器 - 是什么</h2><ol><li><p><strong>1970年由布隆提出</strong></p><p>它是一个空间效率高的概率型数据结构，可以用来告诉你：<strong>一个元素一定不存在或者可能存在</strong></p></li><li><p><strong>优缺点</strong></p><p>优点：空间效率和查询时间都远远超过一般的算法</p><p>缺点：<strong>有一定的误判率、删除困难</strong></p></li><li><p>它实质上是一个很长的二进制向量和一系列随机映射函数（Hash函数）</p></li><li><p>常见应用</p><p>网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统、解决缓存穿透问题</p></li></ol><h2 id="布隆过滤器-原理"><a href="#布隆过滤器-原理" class="headerlink" title="布隆过滤器 - 原理"></a>布隆过滤器 - 原理</h2><p>假设布隆过滤器由 $20$ 位二进制、 $3$ 个哈希函数组成，每个元素经过哈希函数处理都能生成一个索引位置</p><p>添加元素：将每一个哈希函数生成的索引位置都设为 $1$</p><p>查询元素是否存在</p><p>如果有一个哈希函数生成的索引位置不为 $1$，就代表不存在<strong>（$100\%$ 准确）</strong></p><p>如果每一个哈希函数生成的索引位置都为 $1$，就代表存在<strong>（存在一定的误判率）</strong></p><p><img src="/2020/07/21/布隆过滤器/1.png" alt></p><p>添加、查询的时间复杂度都是：$O(k)$ ，$k$ 是哈希函数的个数。空间复杂度是：$O(m)$ ，$m$ 是二进制位的个数</p><h2 id="布隆过滤器-误判率"><a href="#布隆过滤器-误判率" class="headerlink" title="布隆过滤器 - 误判率"></a>布隆过滤器 - 误判率</h2><p>误判率 $p$ 受 $3$ 个因素影响：二进制位的个数 $m$、哈希函数的个数 $k$、数据规模 $n$</p><script type="math/tex; mode=display">p = (1 - e^{-\frac{k(n+0.5)}{m-1}})^k ≈ (1 - e^{-\frac{kn}{m}})^k</script><p>已知误判率 $p$、数据规模 $n$，求二进制位的个数 $m$、哈希函数的个数 $k$</p><script type="math/tex; mode=display">m = - \frac{nlnp}{(ln2)^2} \\    k = \frac{m}{n} ln2</script><h2 id="布隆过滤器-实现"><a href="#布隆过滤器-实现" class="headerlink" title="布隆过滤器 - 实现"></a>布隆过滤器 - 实现</h2><h3 id="布隆过滤器-基本定义"><a href="#布隆过滤器-基本定义" class="headerlink" title="布隆过滤器 - 基本定义"></a>布隆过滤器 - 基本定义</h3><p><strong>数据的存放格式是数组，每个数组存放着Long个字节</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制向量的长度(一共有多少个二进制位)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> bitSize;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制向量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span>[] bits;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 哈希函数的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> hashSize;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n 数据规模</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> p 误判率, 取值范围(0, 1)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || p &lt;= <span class="number">0</span> || p &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"wrong n or p"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 下面三个参数是根据公式计算的</span></span><br><span class="line">      <span class="keyword">double</span> ln2 = Math.log(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 求出二进制向量的长度</span></span><br><span class="line">      bitSize = (<span class="keyword">int</span>) (- (n * Math.log(p)) / (ln2 * ln2));</span><br><span class="line">      <span class="comment">// 求出哈希函数的个数</span></span><br><span class="line">      hashSize = (<span class="keyword">int</span>) (bitSize * ln2 / n);</span><br><span class="line">      <span class="comment">// bits数组的长度</span></span><br><span class="line">      bits = <span class="keyword">new</span> <span class="keyword">long</span>[(bitSize + Long.SIZE - <span class="number">1</span>) / Long.SIZE];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nullCheck</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Value must not be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器-设置index位置的二进位为1-按位或"><a href="#布隆过滤器-设置index位置的二进位为1-按位或" class="headerlink" title="布隆过滤器 - 设置index位置的二进位为1(按位或 | )"></a>布隆过滤器 - 设置index位置的二进位为1(按位或 | )</h3><div class="table-container"><table><thead><tr><th style="text-align:right">$101010101010010101$</th><th></th></tr></thead><tbody><tr><td style="text-align:right">$\mid 000000000000000100$</td><td>$(1 &lt;&lt; index)$</td></tr><tr><td style="text-align:right">$101010111010010101$</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// （index / Long.SIZE） index在数组中的下标</span></span><br><span class="line">    <span class="comment">// value改下标的值</span></span><br><span class="line">    <span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line">    <span class="keyword">int</span> bitValue = <span class="number">1</span> &lt;&lt; (index % Long.SIZE);</span><br><span class="line">    bits[index / Long.SIZE] = value | bitValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (value &amp; bitValue) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器-查看index位置的二进位的值"><a href="#布隆过滤器-查看index位置的二进位的值" class="headerlink" title="布隆过滤器 - 查看index位置的二进位的值"></a>布隆过滤器 - 查看index位置的二进位的值</h3><div class="table-container"><table><thead><tr><th style="text-align:right">$101010101010010101$</th><th></th></tr></thead><tbody><tr><td style="text-align:right">&amp;$000000000000000100$</td><td>$(1 &lt;&lt; index)$</td></tr><tr><td style="text-align:right">$000000000000000100$</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @return true代表1, false代表0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line">    <span class="keyword">int</span> bitValue = <span class="number">1</span> &lt;&lt; (index % Long.SIZE);</span><br><span class="line">    <span class="keyword">return</span> (value &amp; bitValue) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器-添加元素"><a href="#布隆过滤器-添加元素" class="headerlink" title="布隆过滤器 - 添加元素"></a>布隆过滤器 - 添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    nullCheck(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用value生成2个整数</span></span><br><span class="line">    <span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line">    <span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">        <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            combinedHash = ~combinedHash;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 生成一个二进位的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line">        <span class="comment">// 设置index位置的二进位为1</span></span><br><span class="line">        <span class="keyword">if</span> (set(index)) result = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器-判断一个元素是否存在"><a href="#布隆过滤器-判断一个元素是否存在" class="headerlink" title="布隆过滤器 - 判断一个元素是否存在"></a>布隆过滤器 - 判断一个元素是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    nullCheck(value);</span><br><span class="line">    <span class="comment">// 利用value生成2个整数</span></span><br><span class="line">    <span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line">    <span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">        <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            combinedHash = ~combinedHash;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 生成一个二进位的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line">        <span class="comment">// 查询index位置的二进位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (!get(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;布隆过滤器（Bloom-Filter）&quot;&gt;&lt;a href=&quot;#布隆过滤器（Bloom-Filter）&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器（Bloom Filter）&quot;&gt;&lt;/a&gt;布隆过滤器（Bloom Filter）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="布隆过滤器" scheme="http://yoursite.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="BloomFilter" scheme="http://yoursite.com/tags/BloomFilter/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/07/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/07/19/动态规划/</id>
    <published>2020-07-19T08:44:57.000Z</published>
    <updated>2020-07-24T04:52:09.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h1><h2 id="动态规划-是什么"><a href="#动态规划-是什么" class="headerlink" title="动态规划 - 是什么"></a>动态规划 - 是什么</h2><p>动态规划，简称 $DP$</p><p>是求解最优化问题的一种常用策略</p><p>通常的使用套路（一步一步优化）</p><p><strong>① 暴力递归（自顶向下，出现了重叠子问题）</strong></p><p><strong>② 记忆化搜索（自顶向下）</strong></p><p><strong>③ 递推（自底向上）</strong></p><h2 id="动态规划-常规步骤"><a href="#动态规划-常规步骤" class="headerlink" title="动态规划 - 常规步骤"></a>动态规划 - 常规步骤</h2><p>动态规划中的“动态”可以理解为是“会变化的状态”</p><p><strong>① 定义状态（状态是原问题、子问题的解）</strong></p><p>​    比如定义 $dp(i)$ 的含义</p><p><strong>② 设置初始状态（边界）</strong></p><p>​    比如设置 $dp(0)$ 的值</p><p><strong>③ 确定状态转移方程</strong></p><p>​    比如确定 $dp(i)$ 和 $dp(i – 1)$ 的关系</p><h2 id="动态规划-一些相关概念"><a href="#动态规划-一些相关概念" class="headerlink" title="动态规划 - 一些相关概念"></a>动态规划 - 一些相关概念</h2><p>来自维基百科的解释</p><p><strong>Dynamic Programming</strong> is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p><p><strong>① 将复杂的原问题拆解成若干个简单的子问题</strong></p><p><strong>② 每个子问题仅仅解决1次，并保存它们的解</strong></p><p><strong>③ 最后推导出原问题的解</strong></p><p>可以用动态规划来解决的问题，通常具备 $2$ 个特点</p><p><strong>最优子结构（最优化原理）：通过求解子问题的最优解，可以获得原问题的最优解</strong></p><p><strong>无后效性</strong></p><ul><li><p>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响（未来与过去无关）</p></li><li><p>在推导后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的</p></li></ul><h2 id="练习1-–-找零钱"><a href="#练习1-–-找零钱" class="headerlink" title="练习1 – 找零钱"></a>练习1 – 找零钱</h2><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LeetCode地址</a></p><p><img src="/2020/07/19/动态规划/1.png" alt></p><p>假设有 $25$ 分、$20$ 分、$5$ 分、$1$ 分的硬币，现要找给客户 $41$ 分的零钱，如何办到硬币个数最少？</p><p>此前用贪心策略得到的并非是最优解（贪心得到的解是 $5$ 枚硬币）</p><p><strong>假设 $dp(n)$ 是凑到 $n$ 分需要的最少硬币个数</strong></p><p>如果第 $1$ 次选择了 $25$ 分的硬币，那么 $dp(n) = dp(n – 25) + 1$</p><p>如果第 $1$ 次选择了 $20$ 分的硬币，那么 $dp(n) = dp(n – 20) + 1$</p><p>如果第 $1$ 次选择了 $5$ 分的硬币，那么 $dp(n) = dp(n – 5) + 1$</p><p>如果第 $1$ 次选择了 $1$ 分的硬币，那么 $dp(n) = dp(n – 1) + 1$</p><p>所以 $dp(n) = min \{ dp(n – 25), dp(n – 20), dp(n – 5), dp(n – 1) \} + 1$</p><h3 id="找零钱-–-暴力递归"><a href="#找零钱-–-暴力递归" class="headerlink" title="找零钱 – 暴力递归"></a>找零钱 – 暴力递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力递归（自顶向下的调用，出现了重叠子问题）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">25</span> || n == <span class="number">20</span> || n == <span class="number">5</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min1 = Math.min(coins(n - <span class="number">25</span>), coins(n - <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">int</span> min2 = Math.min(coins(n - <span class="number">5</span>), coins(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Math.min(min1, min2) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于斐波那契数列的递归版，会有大量的重复计算，时间复杂度较高</p><h3 id="找零钱-–-记忆化搜索"><a href="#找零钱-–-记忆化搜索" class="headerlink" title="找零钱 – 记忆化搜索"></a>找零钱 – 记忆化搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索（自顶向下的调用）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断传入的 n 是否大于面值</span></span><br><span class="line">    <span class="keyword">int</span>[] faces = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> face : faces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; face) <span class="keyword">break</span>;</span><br><span class="line">        dp[face] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coins(n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> min1 = Math.min(coins(n - <span class="number">25</span>, dp), coins(n - <span class="number">20</span>, dp));</span><br><span class="line">        <span class="keyword">int</span> min2 = Math.min(coins(n - <span class="number">5</span>, dp), coins(n - <span class="number">1</span>, dp));</span><br><span class="line">        dp[n] = Math.min(min1, min2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找零钱-–-递推"><a href="#找零钱-–-递推" class="headerlink" title="找零钱 – 递推"></a>找零钱 – 递推</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推（自底向上）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">5</span>) min = Math.min(dp[i - <span class="number">5</span>], min);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">20</span>) min = Math.min(dp[i - <span class="number">20</span>], min);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">25</span>) min = Math.min(dp[i - <span class="number">25</span>], min);</span><br><span class="line">        dp[i] = min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度、空间复杂度：$O(n)$</p><h3 id="输出找零钱的具体方案"><a href="#输出找零钱的具体方案" class="headerlink" title="输出找零钱的具体方案"></a>输出找零钱的具体方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// faces[i]是凑够i分时最后那枚硬币的面值</span></span><br><span class="line">    <span class="keyword">int</span>[] faces = <span class="keyword">new</span> <span class="keyword">int</span>[dp.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = dp[i - <span class="number">1</span>];</span><br><span class="line">        faces[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">5</span> &amp;&amp; dp[i - <span class="number">5</span>] &lt; min) &#123;</span><br><span class="line">            min = dp[i - <span class="number">5</span>];</span><br><span class="line">            faces[i] = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">20</span> &amp;&amp; dp[i - <span class="number">20</span>] &lt; min) &#123;</span><br><span class="line">            min = dp[i - <span class="number">20</span>];</span><br><span class="line">            faces[i] = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">25</span> &amp;&amp; dp[i - <span class="number">25</span>] &lt; min) &#123;</span><br><span class="line">            min = dp[i - <span class="number">25</span>];</span><br><span class="line">            faces[i] = <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = min + <span class="number">1</span>;</span><br><span class="line">        print(faces, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print(faces, n);</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] faces, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"["</span> + n + <span class="string">"] = "</span>);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.print(faces[n] + <span class="string">" "</span>);</span><br><span class="line">        n -= faces[n];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找零钱-–-通用实现"><a href="#找零钱-–-通用实现" class="headerlink" title="找零钱 – 通用实现"></a>找零钱 – 通用实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coins5</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] faces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || faces == <span class="keyword">null</span> || faces.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> face : faces) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; face) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = dp[i - face];</span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= min) <span class="keyword">continue</span>;</span><br><span class="line">            min = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == Integer.MAX_VALUE) &#123;</span><br><span class="line">            dp[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2-–-最大连续子序列和"><a href="#练习2-–-最大连续子序列和" class="headerlink" title="练习2 – 最大连续子序列和"></a>练习2 – 最大连续子序列和</h2><p>给定一个长度为 $n$ 的整数序列，求它的最大连续子序列和</p><p>比如 $–2、1、–3、4、–1、2、1、–5、4$ 的最大连续子序列和是 $4 + (–1) + 2 + 1 = 6$</p><p><strong>状态定义</strong></p><p><strong>假设 $dp(i)$ 是以 $nums[i]$ 结尾的最大连续子序列和（$nums$ 是整个序列）</strong></p><ul><li><p>以 $nums[0] – 2$ 结尾的最大连续子序列是 $–2$，所以 $dp(0) = –2$</p></li><li><p>以 $nums[1] 1$ 结尾的最大连续子序列是 $1$，所以 $dp(1) = 1$</p></li><li><p>以 $nums[2] –3$ 结尾的最大连续子序列是 $1、–3$，所以 $dp(2) = dp(1) + (–3) = –2$</p></li><li><p>以 $nums[3] 4$ 结尾的最大连续子序列是 $4$，所以 $dp(3) = 4$</p></li><li><p>以 $nums[4] –1$ 结尾的最大连续子序列是 $4、–1$，所以 $dp(4) = dp(3) + (–1) = 3$</p></li><li><p>以 $nums[5] 2$ 结尾的最大连续子序列是 $4、–1、2$，所以 $dp(5) = dp(4) + 2 = 5$</p></li><li><p>以 $nums[6] 1$ 结尾的最大连续子序列是 $4、–1、2、1$，所以 $dp(6) = dp(5) + 1 = 6$</p></li><li><p>以 $nums[7] –5$ 结尾的最大连续子序列是 $4、–1、2、1、–5$，所以 $dp(7) = dp(6) + (–5) = 1$</p></li><li><p>以 $nums[8] 4$ 结尾的最大连续子序列是 $4、–1、2、1、–5、4$，所以 $dp(8) = dp(7) + 4 = 5$</p></li></ul><h3 id="最大连续子序列和-–-状态转移方程和初始状态"><a href="#最大连续子序列和-–-状态转移方程和初始状态" class="headerlink" title="最大连续子序列和 – 状态转移方程和初始状态"></a>最大连续子序列和 – 状态转移方程和初始状态</h3><p><strong>状态转移方程</strong></p><p>如果 $dp(i – 1) ≤ 0$，那么 $dp(i) = nums[i]$</p><p>如果 $dp(i – 1) &gt; 0$，那么 $dp(i) = dp(i – 1) + nums[i]$</p><p><strong>初始状态</strong></p><p>$dp(0)$ 的值是 $nums[0]$</p><p><strong>最终的解</strong></p><p>最大连续子序列和是所有 $dp(i)$ 中的最大值 $max \{ dp(i) \}，i ∈ [0, nums.length)$</p><h3 id="最大连续子序列和-–-动态规划-–-一维数组实现"><a href="#最大连续子序列和-–-动态规划-–-一维数组实现" class="headerlink" title="最大连续子序列和 – 动态规划 – 一维数组实现"></a>最大连续子序列和 – 动态规划 – 一维数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nums = &#123;–2、1、–3、4、–1、2、1、–5、4&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (prev &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = prev + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n)$，时间复杂度：$O(n)$</p><h3 id="最大连续子序列和-–-动态规划-–-优化实现-去掉一维数组"><a href="#最大连续子序列和-–-动态规划-–-优化实现-去掉一维数组" class="headerlink" title="最大连续子序列和 – 动态规划 – 优化实现(去掉一维数组)"></a>最大连续子序列和 – 动态规划 – 优化实现(去掉一维数组)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nums = &#123;–2、1、–3、4、–1、2、1、–5、4&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dp = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp = dp + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(dp, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(1)$，时间复杂度：$O(n)$</p><h2 id="练习3-–-最长上升子序列（LIS）"><a href="#练习3-–-最长上升子序列（LIS）" class="headerlink" title="练习3 – 最长上升子序列（LIS）"></a>练习3 – 最长上升子序列（LIS）</h2><p>最长上升子序列（最长递增子序列，$Longest Increasing Subsequence，LIS$）</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/19/动态规划/2.png" alt></p><h3 id="最长上升子序列-–-动态规划-–-状态定义"><a href="#最长上升子序列-–-动态规划-–-状态定义" class="headerlink" title="最长上升子序列 – 动态规划 – 状态定义"></a>最长上升子序列 – 动态规划 – 状态定义</h3><p>假设数组是 $nums， [10, 2, 2, 5, 1, 7, 101, 18]$</p><p>$dp(i)$ 是以 $nums[i]$ 结尾的最长上升子序列的长度，$i ∈ [0, nums.length)$</p><p>以 $nums[0] 10$ 结尾的最长上升子序列是 $10$，所以 $dp(0) = 1$</p><p>以 $nums[1] 2$ 结尾的最长上升子序列是 $2$，所以 $dp(1) = 1$</p><p>以 $nums[2] 2$ 结尾的最长上升子序列是 $2$，所以 $dp(2) = 1$</p><p>以 $nums[3] 5$ 结尾的最长上升子序列是 $2、5$，所以 $dp(3) = dp(1) + 1 = dp(2) + 1 = 2$</p><p>以 $nums[4] 1$ 结尾的最长上升子序列是 $1$，所以 $dp(4) = 1$</p><p>以 $nums[5] 7$ 结尾的最长上升子序列是 $2、5、7$，所以 $dp(5) = dp(3) + 1 = 3$</p><p>以 $nums[6] 101$ 结尾的最长上升子序列是 $2、5、7、101$，所以 $dp(6) = dp(5) + 1 = 4$</p><p>以 $nums[7] 18$ 结尾的最长上升子序列是 $2、5、7、18$，所以 $dp(7) = dp(5) + 1 = 4$</p><p>最长上升子序列的长度是所有 $dp(i)$ 中的最大值 $max \{ dp(i) \}，i ∈ [0, nums.length)$</p><h3 id="最长上升子序列-–-动态规划-–-状态转移方程"><a href="#最长上升子序列-–-动态规划-–-状态转移方程" class="headerlink" title="最长上升子序列 – 动态规划 – 状态转移方程"></a>最长上升子序列 – 动态规划 – 状态转移方程</h3><p><strong>遍历 $j ∈ [0, i)$</strong></p><ol><li><p>当 $nums[i] &gt; nums[ j]$</p><p>$nums[i]$ 可以接在 $nums[j]$ 后面，形成一个比 $dp(j)$ 更长的上升子序列，长度为 $dp(j) + 1$</p><p>$dp(i) = max \{ dp(i), dp( j) + 1 \}$</p></li><li><p>当 $nums[i] ≤ nums[j]$</p><p>$nums[i]$ 不能接在 $nums[j]$ 后面，跳过此次遍历$（continue）$</p></li></ol><p><strong>状态的初始值</strong></p><ol><li><p>$dp(0) = 1$</p></li><li><p>所有的 $dp(i)$ 默认都初始化为 $1$</p></li></ol><h3 id="最长上升子序列-–-动态规划-–-实现"><a href="#最长上升子序列-–-动态规划-–-实现" class="headerlink" title="最长上升子序列 – 动态规划 – 实现"></a>最长上升子序列 – 动态规划 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n)$，时间复杂度：$O(n^2)$</p><h3 id="最长上升子序列-–-二分搜索-–-思路"><a href="#最长上升子序列-–-二分搜索-–-思路" class="headerlink" title="最长上升子序列 – 二分搜索 – 思路"></a>最长上升子序列 – 二分搜索 – 思路</h3><p>把每个数字看做是一张扑克牌，从左到右按顺序处理每一个扑克牌</p><p>将它压在（从左边数过来）第一个牌顶 ≥ 它的牌堆上面</p><p>如果找不到牌顶 ≥ 它的牌堆，就在最右边新建一个牌堆，将它放入这个新牌堆中</p><p><img src="/2020/07/19/动态规划/3.png" alt></p><p>当处理完所有牌，最终牌堆的数量就是最长上升子序列的长度</p><p><strong>思路（假设数组是 $nums$，也就是最初的牌数组）</strong></p><p>$top[i]$ 是第 $i$ 个牌堆的牌顶，$len$ 是牌堆的数量，初始值为 $0$</p><p>遍历每一张牌 $num$</p><p>利用二分搜索找出 $num$ <strong>最终要放入的牌堆位置</strong> $index$</p><p>$num$ 作为第 $index$ 个牌堆的牌顶，$top[index] = num$</p><p>如果 $index$ 等于 $len$，相当于新建一个牌堆，牌堆数量 $+1$，也就是 $len++$</p><h3 id="最长上升子序列-–-二分搜索-–-实现"><a href="#最长上升子序列-–-二分搜索-–-实现" class="headerlink" title="最长上升子序列 – 二分搜索 – 实现"></a>最长上升子序列 – 二分搜索 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 牌堆的数量</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 牌顶数组</span></span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 遍历所有的牌</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = len;</span><br><span class="line">        <span class="comment">// 二分搜索</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= top[mid]) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 覆盖牌顶</span></span><br><span class="line">        top[begin] = num;</span><br><span class="line">        <span class="comment">// 检查是否要新建一个牌堆</span></span><br><span class="line">        <span class="keyword">if</span> (begin == len) len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n)$；时间复杂度：$O(nlogn)$</p><h2 id="练习4-–-最长公共子序列（LCS）"><a href="#练习4-–-最长公共子序列（LCS）" class="headerlink" title="练习4 – 最长公共子序列（LCS）"></a>练习4 – 最长公共子序列（LCS）</h2><p>最长公共子序列（$Longest Common Subsequence，LCS$）</p><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/19/动态规划/4.png" alt></p><h3 id="最长公共子序列-–-思路"><a href="#最长公共子序列-–-思路" class="headerlink" title="最长公共子序列 – 思路"></a>最长公共子序列 – 思路</h3><p>假设 $2$ 个序列分别是 $nums1、nums2$</p><p>$i ∈ [1, nums1.length]$</p><p>$j ∈ [1, nums2.length]$</p><p><img src="/2020/07/19/动态规划/5.png" alt></p><p>假设 $dp(i, j)$ 是【$nums1$ 前 $i$ 个元素】与【$nums2$ 前 $j$ 个元素】的最长公共子序列长度</p><p>$dp(i, 0)、dp(0, j)$ 初始值均为 $0$</p><p>如果 $nums1[i – 1] = nums2[ j – 1]$，那么 $dp(i, j) = dp(i – 1, j – 1) + 1$</p><p>如果 $nums1[i – 1] ≠ nums2[ j – 1]$，那么 $dp(i, j) = max \{ dp(i – 1, j), dp(i, j – 1) \}$</p><p><img src="/2020/07/19/动态规划/6.png" alt></p><h3 id="最长公共子序列-–-递归实现"><a href="#最长公共子序列-–-递归实现" class="headerlink" title="最长公共子序列 – 递归实现"></a>最长公共子序列 – 递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs1</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> lcs1(nums1, nums1.length, nums2, nums2.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求nums1前i个元素和nums2前j个元素的最长公共子序列长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs1</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> i, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> lcs1(nums1, i - <span class="number">1</span>, nums2, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(lcs1(nums1, i - <span class="number">1</span>, nums2, j), </span><br><span class="line">                    lcs1(nums1, i, nums2, j - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(k)$ , $k = min\{n, m\}，n、m$ 是 $2$ 个序列的长度</p><p>时间复杂度：$O(2^n)$，当 $n = m$ 时</p><h4 id="最长公共子序列-–-递归实现分析"><a href="#最长公共子序列-–-递归实现分析" class="headerlink" title="最长公共子序列 – 递归实现分析"></a>最长公共子序列 – 递归实现分析</h4><p><img src="/2020/07/19/动态规划/7.png" alt></p><p><strong>出现了重复的递归调用</strong></p><h3 id="最长公共子序列-–-非递归实现-二维数组实现"><a href="#最长公共子序列-–-非递归实现-二维数组实现" class="headerlink" title="最长公共子序列 – 非递归实现 - 二维数组实现"></a>最长公共子序列 – 非递归实现 - 二维数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs2</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n ∗ m)$，时间复杂度：$O(n ∗ m)$</p><h3 id="dp-数组的计算结果分析"><a href="#dp-数组的计算结果分析" class="headerlink" title="$dp$ 数组的计算结果分析"></a>$dp$ 数组的计算结果分析</h3><p><img src="/2020/07/19/动态规划/8.png" alt></p><p>举例：计算 $dp[1][2]$ 时，<strong>需要的前提计算结果为</strong> $dp[1,1]、dp[0,2]$ 和 $dp[0,1]$ 的值</p><p><img src="/2020/07/19/动态规划/11.png" alt></p><h3 id="最长公共子序列-–-非递归实现-–-滚动数组"><a href="#最长公共子序列-–-非递归实现-–-滚动数组" class="headerlink" title="最长公共子序列 – 非递归实现 – 滚动数组"></a>最长公共子序列 – 非递归实现 – 滚动数组</h3><p>可以使用滚动数组优化空间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs3</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> prevRow = (i - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[row][j] = dp[prevRow][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[row][j] = Math.max(dp[prevRow][j], dp[row][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums1.length &amp; <span class="number">1</span>][nums2.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列-–-非递归实现-–-一维数组"><a href="#最长公共子序列-–-非递归实现-–-一维数组" class="headerlink" title="最长公共子序列 – 非递归实现 – 一维数组"></a>最长公共子序列 – 非递归实现 – 一维数组</h3><p>可以将 <strong>二维数组 优化成 一维数组</strong>，进一步降低空间复杂度</p><p>举例：当计算 $dp[6]$ 时，$dp[]$ 数组中的值存放的就是下图中圆圈的值，再将 $dp[6]$ 左上角的值存放在 $leftTop$ 中即可。</p><p>另一种思路：<strong>每行的列从后往前计算</strong>，$leftTop$ 也可省略，只需一个一维数组。</p><p><img src="/2020/07/19/动态规划/12.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs4</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTop = cur;</span><br><span class="line">            cur = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = leftTop + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums2.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列-–-非递归实现-–-一维数组再次优化"><a href="#最长公共子序列-–-非递归实现-–-一维数组再次优化" class="headerlink" title="最长公共子序列 – 非递归实现 – 一维数组再次优化"></a>最长公共子序列 – 非递归实现 – 一维数组再次优化</h3><p>可以将空间复杂度优化至$O(k) , k = min\{n, m\}$</p><p><strong>数组元素数量少的做列 $row$</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span>[] rowsNums = nums1, colsNums = nums2;</span><br><span class="line">   <span class="keyword">if</span> (nums1.length &lt; nums2.length) &#123;</span><br><span class="line">      colsNums = nums1;</span><br><span class="line">      rowsNums = nums2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[colsNums.length + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowsNums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= colsNums.length; j++) &#123;</span><br><span class="line">         <span class="keyword">int</span> leftTop = cur;</span><br><span class="line">         cur = dp[j];</span><br><span class="line">         <span class="keyword">if</span> (rowsNums[i - <span class="number">1</span>] == colsNums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[j] = leftTop + <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[colsNums.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列-字符串实现"><a href="#最长公共子序列-字符串实现" class="headerlink" title="最长公共子序列 - 字符串实现"></a>最长公共子序列 - 字符串实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text1 == <span class="keyword">null</span> || text2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars1 = text1.toCharArray();  </span><br><span class="line">    <span class="keyword">if</span> (chars1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = text2.toCharArray();  </span><br><span class="line">    <span class="keyword">if</span> (chars2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] rowsChars = chars1, colsChars = chars2;</span><br><span class="line">    <span class="keyword">if</span> (chars1.length &lt; chars2.length) &#123;</span><br><span class="line">        colsChars = chars1;</span><br><span class="line">        rowsChars = chars2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[colsChars.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowsChars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= colsChars.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTop = cur;</span><br><span class="line">            cur = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (rowsChars[i - <span class="number">1</span>] == colsChars[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = leftTop + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[colsChars.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习5-–-最长公共子串"><a href="#练习5-–-最长公共子串" class="headerlink" title="练习5 – 最长公共子串"></a>练习5 – 最长公共子串</h2><p>最长公共子串$（Longest Common Substring）$</p><p>子串是连续的子序列</p><p>求两个字符串的最长公共子串长度</p><p>$ABCBA$ 和 $BABCA$ 的最长公共子串是 $ABC$，长度为 $3$</p><h3 id="最长公共子串-–-思路"><a href="#最长公共子串-–-思路" class="headerlink" title="最长公共子串 – 思路"></a>最长公共子串 – 思路</h3><ol><li><p>假设 $2$ 个字符串分别是 $str1、str2$</p><p>$i ∈ [1, str1.length]$</p><p>$j ∈ [1, str2.length]$</p></li><li><p>假设 $dp(i, j)$ 是以 $str1[i – 1]、str2[ j – 1]$ 结尾的最长公共子串长度</p><p>$dp(i, 0)、dp(0, j)$ 初始值均为 $0$</p><p>如果 $str1[i – 1] = str2[ j – 1]$，那么 $dp(i, j) = dp(i – 1, j – 1) + 1$</p><p>如果 $str1[i – 1] ≠ str2[ j – 1]$，那么 $dp(i, j) = 0$</p></li><li><p>最长公共子串的长度是所有 $dp(i, j)$ 中的最大值 $max \{ dp(i, j) \}$</p></li></ol><h3 id="最长公共子串-–-实现-二维数组"><a href="#最长公共子串-–-实现-二维数组" class="headerlink" title="最长公共子串 – 实现 - 二维数组"></a>最长公共子串 – 实现 - 二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs1</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[chars1.length + <span class="number">1</span>][chars2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= chars1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= chars2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars1[i - <span class="number">1</span>] != chars2[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            max = Math.max(dp[i][j], max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n ∗ m)$ 时间复杂度：$O(n ∗ m)$</p><h3 id="最长公共子串-–-一维数组实现-优化原理跟练习4类似"><a href="#最长公共子串-–-一维数组实现-优化原理跟练习4类似" class="headerlink" title="最长公共子串 – 一维数组实现(优化原理跟练习4类似)"></a>最长公共子串 – 一维数组实现(优化原理跟练习4类似)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (chars2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] rowsChars = chars1, colsChars = chars2;</span><br><span class="line">    <span class="keyword">if</span> (chars1.length &lt; chars2.length) &#123;</span><br><span class="line">        colsChars = chars1;</span><br><span class="line">        rowsChars = chars2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上方整行的值</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[colsChars.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowsChars.length; row++) &#123;</span><br><span class="line">        <span class="comment">// 左上角的值</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt;= colsChars.length; col++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTop = cur;</span><br><span class="line">            cur = dp[col];</span><br><span class="line">            <span class="keyword">if</span> (chars1[row - <span class="number">1</span>] != chars2[col - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[col] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[col] = leftTop + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(dp[col], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(k),k = min\{n, m\}$</p><p>时间复杂度：$O(n ∗ m)$</p><h3 id="最长公共子串-–-一维数组优化-每行的列从后往前开始计算"><a href="#最长公共子串-–-一维数组优化-每行的列从后往前开始计算" class="headerlink" title="最长公共子串 – 一维数组优化 - 每行的列从后往前开始计算"></a>最长公共子串 – 一维数组优化 - 每行的列从后往前开始计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">   <span class="keyword">if</span> (chars1.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">   <span class="keyword">if</span> (chars2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span>[] rowsChars = chars1, colsChars = chars2;</span><br><span class="line">   <span class="keyword">if</span> (chars1.length &lt; chars2.length) &#123;</span><br><span class="line">      colsChars = chars1;</span><br><span class="line">      rowsChars = chars2;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[colsChars.length + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowsChars.length; row++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = colsChars.length; col &gt;= <span class="number">1</span>; col--) &#123;</span><br><span class="line">         <span class="keyword">if</span> (chars1[row - <span class="number">1</span>] != chars2[col - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[col] = <span class="number">0</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[col] = dp[col - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            max = Math.max(dp[col], max);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习6-–-0-1背包"><a href="#练习6-–-0-1背包" class="headerlink" title="练习6 – 0-1背包"></a>练习6 – 0-1背包</h2><ol><li><p>有 $n$ 件物品和一个最大承重为 $W$ 的背包，每件物品的重量是 $𝑤i$、价值是 $𝑣i$</p><p>在保证总重量不超过 $W$ 的前提下，选择某些物品装入背包，背包的最大总价值是多少？</p><p>注意：每个物品只有 $1$ 件，也就是每个物品只能选择 $0$ 件或者 $1$ 件</p></li><li><p>假设 $values$ 是价值数组，$weights$ 是重量数组</p><p>编号为 $k$ 的物品，价值是 $values[k]$，重量是 $weights[k]，k ∈ [0, n)$</p></li><li><p>假设 $dp(i, j)$ 是最大承重为  $j$、有前 $i$ 件物品可选时的最大总价值，$i ∈ [1, n]，j ∈ [1, W]$</p><p>$dp(i, 0)、dp(0, j)$ 初始值均为 $0$</p><p>如果 $j &lt; weights[i – 1]$，那么 $dp(i, j) = dp(i – 1, j)$ ，<strong>不够再容纳东西了</strong></p><p>如果 $j ≥ weights[i – 1]$，那么 $dp(i, j) = max \{ dp(i – 1, j), dp(i – 1, j – weights[i – 1]) + values[i – 1] \}$，<strong>可以再容纳东西，有两种选择，装进背包与不装进背包</strong></p></li></ol><h3 id="0-1背包-–-非递归实现"><a href="#0-1背包-–-非递归实现" class="headerlink" title="0-1背包 – 非递归实现"></a>0-1背包 – 非递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue1</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values.length != weights.length || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[values.length + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weights[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j], </span><br><span class="line">                    values[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[values.length][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dp-数组的计算结果分析-1"><a href="#dp-数组的计算结果分析-1" class="headerlink" title="dp 数组的计算结果分析"></a>dp 数组的计算结果分析</h3><p><img src="/2020/07/19/动态规划/9.png" alt></p><h3 id="0-1背包-–-非递归实现-–-一维数组"><a href="#0-1背包-–-非递归实现-–-一维数组" class="headerlink" title="0-1背包 – 非递归实现 – 一维数组"></a>0-1背包 – 非递归实现 – 一维数组</h3><p>$dp(i, j)$ 都是由 $dp(i – 1, k)$ 推导出来的，也就是说，第 $i$ 行的数据是由它的上一行第 $i – 1$ 行推导出来的</p><p>因此，可以使用一维数组来优化</p><p>另外，由于 $k ≤ j$ ，所以 $j$ 的遍历应该由大到小，否则导致数据错乱（<strong>每行的列由后往前遍历</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue2</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values.length != weights.length || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = capacity; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// j &lt; weights[i - 1] 可以合并到 for 循环里判断</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weights[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[j] = Math.max(dp[j], values[i - <span class="number">1</span>] + dp[j - weights[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1背包-–-非递归实现-–-一维数组优化"><a href="#0-1背包-–-非递归实现-–-一维数组优化" class="headerlink" title="0-1背包 – 非递归实现 – 一维数组优化"></a>0-1背包 – 非递归实现 – 一维数组优化</h3><p>观察二维数组表，得出结论：$j$ 的下界可以从 $1$ 改为 $weights[i – 1]$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values.length != weights.length || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = capacity; j &gt;= weights[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], values[i - <span class="number">1</span>] + dp[j - weights[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1背包-–-恰好装满"><a href="#0-1背包-–-恰好装满" class="headerlink" title="0-1背包 – 恰好装满"></a>0-1背包 – 恰好装满</h3><p>有 $n$ 件物品和一个最大承重为 $W$ 的背包，每件物品的重量是 $𝑤i$、价值是 $𝑣i$</p><p>在保证总重量恰好等于 $W$ 的前提下，选择某些物品装入背包，背包的最大总价值是多少？</p><p>注意：每个物品只有 $1$ 件，也就是每个物品只能选择 $0$ 件或者 $1$ 件</p><p>$dp(i, j)$ 初始状态调整</p><p>$dp(i, 0) = 0$，总重量恰好为 $0$，最大总价值必然也为 $0$</p><p>$dp(0, j) = –∞$<strong>（负无穷）</strong>，$j ≥ 1$，负数在这里代表无法恰好装满</p><p><img src="/2020/07/19/动态规划/10.png" alt></p><h3 id="0-1背包-–-恰好装满-–-实现"><a href="#0-1背包-–-恰好装满-–-实现" class="headerlink" title="0-1背包 – 恰好装满 – 实现"></a>0-1背包 – 恰好装满 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果返回-1，代表没法刚好凑到capacity这个容量</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValueExactly</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values.length != weights.length || capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">        dp[j] = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = capacity; j &gt;= weights[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], values[i - <span class="number">1</span>] + dp[j - weights[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[capacity] &lt; <span class="number">0</span> ? -<span class="number">1</span> : dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划（Dynamic-Programming）&quot;&gt;&lt;a href=&quot;#动态规划（Dynamic-Programming）&quot; class=&quot;headerlink&quot; title=&quot;动态规划（Dynamic Programming）&quot;&gt;&lt;/a&gt;动态规划（Dynami
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>分治</title>
    <link href="http://yoursite.com/2020/07/19/%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2020/07/19/分治/</id>
    <published>2020-07-19T06:03:47.000Z</published>
    <updated>2020-07-19T09:02:23.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治（Divide-And-Conquer）"><a href="#分治（Divide-And-Conquer）" class="headerlink" title="分治（Divide And Conquer）"></a>分治（Divide And Conquer）</h1><h2 id="什么是分治"><a href="#什么是分治" class="headerlink" title="什么是分治"></a>什么是分治</h2><p>分治，也就是分而治之。它的一般步骤是</p><p>① 将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样）</p><p>② 子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解）</p><p>③ 利用子问题的解推导出原问题的解</p><p>因此，<strong>分治策略非常适合用递归</strong></p><p><strong>需要注意的是：子问题之间是相互独立的</strong></p><h2 id="分治的应用"><a href="#分治的应用" class="headerlink" title="分治的应用"></a>分治的应用</h2><p>快速排序</p><p>归并排序</p><p>$Karatsuba$ 算法（大数乘法）</p><p><img src="/2020/07/19/分治/1.png" alt></p><h2 id="主定理（Master-Theorem）"><a href="#主定理（Master-Theorem）" class="headerlink" title="主定理（Master Theorem）"></a>主定理（Master Theorem）</h2><p>分治策略通常遵守一种通用模式</p><p>解决规模为 $n$ 的问题，分解成 $a$ 个规模为 $\frac{n}{b}$ 的子问题，然后在 $O(n^d)$时间内将子问题的解合并起来</p><p>算法运行时间为：$T(n)= aT(\frac{n}{b}) + O(n^d), a &gt; 0,b &gt; 1,d ≥ 0$</p><p>$d &gt; log_ba, T(n) = O(n^d)$</p><p>$d = log_ba, T(n) = O(n^dlogn)$</p><p>$d &lt; log_ba, T(n) = O(n^{log_ba})$</p><p>比如归并排序的运行时间是：$T(n) = 2T(\frac{n}{2}) + O(n), a = 2,b = 2,d = 1,$ 所以$T(n) = O(nlogn)$</p><h2 id="练习1-–-最大连续子序列和"><a href="#练习1-–-最大连续子序列和" class="headerlink" title="练习1 – 最大连续子序列和"></a>练习1 – 最大连续子序列和</h2><p><strong><a href="/2020/07/19/动态规划/" title="动态规划实现子序列">动态规划实现子序列</a></strong></p><p><a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/" target="_blank" rel="noopener">LeetCode地址</a></p><p><img src="/2020/07/19/分治/2.png" alt></p><p><strong>这道题也属于最大切片问题（最大区段，$Greatest Slice$）</strong></p><p><strong>概念区分</strong>：<strong>子串、子数组、子区间必须是连续的，子序列是可以不连续的</strong></p><h3 id="解法1-–-暴力出奇迹"><a href="#解法1-–-暴力出奇迹" class="headerlink" title="解法1 – 暴力出奇迹"></a>解法1 – 暴力出奇迹</h3><p>穷举出所有可能的连续子序列，并计算出它们的和，最后取它们中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">0</span>; begin &lt; nums.length; begin++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = begin; end &lt; nums.length; end++) &#123;</span><br><span class="line">            <span class="comment">// sum是[begin, end]的和</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(1)$ ，时间复杂度：$O(n^3)$</p><h3 id="解法1-–-暴力出奇迹-–-优化"><a href="#解法1-–-暴力出奇迹-–-优化" class="headerlink" title="解法1 – 暴力出奇迹 – 优化"></a>解法1 – 暴力出奇迹 – 优化</h3><p>重复利用前面计算过的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">0</span>; begin &lt; nums.length; begin++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = begin; end &lt; nums.length; end++) &#123;</span><br><span class="line">            <span class="comment">// sum是[begin, end]的和</span></span><br><span class="line">            sum += nums[end];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(1)$ ，时间复杂度：$O(n^2)$</p><h3 id="解法2-–-分治"><a href="#解法2-–-分治" class="headerlink" title="解法2 – 分治"></a>解法2 – 分治</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> maxSubArray(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解[begin, end)中最大连续子序列的和</span></span><br><span class="line"><span class="comment"> * T(n) = T(n/2) + T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"> * T(n) = 2T(n/2) + O(n)</span></span><br><span class="line"><span class="comment"> * logba = 1  d = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span> nums[begin];</span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftMax = nums[mid - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> leftSum = leftMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">2</span>; i &gt;= begin; i--) &#123;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">        leftMax = Math.max(leftMax, leftSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightMax = nums[mid];</span><br><span class="line">    <span class="keyword">int</span> rightSum = rightMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">        rightSum += nums[i];</span><br><span class="line">        rightMax = Math.max(rightMax, rightSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax + rightMax, </span><br><span class="line">                    Math.max(</span><br><span class="line">                        maxSubArray(nums, begin, mid), </span><br><span class="line">                        maxSubArray(nums, mid, end))</span><br><span class="line">                   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(logn)$</p><p>时间复杂度：$O(nlogn)$</p><p>跟归并排序、快速排序一样</p><p>$T(n) = 2(T)(\frac{n}{2}) + O(n)$</p><h2 id="练习2-–-大数乘法"><a href="#练习2-–-大数乘法" class="headerlink" title="练习2 – 大数乘法"></a>练习2 – 大数乘法</h2><p>$2$ 个超大的数（比如 $2$ 个 $100$ 位的数），如何进行乘法？</p><p>按照小学时学习的乘法运算，在进行 $n$ 位数之间的相乘时，需要大约进行 $n^2$ 次个位数的相乘</p><p>比如计算 $36 * 54$</p><p><img src="/2020/07/19/分治/3.png" alt></p><p>$T(n) = 4T(\frac{n}{2}) + O(n) = O(n^2)$</p><p>$1960$ 年 $Anatolii Alexeevitch Karatsuba$ 提出了 $Karatsuba$ 算法，提高了大数乘法的效率</p><p><img src="/2020/07/19/分治/4.png" alt></p><p>$BC + AD = AC + BD − (A − B)(C − D)$</p><p>$T(n) = 3T(\frac{n}{2}) + O(n) = O(n^{log_23}) = O(n^{1.585})$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分治（Divide-And-Conquer）&quot;&gt;&lt;a href=&quot;#分治（Divide-And-Conquer）&quot; class=&quot;headerlink&quot; title=&quot;分治（Divide And Conquer）&quot;&gt;&lt;/a&gt;分治（Divide And Conque
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yoursite.com/2020/07/19/%E8%B4%AA%E5%BF%83/"/>
    <id>http://yoursite.com/2020/07/19/贪心/</id>
    <published>2020-07-19T04:42:57.000Z</published>
    <updated>2020-07-20T08:30:23.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心（Greedy）"><a href="#贪心（Greedy）" class="headerlink" title="贪心（Greedy）"></a>贪心（Greedy）</h1><h2 id="什么是贪心算法"><a href="#什么是贪心算法" class="headerlink" title="什么是贪心算法"></a>什么是贪心算法</h2><p>贪心策略，也称为贪婪策略</p><p>每一步都采取当前状态下最优的选择（<strong>局部最优解</strong>），从而希望推导出全局最优解</p><p><strong>贪心的应用</strong></p><ul><li><p>哈夫曼树</p></li><li><p>最小生成树算法：$Prim、Kruskal$</p></li><li><p>最短路径算法：$Dijkstra$</p></li></ul><h2 id="练习1-–-最优装载问题（加勒比海盗）"><a href="#练习1-–-最优装载问题（加勒比海盗）" class="headerlink" title="练习1 – 最优装载问题（加勒比海盗）"></a>练习1 – 最优装载问题（加勒比海盗）</h2><p>在北美洲东南部，有一片神秘的海域，是海盗最活跃的加勒比海</p><p>有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值</p><p>海盗船的载重量为 $W$，每件古董的重量为 $𝑤_i$，海盗们该如何把尽可能多数量的古董装上海盗船？</p><p>比如 $W$ 为 $30$，$𝑤_i$ 分别为 $3、 5、 4、 10、 7、 14、 2、 11$</p><p>贪心策略：每一次都优先选择重量最小的古董</p><p>① 选择重量为 $2$ 的古董，剩重量 $28$</p><p>② 选择重量为 $3$ 的古董，剩重量 $25$</p><p>③ 选择重量为 $4$ 的古董，剩重量 $21$</p><p>④ 选择重量为 $5$ 的古董，剩重量 $16$</p><p>⑤ 选择重量为 $7$ 的古董，剩重量 $9$</p><p>最多能装载 $5$ 个古董</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pirate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] weights = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">11</span>&#125;;</span><br><span class="line">Arrays.sort(weights);</span><br><span class="line"><span class="keyword">int</span> capacity = <span class="number">30</span>, weight = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length &amp;&amp; weight &lt; capacity; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> newWeight = weight + weights[i];</span><br><span class="line"><span class="keyword">if</span> (newWeight &lt;= capacity) &#123;</span><br><span class="line">weight = newWeight;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(weights[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"一共选了"</span> + count + <span class="string">"件古董"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习2-–-零钱兑换"><a href="#练习2-–-零钱兑换" class="headerlink" title="练习2 – 零钱兑换"></a>练习2 – 零钱兑换</h2><p><strong><a href="/2020/07/19/动态规划/" title="动态规划实现零钱兑换">动态规划实现零钱兑换</a></strong></p><p>假设有 $25$ 分、$10$ 分、$5$ 分、$1$ 分的硬币，现要找给客户 $41$ 分的零钱，如何办到硬币个数最少？</p><p>贪心策略：每一次都优先选择面值最大的硬币</p><p>① 选择 $25$ 分的硬币，剩 $16$ 分</p><p>② 选择 $10$ 分的硬币，剩 $6$ 分</p><p>③ 选择 $5$ 分的硬币，剩 $1$ 分</p><p>④ 选择 $1$ 分的硬币</p><p>最终的解是共 $4$ 枚硬币</p><p>$25$ 分、$10$ 分、$5$ 分、$1$ 分硬币各一枚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer[] faces = &#123;<span class="number">25</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>&#125;</span><br><span class="line">Arrays.sort(faces);</span><br><span class="line"><span class="keyword">int</span> coins = <span class="number">0</span>, money = <span class="number">41</span>;</span><br><span class="line">idx = faces.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (money &gt;= faces[idx]) &#123;</span><br><span class="line">        System.out.println(faces[idx]);</span><br><span class="line">        money -= faces[idx];</span><br><span class="line">        coins++;</span><br><span class="line">    &#125;</span><br><span class="line">    idx--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(coins);</span><br></pre></td></tr></table></figure><h2 id="零钱兑换的另一个例子"><a href="#零钱兑换的另一个例子" class="headerlink" title="零钱兑换的另一个例子"></a>零钱兑换的另一个例子</h2><p>假设有 $25$ 分、$20$ 分、$5$ 分、$1$ 分的硬币，现要找给客户 $41$ 分的零钱，如何办到硬币个数最少？</p><p>贪心策略：每一步都优先选择面值最大的硬币</p><p>① 选择 $25$ 分的硬币，剩 $16$ 分</p><p>② 选择 $5$ 分的硬币，剩 $11$ 分</p><p>③ 选择 $5$ 分的硬币，剩 $6$ 分</p><p>④ 选择 $5$ 分的硬币，剩 $1$ 分</p><p>⑤ 选择 $1$ 分的硬币</p><p>最终的解是 $1$ 枚 $25$ 分、$3$ 枚 $5$ 分、$1$ 枚 $1$ 分的硬币，共 $5$ 枚硬币</p><p><strong>实际上本题的最优解是：$2$ 枚 $20$ 分、$1$ 枚 $1$ 分的硬币，共 $3$ 枚硬币</strong></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>贪心策略并不一定能得到全局最优解</strong></p><p>因为一般没有测试所有可能的解，容易过早做决定，所以没法达到最佳解</p><p>贪图眼前局部的利益最大化，看不到长远未来，走一步看一步</p><p>优点：简单、高效、不需要穷举所有可能，<strong>通常作为其他算法的辅助算法来使用</strong></p><p>缺点：鼠目寸光，不从整体上考虑其他可能，每次采取局部最优解，不会再回溯，因此<strong>很少情况会得到最优解</strong></p><h2 id="练习3-–-0-1背包"><a href="#练习3-–-0-1背包" class="headerlink" title="练习3 – 0-1背包"></a>练习3 – 0-1背包</h2><p><strong><a href="/2020/07/19/动态规划/" title="动态规划实现0-1背包">动态规划实现0-1背包</a></strong></p><p>有 $n$ 件物品和一个最大承重为 $W$ 的背包，每件物品的重量是 $𝑤_i$、价值是 $𝑣_i$</p><p>在保证总重量不超过 $W$ 的前提下，将哪几件物品装入背包，可以使得背包的总价值最大？</p><p>注意：每个物品只有 $1$ 件，也就是每个物品只能选择 $0$ 件或者 $1$ 件，因此称为 $0-1$背包问题</p><p>如果采取贪心策略，有 $3$ 个方案</p><p>① 价值主导：优先选择价值最高的物品放进背包</p><p>② 重量主导：优先选择重量最轻的物品放进背包</p><p>③ 价值密度主导：优先选择价值密度最高的物品放进背包（价值密度 = 价值 ÷ 重量）</p><h3 id="0-1背包-–-实例"><a href="#0-1背包-–-实例" class="headerlink" title="0-1背包 – 实例"></a>0-1背包 – 实例</h3><p>假设背包最大承重 $150$，$7$ 个物品如表格所示</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>编号</strong></th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center"><strong>重量</strong></td><td style="text-align:center">35</td><td style="text-align:center">30</td><td style="text-align:center">60</td><td style="text-align:center">50</td><td style="text-align:center">40</td><td style="text-align:center">10</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center"><strong>价值</strong></td><td style="text-align:center">10</td><td style="text-align:center">40</td><td style="text-align:center">30</td><td style="text-align:center">50</td><td style="text-align:center">35</td><td style="text-align:center">40</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center"><strong>价值密度</strong></td><td style="text-align:center">0.29</td><td style="text-align:center">1.33</td><td style="text-align:center">0.5</td><td style="text-align:center">1.0</td><td style="text-align:center">0.88</td><td style="text-align:center">4.0</td><td style="text-align:center">1.2</td></tr></tbody></table></div><p>① 价值主导：放入背包的物品编号是 $4、2、6、5$，总重量 $130$，总价值 $165$</p><p>② 重量主导：放入背包的物品编号是 $6、7、2、1、5$，总重量 $140$，总价值 $155$</p><p>③ 价值密度主导：放入背包的物品编号是 $6、2、7、4、1$，总重量 $150$，总价值 $170$</p><h3 id="0-1背包-–-实现"><a href="#0-1背包-–-实现" class="headerlink" title="0-1背包 – 实现"></a>0-1背包 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(String title, Comparator&lt;Article&gt; cmp)</span> </span>&#123;</span><br><span class="line">    Article[] articles = <span class="keyword">new</span> Article[] &#123;</span><br><span class="line">        <span class="keyword">new</span> Article(<span class="number">35</span>, <span class="number">10</span>), <span class="keyword">new</span> Article(<span class="number">30</span>, <span class="number">40</span>),</span><br><span class="line">        <span class="keyword">new</span> Article(<span class="number">60</span>, <span class="number">30</span>), <span class="keyword">new</span> Article(<span class="number">50</span>, <span class="number">50</span>),</span><br><span class="line">        <span class="keyword">new</span> Article(<span class="number">40</span>, <span class="number">35</span>), <span class="keyword">new</span> Article(<span class="number">10</span>, <span class="number">40</span>),</span><br><span class="line">        <span class="keyword">new</span> Article(<span class="number">25</span>, <span class="number">30</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(articles, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">150</span>, weight = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    List&lt;Article&gt; selectedArticles = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; articles.length &amp;&amp; weight &lt; capacity; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> newWeight = weight + articles[i].weight;</span><br><span class="line">        <span class="keyword">if</span> (newWeight &lt;= capacity) &#123;</span><br><span class="line">            weight = newWeight;</span><br><span class="line">            value += articles[i].value;</span><br><span class="line">            selectedArticles.add(articles[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"【"</span> + title + <span class="string">"】"</span>);</span><br><span class="line">    System.out.println(<span class="string">"总价值："</span> + value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedArticles.size(); i++) &#123;</span><br><span class="line">        System.out.println(selectedArticles.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    select(<span class="string">"价值主导"</span>, (Article a1, Article a2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a2.value - a1.value;</span><br><span class="line">    &#125;);</span><br><span class="line">    select(<span class="string">"重量主导"</span>, (Article a1, Article a2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.weight - a2.weight;</span><br><span class="line">    &#125;);</span><br><span class="line">    select(<span class="string">"价值密度主导"</span>, (Article a1, Article a2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(a2.valueDensity, a1.valueDensity);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> valueDensity;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Article</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.weight = weight;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">valueDensity = value * <span class="number">1.0</span> / weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Article [weight="</span> + weight + <span class="string">", value="</span> + value + <span class="string">", valueDensity="</span> + valueDensity + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/19/贪心/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;贪心（Greedy）&quot;&gt;&lt;a href=&quot;#贪心（Greedy）&quot; class=&quot;headerlink&quot; title=&quot;贪心（Greedy）&quot;&gt;&lt;/a&gt;贪心（Greedy）&lt;/h1&gt;&lt;h2 id=&quot;什么是贪心算法&quot;&gt;&lt;a href=&quot;#什么是贪心算法&quot; class
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="http://yoursite.com/2020/07/18/%E5%9B%9E%E6%BA%AF/"/>
    <id>http://yoursite.com/2020/07/18/回溯/</id>
    <published>2020-07-18T07:20:31.000Z</published>
    <updated>2020-07-18T07:53:57.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯（Back-Tracking）"><a href="#回溯（Back-Tracking）" class="headerlink" title="回溯（Back Tracking）"></a>回溯（Back Tracking）</h1><h2 id="什么是回溯"><a href="#什么是回溯" class="headerlink" title="什么是回溯"></a>什么是回溯</h2><p>回溯可以理解为：通过选择不同的岔路口来通往目的地（找到想要的结果）</p><p>每一步都选择一条路出发，能进则进，不能进则退回上一步（回溯），换一条路再试</p><p>树、图的深度优先搜索 ($DFS$)、八皇后、走迷宫都是典型的回溯应用</p><h2 id="八皇后问题（Eight-Queens）"><a href="#八皇后问题（Eight-Queens）" class="headerlink" title="八皇后问题（Eight Queens）"></a>八皇后问题（Eight Queens）</h2><p>八皇后问题是一个古老而著名的问题</p><p>在 $8*8$ 格的国际象棋上摆放八个皇后，使其不能互相攻击：任意两个皇后都不能处于同一行、同一列、同一斜线上</p><p>请问有多少种摆法？</p><p><img src="/2020/07/18/回溯/1.png" alt></p><h3 id="八皇后问题的解决思路"><a href="#八皇后问题的解决思路" class="headerlink" title="八皇后问题的解决思路"></a>八皇后问题的解决思路</h3><p><strong>思路一：暴力出奇迹</strong></p><p>从 $64$ 个格子中选出任意 $8$ 个格子摆放皇后，检查每一种摆法的可行性</p><p>一共 $C^8_{64}$ 种摆法（大概是 $4.4 ∗ 10^9$ 种摆法）</p><p><strong>思路二：根据题意减小暴力程度</strong></p><p>很显然，每一行只能放一个皇后，所以共有 $88$ 种摆法（ $16777216$ 种），检查每一种摆法的可行性</p><script type="math/tex; mode=display">A^m_n = n(n-1) \cdots (n-m+1) = \frac{n!}{(n-m)!} \\C^m_n = \frac{A^m_n}{m!} = \frac{n!}{m!(n-m)!} = C^{n-m}_n</script><p><strong>思路三：回溯法</strong></p><p>回溯 + 剪枝</p><h3 id="四皇后-–-回溯法"><a href="#四皇后-–-回溯法" class="headerlink" title="四皇后 – 回溯法"></a>四皇后 – 回溯法</h3><p>在解决八皇后问题之前，可以先缩小数据规模，看看如何解决四皇后问题</p><p><img src="/2020/07/18/回溯/2.png" alt></p><h3 id="四皇后-–-剪枝（Pruning）"><a href="#四皇后-–-剪枝（Pruning）" class="headerlink" title="四皇后 – 剪枝（Pruning）"></a>四皇后 – 剪枝（Pruning）</h3><p><img src="/2020/07/18/回溯/3.png" alt></p><h3 id="八皇后-–-回溯法"><a href="#八皇后-–-回溯法" class="headerlink" title="八皇后 – 回溯法"></a>八皇后 – 回溯法</h3><p><img src="/2020/07/18/回溯/4.png" alt></p><p><img src="/2020/07/18/回溯/5.png" alt></p><p><img src="/2020/07/18/回溯/6.png" alt></p><h4 id="八皇后实现-–-合法性检查"><a href="#八皇后实现-–-合法性检查" class="headerlink" title="八皇后实现 – 合法性检查"></a>八皇后实现 – 合法性检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组索引是行号，数组元素是列号</span></span><br><span class="line"><span class="keyword">int</span>[] cols;</span><br><span class="line"><span class="comment">// 一共有多少种摆法</span></span><br><span class="line"><span class="keyword">int</span> ways;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第row行第col列是否可以摆放皇后</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="comment">// 第col列已经有皇后</span></span><br><span class="line">        <span class="keyword">if</span> (cols[i] == col) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第i行的皇后跟第row行第col列格子处在同一斜线上</span></span><br><span class="line">        <span class="comment">// 斜率等于 -1 或 1</span></span><br><span class="line">        <span class="keyword">if</span> (row - i == Math.abs(col - cols[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八皇后实现-–-打印"><a href="#八皇后实现-–-打印" class="headerlink" title="八皇后实现 – 打印"></a>八皇后实现 – 打印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; cols.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols.length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols[row] == col) &#123;</span><br><span class="line">                System.out.print(<span class="string">"1 "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"0 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八皇后实现-–-从某一行开始摆放皇后"><a href="#八皇后实现-–-从某一行开始摆放皇后" class="headerlink" title="八皇后实现 – 从某一行开始摆放皇后"></a>八皇后实现 – 从某一行开始摆放皇后</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第row行开始摆放皇后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cols的大小为n，row == n，n个都摆完，证明这次的n个摆放是正确的</span></span><br><span class="line">    <span class="comment">// 摆法++，展示摆法方式</span></span><br><span class="line">    <span class="keyword">if</span> (row == cols.length) &#123;</span><br><span class="line">        ways++;</span><br><span class="line">        show();</span><br><span class="line">        <span class="comment">// 继续寻找其他可能的摆法方式</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不满足时回溯，行row--，列col++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols.length; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(row, col)) &#123;</span><br><span class="line">            <span class="comment">// 在第row行第col列摆放皇后</span></span><br><span class="line">            cols[row] = col;</span><br><span class="line">            <span class="comment">// 满足时行row++，继续尝试在下一行摆放（递归）</span></span><br><span class="line">            place(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八皇后实现-–-摆放所有皇后"><a href="#八皇后实现-–-摆放所有皇后" class="headerlink" title="八皇后实现 – 摆放所有皇后"></a>八皇后实现 – 摆放所有皇后</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    cols = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    place(<span class="number">0</span>);</span><br><span class="line">    System.out.println(n + <span class="string">"皇后一共有"</span> + ways + <span class="string">"种摆法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/18/回溯/7.png" alt></p><h3 id="八皇后优化-–-成员变量"><a href="#八皇后优化-–-成员变量" class="headerlink" title="八皇后优化 – 成员变量"></a>八皇后优化 – 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组索引是行号，数组元素是列号</span></span><br><span class="line"><span class="comment">// 仅在打印中使用</span></span><br><span class="line"><span class="keyword">int</span>[] queens;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记着某一列是否有皇后，行号不用考虑</span></span><br><span class="line"><span class="keyword">boolean</span>[] cols;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记着某一斜线上是否有皇后（左上角 -&gt; 右下角）↘</span></span><br><span class="line"><span class="comment">// 举例：当n为4时，从左上角到右下角有7条斜线 n^2 - 1</span></span><br><span class="line"><span class="keyword">boolean</span>[] leftTop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记着某一斜线上是否有皇后（右上角 -&gt; 左下角）↙</span></span><br><span class="line"><span class="keyword">boolean</span>[] rightTop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一共有多少种摆法</span></span><br><span class="line"><span class="keyword">int</span> ways;</span><br></pre></td></tr></table></figure><h4 id="八皇后优化-–-从某一行开始摆放皇后"><a href="#八皇后优化-–-从某一行开始摆放皇后" class="headerlink" title="八皇后优化 – 从某一行开始摆放皇后"></a>八皇后优化 – 从某一行开始摆放皇后</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == cols.length) &#123;</span><br><span class="line">        ways++;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols.length; col++) &#123;</span><br><span class="line">        <span class="comment">// 如果成立，意味着col列已经有皇后</span></span><br><span class="line">        <span class="keyword">if</span> (cols[col]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两条斜线是否有皇后</span></span><br><span class="line">        <span class="keyword">int</span> ltIndex = row - col + cols.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftTop[ltIndex]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> rtIndex = row +col;</span><br><span class="line">        <span class="keyword">if</span> (rightTop[rtIndex]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// col列、两条斜线没皇后</span></span><br><span class="line">        <span class="comment">// queens 回溯时不用修改，会被后来覆盖</span></span><br><span class="line">        <span class="comment">// queens 只在打印时使用</span></span><br><span class="line">        queens[row] = col;</span><br><span class="line">        cols[col] = <span class="keyword">true</span>;</span><br><span class="line">        leftTop[ltIndex] = <span class="keyword">true</span>;</span><br><span class="line">        rightTop[rtIndex] = <span class="keyword">true</span>;</span><br><span class="line">        place(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯（恢复现场）</span></span><br><span class="line">        cols[col] = <span class="keyword">false</span>;</span><br><span class="line">        leftTop[ltIndex] = <span class="keyword">false</span>;</span><br><span class="line">        rightTop[rtIndex] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八皇后优化-–-摆放所有皇后"><a href="#八皇后优化-–-摆放所有皇后" class="headerlink" title="八皇后优化 – 摆放所有皇后"></a>八皇后优化 – 摆放所有皇后</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    leftTop = <span class="keyword">new</span> <span class="keyword">boolean</span>[(n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>];</span><br><span class="line">    rightTop = <span class="keyword">new</span> <span class="keyword">boolean</span>[leftTop.length];</span><br><span class="line">    place(<span class="number">0</span>);</span><br><span class="line">    System.out.println(n + <span class="string">"皇后一共有"</span> + ways + <span class="string">"种摆法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八皇后优化-–-对角线"><a href="#八皇后优化-–-对角线" class="headerlink" title="八皇后优化 – 对角线"></a>八皇后优化 – 对角线</h4><p><strong>左上角 -&gt; 右下角的对角线索引：$row – col + 7$</strong></p><p><img src="/2020/07/18/回溯/8.png" alt></p><p><strong>右上角 -&gt; 左下角的对角线索引：$row + col$</strong></p><p><img src="/2020/07/18/回溯/9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回溯（Back-Tracking）&quot;&gt;&lt;a href=&quot;#回溯（Back-Tracking）&quot; class=&quot;headerlink&quot; title=&quot;回溯（Back Tracking）&quot;&gt;&lt;/a&gt;回溯（Back Tracking）&lt;/h1&gt;&lt;h2 id=&quot;什么是回溯
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法对策" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AF%B9%E7%AD%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="http://yoursite.com/2020/07/15/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/07/15/最短路径/</id>
    <published>2020-07-15T09:12:48.000Z</published>
    <updated>2020-07-18T03:29:34.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径（Shortest-Path）"><a href="#最短路径（Shortest-Path）" class="headerlink" title="最短路径（Shortest Path）"></a>最短路径（Shortest Path）</h1><h2 id="什么是最短路径"><a href="#什么是最短路径" class="headerlink" title="什么是最短路径"></a>什么是最短路径</h2><p>最短路径是指两顶点之间权值之和最小的路径（有向图、无向图均适用，<strong>不能有负权环）</strong></p><p><img src="/2020/07/15/最短路径/1.png" alt></p><p>无权图相当于是全部边权值为 $1$ 的有权图</p><p><img src="/2020/07/15/最短路径/2.png" alt></p><h2 id="最短路径-–-负权边"><a href="#最短路径-–-负权边" class="headerlink" title="最短路径 – 负权边"></a>最短路径 – 负权边</h2><p>有负权边，但没有负权环时，存在最短路径</p><p><img src="/2020/07/15/最短路径/3.png" alt></p><p>$A$ 到 $E$ 的最短路径是：$A → B → E$</p><h2 id="最短路径-–-负权环"><a href="#最短路径-–-负权环" class="headerlink" title="最短路径 – 负权环"></a>最短路径 – 负权环</h2><p>有负权环时，不存在最短路径</p><p><img src="/2020/07/15/最短路径/4.png" alt></p><p>通过负权环， $A$ 到 $E$ 的路径可以无限短</p><p>$A → E → D → F → E → D → F → E → D → F → E → D → F → E → ……$</p><h2 id="求解最短路径的3个经典算法"><a href="#求解最短路径的3个经典算法" class="headerlink" title="求解最短路径的3个经典算法"></a>求解最短路径的3个经典算法</h2><p>最短路径的典型应用之一：<strong>路径规划问题</strong></p><p>单源最短路径算法</p><ol><li><p>$Dijkstra$（迪杰斯特拉算法）</p></li><li><p>$Bellman-Ford$（贝尔曼-福特算法）</p></li></ol><p>多源最短路径算法</p><ol><li>$Floyd$（弗洛伊德算法）</li></ol><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>$Dijkstra$ 属于单源最短路径算法，用于计算一个顶点到其他所有顶点的最短路径</p><p>使用前提：<strong>不能有负权边</strong></p><p>时间复杂度：可优化至 $O(ElogV)$ ，$E$ 是边数量，$V$ 是节点数量</p><p>由荷兰的科学家 $Edsger Wybe Dijkstra$ 发明，曾在 $1972$ 年获得图灵奖</p><h3 id="Dijkstra-–-等价思考"><a href="#Dijkstra-–-等价思考" class="headerlink" title="Dijkstra – 等价思考"></a>Dijkstra – 等价思考</h3><p>$Dijkstra$ 的原理其实跟生活中的一些自然现象完全一样</p><p>把每 $1$ 个顶点想象成是 $1$ 块小石头</p><p>每 $1$ 条边想象成是 $1$ 条绳子，每一条绳子都连接着 $2$ 块小石头，边的权值就是绳子的长度</p><p>将小石头和绳子平放在一张桌子上（下图是一张俯视图，图中黄颜色的是桌子）</p><p><img src="/2020/07/15/最短路径/5.png" alt></p><p>接下来想象一下，手拽着小石头 $A$，慢慢地向上提起来，远离桌面</p><p>$B、D、C、E$会依次离开桌面</p><p>最后绷直的绳子就是 $A$ 到其他小石头的最短路径</p><p><strong>有一个很关键的信息</strong></p><p><strong>后离开桌面的小石头，都是被先离开桌面的小石头拉起来的</strong></p><h3 id="Dijkstra-–-执行过程"><a href="#Dijkstra-–-执行过程" class="headerlink" title="Dijkstra – 执行过程"></a>Dijkstra – 执行过程</h3><p><img src="/2020/07/15/最短路径/6.png" alt></p><p><strong>绿色：已经“离开桌面”，已经确定了最终的最短路径</strong></p><p><strong>红色：更新了最短路径信息</strong></p><p><img src="/2020/07/15/最短路径/7.png" alt></p><p><strong>松弛操作$（Relaxation）$</strong>：更新 $2$ 个顶点之间的最短路径</p><p><strong>这里一般是指：更新源点到另一个点的最短路径</strong></p><p><strong>松弛操作的意义：尝试找出更短的最短路径</strong></p><p>确定 $A$ 到 $D$ 的最短路径后，对 $DC、DE$ 边进行松弛操作，更新了 $A$ 到 $C$、$A$ 到 $E$ 的最短路径</p><p><img src="/2020/07/15/最短路径/8.png" alt></p><h3 id="Dijkstra-–-代码实现"><a href="#Dijkstra-–-代码实现" class="headerlink" title="Dijkstra – 代码实现"></a>Dijkstra – 代码实现</h3><h4 id="边和顶点的定义"><a href="#边和顶点的定义" class="headerlink" title="边和顶点的定义"></a>边和顶点的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; inEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; outEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Vertex(V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">"null"</span> : value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; from;</span><br><span class="line">    Vertex&lt;V, E&gt; to;</span><br><span class="line">    E weight;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EdgeInfo&lt;V, E&gt; <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EdgeInfo&lt;&gt;(from.value, to.value, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from.hashCode() * <span class="number">31</span> + to.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;V, Vertex&lt;V, E&gt;&gt; vertices = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Set&lt;Edge&lt;V, E&gt;&gt; edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;Edge&lt;V, E&gt;&gt; edgeComparator = (Edge&lt;V, E&gt; e1, Edge&lt;V, E&gt; e2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> weightManager.compare(e1.weight, e2.weight);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="边信息的定义"><a href="#边信息的定义" class="headerlink" title="边信息的定义"></a>边信息的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeInfo</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> V from;</span><br><span class="line">    <span class="keyword">private</span> V to;</span><br><span class="line">    <span class="keyword">private</span> E weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeInfo</span><span class="params">(V from, V to, E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(V from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo</span><span class="params">(V to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"EdgeInfo [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径信息的定义"><a href="#路径信息的定义" class="headerlink" title="路径信息的定义"></a>路径信息的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PathInfo</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> E weight;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathInfo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathInfo</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; getEdgeInfos() &#123;</span><br><span class="line">        <span class="keyword">return</span> edgeInfos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdgeInfos</span><span class="params">(List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.edgeInfos = edgeInfos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PathInfo [weight="</span> + weight + <span class="string">", edgeInfos="</span> + edgeInfos + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="权值的定义和比较"><a href="#权值的定义和比较" class="headerlink" title="权值的定义和比较"></a>权值的定义和比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WeightManager&lt;Double&gt; weightManager = <span class="keyword">new</span> WeightManager&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double w1, Double w2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w1.compareTo(w2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">add</span><span class="params">(Double w1, Double w2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w1 + w2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="从路径中挑一个最小的路径出来"><a href="#从路径中挑一个最小的路径出来" class="headerlink" title="从路径中挑一个最小的路径出来"></a>从路径中挑一个最小的路径出来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; getMinPath(Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt;&gt; it = paths.entrySet().iterator();</span><br><span class="line">    Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = it.next();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="keyword">if</span> (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            minEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; dijkstra(V begin) &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经是最短路径 存储起点到某个点，（包括路径信息）</span></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还未确定是最短路径</span></span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化从起点出发，直接到的点，存放到paths</span></span><br><span class="line">    paths.put(beginVertex, <span class="keyword">new</span> PathInfo&lt;&gt;(weightManager.zero()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!paths.isEmpty()) &#123;</span><br><span class="line">        Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = getMinPath(paths);</span><br><span class="line">        <span class="comment">// minVertex离开桌面</span></span><br><span class="line">        Vertex&lt;V, E&gt; minVertex = minEntry.getKey();</span><br><span class="line">        PathInfo&lt;V, E&gt; minPath = minEntry.getValue();</span><br><span class="line">        selectedPaths.put(minVertex.value, minPath);</span><br><span class="line">        paths.remove(minVertex);</span><br><span class="line">        <span class="comment">// 对它的minVertex的outEdges进行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : minVertex.outEdges) &#123;</span><br><span class="line">            <span class="comment">// 如果edge.to已经离开桌面，就没必要进行松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (selectedPaths.containsKey(edge.to.value)) <span class="keyword">continue</span>;</span><br><span class="line">            relaxForDijkstra(edge, minPath, paths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selectedPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectedPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 松弛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edge 需要进行松弛的边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromPath edge的from的最短路径信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paths 存放着其他点（对于dijkstra来说，就是还没有离开桌面的点）的最短路径信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relaxForDijkstra</span><span class="params">(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新的可选择的最短路径：beginVertex到edge.from的最短路径 + edge.weight</span></span><br><span class="line">    E newWeight = weightManager.add(fromPath.weight, edge.weight);</span><br><span class="line">    <span class="comment">// 以前的最短路径：beginVertex到edge.to的最短路径</span></span><br><span class="line">    PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to);</span><br><span class="line">    <span class="keyword">if</span> (oldPath != <span class="keyword">null</span> &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldPath = <span class="keyword">new</span> PathInfo&lt;&gt;();</span><br><span class="line">        paths.put(edge.to, oldPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldPath.edgeInfos.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oldPath.weight = newWeight;</span><br><span class="line">    oldPath.edgeInfos.addAll(fromPath.edgeInfos);</span><br><span class="line">    oldPath.edgeInfos.add(edge.info());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra-算法测试"><a href="#Dijkstra-算法测试" class="headerlink" title="Dijkstra - 算法测试"></a>Dijkstra - 算法测试</h3><h4 id="构建有向图"><a href="#构建有向图" class="headerlink" title="构建有向图"></a>构建有向图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;Object, Double&gt; <span class="title">directedGraph</span><span class="params">(Object[][] data)</span> </span>&#123;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = <span class="keyword">new</span> ListGraph&lt;&gt;(weightManager);</span><br><span class="line">    <span class="keyword">for</span> (Object[] edge : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">2</span>) &#123;</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(edge[<span class="number">2</span>].toString());</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无负权值测试"><a href="#无负权值测试" class="headerlink" title="无负权值测试"></a>无负权值测试</h4><p><img src="/2020/07/15/最短路径/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] SP = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">10</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"D"</span>, <span class="number">30</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"E"</span>, <span class="number">100</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">50</span>&#125;, </span><br><span class="line">&#123;<span class="string">"C"</span>, <span class="string">"E"</span>, <span class="number">10</span>&#125;, </span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">20</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"E"</span>, <span class="number">60</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.SP);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra(<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/9.png" alt></p><h4 id="有负权值测试（dijkstra不能有负权边）"><a href="#有负权值测试（dijkstra不能有负权边）" class="headerlink" title="有负权值测试（dijkstra不能有负权边）"></a>有负权值测试（dijkstra不能有负权边）</h4><p><img src="/2020/07/15/最短路径/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT1 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, -<span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"D"</span>, -<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra(<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$dijkstra$ <strong>算法不能有负权边，不然会算错</strong></p><p><img src="/2020/07/15/最短路径/12.png" alt></p><h2 id="Bellman−Ford"><a href="#Bellman−Ford" class="headerlink" title="Bellman−Ford"></a>Bellman−Ford</h2><h3 id="Bellman−Ford-是什么"><a href="#Bellman−Ford-是什么" class="headerlink" title="Bellman−Ford - 是什么"></a>Bellman−Ford - 是什么</h3><p>$Bellman-Ford$ 也属于单源最短路径算法，<strong>支持负权边</strong>，<strong>还能检测出是否有负权环</strong></p><p>算法原理：对所有的边进行 $V – 1$ 次松弛操作（ $V$ 是节点数量），得到所有可能的最短路径</p><p>时间复杂度：$O(EV)$ ，$E$ 是边数量，$V$ 是节点数量</p><p>下图的最好情况是恰好从左到右的顺序对边进行松弛操作</p><p>对所有边仅需进行 $1$ 次松弛操作就能计算出 $A$ 到达其他所有顶点的最短路径</p><p><img src="/2020/07/15/最短路径/13.png" alt></p><p>最坏情况是恰好每次都从右到左的顺序对边进行松弛操作</p><p>对所有边需进行 $V – 1$ 次松弛操作才能计算出 $A$ 到达其他所有顶点的最短路径</p><p><img src="/2020/07/15/最短路径/14.png" alt></p><h3 id="Bellman-Ford-–-实例"><a href="#Bellman-Ford-–-实例" class="headerlink" title="Bellman-Ford – 实例"></a>Bellman-Ford – 实例</h3><p>一共 $8$ 条边</p><p>假设每次松弛操作的顺序是：$DC、DF、BC、ED、EF、BE、AE、AB$</p><p><img src="/2020/07/15/最短路径/15.png" alt></p><p><img src="/2020/07/15/最短路径/16.png" alt></p><p><img src="/2020/07/15/最短路径/17.png" alt></p><p><img src="/2020/07/15/最短路径/18.png" alt></p><p>不难分析出，经过 $4$ 次松弛操作之后，已经计算出了 $A$ 到其他所有顶点的最短路径</p><h3 id="Bellman-Ford-–-代码实现"><a href="#Bellman-Ford-–-代码实现" class="headerlink" title="Bellman-Ford – 代码实现"></a>Bellman-Ford – 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; bellmanFord(V begin) &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化起点权值为0，（A -&gt; A = 0）后续松弛操作才能计算，权值相加和比较不能为null</span></span><br><span class="line">    selectedPaths.put(begin, <span class="keyword">new</span> PathInfo&lt;&gt;(weightManager.zero()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = vertices.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// v - 1 次</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">            PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value);</span><br><span class="line">            <span class="keyword">if</span> (fromPath == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            relax(edge, fromPath, selectedPaths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有环</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">        PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value);</span><br><span class="line">        <span class="keyword">if</span> (fromPath == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (relax(edge, fromPath, selectedPaths)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"有负权环"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selectedPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectedPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 松弛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edge 需要进行松弛的边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromPath edge的from的最短路径信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paths 存放着其他点（对于dijkstra来说，就是还没有离开桌面的点）的最短路径信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">relax</span><span class="params">(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;V, PathInfo&lt;V, E&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新的可选择的最短路径：beginVertex到edge.from的最短路径 + edge.weight</span></span><br><span class="line">    E newWeight = weightManager.add(fromPath.weight, edge.weight);</span><br><span class="line">    <span class="comment">// 以前的最短路径：beginVertex到edge.to的最短路径</span></span><br><span class="line">    PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to.value);</span><br><span class="line">    <span class="keyword">if</span> (oldPath != <span class="keyword">null</span> &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldPath = <span class="keyword">new</span> PathInfo&lt;&gt;();</span><br><span class="line">        paths.put(edge.to.value, oldPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldPath.edgeInfos.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oldPath.weight = newWeight;</span><br><span class="line">    oldPath.edgeInfos.addAll(fromPath.edgeInfos);</span><br><span class="line">    oldPath.edgeInfos.add(edge.info());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford-–-算法测试"><a href="#Bellman-Ford-–-算法测试" class="headerlink" title="Bellman-Ford – 算法测试"></a>Bellman-Ford – 算法测试</h3><h4 id="有负权值测试"><a href="#有负权值测试" class="headerlink" title="有负权值测试"></a>有负权值测试</h4><p><img src="/2020/07/15/最短路径/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT1 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, -<span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"D"</span>, -<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord(<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/19.png" alt></p><h4 id="有负权环测试"><a href="#有负权环测试" class="headerlink" title="有负权环测试"></a>有负权环测试</h4><p><img src="/2020/07/15/最短路径/20.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT2 = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, </span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT2);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/21.png" alt></p><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="Floyd-是什么"><a href="#Floyd-是什么" class="headerlink" title="Floyd - 是什么"></a>Floyd - 是什么</h3><p>$Floyd$ 属于多源最短路径算法，能够求出任意 $2$ 个顶点之间的最短路径，支持负权边</p><p>时间复杂度：$O(V^3)$，效率比执行 $V$ 次 $Dijkstra$ 算法要好（ $V$ 是顶点数量）</p><p>算法原理</p><p>从任意顶点 $i$ 到任意顶点 $j$ 的最短路径不外乎两种可能</p><p>① 直接从 $i$ 到 $j$</p><p>② 从 $i$ 经过若干个顶点到 $j$</p><p>假设 $dist(i，j)$ 为顶点 $i$ 到顶点 $j$ 的最短路径的距离</p><p>对于每一个顶点 $k$，检查 $dist(i，k) + dist(k，j)＜dist(i，j)$ 是否成立</p><p>如果成立，证明从 $i$ 到 $k$ 再到 $j$ 的路径比 $i$ 直接到 $j$ 的路径短，设置 $dist(i，j) = dist(i，k) + dist(k，j)$</p><p>当我们遍历完所有结点 $k$，$dist(i，j)$ 中记录的便是 $i$ 到 $j$ 的最短路径的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist(i,k)) + dist(k,j) &lt; dist(i,j))&#123;</span><br><span class="line">                dist(i,j) = dist(i,k) + dist(k,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd-代码实现"><a href="#Floyd-代码实现" class="headerlink" title="Floyd - 代码实现"></a>Floyd - 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; floyd() &#123;</span><br><span class="line">    Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 把能直接走的路径存放在map</span></span><br><span class="line">        Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(edge.from.value);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            paths.put(edge.from.value, map);</span><br><span class="line">        &#125;</span><br><span class="line">        PathInfo&lt;V, E&gt; pathInfo = <span class="keyword">new</span> PathInfo&lt;&gt;(edge.weight);</span><br><span class="line">        pathInfo.edgeInfos.add(edge.info());</span><br><span class="line">        map.put(edge.to.value, pathInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vertices.forEach((V v2, Vertex&lt;V, E&gt; vertex2) -&gt; &#123;</span><br><span class="line">        vertices.forEach((V v1, Vertex&lt;V, E&gt; vertex1) -&gt; &#123;</span><br><span class="line">            vertices.forEach((V v3, Vertex&lt;V, E&gt; vertex3) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1.equals(v2) || v2.equals(v3) || v1.equals(v3)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v1 -&gt; v2</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path12 = getPathInfo(v1, v2, paths);</span><br><span class="line">                <span class="keyword">if</span> (path12 == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v2 -&gt; v3</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path23 = getPathInfo(v2, v3, paths);</span><br><span class="line">                <span class="keyword">if</span> (path23 == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v1 -&gt; v3 </span></span><br><span class="line">                PathInfo&lt;V, E&gt; path13 = getPathInfo(v1, v3, paths);</span><br><span class="line"></span><br><span class="line">                E newWeight = weightManager.add(path12.weight, path23.weight);</span><br><span class="line">                <span class="keyword">if</span> (path13 != <span class="keyword">null</span> &amp;&amp; weightManager.compare(newWeight, path13.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path13 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    path13 = <span class="keyword">new</span> PathInfo&lt;V, E&gt;();</span><br><span class="line">                    paths.get(v1).put(v3, path13);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    path13.edgeInfos.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                path13.weight = newWeight;</span><br><span class="line">                path13.edgeInfos.addAll(path12.edgeInfos);</span><br><span class="line">                path13.edgeInfos.addAll(path23.edgeInfos);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PathInfo&lt;V, E&gt; <span class="title">getPathInfo</span><span class="params">(V from, V to, Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(from);</span><br><span class="line">    <span class="keyword">return</span> map == <span class="keyword">null</span> ? <span class="keyword">null</span> : map.get(to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd-算法测试"><a href="#Floyd-算法测试" class="headerlink" title="Floyd - 算法测试"></a>Floyd - 算法测试</h3><p><img src="/2020/07/15/最短路径/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT1 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, -<span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"D"</span>, -<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1);</span><br><span class="line">    Map&lt;Object, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt;&gt; sp = graph.shortestPath();</span><br><span class="line">    sp.forEach((Object from, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; paths) -&gt; &#123;</span><br><span class="line">        System.out.println(from + <span class="string">"---------------------"</span>);</span><br><span class="line">        paths.forEach((Object to, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">            System.out.println(to + <span class="string">" - "</span> + path);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/22.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径（Shortest-Path）&quot;&gt;&lt;a href=&quot;#最短路径（Shortest-Path）&quot; class=&quot;headerlink&quot; title=&quot;最短路径（Shortest Path）&quot;&gt;&lt;/a&gt;最短路径（Shortest Path）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
      <category term="迪杰斯特拉算法" scheme="http://yoursite.com/tags/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    
      <category term="Bellman-Ford" scheme="http://yoursite.com/tags/Bellman-Ford/"/>
    
      <category term="Floyd" scheme="http://yoursite.com/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>生成树</title>
    <link href="http://yoursite.com/2020/07/15/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/15/生成树/</id>
    <published>2020-07-15T08:48:41.000Z</published>
    <updated>2020-07-16T04:54:58.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成树（Spanning-Tree）"><a href="#生成树（Spanning-Tree）" class="headerlink" title="生成树（Spanning Tree）"></a>生成树（Spanning Tree）</h1><h2 id="什么是生成树"><a href="#什么是生成树" class="headerlink" title="什么是生成树"></a>什么是生成树</h2><p>生成树 $（ Spanning Tree ）$，也称为支撑树</p><p>连通图的极小连通子图，它含有图中全部的 $n$ 个顶点，恰好只有 $n – 1$ 条边</p><p><img src="/2020/07/15/生成树/1.png" alt></p><h2 id="最小生成树（Minimum-Spanning-Tree）"><a href="#最小生成树（Minimum-Spanning-Tree）" class="headerlink" title="最小生成树（Minimum Spanning Tree）"></a>最小生成树（Minimum Spanning Tree）</h2><p>最小生成树$（Minimum Spanning Tree$，简称$MST）$</p><p>也称为最小权重生成树$（Minimum Weight Spanning Tree）$、最小支撑树</p><p>是所有生成树中，总权值最小的那棵</p><p>适用于<strong>有权的连通图</strong>（无向）</p><p><img src="/2020/07/15/生成树/2.png" alt></p><h3 id="最小生成树的应用"><a href="#最小生成树的应用" class="headerlink" title="最小生成树的应用"></a>最小生成树的应用</h3><p>最小生成树在许多领域都有重要的作用，例如</p><p>要在 $n$ 个城市之间铺设光缆，使它们都可以通信</p><p>铺设光缆的费用很高，且各个城市之间因为距离不同等因素，铺设光缆的费用也不同</p><p>如何使铺设光缆的总费用最低？</p><h3 id="最小生成树的实现算法"><a href="#最小生成树的实现算法" class="headerlink" title="最小生成树的实现算法"></a>最小生成树的实现算法</h3><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个，否则可能会有多个最小生成树</p><p>求最小生成树的 $2$ 个经典算法</p><p>$Prim$（普里姆算法）</p><p>$Kruskal$（克鲁斯克尔算法）</p><h4 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h4><p>切分$（Cut）$：把图中的节点分为两部分，称为一个切分</p><p>下图有个切分 $C = (S, T)，S = \{A, B, D\}，T = \{C, E\}$</p><p><img src="/2020/07/15/生成树/3.png" alt></p><p>横切边$（Crossing Edge）$：如果一个边的两个顶点，分别属于切分的两部分，这个边称为横切边</p><p>比如上图的边 $BC、BE、DE$就是横切边</p><p>切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树</p><h4 id="边和顶点的定义"><a href="#边和顶点的定义" class="headerlink" title="边和顶点的定义"></a>边和顶点的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; inEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; outEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Vertex(V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">"null"</span> : value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; from;</span><br><span class="line">    Vertex&lt;V, E&gt; to;</span><br><span class="line">    E weight;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EdgeInfo&lt;V, E&gt; <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EdgeInfo&lt;&gt;(from.value, to.value, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from.hashCode() * <span class="number">31</span> + to.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="边信息的定义"><a href="#边信息的定义" class="headerlink" title="边信息的定义"></a>边信息的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeInfo</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> V from;</span><br><span class="line">    <span class="keyword">private</span> V to;</span><br><span class="line">    <span class="keyword">private</span> E weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeInfo</span><span class="params">(V from, V to, E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(V from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo</span><span class="params">(V to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"EdgeInfo [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prim算法-–-执行过程"><a href="#Prim算法-–-执行过程" class="headerlink" title="Prim算法 – 执行过程"></a>Prim算法 – 执行过程</h4><p>假设 $G = (V，E)$ 是有权的连通图（无向），$A$ 是 $G$ 中最小生成树的边集</p><p>算法从 $S = \{ u0 \}（u0 ∈ V），A = \{ \} $  开始，重复执行下述操作，直到 $S = V $为止</p><p>找到切分 $C = (S，V – S)$ 的最小横切边 $(u0，v0) $并入集合 $A$，同时将 $v0$ 并入集合 $S$</p><p><img src="/2020/07/15/生成树/4.png" alt></p><p><img src="/2020/07/15/生成树/5.png" alt></p><p><img src="/2020/07/15/生成树/6.png" alt></p><h4 id="Prim算法-–-实现"><a href="#Prim算法-–-实现" class="headerlink" title="Prim算法 – 实现"></a>Prim算法 – 实现</h4><a href="/2020/07/14/二叉堆/" title="MinHeap的实现原理">MinHeap的实现原理</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;EdgeInfo&lt;V, E&gt;&gt; prim() &#123;</span><br><span class="line">    Iterator&lt;Vertex&lt;V, E&gt;&gt; it = vertices.values().iterator();</span><br><span class="line">    <span class="keyword">if</span> (!it.hasNext()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Vertex&lt;V, E&gt; vertex = it.next();</span><br><span class="line">    Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Vertex&lt;V, E&gt;&gt; addedVertices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    addedVertices.add(vertex);</span><br><span class="line">    MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = <span class="keyword">new</span> MinHeap&lt;&gt;(vertex.outEdges, edgeComparator);</span><br><span class="line">    <span class="keyword">int</span> verticesSize = vertices.size();</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; addedVertices.size() &lt; verticesSize) &#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = heap.remove();</span><br><span class="line">        <span class="keyword">if</span> (addedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line">        edgeInfos.add(edge.info());</span><br><span class="line">        addedVertices.add(edge.to);</span><br><span class="line">        heap.addAll(edge.to.outEdges);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edgeInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal算法-–-执行过程"><a href="#Kruskal算法-–-执行过程" class="headerlink" title="Kruskal算法 – 执行过程"></a>Kruskal算法 – 执行过程</h4><p>按照边的权重顺序（从小到大）将边加入生成树中，直到生成树中含有 $V – 1$ 条边为止（ $V$ 是顶点数量）</p><p>若加入该边会与生成树形成环，则不加入该边</p><p>从第 $3$ 条边开始，可能会与生成树形成环</p><p><img src="/2020/07/15/生成树/7.png" alt></p><p><img src="/2020/07/15/生成树/8.png" alt></p><p><img src="/2020/07/15/生成树/9.png" alt></p><h4 id="Kruskal算法-–-实现"><a href="#Kruskal算法-–-实现" class="headerlink" title="Kruskal算法 – 实现"></a>Kruskal算法 – 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;EdgeInfo&lt;V, E&gt;&gt; kruskal() &#123;</span><br><span class="line">    <span class="keyword">int</span> edgeSize = vertices.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (edgeSize == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = <span class="keyword">new</span> MinHeap&lt;&gt;(edges, edgeComparator);</span><br><span class="line">    UnionFind&lt;Vertex&lt;V, E&gt;&gt; uf = <span class="keyword">new</span> UnionFind&lt;&gt;();</span><br><span class="line">    vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123;</span><br><span class="line">        uf.makeSet(vertex);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; edgeInfos.size() &lt; edgeSize) &#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = heap.remove(); </span><br><span class="line">        <span class="keyword">if</span> (uf.isSame(edge.from, edge.to)) <span class="keyword">continue</span>; </span><br><span class="line">        edgeInfos.add(edge.info());</span><br><span class="line">        uf.union(edge.from, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edgeInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(ElogE)$</p><h3 id="算法测试"><a href="#算法测试" class="headerlink" title="算法测试"></a>算法测试</h3><h4 id="构建无向图"><a href="#构建无向图" class="headerlink" title="构建无向图"></a>构建无向图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;Object, Double&gt; <span class="title">undirectedGraph</span><span class="params">(Object[][] data)</span> </span>&#123;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = <span class="keyword">new</span> ListGraph&lt;&gt;(weightManager);</span><br><span class="line">    <span class="keyword">for</span> (Object[] edge : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">2</span>) &#123;</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            graph.addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(edge[<span class="number">2</span>].toString());</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], weight);</span><br><span class="line">            graph.addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建有向图"><a href="#构建有向图" class="headerlink" title="构建有向图"></a>构建有向图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;Object, Double&gt; <span class="title">directedGraph</span><span class="params">(Object[][] data)</span> </span>&#123;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = <span class="keyword">new</span> ListGraph&lt;&gt;(weightManager);</span><br><span class="line">    <span class="keyword">for</span> (Object[] edge : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">2</span>) &#123;</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(edge[<span class="number">2</span>].toString());</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试无向图"><a href="#测试无向图" class="headerlink" title="测试无向图"></a>测试无向图</h4><p><img src="/2020/07/15/生成树/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] MST_01 = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_01);</span><br><span class="line">    <span class="comment">// Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim();</span></span><br><span class="line">    Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal();</span><br><span class="line">    <span class="keyword">for</span> (EdgeInfo&lt;Object, Double&gt; info : infos) &#123;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/生成树/12.png" alt></p><h4 id="测试有向图"><a href="#测试有向图" class="headerlink" title="测试有向图"></a>测试有向图</h4><p><img src="/2020/07/15/生成树/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] MST_02 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">17</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"F"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"E"</span>, <span class="number">16</span>&#125;,</span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">6</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">5</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"F"</span>, <span class="number">11</span>&#125;,</span><br><span class="line">&#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">10</span>&#125;, </span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"E"</span>, <span class="number">4</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"F"</span>, <span class="number">14</span>&#125;,</span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"F"</span>, <span class="number">33</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_02);</span><br><span class="line">    Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim();</span><br><span class="line">    <span class="comment">// Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal();</span></span><br><span class="line">    <span class="keyword">for</span> (EdgeInfo&lt;Object, Double&gt; info : infos) &#123;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/生成树/13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生成树（Spanning-Tree）&quot;&gt;&lt;a href=&quot;#生成树（Spanning-Tree）&quot; class=&quot;headerlink&quot; title=&quot;生成树（Spanning Tree）&quot;&gt;&lt;/a&gt;生成树（Spanning Tree）&lt;/h1&gt;&lt;h2 id=&quot;什
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="Prim" scheme="http://yoursite.com/tags/Prim/"/>
    
      <category term="Kruskal" scheme="http://yoursite.com/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>AOV网</title>
    <link href="http://yoursite.com/2020/07/15/AOV%E7%BD%91/"/>
    <id>http://yoursite.com/2020/07/15/AOV网/</id>
    <published>2020-07-15T08:45:45.000Z</published>
    <updated>2020-07-15T08:47:16.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOV网（Activity-On-Vertex-Network）"><a href="#AOV网（Activity-On-Vertex-Network）" class="headerlink" title="AOV网（Activity On Vertex Network）"></a>AOV网（Activity On Vertex Network）</h2><p>一项大的工程常被分为多个小的子工程</p><p>子工程之间可能存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始</p><p>在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，子工程被称为活动$（Activity）$</p><p>以顶点表示活动、有向边表示活动之间的先后关系，这样的图简称为 $AOV$ 网</p><p>标准的 $AOV$网必须是一个有向无环图$（Directed Acyclic Graph$，简称 $DAG$）</p><p><img src="/2020/07/15/AOV网/1.png" alt></p><p><strong>B依赖于A；C依赖于B；D依赖于B；E依赖于B、C、D；F依赖于E</strong></p><h3 id="拓扑排序（Topological-Sort）"><a href="#拓扑排序（Topological-Sort）" class="headerlink" title="拓扑排序（Topological Sort）"></a>拓扑排序（Topological Sort）</h3><p>前驱活动：有向边起点的活动称为终点的前驱活动</p><p>只有当一个活动的前驱全部都完成后，这个活动才能进行</p><p>后继活动：有向边终点的活动称为起点的后继活动</p><p>将 AOV 网中所有活动排成一个序列，使得每个活动的前驱活动都排在该活动的前面</p><p>比如上图的拓扑排序结果是：A、B、C、D、E、F 或者 A、B、D、C、E、F （结果并不一定是唯一的）</p><h3 id="拓扑排序-–-思路"><a href="#拓扑排序-–-思路" class="headerlink" title="拓扑排序 – 思路"></a>拓扑排序 – 思路</h3><p>可以使用卡恩算法（Kahn于1962年提出）完成拓扑排序</p><p>假设 L 是存放拓扑排序结果的列表</p><p>① 把所有入度为 0 的顶点放入 L 中，然后把这些顶点从图中去掉</p><p>② 重复操作 ①，直到找不到入度为 0 的顶点</p><p>如果此时 L 中的元素个数和顶点总数相同，说明拓扑排序完成</p><p>如果此时 L 中的元素个数少于顶点总数，说明原图中存在环，无法进行拓扑排序</p><p><img src="/2020/07/15/AOV网/2.png" alt></p><h3 id="拓扑排序-–-实现"><a href="#拓扑排序-–-实现" class="headerlink" title="拓扑排序 – 实现"></a>拓扑排序 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;V&gt; <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;V&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;Vertex&lt;V, E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, Integer&gt; ins = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化（将度为0的节点都放入队列）</span></span><br><span class="line">    vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> in = vertex.inEdges.size();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.offer(vertex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ins.put(vertex, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Vertex&lt;V, E&gt; vertex = queue.poll();</span><br><span class="line">        <span class="comment">// 放入返回结果中</span></span><br><span class="line">        list.add(vertex.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">            <span class="keyword">int</span> toIn = ins.get(edge.to) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (toIn == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(edge.to);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ins.put(edge.to, toIn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AOV网（Activity-On-Vertex-Network）&quot;&gt;&lt;a href=&quot;#AOV网（Activity-On-Vertex-Network）&quot; class=&quot;headerlink&quot; title=&quot;AOV网（Activity On Vertex Netw
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2020/07/15/%E5%9B%BE/"/>
    <id>http://yoursite.com/2020/07/15/图/</id>
    <published>2020-07-15T07:52:11.000Z</published>
    <updated>2020-07-16T04:10:28.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h1><h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><p>图由顶点$（vertex）$和边$（edge）$组成，通常表示为 $G = (V, E)$</p><p>$G$ 表示一个图，$V$ 是顶点集，$E$ 是边集</p><p>顶点集 $V$ 有穷且非空</p><p>任意两个顶点之间都可以用边来表示它们之间的关系，边集 $E$ 可以是空的</p><h2 id="有向图（Directed-Graph）"><a href="#有向图（Directed-Graph）" class="headerlink" title="有向图（Directed Graph）"></a>有向图（Directed Graph）</h2><p>有向图的边是有明确方向的</p><p><img src="/2020/07/15/图/1.png" alt></p><p>有向无环图（Directed Acyclic Graph，简称 DAG）</p><p>如果一个有向图，从任意顶点出发无法经过若干条边回到该顶点，那么它就是一个有向无环图</p><p><img src="/2020/07/15/图/2.png" alt></p><h3 id="出度、入度"><a href="#出度、入度" class="headerlink" title="出度、入度"></a>出度、入度</h3><p>出度、入度适用于有向图</p><p><strong>出度$（Out-degree）$</strong></p><p>一个顶点的出度为 $x$，是指有 $x$ 条边以该顶点为起点</p><p>顶点 $11$ 的出度是 $3$</p><p><strong>入度$（In-degree）$</strong></p><p>一个顶点的入度为 $x$，是指有 $x$ 条边以该顶点为终点</p><p>顶点 $11$ 的入度是 $2$</p><p><img src="/2020/07/15/图/3.png" alt></p><h2 id="无向图（Undirected-Graph）"><a href="#无向图（Undirected-Graph）" class="headerlink" title="无向图（Undirected Graph）"></a>无向图（Undirected Graph）</h2><p>无向图的边是无方向的，效果类似于下面的有向图</p><p><img src="/2020/07/15/图/4.png" alt></p><h2 id="混合图（Mixed-Graph）"><a href="#混合图（Mixed-Graph）" class="headerlink" title="混合图（Mixed Graph）"></a>混合图（Mixed Graph）</h2><p>混合图的边可能是无向的，也可能是有向的</p><p><img src="/2020/07/15/图/5.png" alt></p><h2 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h2><p><strong>平行边</strong></p><p>在无向图中，关联一对顶点的无向边如果多于 $1$ 条，则称这些边为平行边</p><p>在有向图中，关联一对顶点的有向边如果多于 $1$ 条，并且它们的的方向相同，则称这些边为平行边</p><p><strong>多重图（Multigraph）</strong></p><p>有平行边或者有自环的图</p><p><strong>简单图（Simple Graph）</strong></p><p>既没有平行边也不没有自环的图</p><p><img src="/2020/07/15/图/6.png" alt></p><h2 id="无向完全图（Undirected-Complete-Graph）"><a href="#无向完全图（Undirected-Complete-Graph）" class="headerlink" title="无向完全图（Undirected Complete Graph）"></a>无向完全图（Undirected Complete Graph）</h2><p>无向完全图的任意两个顶点之间都存在边</p><p>$n$ 个顶点的无向完全图有 $n(n − 1)/2$ 条边</p><p>$n − 1 + n − 2 + n − 3 + ⋯ + 3 + 2 + 1$</p><p><img src="/2020/07/15/图/7.png" alt></p><h2 id="有向完全图（Directed-Complete-Graph）"><a href="#有向完全图（Directed-Complete-Graph）" class="headerlink" title="有向完全图（Directed Complete Graph）"></a>有向完全图（Directed Complete Graph）</h2><p>有向完全图的任意两个顶点之间都存在方向相反的两条边</p><p>$n$ 个顶点的有向完全图有 $n(n − 1)$ 条边</p><p><img src="/2020/07/15/图/8.png" alt></p><p>稠密图（Dense Graph）：边数接近于或等于完全图</p><p>稀疏图（Sparse Graph）：边数远远少于完全图</p><h2 id="有权图（Weighted-Graph）"><a href="#有权图（Weighted-Graph）" class="headerlink" title="有权图（Weighted Graph）"></a>有权图（Weighted Graph）</h2><p>有权图的边可以拥有权值$（Weight）$</p><p><img src="/2020/07/15/图/9.png" alt></p><h2 id="连通图（Connected-Graph）"><a href="#连通图（Connected-Graph）" class="headerlink" title="连通图（Connected Graph）"></a>连通图（Connected Graph）</h2><p>如果顶点 $x$ 和 $y$ 之间存在可相互抵达的路径（直接或间接的路径），则称 $x$ 和 $y$ 是连通的</p><p>如果无向图 $G$ 中任意 $2$ 个顶点都是连通的，则称 $G$ 为连通图</p><h3 id="连通分量（Connected-Component）"><a href="#连通分量（Connected-Component）" class="headerlink" title="连通分量（Connected Component）"></a>连通分量（Connected Component）</h3><p>连通分量：无向图的极大连通子图</p><p>连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量</p><p>下面的无向图有 $3$ 个连通分量</p><p><img src="/2020/07/15/图/10.png" alt></p><h2 id="强连通图（Strongly-Connected-Graph）"><a href="#强连通图（Strongly-Connected-Graph）" class="headerlink" title="强连通图（Strongly Connected Graph）"></a>强连通图（Strongly Connected Graph）</h2><p>如果有向图 $G$ 中任意 $2$ 个顶点都是连通的，则称 $G$ 为强连通图</p><p><img src="/2020/07/15/图/11.png" alt></p><h3 id="强连通分量（Strongly-Connected-Component）"><a href="#强连通分量（Strongly-Connected-Component）" class="headerlink" title="强连通分量（Strongly Connected Component）"></a>强连通分量（Strongly Connected Component）</h3><p>强连通分量：有向图的极大强连通子图</p><p>强连通图只有一个强连通分量，即其自身；非强连通的有向图有多个强连通分量</p><p><img src="/2020/07/15/图/12.png" alt></p><h2 id="图的实现方案"><a href="#图的实现方案" class="headerlink" title="图的实现方案"></a>图的实现方案</h2><p>图有2种常见的实现方案</p><ol><li><p><strong>邻接矩阵（Adjacency Matrix）</strong></p></li><li><p><strong>邻接表（Adjacency List）</strong></p></li></ol><h3 id="邻接矩阵（Adjacency-Matrix）"><a href="#邻接矩阵（Adjacency-Matrix）" class="headerlink" title="邻接矩阵（Adjacency Matrix）"></a>邻接矩阵（Adjacency Matrix）</h3><ol><li><p>邻接矩阵的存储方式</p><p>一维数组存放顶点信息</p><p>二维数组存放边信息</p></li><li><p>邻接矩阵比较适合稠密图</p><p>不然会比较浪费内存</p></li></ol><p><img src="/2020/07/15/图/13.png" alt></p><h4 id="邻接矩阵-–-有权图"><a href="#邻接矩阵-–-有权图" class="headerlink" title="邻接矩阵 – 有权图"></a>邻接矩阵 – 有权图</h4><p><img src="/2020/07/15/图/14.png" alt></p><h3 id="邻接表（Adjacency-List）"><a href="#邻接表（Adjacency-List）" class="headerlink" title="邻接表（Adjacency List）"></a>邻接表（Adjacency List）</h3><p><img src="/2020/07/15/图/15.png" alt></p><h4 id="邻接表-–-有权图"><a href="#邻接表-–-有权图" class="headerlink" title="邻接表 – 有权图"></a>邻接表 – 有权图</h4><p><img src="/2020/07/15/图/16.png" alt></p><h2 id="图的基础接口"><a href="#图的基础接口" class="headerlink" title="图的基础接口"></a>图的基础接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">edgesSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 顶点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">verticesSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加、删除顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(V v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeVertex</span><span class="params">(V v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(V from, V to)</span></span>;</span><br><span class="line"><span class="comment">// 添加有权边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(V from, V to, E weight)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(V from, V to)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="顶点的定义"><a href="#顶点的定义" class="headerlink" title="顶点的定义"></a>顶点的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; inEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; outEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Vertex(V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">"null"</span> : value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="边的定义"><a href="#边的定义" class="headerlink" title="边的定义"></a>边的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; from;</span><br><span class="line">    Vertex&lt;V, E&gt; to;</span><br><span class="line">    E weight;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from.hashCode() * <span class="number">31</span> + to.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某一顶点出发访问图中其余顶点，且每一个顶点仅被访问一次</p><p>图有 $2$ 种常见的遍历方式（有向图、无向图都适用）</p><ol><li><p>广度优先搜索$（Breadth First Search，BFS）$，又称为宽度优先搜索、横向优先搜索</p></li><li><p>深度优先搜索$（Depth First Search，DFS）$</p></li></ol><p>发明“深度优先搜索”算法的 $2$ 位科学家在 $1986$年共同获得计算机领域的最高奖：图灵奖</p><h3 id="广度优先搜索（Breadth-First-Search）"><a href="#广度优先搜索（Breadth-First-Search）" class="headerlink" title="广度优先搜索（Breadth First Search）"></a>广度优先搜索（Breadth First Search）</h3><p>二叉树层序遍历也是一种广度优先搜索</p><p><img src="/2020/07/15/图/17.png" alt></p><p><img src="/2020/07/15/图/18.png" alt></p><h4 id="广度优先搜索-–-思路"><a href="#广度优先搜索-–-思路" class="headerlink" title="广度优先搜索 – 思路"></a>广度优先搜索 – 思路</h4><p><img src="/2020/07/15/图/19.png" alt></p><h4 id="广度优先搜索-–-实现"><a href="#广度优先搜索-–-实现" class="headerlink" title="广度优先搜索 – 实现"></a>广度优先搜索 – 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(&lt;Vertex&lt;V, E&gt;&gt; beginVertex)</span> </span>&#123;</span><br><span class="line">    Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;Vertex&lt;V, E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(beginVertex);</span><br><span class="line">    visitedVertices.add(beginVertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Vertex&lt;V, E&gt; vertex = queue.poll();</span><br><span class="line">        System.out.println(vertex.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visitedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line">            queue.offer(edge.to);</span><br><span class="line">            visitedVertices.add(edge.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth First Search）"></a>深度优先搜索（Depth First Search）</h3><p>二叉树前序遍历也是一种深度优先搜索</p><p><img src="/2020/07/15/图/20.png" alt></p><p><img src="/2020/07/15/图/21.png" alt></p><h4 id="深度优先搜索-–-递归实现"><a href="#深度优先搜索-–-递归实现" class="headerlink" title="深度优先搜索 – 递归实现"></a>深度优先搜索 – 递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(V begin)</span> </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(beginVertex, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Vertex&lt;V, E&gt; vertex, Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices)</span> </span>&#123;</span><br><span class="line">    System.out.println(vertex.value);</span><br><span class="line">    visitedVertices.add(vertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visitedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(edge.to, visitedVertices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先搜索-–-非递归实现"><a href="#深度优先搜索-–-非递归实现" class="headerlink" title="深度优先搜索 – 非递归实现"></a>深度优先搜索 – 非递归实现</h4><p><img src="/2020/07/15/图/22.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Vertex&lt;V, E&gt; beginVertex)</span> </span>&#123;</span><br><span class="line">    Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Stack&lt;Vertex&lt;V, E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先访问起点</span></span><br><span class="line">    stack.push(beginVertex);</span><br><span class="line">    visitedVertices.add(beginVertex);</span><br><span class="line">    System.out.println(beginVertex.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Vertex&lt;V, E&gt; vertex = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visitedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            stack.push(edge.from);</span><br><span class="line">            stack.push(edge.to);</span><br><span class="line">            visitedVertices.add(edge.to);</span><br><span class="line">            System.out.println(edge.to.value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图（Graph）&quot;&gt;&lt;a href=&quot;#图（Graph）&quot; class=&quot;headerlink&quot; title=&quot;图（Graph）&quot;&gt;&lt;/a&gt;图（Graph）&lt;/h1&gt;&lt;h2 id=&quot;什么是图&quot;&gt;&lt;a href=&quot;#什么是图&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2020/07/15/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/07/15/并查集/</id>
    <published>2020-07-15T06:51:30.000Z</published>
    <updated>2020-07-15T07:48:22.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集（Union-Find）"><a href="#并查集（Union-Find）" class="headerlink" title="并查集（Union Find）"></a>并查集（Union Find）</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>假设有n个村庄，有些村庄之间有连接的路，有些村庄之间并没有连接的路</p><p><img src="/2020/07/15/并查集/1.png" alt></p><p>设计一个数据结构，能够快速执行2个操作</p><ol><li><p>查询2个村庄之间是否有连接的路</p></li><li><p>连接2个村庄</p></li></ol><p>数组、链表、平衡二叉树、集合（Set）？</p><p>查询、连接的时间复杂度都是：$O(n)$</p><p><strong>并查集能够办到查询、连接的均摊时间复杂度都是 $O(α(n)),α(n) &lt; 5$</strong></p><p><strong>并查集非常适合解决这类“连接”相关的问题</strong></p><h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><p>并查集也叫作不相交集合（Disjoint Set）</p><p>并查集有2个核心操作</p><p><strong>查找$（Find）$：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是指广义的数据集合）</strong></p><p><strong>合并$（Union）$：将两个元素所在的集合合并为一个集合</strong></p><p>有2种常见的实现思路</p><ol><li><p>$Quick Find$</p><p>查找$（Find）$的时间复杂度：$O(1)$</p><p>合并$（Union）$的时间复杂度：$O(n)$</p></li><li><p>$Quick Union$</p><p>查找$（Find）$的时间复杂度：$O(logn)$，可以优化至 $O(α(n)),α(n) &lt; 5$</p><p>合并$（Union）$的时间复杂度：$O(logn)$，可以优化至 $O(α(n)),α(n) &lt; 5$</p></li></ol><h2 id="如何存储数据？"><a href="#如何存储数据？" class="headerlink" title="如何存储数据？"></a>如何存储数据？</h2><p>假设并查集处理的数据都是整型，那么可以用整型数组来存储数据</p><p><img src="/2020/07/15/并查集/2.png" alt></p><p><strong>不难看出</strong></p><p><strong>$0、1、3$ 属于同一集合</strong></p><p><strong>$2$ 单独属于一个集合</strong></p><p><strong>$4、5、6、7$ 属于同一集合</strong></p><p>因此，并查集是可以用数组实现的树形结构（二叉堆、优先级队列也是可以用数组实现的树形结构）</p><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找v所属的集合（根节点）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并v1、v2所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查v1、v2是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(v1) == find(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化时，每个元素各自属于一个单元素集合</p><p><img src="/2020/07/15/并查集/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span>[] parents;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"capacity must be &gt;= 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parents = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">        parents[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><h3 id="Quick-Find-–-Union"><a href="#Quick-Find-–-Union" class="headerlink" title="Quick Find – Union"></a>Quick Find – Union</h3><p>$Quick Find$ 的 $union(v1, v2)$：让 $v1$ 所在集合的所有元素都指向 $v2$ 的根节点</p><p><img src="/2020/07/15/并查集/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v1所在集合的所有元素，都嫁接到v2的父节点上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == p1) &#123;</span><br><span class="line">            parents[i] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$</p><h3 id="Quick-Find-–-Find"><a href="#Quick-Find-–-Find" class="headerlink" title="Quick Find – Find"></a>Quick Find – Find</h3><p><img src="/2020/07/15/并查集/5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父节点就是根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">return</span> parents[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find(0) == 2$ | $find(1) == 2$ | $find(3) == 4$ | $find(2) == 2$</p><p>时间复杂度：$O(1)$</p><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><h3 id="Quick-Union-–-Union"><a href="#Quick-Union-–-Union" class="headerlink" title="Quick Union – Union"></a>Quick Union – Union</h3><p>$Quick Union$ 的 $union(v1, v2)$：让 $v1$ 的根节点指向 $v2$ 的根节点</p><p><img src="/2020/07/15/并查集/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v1的根节点嫁接到v2的根节点上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line">    parents[p1] = p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(logn)$</p><h3 id="Quick-Union-–-Find"><a href="#Quick-Union-–-Find" class="headerlink" title="Quick Union – Find"></a>Quick Union – Find</h3><p><img src="/2020/07/15/并查集/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过parent链条不断地向上找，直到找到根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">        v = parents[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find(0) == 2$ | $find(1) == 2$ | $find(3) == 2$ | $find(2) == 2$</p><p>时间复杂度：$O(logn)$</p><h2 id="Quick-Union-–-优化"><a href="#Quick-Union-–-优化" class="headerlink" title="Quick Union – 优化"></a>Quick Union – 优化</h2><p>在 $Union$ 的过程中，可能会出现树不平衡的情况，甚至退化成链表</p><p><img src="/2020/07/15/并查集/8.png" alt></p><p>有2种常见的优化方案</p><ol><li><p>基于 $size$ 的优化：<strong>元素少的树嫁接到元素多的树</strong></p></li><li><p>基于 $rank$ 的优化：<strong>矮的树嫁接到高的树</strong></p></li></ol><h3 id="Quick-Union-–-基于size的优化"><a href="#Quick-Union-–-基于size的优化" class="headerlink" title="Quick Union – 基于size的优化"></a>Quick Union – 基于size的优化</h3><p><img src="/2020/07/15/并查集/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizes.length; i++) &#123;</span><br><span class="line">    sizes[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sizes[p1] &lt; sizes[p2]) &#123;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">        sizes[p2] += sizes[p1];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parents[p2] = p1;</span><br><span class="line">        sizes[p1] += sizes[p2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 $size$ 的优化，也可能会存在树不平衡的问题</p><p><img src="/2020/07/15/并查集/10.png" alt></p><h3 id="Quick-Union-–-基于rank的优化"><a href="#Quick-Union-–-基于rank的优化" class="headerlink" title="Quick Union – 基于rank的优化"></a>Quick Union – 基于rank的优化</h3><p><img src="/2020/07/15/并查集/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ranks = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">Arrays.fill(ranks, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranks[p1] &lt; ranks[p2]) &#123;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[p1] &gt; ranks[p2]) &#123;</span><br><span class="line">        parents[p2] = p1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">        ranks[p2]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径压缩（Path-Compression）"><a href="#路径压缩（Path-Compression）" class="headerlink" title="路径压缩（Path Compression）"></a>路径压缩（Path Compression）</h3><p>虽然有了基于 $rank$ 的优化，树会相对平衡一点</p><p>但是随着 $Union$次数的增多，树的高度依然会越来越高</p><p>导致 $find$ 操作变慢，尤其是底层节点（因为 $find$ 是不断向上找到根节点)</p><p>什么是路径压缩？</p><p>在 $find$ 时使路径上的所有节点都指向根节点，从而降低树的高度</p><p><img src="/2020/07/15/并查集/12.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// v == 1, parents[v] == 2</span></span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">if</span> (parents[v] != v) &#123;</span><br><span class="line">        parents[v] = find(parents[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parents[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩使路径上的所有节点都指向根节点，所以实现成本稍高</p><p>还有 $2$ 种更优的做法，不但能降低树高，实现成本也比路径压缩低</p><p>路径分裂$（Path Spliting）$</p><p>路径减半$（Path Halving）$</p><p>路径分裂、路径减半的效率差不多，但都比路径压缩要好</p><h4 id="路径分裂（Path-Spliting）"><a href="#路径分裂（Path-Spliting）" class="headerlink" title="路径分裂（Path Spliting）"></a>路径分裂（Path Spliting）</h4><p>路径分裂：使路径上的每个节点都指向其祖父节点$（parent$ 的 $parent）$</p><p><img src="/2020/07/15/并查集/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = parents[v];</span><br><span class="line">        parents[v] = parents[parents[v]];</span><br><span class="line">        v = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径减半（Path-Halving）"><a href="#路径减半（Path-Halving）" class="headerlink" title="路径减半（Path Halving）"></a>路径减半（Path Halving）</h4><p>路径减半：使路径上每隔一个节点就指向其祖父节点$（parent$ 的 $parent）$</p><p><img src="/2020/07/15/并查集/14.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">        parents[v] = parents[parents[v]];</span><br><span class="line">        v = parents[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity" target="_blank" rel="noopener">摘自《维基百科》</a></p><p><img src="/2020/07/15/并查集/15.png" alt></p><p>大概意思是</p><p>使用路径压缩、分裂或减半 + 基于 $rank$ 或者 $size$ 的优化</p><p>可以确保每个操作的均摊时间复杂度为 $O(𝛼(𝑛)),α(𝑛) &lt; 5$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集（Union-Find）&quot;&gt;&lt;a href=&quot;#并查集（Union-Find）&quot; class=&quot;headerlink&quot; title=&quot;并查集（Union Find）&quot;&gt;&lt;/a&gt;并查集（Union Find）&lt;/h1&gt;&lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>休眠排序</title>
    <link href="http://yoursite.com/2020/07/15/%E4%BC%91%E7%9C%A0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/休眠排序/</id>
    <published>2020-07-15T06:34:20.000Z</published>
    <updated>2020-07-15T06:35:10.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="史上“最强”排序-–-休眠排序"><a href="#史上“最强”排序-–-休眠排序" class="headerlink" title="史上“最强”排序 – 休眠排序"></a>史上“最强”排序 – 休眠排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepSort</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(value);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">60</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array) &#123;</span><br><span class="line">            <span class="keyword">new</span> SleepSort(item).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;史上“最强”排序-–-休眠排序&quot;&gt;&lt;a href=&quot;#史上“最强”排序-–-休眠排序&quot; class=&quot;headerlink&quot; title=&quot;史上“最强”排序 – 休眠排序&quot;&gt;&lt;/a&gt;史上“最强”排序 – 休眠排序&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="http://yoursite.com/2020/07/15/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/桶排序/</id>
    <published>2020-07-15T06:00:39.000Z</published>
    <updated>2020-07-15T06:33:20.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><h2 id="什么是桶排序"><a href="#什么是桶排序" class="headerlink" title="什么是桶排序"></a>什么是桶排序</h2><p>执行流程</p><p>① 创建一定数量的桶（比如用数组、链表作为桶）</p><p>② 按照一定的规则（不同类型的数据，规则不同），将序列中的元素均匀分配到对应的桶</p><p>③ 分别对每个桶进行单独排序</p><p>④ 将所有非空桶的元素合并成有序序列</p><p>元素在桶中的索引</p><p>元素值 * 元素数量</p><p><img src="/2020/07/15/桶排序/1.png" alt></p><h2 id="桶排序-–-实现"><a href="#桶排序-–-实现" class="headerlink" title="桶排序 – 实现"></a>桶排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] array = &#123;<span class="number">0.34</span>,<span class="number">0.47</span>,<span class="number">0.29</span>,<span class="number">0.84</span>,<span class="number">0.45</span>,<span class="number">0.38</span>,<span class="number">0.35</span>,<span class="number">0.76</span>&#125;;</span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line">List&lt;Double&gt;[] buckets = <span class="keyword">new</span> List[array.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> v : array) &#123;</span><br><span class="line">    <span class="keyword">int</span> bucketIndex = (<span class="keyword">int</span>) (v * array.length);</span><br><span class="line">    List&lt;Double&gt; bucket = buckets[bucketIndex];</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bucket = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        buckets[bucketIndex] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket.add(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每个桶进行排序</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (List&lt;Double&gt; bucket : buckets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    bucket.sort(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (Double d : bucket) &#123;</span><br><span class="line">        array[index++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n + m)$，$m$ 是桶的数量</p><p>时间复杂度：$O(n) + m ∗ O( \frac{n} {m} ∗ log\frac{n}{m}) = O(n + n ∗ log\frac{n}{m}) = O(n + n ∗ logn − n ∗ logm)$</p><p>因 此 为 $O(n + k)$ ，$k$ 为 $n ∗ logn − n ∗ logm$</p><p>属于稳定排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序（Bucket-Sort）&quot;&gt;&lt;a href=&quot;#桶排序（Bucket-Sort）&quot; class=&quot;headerlink&quot; title=&quot;桶排序（Bucket Sort）&quot;&gt;&lt;/a&gt;桶排序（Bucket Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是桶排序&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://yoursite.com/2020/07/15/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/基数排序/</id>
    <published>2020-07-15T06:00:22.000Z</published>
    <updated>2020-07-15T06:21:11.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="什么是基数排序"><a href="#什么是基数排序" class="headerlink" title="什么是基数排序"></a>什么是基数排序</h2><p>基数排序非常适合用于整数排序（尤其是非负整数），因此本课程只演示对非负整数进行基数排序</p><p>执行流程：依次对个位数、十位数、百位数、千位数、万位数…进行排序（从低位到高位）</p><p><img src="/2020/07/15/基数排序/1.png" alt></p><p>个位数、十位数、百位数的取值范围都是固定的 $0$ ~ $9$，可以使用计数排序对它们进行排序</p><p><strong>如果先对高位排序，再对低位排序，是不可行的</strong></p><h2 id="基数排序-–-实现"><a href="#基数排序-–-实现" class="headerlink" title="基数排序 – 实现"></a>基数排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 个位数: array[i] / 1 % 10 = 3</span></span><br><span class="line">    <span class="comment">// 十位数：array[i] / 10 % 10 = 9</span></span><br><span class="line">    <span class="comment">// 百位数：array[i] / 100 % 10 = 5</span></span><br><span class="line">    <span class="comment">// 千位数：array[i] / 1000 % 10 = ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> divider = <span class="number">1</span>; divider &lt;= max; divider *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(divider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> divider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer / divider % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累加次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newArray[--counts[array[i] / divider % <span class="number">10</span>]] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">        array[i] = newArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好、最坏、平均时间复杂度：$O(d ∗ (n + k))$ ，$d$ 是最大值的位数，$k$ 是进制。属于稳定排序</p><p>空间复杂度：$O(n + k)$，$k$ 是进制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基数排序（Radix-Sort）&quot;&gt;&lt;a href=&quot;#基数排序（Radix-Sort）&quot; class=&quot;headerlink&quot; title=&quot;基数排序（Radix Sort）&quot;&gt;&lt;/a&gt;基数排序（Radix Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是基数排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/计数排序/</id>
    <published>2020-07-15T06:00:02.000Z</published>
    <updated>2020-07-15T06:16:25.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p>冒泡、选择、插入、归并、快速、希尔、堆排序，都是基于比较的排序</p><p>平均时间复杂度目前最低是 $O(nlogn)$ </p><p>计数排序、桶排序、基数排序，都不是基于比较的排序</p><p>它们是典型的用空间换时间，在某些时候，平均时间复杂度可以比 $O(nlogn)$ 更低</p><h2 id="什么是计数排序"><a href="#什么是计数排序" class="headerlink" title="什么是计数排序"></a>什么是计数排序</h2><p>计数排序于1954年由Harold H. Seward提出，适合对一定范围内的整数进行排序</p><p>计数排序的核心思想：</p><p><strong>统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引</strong></p><h2 id="计数排序-–-最简单的实现"><a href="#计数排序-–-最简单的实现" class="headerlink" title="计数排序 – 最简单的实现"></a>计数排序 – 最简单的实现</h2><p><img src="/2020/07/15/计数排序/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间，存储每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> + max];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer]++;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据整数的出现次数，对整数进行排序</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的实现存在以下问题</p><ul><li><p><strong>无法对负整数进行排序</strong></p></li><li><p><strong>极其浪费内存空间</strong></p></li><li><p><strong>是个不稳定的排序</strong></p></li></ul><h2 id="计数排序-–-改进思路"><a href="#计数排序-–-改进思路" class="headerlink" title="计数排序 – 改进思路"></a>计数排序 – 改进思路</h2><p>假设 $array$ 中的最小值是 $min$</p><p>$array$ 中的元素 $k$ 对应的 $counts$ 索引是 $k – min$</p><p>$array$ 中的元素 $k$ 在有序序列中的索引</p><p>$counts[k – min] – p$</p><p>$p$ 代表着是倒数第几个 $k$</p><p><img src="/2020/07/15/计数排序/2.png" alt></p><p><img src="/2020/07/15/计数排序/3.png" alt></p><p><img src="/2020/07/15/计数排序/4.png" alt></p><p><img src="/2020/07/15/计数排序/5.png" alt></p><p><img src="/2020/07/15/计数排序/6.png" alt></p><h2 id="计数排序-–-改进实现"><a href="#计数排序-–-改进实现" class="headerlink" title="计数排序 – 改进实现"></a>计数排序 – 改进实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累加次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newArray[--counts[array[i] - min]] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">        array[i] = newArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好、最坏、平均时间复杂度：$O(n + k)$</strong></p><p><strong>空间复杂度：$O(n + k)$</strong></p><p><strong>$k$ 是整数的取值范围</strong></p><p><strong>属于稳定排序</strong></p><h2 id="计数排序-–-对自定义对象进行排序"><a href="#计数排序-–-对自定义对象进行排序" class="headerlink" title="计数排序 – 对自定义对象进行排序"></a>计数排序 – 对自定义对象进行排序</h2><p>如果自定义对象可以提供用以排序的整数类型，依然可以使用计数排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [age="</span> + age </span><br><span class="line">            + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person[] persons = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">"A"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(-<span class="number">13</span>, <span class="string">"B"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">17</span>, <span class="string">"C"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">"D"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(-<span class="number">13</span>, <span class="string">"E"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">"F"</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最值</span></span><br><span class="line"><span class="keyword">int</span> max = persons[<span class="number">0</span>].age;</span><br><span class="line"><span class="keyword">int</span> min = persons[<span class="number">0</span>].age;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (persons[i].age &gt; max) &#123;</span><br><span class="line">        max = persons[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (persons[i].age &lt; min) &#123;</span><br><span class="line">        min = persons[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    counts[person.age - min]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 累加次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">    counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">Person[] newArray = <span class="keyword">new</span> Person[persons.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = persons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    newArray[--counts[persons[i].age - min]] = persons[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">System.arraycopy(newArray, <span class="number">0</span>, persons, <span class="number">0</span>, newArray.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序之后的结果</p><p>① $Person [age=-13, name=B]$</p><p>② $Person [age=-13, name=E]$</p><p>③ $Person [age=12, name=D]$</p><p>④ $Person [age=17, name=C]$</p><p>⑤ $Person [age=20, name=A]$</p><p>⑥ $Person [age=20, name=F]$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数排序（Counting-Sort）&quot;&gt;&lt;a href=&quot;#计数排序（Counting-Sort）&quot; class=&quot;headerlink&quot; title=&quot;计数排序（Counting Sort）&quot;&gt;&lt;/a&gt;计数排序（Counting Sort）&lt;/h1&gt;&lt;p&gt;冒泡
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/希尔排序/</id>
    <published>2020-07-14T11:06:42.000Z</published>
    <updated>2020-07-14T11:32:07.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="什么是希尔排序"><a href="#什么是希尔排序" class="headerlink" title="什么是希尔排序"></a>什么是希尔排序</h2><ol><li><p>1959年由唐纳德·希尔（Donald Shell）提出</p></li><li><p>希尔排序把序列看作是一个矩阵，分成 𝑚 列，逐列进行排序</p><p>𝑚 从某个整数逐渐减为1</p><p>当 𝑚 为1时，整个序列将完全有序</p></li><li><p>因此，希尔排序也被称为递减增量排序（Diminishing Increment Sort）</p></li><li><p>矩阵的列数取决于步长序列（step sequence）</p><p>比如，如果步长序列为 ${1,5,19,41,109,…}$，就代表依次分成109列、41列、19列、5列、1列进行排序</p><p>不同的步长序列，执行效率也不同</p></li></ol><h2 id="希尔排序-–-实例"><a href="#希尔排序-–-实例" class="headerlink" title="希尔排序 – 实例"></a>希尔排序 – 实例</h2><p>希尔本人给出的步长序列是 $𝑛/2^𝑘$，比如 $𝑛$ 为 $16$ 时，步长序列是 {$1, 2, 4, 8$}</p><p><strong>分成8列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/1.png" alt></p><p><strong>分成4列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/2.png" alt></p><p><strong>分成2列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/3.png" alt></p><p><strong>分成1列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/4.png" alt></p><p><strong>不难看出来，从8列变为1列的过程中，逆序对的数量在逐渐减少</strong></p><p>因此希尔排序底层一般使用插入排序对每一列进行排序，很多资料认为希尔排序是插入排序的改进版</p><h2 id="假设有11个元素，步长序列是-1-2-5"><a href="#假设有11个元素，步长序列是-1-2-5" class="headerlink" title="假设有11个元素，步长序列是{1, 2, 5}"></a>假设有11个元素，步长序列是{1, 2, 5}</h2><p><img src="/2020/07/14/希尔排序/5.png" alt></p><p>假设元素在第 $col$ 列、第 $row$ 行，步长（总列数）是 $step$</p><p>那么这个元素在数组中的索引是 $col + row * step$</p><p>比如 $9$ 在排序前是第 $2$ 列、第 $0$ 行，那么它排序前的索引是 $2 + 0 * 5 = 2$</p><p>比如 $4$ 在排序前是第 $2$ 列、第 $1$ 行，那么它排序前的索引是 $2 + 1 * 5 = 7$</p><h2 id="希尔排序-–-实现"><a href="#希尔排序-–-实现" class="headerlink" title="希尔排序 – 实现"></a>希尔排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; shellSequence = shellStepSequence();</span><br><span class="line">    <span class="keyword">for</span> (Integer shell : shellSequence) &#123;</span><br><span class="line">        sort(shell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分成step列进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; step; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">        <span class="comment">// col、col+step、col+2*step、col+3*step</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = col + step; begin &lt; array.length; begin += step) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = begin;</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(cur, cur - step);</span><br><span class="line">                cur -= step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况是步长序列只有 $1$，且序列几乎有序，时间复杂度为 $O(n)$</p><p>空间复杂度为 $O(1)$，属于不稳定排序</p><h3 id="希尔排序-–-步长序列"><a href="#希尔排序-–-步长序列" class="headerlink" title="希尔排序 – 步长序列"></a>希尔排序 – 步长序列</h3><p>希尔本人给出的步长序列，最坏情况时间复杂度是 $O(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">shellStepSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> step = array.length;</span><br><span class="line">    <span class="keyword">while</span> ((step &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stepSequence.add(step);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stepSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前已知的最好的步长序列，最坏情况时间复杂度是 $O(n^{4/3})$ ，1986年由<strong>Robert Sedgewick</strong>提出</p><script type="math/tex; mode=display">\begin{cases}9 \left(2^k - 2^{\frac{k}{2}}\right) +1, & \text {k even} \\8 \cdot 2^k - 6 \cdot 2^{\frac{(k+1)}{2}} + 1, & \text {k odd} \\\end{cases} \\1,5,19,41,109,...</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">SedgewickStepSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pow = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            step = <span class="number">1</span> + <span class="number">9</span> * (pow * pow - pow);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pow1 = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, (k - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pow2 = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            step = <span class="number">1</span> + <span class="number">8</span> * pow1 * pow2 - <span class="number">6</span> * pow2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt;= array.length) <span class="keyword">break</span>;</span><br><span class="line">        stepSequence.add(<span class="number">0</span>, step);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stepSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;希尔排序（Shell-Sort）&quot;&gt;&lt;a href=&quot;#希尔排序（Shell-Sort）&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell Sort）&quot;&gt;&lt;/a&gt;希尔排序（Shell Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是希尔排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/快速排序/</id>
    <published>2020-07-14T10:53:40.000Z</published>
    <updated>2020-07-14T11:05:38.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick    Sort）"></a>快速排序（Quick    Sort）</h1><h2 id="什么是快速排序"><a href="#什么是快速排序" class="headerlink" title="什么是快速排序"></a>什么是快速排序</h2><p>1960年由查尔斯·安东尼·理查德·霍尔（Charles Antony Richard Hoare，缩写为C. A. R. Hoare）提出</p><p>昵称为东尼·霍尔（Tony Hoare）</p><h2 id="快速排序-–-执行流程"><a href="#快速排序-–-执行流程" class="headerlink" title="快速排序 – 执行流程"></a>快速排序 – 执行流程</h2><p>① 从序列中选择一个轴点元素（pivot）</p><p>​    假设每次选择 0 位置的元素为轴点元素</p><p>② 利用 pivot 将序列分割成 2 个子序列</p><p>​    将小于 pivot 的元素放在pivot前面（左侧）</p><p>​    将大于 pivot 的元素放在pivot后面（右侧）</p><p>​    等于pivot的元素放哪边都可以</p><p>③ 对子序列进行 ① ② 操作</p><p>​    直到不能再分割（子序列中只剩下1个元素）</p><p><img src="/2020/07/14/快速排序/1.png" alt></p><p><strong>快速排序的本质</strong></p><p><strong>逐渐将每一个元素都转换成轴点元素</strong></p><h2 id="快速排序-–-轴点构造"><a href="#快速排序-–-轴点构造" class="headerlink" title="快速排序 – 轴点构造"></a>快速排序 – 轴点构造</h2><p><img src="/2020/07/14/快速排序/2.png" alt></p><h2 id="快速排序-–-时间复杂度"><a href="#快速排序-–-时间复杂度" class="headerlink" title="快速排序 – 时间复杂度"></a>快速排序 – 时间复杂度</h2><ol><li><p>在轴点左右元素数量比较均匀的情况下，同时也是最好的情况</p><p>$T(n) = 2 ∗ T(n/2) + O(n) = O(nlogn)$</p></li><li><p>如果轴点左右元素数量极度不均匀，最坏情况</p><p>$T(n) = T(n − 1) + O(n) = O(n^2)$</p></li><li><p>为了降低最坏情况的出现概率，一般采取的做法是</p><p>随机选择轴点元素</p></li><li><p>最好、平均时间复杂度：$O(nlogn)$</p><p>最坏时间复杂度：$O(n^2)$</p><p>由于递归调用的缘故，空间复杂度：$O(logn)$</p><p>属于不稳定排序</p></li></ol><p><img src="/2020/07/14/快速排序/3.png" alt></p><h2 id="快速排序-–-实现"><a href="#快速排序-–-实现" class="headerlink" title="快速排序 – 实现"></a>快速排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(<span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 [begin, end) 范围的元素进行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定轴点位置 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> mid = pivotIndex(begin, end);</span><br><span class="line">    <span class="comment">// 对子序列进行快速排序</span></span><br><span class="line">    sort(begin, mid); </span><br><span class="line">    sort(mid + <span class="number">1</span>, end); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造出 [begin, end) 范围的轴点元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 轴点元素的最终位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择一个元素跟begin位置进行交换</span></span><br><span class="line">    swap(begin, begin + (<span class="keyword">int</span>)(Math.random() * (end - begin)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份begin位置的元素</span></span><br><span class="line">    T pivot = array[begin];</span><br><span class="line">    <span class="comment">// end指向最后一个元素</span></span><br><span class="line">    end--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(pivot, array[end]) &lt; <span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">                array[begin++] = array[end];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(pivot, array[begin]) &gt; <span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">                begin++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">                array[end--] = array[begin];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将轴点元素放入最终的位置</span></span><br><span class="line">    array[begin] = pivot;</span><br><span class="line">    <span class="comment">// 返回轴点元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序-–-与轴点相等的元素"><a href="#快速排序-–-与轴点相等的元素" class="headerlink" title="快速排序 – 与轴点相等的元素"></a>快速排序 – 与轴点相等的元素</h3><p><img src="/2020/07/14/快速排序/4.png" alt></p><p>如果序列中的所有元素都与轴点元素相等，利用目前的算法实现，轴点元素可以将序列分割成 2 个均匀的子序列</p><p><strong>思考：cmp 位置的判断分别改为 ≤、≥ 会起到什么效果？</strong></p><p><img src="/2020/07/14/快速排序/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(pivot, array[end]) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">            end--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">            array[begin++] = array[end];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(pivot, array[begin]) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">            array[end--] = array[begin];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>轴点元素分割出来的子序列极度不均匀</strong></p><p><strong>导致出现最坏时间复杂度</strong> $O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序（Quick-Sort）&quot;&gt;&lt;a href=&quot;#快速排序（Quick-Sort）&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quick    Sort）&quot;&gt;&lt;/a&gt;快速排序（Quick    Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/归并排序/</id>
    <published>2020-07-14T10:11:09.000Z</published>
    <updated>2020-07-14T10:52:34.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="什么是归并排序"><a href="#什么是归并排序" class="headerlink" title="什么是归并排序"></a>什么是归并排序</h2><p>1945年由约翰·冯·诺伊曼（John von Neumann）首次提出</p><p>执行流程</p><p>① 不断地将当前序列平均分割成2个子序列</p><p>​    直到不能再分割（序列中只剩1个元素）</p><p>② 不断地将2个子序列合并成一个有序序列</p><p>​    直到最终只剩下1个有序序列</p><p><img src="/2020/07/14/归并排序/1.png" alt></p><h2 id="归并排序-–-divide实现"><a href="#归并排序-–-divide实现" class="headerlink" title="归并排序 – divide实现"></a>归并排序 – divide实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一段临时的数组空间，在merge操作中使用</span></span><br><span class="line">    leftArray = (T[]) <span class="keyword">new</span> Comparable[array.length &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    sort(<span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sort(begin, mid);</span><br><span class="line">    sort(mid, end);</span><br><span class="line">    merge(begin, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-–-merge"><a href="#归并排序-–-merge" class="headerlink" title="归并排序 – merge"></a>归并排序 – merge</h2><h3 id="归并排序-–-merge细节"><a href="#归并排序-–-merge细节" class="headerlink" title="归并排序 – merge细节"></a>归并排序 – merge细节</h3><p><img src="/2020/07/14/归并排序/2.png" alt></p><p>需要 merge 的 2 组序列存在于同一个数组中，并且是挨在一起的</p><p><img src="/2020/07/14/归并排序/3.png" alt></p><p>为了更好地完成 merge 操作，最好将其中 1 组序列备份出来，比如 $[begin, mid)$</p><p><img src="/2020/07/14/归并排序/4.png" alt></p><p>$li == 0，le == mid – begin$</p><p>$ri == mid，re == end$</p><h3 id="归并排序-–-merge-–-左边先结束"><a href="#归并排序-–-merge-–-左边先结束" class="headerlink" title="归并排序 – merge – 左边先结束"></a>归并排序 – merge – 左边先结束</h3><p><img src="/2020/07/14/归并排序/5.png" alt></p><h3 id="归并排序-–-merge-–-右边先结束"><a href="#归并排序-–-merge-–-右边先结束" class="headerlink" title="归并排序 – merge – 右边先结束"></a>归并排序 – merge – 右边先结束</h3><p><img src="/2020/07/14/归并排序/6.png" alt></p><h3 id="归并排序-–-merge实现"><a href="#归并排序-–-merge实现" class="headerlink" title="归并排序 – merge实现"></a>归并排序 – merge实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> li = <span class="number">0</span>, le = mid - begin;</span><br><span class="line">    <span class="keyword">int</span> ri = mid, re = end;</span><br><span class="line">    <span class="keyword">int</span> ai = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份左边数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = li; i &lt; le; i++) &#123;</span><br><span class="line">        leftArray[i] = array[begin + i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左边还没有结束</span></span><br><span class="line">    <span class="keyword">while</span> (li &lt; le) &#123; </span><br><span class="line">        <span class="keyword">if</span> (ri &lt; re &amp;&amp; cmp(array[ri], leftArray[li]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[ai++] = array[ri++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array[ai++] = leftArray[li++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-–-复杂度分析"><a href="#归并排序-–-复杂度分析" class="headerlink" title="归并排序 – 复杂度分析"></a>归并排序 – 复杂度分析</h2><p>归并排序花费的时间</p><p>$T(n) = 2 ∗ T (n/2) + O(n)$</p><p>$T(1) = O(1)$</p><p>$T(n) /n = T(n/2) / (n/2) + O(1)$</p><p>令 $S(n) = T(n) /n$</p><p>$S(1) = O(1)$</p><p>$S(n) = S(n/2) + O(1) = S(n/4)+ O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)$</p><p>$T(n) = n ∗ S(n) = O(nlogn)$</p><p>由于归并排序总是平均分割子序列，所以最好、最坏、平均时间复杂度都是 $O(nlogn)$ ，属于稳定排序</p><p>从代码中不难看出：归并排序的空间复杂度是 $O(n/2 + logn) = O(n)$</p><p>$n/2$ 用于临时存放左侧数组，$logn$ 是因为递归调用</p><h2 id="常见的递推式与复杂度"><a href="#常见的递推式与复杂度" class="headerlink" title="常见的递推式与复杂度"></a>常见的递推式与复杂度</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>递推式</strong></th><th style="text-align:center"><strong>复杂度</strong></th></tr></thead><tbody><tr><td style="text-align:center">$T(n) = T(n/2) + O(1)$</td><td style="text-align:center">$O(logn)$</td></tr><tr><td style="text-align:center">$T(n) = T(n − 1) + O(1)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = T(n/2) + O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n/2) + O(1)  $</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n/2) + O(n)$</td><td style="text-align:center">$O(nlogn)$</td></tr><tr><td style="text-align:center">$T(n) = T(n − 1) + O(n)$</td><td style="text-align:center">$O(n^2)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n − 1) + O(1)$</td><td style="text-align:center">$O(2^n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n − 1) + O(n)$</td><td style="text-align:center">$O(2^n)$</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序（Merge-Sort）&quot;&gt;&lt;a href=&quot;#归并排序（Merge-Sort）&quot; class=&quot;headerlink&quot; title=&quot;归并排序（Merge Sort）&quot;&gt;&lt;/a&gt;归并排序（Merge Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是归并排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
