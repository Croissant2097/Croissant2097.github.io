<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Croissant2097</title>
  
  <subtitle>Record &amp; Share &amp; Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-14T08:42:37.975Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trie</title>
    <link href="http://yoursite.com/2020/07/14/Trie/"/>
    <id>http://yoursite.com/2020/07/14/Trie/</id>
    <published>2020-07-14T07:22:50.000Z</published>
    <updated>2020-07-14T08:42:37.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树</p><p>Trie 搜索字符串的效率主要跟字符串的长度有关</p><p>假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词</p><p><img src="/2020/07/14/Trie/1.png" alt></p><h2 id="Trie代码实现"><a href="#Trie代码实现" class="headerlink" title="Trie代码实现"></a>Trie代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node&lt;V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.word ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">add</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> len = key.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = key.charAt(i); </span><br><span class="line"><span class="keyword">boolean</span> emptyChildren = node.children == <span class="keyword">null</span>;</span><br><span class="line">Node&lt;V&gt; childNode = emptyChildren ? <span class="keyword">null</span> : node.children.get(c);</span><br><span class="line"><span class="keyword">if</span> (childNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">childNode = <span class="keyword">new</span> Node&lt;&gt;(node);</span><br><span class="line">childNode.character = c;</span><br><span class="line">node.children = emptyChildren ? <span class="keyword">new</span> HashMap&lt;&gt;() : node.children;</span><br><span class="line">node.children.put(c, childNode);</span><br><span class="line">&#125;</span><br><span class="line">node = childNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.word) &#123; <span class="comment">// 已经存在这个单词</span></span><br><span class="line">V oldValue = node.value;</span><br><span class="line">node.value = value;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个单词</span></span><br><span class="line">node.word = <span class="keyword">true</span>;</span><br><span class="line">node.value = value;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 找到最后一个节点</span></span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="comment">// 如果不是单词结尾，不用作任何处理</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || !node.word) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line">V oldValue = node.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果还有子节点</span></span><br><span class="line"><span class="keyword">if</span> (node.children != <span class="keyword">null</span> &amp;&amp; !node.children.isEmpty()) &#123;</span><br><span class="line">node.word = <span class="keyword">false</span>;</span><br><span class="line">node.value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有子节点</span></span><br><span class="line">Node&lt;V&gt; parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((parent = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">parent.children.remove(node.character);</span><br><span class="line"><span class="keyword">if</span> (parent.word || !parent.children.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">node = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node(prefix) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;V&gt; <span class="title">node</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> len = key.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || node.children == <span class="keyword">null</span> || node.children.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">char</span> c = key.charAt(i); </span><br><span class="line">node = node.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyCheck</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span> || key.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key must not be empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">Node&lt;V&gt; parent;</span><br><span class="line">HashMap&lt;Character, Node&lt;V&gt;&gt; children;</span><br><span class="line">Character character;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">boolean</span> word; <span class="comment">// 是否为单词的结尾（是否为一个完整的单词）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Trie 的优点：搜索前缀的效率主要跟前缀的长度有关</strong></p><p><strong>Trie 的缺点：需要耗费大量的内存，因此还有待改进</strong></p><p>更多Trie 相关的数据结构和算法</p><p>Double-array Trie、Suffix Tree、Patricia Tree、Crit-bit Tree、AC自动机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Trie&quot;&gt;&lt;a href=&quot;#Trie&quot; class=&quot;headerlink&quot; title=&quot;Trie&quot;&gt;&lt;/a&gt;Trie&lt;/h1&gt;&lt;p&gt;Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树&lt;/p&gt;
&lt;p&gt;Trie 搜索字符串的效率主要跟字符串的
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://yoursite.com/2020/07/14/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/14/哈夫曼树/</id>
    <published>2020-07-14T07:13:27.000Z</published>
    <updated>2020-07-14T08:43:25.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼编码（Huffman-Coding）"><a href="#哈夫曼编码（Huffman-Coding）" class="headerlink" title="哈夫曼编码（Huffman Coding）"></a>哈夫曼编码（Huffman Coding）</h1><p>哈夫曼编码，又称为霍夫曼编码，它是现代压缩算法的基础</p><p>假设要把字符串【ABBBCCCCCCCCDDDDDDEE】转成二进制编码进行传输</p><p>可以转成ASCII编码（65 ~ 69，1000001~1000101），但是有点冗长，如果希望编码更短呢？</p><p>可以先约定5个字母对应的二进制</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">001</td><td style="text-align:center">010</td><td style="text-align:center">011</td><td style="text-align:center">100</td></tr></tbody></table></div><p>对应的二进制编码：000001001001010010010010010010010010011011011011011011100100</p><p>一共20个字母，转成了60个二进制位</p><p>如果使用哈夫曼编码，可以压缩至41个二进制位，约为原来长度的68.3%</p><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>先计算出每个字母的出现频率（权值，这里直接用出现次数），【ABBBCCCCCCCCDDDDDDEE】</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table></div><p>利用这些权值，构建一棵哈夫曼树（又称为霍夫曼树、最优二叉树）</p><p>如何构建一棵哈夫曼树？（假设有 n 个权值）</p><ol><li><p>以权值作为根节点构建 n 棵二叉树，组成森林</p></li><li><p>在森林中选出 2 个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点为其左右子树根节点之和</p></li><li><p>从森林中删除刚才选取的 2 棵树，并将新树加入森林</p></li><li><p>重复 2、3 步骤，直到森林只剩一棵树为止，该树即为哈夫曼树</p></li></ol><h2 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h2><p><img src="/2020/07/14/哈夫曼树/1.png" alt></p><p>left为0，right为1，可以得出5个字母对应的哈夫曼编码</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">1110</td><td style="text-align:center">110</td><td style="text-align:center">0</td><td style="text-align:center">10</td><td style="text-align:center">1111</td></tr></tbody></table></div><p>【ABBBCCCCCCCCDDDDDDEE】的哈夫曼编码是</p><p>1110110110110000000001010101010101111</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>n 个权值构建出来的哈夫曼树拥有 n 个叶子节点</p><p>每个哈夫曼编码都不是另一个哈夫曼编码的前缀</p><p>哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近</p><p>带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径长度。与最终的哈夫曼编码总长度成正比关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈夫曼编码（Huffman-Coding）&quot;&gt;&lt;a href=&quot;#哈夫曼编码（Huffman-Coding）&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼编码（Huffman Coding）&quot;&gt;&lt;/a&gt;哈夫曼编码（Huffman Coding）&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>优先级队列</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/14/优先级队列/</id>
    <published>2020-07-14T07:04:06.000Z</published>
    <updated>2020-07-14T08:44:58.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列（Priority-Queue）"><a href="#优先级队列（Priority-Queue）" class="headerlink" title="优先级队列（Priority Queue）"></a>优先级队列（Priority Queue）</h1><p><strong><a href="/2020/07/11/队列/" title="队列实现">队列实现</a></strong></p><h2 id="优先级队列的接口设计"><a href="#优先级队列的接口设计" class="headerlink" title="优先级队列的接口设计"></a>优先级队列的接口设计</h2><p>普通的队列是 FIFO 原则，也就是先进先出</p><p><strong>优先级队列则是按照优先级高低进行出队，比如将优先级最高的元素作为队头优先出队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> BinaryHeap&lt;E&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">heap.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先级队列的应用场景举例"><a href="#优先级队列的应用场景举例" class="headerlink" title="优先级队列的应用场景举例"></a>优先级队列的应用场景举例</h2><ol><li><p>医院的夜间门诊</p><p>队列元素是病人</p><p>优先级是病情的严重情况、挂号时间</p></li><li><p>操作系统的多任务调度</p><p>队列元素是任务</p><p>优先级是任务类型</p></li></ol><h2 id="优先队列的底层实现"><a href="#优先队列的底层实现" class="headerlink" title="优先队列的底层实现"></a>优先队列的底层实现</h2><p>根据优先队列的特点，很容易想到：可以直接利用二叉堆作为优先队列的底层实现</p><p> <strong><a href="/2020/07/14/二叉堆/" title="二叉堆实现">二叉堆实现</a></strong></p><p>可以通过 Comparator 或 Comparable 去自定义优先级高低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> boneBreak;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> boneBreak)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.boneBreak = boneBreak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.boneBreak - person.boneBreak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", boneBreak="</span> + boneBreak + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Person&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">2</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Rose"</span>, <span class="number">10</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Jake"</span>, <span class="number">5</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"James"</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">System.out.println(queue.deQueue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先级队列（Priority-Queue）&quot;&gt;&lt;a href=&quot;#优先级队列（Priority-Queue）&quot; class=&quot;headerlink&quot; title=&quot;优先级队列（Priority Queue）&quot;&gt;&lt;/a&gt;优先级队列（Priority Queue）&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉堆</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>http://yoursite.com/2020/07/14/二叉堆/</id>
    <published>2020-07-14T06:07:31.000Z</published>
    <updated>2020-07-14T08:43:03.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>设计一种数据结构，用来存放整数，要求提供 3 个接口</p><ol><li><p><strong>添加元素</strong></p></li><li><p><strong>获取最大值</strong></p></li><li><p><strong>删除最大值</strong></p></li></ol><p><img src="/2020/07/14/二叉堆/1.png" alt></p><p>有没有更优的数据结构？</p><p><strong>堆</strong>：获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)</p><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>堆（Heap）也是一种树状的数据结构（不要跟内存模型中的“堆空间”混淆），常见的堆实现有</p><ul><li><p>二叉堆（Binary Heap，完全二叉堆）</p></li><li><p>多叉堆（D-heap、D-ary Heap）</p></li><li><p>索引堆（Index Heap）</p></li><li><p>二项堆（Binomial Heap）</p></li><li><p>斐波那契堆（Fibonacci Heap）</p></li><li><p>左倾堆（Leftist Heap，左式堆）</p></li><li><p>斜堆（Skew Heap）</p></li></ul><p><img src="/2020/07/14/二叉堆/2.png" alt></p><p>堆的一个重要性质：<strong>任意节点的值总是 ≥（ ≤ ）子节点的值</strong></p><p>如果任意节点的值总是 ≥ 子节点的值，称为：<strong>最大堆、大根堆、大顶堆</strong></p><p>如果任意节点的值总是 ≤ 子节点的值，称为：<strong>最小堆、小根堆、小顶堆</strong></p><p>由此可见，堆中的元素必须具备可比较性（跟二叉搜索树一样）</p><h2 id="堆的基本接口设计"><a href="#堆的基本接口设计" class="headerlink" title="堆的基本接口设计"></a>堆的基本接口设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Heap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">// 元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">// 清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">// 添加元素</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">()</span></span>;<span class="comment">// 获得堆顶元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">// 删除堆顶元素</span></span><br><span class="line"><span class="function">E <span class="title">replace</span><span class="params">(E element)</span></span>; <span class="comment">// 删除堆顶元素的同时插入一个新元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHeap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Heap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">protected</span> Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHeap</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> comparator != <span class="keyword">null</span> ? comparator.compare(e1, e2) </span><br><span class="line">: ((Comparable&lt;E&gt;)e1).compareTo(e2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉堆（Binary-Heap）"><a href="#二叉堆（Binary-Heap）" class="headerlink" title="二叉堆（Binary Heap）"></a>二叉堆（Binary Heap）</h2><p><strong>二叉堆的逻辑结构就是一棵完全二叉树</strong>，所以也叫完全二叉堆</p><p>鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）一般用数组实现即可</p><p>索引 i 的规律（ n 是元素数量）</p><ul><li><p>如果 i = 0 ，它是根节点</p></li><li><p>如果 i &gt; 0 ，它的父节点的索引为 floor( (i – 1) / 2 )</p></li><li><p>如果 2i + 1 ≤ n – 1，它的左子节点的索引为 2i + 1</p></li><li><p>如果 2i + 1 &gt; n – 1 ，它无左子节点</p></li><li><p>如果 2i + 2 ≤ n – 1 ，它的右子节点的索引为 2i + 2</p></li><li><p>如果 2i + 2 &gt; n – 1 ，它无右子节点</p></li></ul><p><img src="/2020/07/14/二叉堆/3.png" alt></p><h3 id="二叉堆获取最大值"><a href="#二叉堆获取最大值" class="headerlink" title="二叉堆获取最大值"></a>二叉堆获取最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    emptyCheck();</span><br><span class="line">    <span class="keyword">return</span> elements[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emptyCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Heap is empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-添加"><a href="#最大堆-–-添加" class="headerlink" title="最大堆 – 添加"></a>最大堆 – 添加</h3><p><img src="/2020/07/14/二叉堆/4.png" alt></p><p>循环执行以下操作（图中的 80 简称为 node）</p><ol><li><p><strong>如果 node ＞ 父节点</strong></p><p><strong>与父节点交换位置</strong></p></li><li><p><strong>如果 node ≤ 父节点，或者 node 没有父节点</strong></p><p><strong>退出循环</strong></p></li></ol><p>这个过程，叫做<strong>上滤（Sift Up）</strong></p><p>时间复杂度：O(logn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">    elements[size++] = element;</span><br><span class="line">    siftUp(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E e = elements[index];</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pindex = (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        E p = elements[pindex];</span><br><span class="line">        <span class="keyword">if</span> (compare(e, p) &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换index、pindex位置的内容</span></span><br><span class="line">        E tmp = elements[index];</span><br><span class="line">        elements[index] = elements[pindex];</span><br><span class="line">        elements[pindex] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新赋值index</span></span><br><span class="line">        index = pindex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-添加-–-交换位置的优化"><a href="#最大堆-–-添加-–-交换位置的优化" class="headerlink" title="最大堆 – 添加 – 交换位置的优化"></a>最大堆 – 添加 – 交换位置的优化</h3><p>一般交换位置需要3行代码，可以进一步优化</p><p>将新添加节点备份，确定最终位置才摆放上去</p><p><img src="/2020/07/14/二叉堆/5.png" alt></p><p>仅从交换位置的代码角度看</p><p>可以由大概的 3  O(logn) 优化到 1  O(logn) + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E element = elements[index];</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        E parent = elements[parentIndex];</span><br><span class="line">        <span class="keyword">if</span> (compare(element, parent) &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将父元素存储在index位置</span></span><br><span class="line">        elements[index] = parent;</span><br><span class="line">        <span class="comment">// 重新赋值index</span></span><br><span class="line">        index = parentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-删除"><a href="#最大堆-–-删除" class="headerlink" title="最大堆 – 删除"></a>最大堆 – 删除</h3><p><img src="/2020/07/14/二叉堆/6.png" alt></p><ol><li><p><strong>用最后一个节点覆盖根节点</strong></p></li><li><p><strong>删除最后一个节点</strong></p></li><li><p><strong>循环执行以下操作（图中的 43 简称为 node）</strong></p><ul><li><p><strong>如果 node &lt; 最大的子节点，与最大的子节点交换位置</strong></p></li><li><p><strong>如果 node ≥ 最大的子节点， 或者 node 没有子节点，退出循环</strong></p></li></ul></li></ol><p>这个过程，叫做<strong>下滤（Sift Down）</strong>，时间复杂度：O(logn)</p><p>同样的，交换位置的操作可以像添加那样进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    emptyCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastIndex = --size;</span><br><span class="line">    E root = elements[<span class="number">0</span>];</span><br><span class="line">    elements[<span class="number">0</span>] = elements[lastIndex];</span><br><span class="line">    elements[lastIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    E element = elements[index];</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第一个叶子节点的索引 == 非叶子节点的数量</span></span><br><span class="line">    <span class="comment">// index &lt; 第一个叶子节点的索引</span></span><br><span class="line">    <span class="comment">// 必须保证index位置是非叶子节点</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; half) &#123; </span><br><span class="line">        <span class="comment">// index的节点有2种情况</span></span><br><span class="line">        <span class="comment">// 1.只有左子节点</span></span><br><span class="line">        <span class="comment">// 2.同时有左右子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为左子节点跟它进行比较</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        E child = elements[childIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="keyword">int</span> rightIndex = childIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选出左右子节点最大的那个</span></span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; size &amp;&amp; compare(elements[rightIndex], child) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            child = elements[childIndex = rightIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compare(element, child) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点存放到index位置</span></span><br><span class="line">        elements[index] = child;</span><br><span class="line">        <span class="comment">// 重新设置index</span></span><br><span class="line">        index = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-替换堆顶"><a href="#最大堆-替换堆顶" class="headerlink" title="最大堆 - 替换堆顶"></a>最大堆 - 替换堆顶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line"></span><br><span class="line">    E root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elements[<span class="number">0</span>] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = elements[<span class="number">0</span>];</span><br><span class="line">        elements[<span class="number">0</span>] = element;</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆-–-批量建堆（Heapify）"><a href="#最大堆-–-批量建堆（Heapify）" class="headerlink" title="最大堆 – 批量建堆（Heapify）"></a>最大堆 – 批量建堆（Heapify）</h3><p>批量建堆，有 2 种做法</p><ol><li><p><strong>自上而下的上滤</strong></p></li><li><p><strong>自下而上的下滤</strong></p></li></ol><h4 id="最大堆-–-批量建堆-–-自上而下的上滤"><a href="#最大堆-–-批量建堆-–-自上而下的上滤" class="headerlink" title="最大堆 – 批量建堆 – 自上而下的上滤"></a>最大堆 – 批量建堆 – 自上而下的上滤</h4><p><img src="/2020/07/14/二叉堆/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自上而下的上滤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        siftUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大堆-–-批量建堆-–-自下而上的下滤"><a href="#最大堆-–-批量建堆-–-自下而上的下滤" class="headerlink" title="最大堆 – 批量建堆 – 自下而上的下滤"></a>最大堆 – 批量建堆 – 自下而上的下滤</h4><p><img src="/2020/07/14/二叉堆/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自下而上的下滤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大堆-–-批量建堆-–-效率对比"><a href="#最大堆-–-批量建堆-–-效率对比" class="headerlink" title="最大堆 – 批量建堆 – 效率对比"></a>最大堆 – 批量建堆 – 效率对比</h4><p><img src="/2020/07/14/二叉堆/9.png" alt><strong>所有节点的深度之和</strong></p><ul><li><p>仅仅是叶子节点，就有近 n/2 个，而且每一个叶子节点的深度都是 O(logn) 级别的</p></li><li><p>因此，在叶子节点这一块，就达到了 O(nlogn) 级别</p></li><li><p>O(nlogn) 的时间复杂度足以利用排序算法对所有节点进行全排序</p></li></ul><p><strong>所有节点的高度之和</strong></p><ul><li><p>假设是满树，节点总个数为 $n$，树高为 $h$，那么 $n = 2h − 1$</p></li><li><p>所有节点的树高之和 $H(n) = 2^0 ∗ (h − 0) + 2^1 ∗ (h − 1) + 2^2 ∗ (h − 2) + ⋯ + 2^{h −1}  ∗ [h − (h − 1)]$</p></li><li><p>$H(n) = h ∗ (2^0 + 2^1 + 2^2 + ⋯ + 2^{h −1}) − [1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 1)∗ 2^{h−1}]$</p></li><li><p>$H(n) = h ∗ (2^h − 1) − [(h − 2) ∗ 2^h + 2]$</p></li><li><p>$H(n) = h ∗ 2^h − h − h ∗ 2^h + 2^{h+1} − 2$</p></li><li><p>$H(n) = 2^{h+1} − h − 2 = 2 ∗ (2^h − 1) − h = 2n − h = 2n − log_2(n + 1) = O(n)$</p></li></ul><p><strong>公式推导</strong></p><ul><li><p>$S(h) = 1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 2) ∗ 2^{h−2} + (h − 1) * 2^{h−1}$</p></li><li><p>$2S(h) = 1 ∗ 2^2 + 2 ∗ 2^3 + 3 ∗ 2^4 + ⋯ + (h − 2) ∗ 2^{h−1} +(h − 1) ∗ 2^h$</p></li><li><p>$S(h) – 2S(h) = [2^1 + 2^2 + 2^3 + ⋯ + 2^{h−1}] − (h − 1) ∗ 2^h = (2^h − 2) − (h − 1) ∗ 2^h$</p></li><li><p>$S(h) = (h − 1) ∗ 2^h − (2^h − 2) = (h − 2) ∗ 2^h + 2$</p></li></ul><h3 id="批量建堆"><a href="#批量建堆" class="headerlink" title="批量建堆"></a>批量建堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(E[] elements, Comparator&lt;E&gt; comparator)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(comparator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elements == <span class="keyword">null</span> || elements.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size = elements.length;</span><br><span class="line">        <span class="keyword">int</span> capacity = Math.max(elements.length, DEFAULT_CAPACITY);</span><br><span class="line">        <span class="keyword">this</span>.elements = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elements[i] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自下而上的下滤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何构建一个小顶堆？"><a href="#如何构建一个小顶堆？" class="headerlink" title="如何构建一个小顶堆？"></a>如何构建一个小顶堆？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">88</span>, <span class="number">44</span>, <span class="number">53</span>, <span class="number">41</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">70</span>, <span class="number">18</span>, <span class="number">85</span>, <span class="number">98</span>, <span class="number">81</span>, <span class="number">23</span>, <span class="number">36</span>, <span class="number">43</span>, <span class="number">37</span>&#125;;</span><br><span class="line">BinaryHeap&lt;Integer&gt; heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(data, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">BinaryTrees.println(heap);</span><br></pre></td></tr></table></figure><h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><p>从 n 个整数中，找出最大的前 k 个数（ k 远远小于 n ）</p><p>如果使用排序算法进行全排序，需要 O(nlogn) 的时间复杂度</p><p>如果使用二叉堆来解决，可以使用 O(nlogk) 的时间复杂度来解决</p><ol><li><p>新建一个小顶堆</p></li><li><p>扫描 n 个整数</p><p>先将遍历到的前 k 个数放入堆中</p><p>从第 k + 1 个数开始，如果大于堆顶元素，就使用 replace 操作（删除堆顶元素，将第 k + 1 个数添加到堆中）</p></li><li><p>扫描完毕后，堆中剩下的就是最大的前 k 个数</p></li><li><p>如果是找出最小的前 k 个数呢？</p><p>用大顶堆</p><p>如果小于堆顶元素，就使用 replace 操作</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个小顶堆</span></span><br><span class="line">    BinaryHeap&lt;Integer&gt; heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最大的前k个数</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    Integer[] data = &#123;<span class="number">51</span>, <span class="number">30</span>, <span class="number">39</span>, <span class="number">92</span>, <span class="number">74</span>, <span class="number">25</span>, <span class="number">16</span>, <span class="number">93</span>, </span><br><span class="line">                      <span class="number">91</span>, <span class="number">19</span>, <span class="number">54</span>, <span class="number">47</span>, <span class="number">73</span>, <span class="number">62</span>, <span class="number">76</span>, <span class="number">63</span>, <span class="number">35</span>, <span class="number">18</span>, </span><br><span class="line">                      <span class="number">90</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">49</span>, <span class="number">3</span>, <span class="number">26</span>, <span class="number">61</span>, <span class="number">21</span>, <span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; k) &#123; <span class="comment">// 前k个数添加到小顶堆</span></span><br><span class="line">            heap.add(data[i]); <span class="comment">// logk</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i] &gt; heap.get()) &#123; <span class="comment">// 如果是第k + 1个数，并且大于堆顶元素</span></span><br><span class="line">            heap.replace(data[i]); <span class="comment">// logk</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(nlogk)</span></span><br><span class="line">    BinaryTrees.println(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉堆&quot;&gt;&lt;a href=&quot;#二叉堆&quot; class=&quot;headerlink&quot; title=&quot;二叉堆&quot;&gt;&lt;/a&gt;二叉堆&lt;/h1&gt;&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉堆" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://yoursite.com/2020/07/13/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/13/哈希表/</id>
    <published>2020-07-13T06:35:39.000Z</published>
    <updated>2020-07-14T08:45:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表（HashTable）"><a href="#哈希表（HashTable）" class="headerlink" title="哈希表（HashTable）"></a>哈希表（HashTable）</h1><h2 id="先来分析TreeMap（）"><a href="#先来分析TreeMap（）" class="headerlink" title="先来分析TreeMap（）"></a>先来分析TreeMap（<a href="/2020/07/13/映射/" title="红黑树映射实现">红黑树映射实现</a>）</h2><ul><li><p>时间复杂度（平均）</p></li><li><p>添加、删除、搜索：O(logn)</p></li></ul><p><strong>特点</strong></p><ul><li><p>Key 必须具备可比较性</p></li><li><p>元素的分布是有顺序的</p></li></ul><p><strong>在实际应用中，很多时候的需求</strong></p><ul><li><p>Map 中存储的元素不需要讲究顺序</p></li><li><p>Map 中的 Key 不需要具备可比较性</p></li></ul><p>不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)，那就是<strong>采取哈希表来实现 Map</strong></p><h2 id="什么是哈希表（HashTable）"><a href="#什么是哈希表（HashTable）" class="headerlink" title="什么是哈希表（HashTable）"></a>什么是哈希表（HashTable）</h2><p>哈希表也叫做散列表（ hash 有“剁碎”的意思）</p><p>添加、搜索、删除的流程都是类似的</p><ol><li><p><strong>利用哈希函数生成 key 对应的 index【O(1)】</strong></p></li><li><p><strong>根据 index 操作定位数组元素【O(1)】</strong></p></li></ol><p>哈希表是【<strong>空间换时间</strong>】的典型应用</p><p>哈希函数，也叫做散列函数</p><p>哈希表内部的数组元素，很多地方也叫 Bucket（桶），整个数组叫 Buckets 或者 Bucket Array</p><p><img src="/2020/07/13/哈希表/1.png" alt></p><h2 id="哈希冲突（Hash-Collision）"><a href="#哈希冲突（Hash-Collision）" class="headerlink" title="哈希冲突（Hash Collision）"></a>哈希冲突（Hash Collision）</h2><p>哈希冲突也叫做哈希碰撞</p><p>2 个不同的 key，经过哈希函数计算出相同的结果</p><p><strong>key1 ≠ key2 ，hash(key1) = hash(key2)</strong></p><p><img src="/2020/07/13/哈希表/2.png" alt></p><p><strong>解决哈希冲突的常见方法</strong></p><ol><li><p>开放定址法（Open Addressing）</p><p>按照一定规则向其他地址探测，直到遇到空桶</p></li><li><p>再哈希法（Re-Hashing）</p><p>设计多个哈希函数</p></li><li><p>链地址法（Separate Chaining）</p><p>比如通过链表将同一index的元素串起来</p></li></ol><h2 id="JDK1-8的哈希冲突解决方案"><a href="#JDK1-8的哈希冲突解决方案" class="headerlink" title="JDK1.8的哈希冲突解决方案"></a>JDK1.8的哈希冲突解决方案</h2><p><strong>JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突</strong></p><ol><li><p>默认使用单向链表将元素串起来</p></li><li><p>在添加元素时，可能会<strong>由单向链表转为红黑树来存储元素</strong></p><p>比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时</p><p>当红黑树节点数量少到一定程度时，又会转为单向链表</p></li></ol><p><img src="/2020/07/13/哈希表/3.png" alt></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希表中哈希函数的实现步骤大概如下</p><ol><li><p>先生成 key 的哈希值（必须是整数）</p></li><li><p>再让 key 的哈希值跟数组的大小进行相关运算，生成一个索引值</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_code(key) % table.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为了提高效率，可以使用 &amp; 位运算取代 % 运算【前提：将数组的长度设计为 2 的幂（2n）】</strong></p><div class="table-container"><table><thead><tr><th style="text-align:right"><strong>1100  1010</strong></th><th style="text-align:right"><strong>1011  1100</strong></th></tr></thead><tbody><tr><td style="text-align:right"><strong>&amp;  1111</strong></td><td style="text-align:right"><strong>&amp;  1111</strong></td></tr><tr><td style="text-align:right"><strong>1010</strong></td><td style="text-align:right"><strong>1100</strong></td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_code(key) % (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>良好的哈希函数</strong></p><p>让哈希值更加均匀分布 → 减少哈希冲突次数 → 提升哈希表的性能</p><h2 id="如何生成key的哈希值"><a href="#如何生成key的哈希值" class="headerlink" title="如何生成key的哈希值"></a>如何生成key的哈希值</h2><p>key 的常见种类可能有</p><p><strong>整数、浮点数、字符串、自定义对象</strong></p><p>不同种类的 key，哈希值的生成方式不一样，但目标是一致的</p><p>尽量让每个 key 的哈希值是唯一的</p><p>尽量让 key 的所有信息参与运算</p><p><strong>在Java中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null</strong></p><h3 id="整数的哈希值"><a href="#整数的哈希值" class="headerlink" title="整数的哈希值"></a>整数的哈希值</h3><p>整数值当做哈希值</p><p>比如 10 的哈希值就是 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数的哈希值"><a href="#浮点数的哈希值" class="headerlink" title="浮点数的哈希值"></a>浮点数的哈希值</h3><p>将存储的二进制格式转为整数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Long和Double的哈希值"><a href="#Long和Double的哈希值" class="headerlink" title="Long和Double的哈希值"></a>Long和Double的哈希值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">double</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bits = doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>>&gt;&gt; 和 ^ 的作用是？</strong></p><p><strong>高32bit 和 低32bit 混合计算出 32bit 的哈希值</strong></p><p><strong>充分利用所有信息计算出哈希值</strong></p><p><img src="/2020/07/13/哈希表/4.png" alt></p><h3 id="字符串的哈希值"><a href="#字符串的哈希值" class="headerlink" title="字符串的哈希值"></a>字符串的哈希值</h3><p>字符串是由若干个字符组成的</p><p>比如字符串 jack，由 j、a、c、k 四个字符组成（字符的本质就是一个整数）</p><p>因此，jack 的哈希值可以表示为 $ j ∗ n^3 + a ∗ n^2 + c ∗ n^1 + k ∗ n^0$，等价于 $[ ( j ∗ n + a ) ∗ n + c ] ∗ n + k$</p><p>在JDK中，乘数 n 为 31，为什么使用 31？</p><p><strong>31 是一个奇素数，JVM会将 31 * i 优化成 (i &lt;&lt; 5) – i</strong></p><script type="math/tex; mode=display">31 * i = (2^5 - 1) * i = i * 2^5 - i = (i << 5) -i</script><p>31不仅仅是符合$2^n – 1$，它是个<strong>奇素数（既是奇数，又是素数，也就是质数）</strong></p><p><strong>素数和其他数相乘的结果比其他方式更容易产成唯一性，减少哈希冲突</strong></p><p>最终选择31是经过观测分布结果后的选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">"jack"</span>;</span><br><span class="line"><span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = string.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = string.charAt(i);</span><br><span class="line">    <span class="comment">// hashCode = 31 * hashCode + c;</span></span><br><span class="line">    hashCode = (hashCode &lt;&lt; <span class="number">5</span>) - hashCode + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义对象的哈希值"><a href="#自定义对象的哈希值" class="headerlink" title="自定义对象的哈希值"></a>自定义对象的哈希值</h3><p>自定义对象作为 key，最好同时<strong>重写 hashCode 、equals 方法</strong></p><ol><li><p>equals ：用以判断 2 个 key 是否为同一个 key</p><ul><li><p><strong>自反性</strong>：对于任何非 null 的 x，x.equals(x)必须返回true</p></li><li><p><strong>对称性</strong>：对于任何非 null 的 x、y，如果 y.equals(x) 返回 true，x.equals(y) 必须返回 true</p></li><li><p><strong>传递性</strong>：对于任何非 null 的 x、y、z，如果 x.equals(y)、y.equals(z) 返回 true，那么x.equals(z) 必须 返回 true</p></li><li><p><strong>一致性</strong>：对于任何非 null 的 x、y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用</p></li><li><p>x.equals(y) 就会一致地返回 true，或者一致地返回 false</p></li><li><p>对于任何非 null 的 x，x.equals(null) 必须返回 false</p></li></ul></li><li><p>hashCode ：必须保证 equals 为 true 的 2 个 key 的哈希值一样</p></li><li><p>反过来 hashCode 相等的 key，不一定 equals 为 true</p></li><li><p>不重写 hashCode 方法只重写 equals 会有什么后果？</p><p>可能会导致 2 个 equals 为 true 的 key 同时存在哈希表中</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> height;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">float</span> height, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.height = height;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来比较2个对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 内存地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span> || obj.getClass() != getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// if (obj == null || !(obj instanceof Person)) return false;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较成员变量</span></span><br><span class="line">Person person = (Person) obj;</span><br><span class="line"><span class="keyword">return</span> person.age == age</span><br><span class="line">&amp;&amp; person.height == height</span><br><span class="line">&amp;&amp; (person.name == <span class="keyword">null</span> ? name == <span class="keyword">null</span> : person.name.equals(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hashCode = Integer.hashCode(age);</span><br><span class="line">hashCode = hashCode * <span class="number">31</span> + Float.hashCode(height);</span><br><span class="line">hashCode = hashCode * <span class="number">31</span> + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age - o.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希值的进一步处理：扰动计算"><a href="#哈希值的进一步处理：扰动计算" class="headerlink" title="哈希值的进一步处理：扰动计算"></a>哈希值的进一步处理：扰动计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h2><p>装填因子（Load Factor）：节点总数量 / 哈希表桶数组长度，也叫做负载因子</p><p>在JDK1.8的HashMap中，如果装填因子超过0.75，就扩容为原来的2倍</p><h2 id="TreeMap-vs-HashMap"><a href="#TreeMap-vs-HashMap" class="headerlink" title="TreeMap vs HashMap"></a>TreeMap vs HashMap</h2><p><strong>何时选择TreeMap：元素具备可比较性且要求升序遍历（按照元素从小到大）</strong></p><p><strong>何时选择HashMap：无序遍历</strong></p><h2 id="HashMap代码实现"><a href="#HashMap代码实现" class="headerlink" title="HashMap代码实现"></a>HashMap代码实现</h2><h3 id="Map接口定义"><a href="#Map接口定义" class="headerlink" title="Map接口定义"></a>Map接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> stop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些简单的函数"><a href="#一些简单的函数" class="headerlink" title="一些简单的函数"></a>一些简单的函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 初始容量 2^4</span></span><br><span class="line">    <span class="comment">// 装填因子，大于0.75扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">new</span> Node[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 清空哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            table[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(key, value, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 红黑树节点左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; parent = grand.right;</span><br><span class="line">        Node&lt;K, V&gt; child = parent.left;</span><br><span class="line">        grand.right = child;</span><br><span class="line">        parent.left = grand;</span><br><span class="line">        afterRotate(grand, parent, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点右旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; parent = grand.left;</span><br><span class="line">        Node&lt;K, V&gt; child = parent.right;</span><br><span class="line">        grand.left = child;</span><br><span class="line">        parent.right = grand;</span><br><span class="line">        afterRotate(grand, parent, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点选择之后的修复</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRotate</span><span class="params">(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让parent称为子树的根节点</span></span><br><span class="line">        parent.parent = grand.parent;</span><br><span class="line">        <span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">            grand.parent.left = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">            grand.parent.right = parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// grand是root节点</span></span><br><span class="line">            table[index(grand)] = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新child的parent</span></span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.parent = grand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新grand的parent</span></span><br><span class="line">        grand.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">color</span><span class="params">(Node&lt;K, V&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        node.color = color;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">red</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color(node, RED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">black</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : node.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成Hash值"><a href="#生成Hash值" class="headerlink" title="生成Hash值"></a>生成Hash值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash(key) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash节点定义"><a href="#Hash节点定义" class="headerlink" title="Hash节点定义"></a>Hash节点定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">boolean</span> color = RED;</span><br><span class="line">    Node&lt;K, V&gt; left;</span><br><span class="line">    Node&lt;K, V&gt; right;</span><br><span class="line">    Node&lt;K, V&gt; parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">int</span> hash = key == <span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode();</span><br><span class="line">        <span class="keyword">this</span>.hash = hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node_"</span> + key + <span class="string">"_"</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(key, value, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="node函数查找节点"><a href="#node函数查找节点" class="headerlink" title="node函数查找节点"></a>node函数查找节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">node</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; root = table[index(key)];</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">null</span> : node(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">node</span><span class="params">(Node&lt;K, V&gt; node, K k1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h1 = hash(k1);</span><br><span class="line">    <span class="comment">// 存储查找结果</span></span><br><span class="line">    Node&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        K k2 = node.key;</span><br><span class="line">        <span class="keyword">int</span> h2 = node.hash;</span><br><span class="line">        <span class="comment">// 先比较哈希值</span></span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">            node = cmp &gt; <span class="number">0</span> ? node.right : node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; (result = node(node.right, k1)) != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只能往左边找</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash添加-put-K-key-V-value"><a href="#Hash添加-put-K-key-V-value" class="headerlink" title="Hash添加 put(K key, V value)"></a>Hash添加 put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    resize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = index(key);</span><br><span class="line">    <span class="comment">// 取出index位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = createNode(key, value, <span class="keyword">null</span>);</span><br><span class="line">        table[index] = root;</span><br><span class="line">        size++;</span><br><span class="line">        fixAfterPut(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树上面</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    K k1 = key;</span><br><span class="line">    <span class="keyword">int</span> h1 = hash(k1);</span><br><span class="line">    Node&lt;K, V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>; <span class="comment">// 是否已经搜索过这个key</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;</span><br><span class="line">        K k2 = node.key;</span><br><span class="line">        <span class="keyword">int</span> h2 = node.hash;</span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            cmp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searched) &#123; <span class="comment">// 已经扫描了</span></span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// searched == false; 还没有扫描，然后再根据内存地址大小决定左右</span></span><br><span class="line">            <span class="keyword">if</span> ((node.left != <span class="keyword">null</span> &amp;&amp; (result = node(node.left, k1)) != <span class="keyword">null</span>)</span><br><span class="line">                || (node.right != <span class="keyword">null</span> &amp;&amp; (result = node(node.right, k1)) != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 已经存在这个key</span></span><br><span class="line">                node = result;</span><br><span class="line">                cmp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在这个key</span></span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            V oldValue = node.value;</span><br><span class="line">            node.key = key;</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.hash = h1;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = createNode(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">    fixAfterPut(newNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash添加后修复红黑树"><a href="#Hash添加后修复红黑树" class="headerlink" title="Hash添加后修复红黑树"></a>Hash添加后修复红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterPut</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        black(node);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叔父节点</span></span><br><span class="line">    Node&lt;K, V&gt; uncle = parent.sibling();</span><br><span class="line">    <span class="comment">// 祖父节点</span></span><br><span class="line">    Node&lt;K, V&gt; grand = red(parent.parent);</span><br><span class="line">    <span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">        black(parent);</span><br><span class="line">        black(uncle);</span><br><span class="line">        <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">        fixAfterPut(grand);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叔父节点不是红色</span></span><br><span class="line">    <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">            black(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">            black(node);</span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        rotateRight(grand);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">            black(node);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">            black(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        rotateLeft(grand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash删除-key、节点"><a href="#Hash删除-key、节点" class="headerlink" title="Hash删除(key、节点)"></a>Hash删除(key、节点)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(node(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> V <span class="title">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; willNode = node;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    V oldValue = node.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line">        <span class="comment">// 找到后继节点</span></span><br><span class="line">        Node&lt;K, V&gt; s = successor(node);</span><br><span class="line">        <span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">        node.key = s.key;</span><br><span class="line">        node.value = s.value;</span><br><span class="line">        node.hash = s.hash;</span><br><span class="line">        <span class="comment">// 删除后继节点</span></span><br><span class="line">        node = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除node节点（node的度必然是1或者0）</span></span><br><span class="line">    Node&lt;K, V&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line">    <span class="keyword">int</span> index = index(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点</span></span><br><span class="line">        <span class="comment">// 更改parent</span></span><br><span class="line">        replacement.parent = node.parent;</span><br><span class="line">        <span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">            table[index] = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">            node.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">        fixAfterRemove(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是叶子节点并且是根节点</span></span><br><span class="line">        table[index] = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">            node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">        fixAfterRemove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交给子类去处理</span></span><br><span class="line">    afterRemove(willNode, node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash删除后修复红黑树"><a href="#Hash删除后修复红黑树" class="headerlink" title="Hash删除后修复红黑树"></a>Hash删除后修复红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterRemove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">    <span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">        black(node);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;K, V&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">            <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">            <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">            black(parent);</span><br><span class="line">            red(sibling);</span><br><span class="line">            <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                fixAfterRemove(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">                rotateRight(sibling);</span><br><span class="line">                sibling = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            color(sibling, colorOf(parent));</span><br><span class="line">            black(sibling.right);</span><br><span class="line">            black(parent);</span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">            <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">            <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">            black(parent);</span><br><span class="line">            red(sibling);</span><br><span class="line">            <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                fixAfterRemove(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">                rotateLeft(sibling);</span><br><span class="line">                sibling = parent.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            color(sibling, colorOf(parent));</span><br><span class="line">            black(sibling.left);</span><br><span class="line">            black(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树后继节点"><a href="#红黑树后继节点" class="headerlink" title="红黑树后继节点"></a>红黑树后继节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">successor</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点在左子树当中（right.left.left.left....）</span></span><br><span class="line">    Node&lt;K, V&gt; p = node.right;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash查找（key、vaule）"><a href="#Hash查找（key、vaule）" class="headerlink" title="Hash查找（key、vaule）"></a>Hash查找（key、vaule）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 得到key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; node = node(key);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="keyword">null</span> ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        queue.offer(table[i]);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(value, node.value)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash扩容"><a href="#Hash扩容" class="headerlink" title="Hash扩容"></a>Hash扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装填因子 &lt;= 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (size / table.length &lt;= DEFAULT_LOAD_FACTOR) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">    table = <span class="keyword">new</span> Node[oldTable.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldTable.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldTable[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        queue.offer(oldTable[i]);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挪动代码得放到最后面</span></span><br><span class="line">            moveNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动节点"><a href="#移动节点" class="headerlink" title="移动节点"></a>移动节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveNode</span><span class="params">(Node&lt;K, V&gt; newNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    newNode.parent = <span class="keyword">null</span>;</span><br><span class="line">    newNode.left = <span class="keyword">null</span>;</span><br><span class="line">    newNode.right = <span class="keyword">null</span>;</span><br><span class="line">    newNode.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = index(newNode);</span><br><span class="line">    <span class="comment">// 取出index位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">        table[index] = root;</span><br><span class="line">        fixAfterPut(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树上面</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    K k1 = newNode.key;</span><br><span class="line">    <span class="keyword">int</span> h1 = newNode.hash;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;</span><br><span class="line">        K k2 = node.key;</span><br><span class="line">        <span class="keyword">int</span> h2 = node.hash;</span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; k2 != <span class="keyword">null</span> </span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    newNode.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">    fixAfterPut(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>在HashMap的基础上维护元素的添加顺序，使得遍历的结果是遵从添加顺序的</p><p>假设添加顺序是：37、21、31、41、97、95、52、42、83</p><p><img src="/2020/07/13/哈希表/5.png" alt></p><h4 id="LinkedHashMap-–-删除注意点"><a href="#LinkedHashMap-–-删除注意点" class="headerlink" title="LinkedHashMap – 删除注意点"></a>LinkedHashMap – 删除注意点</h4><p>删除度为2的节点node时（比如删除31）</p><p>需要注意更换 node 与 前驱/后继节点的连接位置</p><p><img src="/2020/07/13/哈希表/6.png" alt></p><h4 id="LinkedHashMap-–-更换节点的连接位置"><a href="#LinkedHashMap-–-更换节点的连接位置" class="headerlink" title="LinkedHashMap – 更换节点的连接位置"></a>LinkedHashMap – 更换节点的连接位置</h4><p><img src="/2020/07/13/哈希表/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换prev</span></span><br><span class="line">LinkedNode&lt;K, V&gt; tmp = node1.prev;</span><br><span class="line">node1.prev = node2.prev;</span><br><span class="line">node2.prev = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node1.prev.next = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node2.prev.next = node2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换next</span></span><br><span class="line">tmp = node1.next;</span><br><span class="line">node1.next = node2.next;</span><br><span class="line">node2.next = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node1.next.prev = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node2.next.prev = node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap代码实现"><a href="#LinkedHashMap代码实现" class="headerlink" title="LinkedHashMap代码实现"></a>LinkedHashMap代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> LinkedNode&lt;K, V&gt; first;</span><br><span class="line"><span class="keyword">private</span> LinkedNode&lt;K, V&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.clear();</span><br><span class="line">first = <span class="keyword">null</span>;</span><br><span class="line">last = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">LinkedNode&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (Objects.equals(value, node.value)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visitor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">LinkedNode&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (visitor.visit(node.key, node.value)) <span class="keyword">return</span>;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;K, V&gt; willNode, Node&lt;K, V&gt; removedNode)</span> </span>&#123;</span><br><span class="line">LinkedNode&lt;K, V&gt; node1 = (LinkedNode&lt;K, V&gt;) willNode;</span><br><span class="line">LinkedNode&lt;K, V&gt; node2 = (LinkedNode&lt;K, V&gt;) removedNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node1 != node2) &#123;</span><br><span class="line"><span class="comment">// 交换linkedWillNode和linkedRemovedNode在链表中的位置</span></span><br><span class="line"><span class="comment">// 交换prev</span></span><br><span class="line">LinkedNode&lt;K, V&gt; tmp = node1.prev;</span><br><span class="line">node1.prev = node2.prev;</span><br><span class="line">node2.prev = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node1.prev.next = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node2.prev.next = node2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换next</span></span><br><span class="line">tmp = node1.next;</span><br><span class="line">node1.next = node2.next;</span><br><span class="line">node2.next = tmp;</span><br><span class="line"><span class="keyword">if</span> (node1.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">last = node1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node1.next.prev = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">last = node2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node2.next.prev = node2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedNode&lt;K, V&gt; prev = node2.prev;</span><br><span class="line">LinkedNode&lt;K, V&gt; next = node2.next;</span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">last = prev;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next.prev = prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line">LinkedNode node = <span class="keyword">new</span> LinkedNode(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">first = last = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">last.next = node;</span><br><span class="line">node.prev = last;</span><br><span class="line">last = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">LinkedNode&lt;K, V&gt; prev;</span><br><span class="line">LinkedNode&lt;K, V&gt; next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(key, value, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希表（HashTable）&quot;&gt;&lt;a href=&quot;#哈希表（HashTable）&quot; class=&quot;headerlink&quot; title=&quot;哈希表（HashTable）&quot;&gt;&lt;/a&gt;哈希表（HashTable）&lt;/h1&gt;&lt;h2 id=&quot;先来分析TreeMap（）&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="映射" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%98%A0%E5%B0%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="映射" scheme="http://yoursite.com/tags/%E6%98%A0%E5%B0%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>映射</title>
    <link href="http://yoursite.com/2020/07/13/%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/13/映射/</id>
    <published>2020-07-13T06:23:56.000Z</published>
    <updated>2020-07-14T08:44:51.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h1><p>Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C、Swift 等）</p><p><img src="/2020/07/13/映射/1.png" alt></p><p><strong>Map 的每一个 key 是唯一的</strong></p><h2 id="Map的接口设计"><a href="#Map的接口设计" class="headerlink" title="Map的接口设计"></a>Map的接口设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> stop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现</p><h2 id="Map利用红黑树实现"><a href="#Map利用红黑树实现" class="headerlink" title="Map利用红黑树实现"></a>Map利用红黑树实现</h2><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;K&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">keyNotNullCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加第一个节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> Node&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">afterPut(root);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加的不是第一个节点</span></span><br><span class="line"><span class="comment">// 找到父节点</span></span><br><span class="line">Node&lt;K, V&gt; parent = root;</span><br><span class="line">Node&lt;K, V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">cmp = compare(key, node.key);</span><br><span class="line">parent = node;</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.right;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">node.key = key;</span><br><span class="line">V oldValue = node.value;</span><br><span class="line">node.value = value;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">parent.right = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent.left = newNode;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">afterPut(newNode);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> remove(node(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.offer(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (valEquals(value, node.value)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visitor == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">traversal(root, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node&lt;K, V&gt; node, Visitor&lt;K, V&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || visitor.stop) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">traversal(node.left, visitor);</span><br><span class="line"><span class="keyword">if</span> (visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">visitor.visit(node.key, node.value);</span><br><span class="line">traversal(node.right, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valEquals</span><span class="params">(V v1, V v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 == <span class="keyword">null</span> ? v2 == <span class="keyword">null</span> : v1.equals(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">size--;</span><br><span class="line"></span><br><span class="line">V oldValue = node.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line"><span class="comment">// 找到后继节点</span></span><br><span class="line">Node&lt;K, V&gt; s = successor(node);</span><br><span class="line"><span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">node.key = s.key;</span><br><span class="line">node.value = s.value;</span><br><span class="line"><span class="comment">// 删除后继节点</span></span><br><span class="line">node = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除node节点（node的度必然是1或者0）</span></span><br><span class="line">Node&lt;K, V&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点</span></span><br><span class="line"><span class="comment">// 更改parent</span></span><br><span class="line">replacement.parent = node.parent;</span><br><span class="line"><span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line"><span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">root = replacement;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">node.parent.left = replacement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">node.parent.right = replacement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点之后的处理</span></span><br><span class="line">afterRemove(replacement);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是叶子节点并且是根节点</span></span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line"><span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点之后的处理</span></span><br><span class="line">afterRemove(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果删除的节点是红色</span></span><br><span class="line"><span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line"><span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">black(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line"><span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line"><span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">Node&lt;K, V&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line"><span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line"><span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">black(sibling);</span><br><span class="line">red(parent);</span><br><span class="line">rotateLeft(parent);</span><br><span class="line"><span class="comment">// 更换兄弟</span></span><br><span class="line">sibling = parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line"><span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line"><span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">black(parent);</span><br><span class="line">red(sibling);</span><br><span class="line"><span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">afterRemove(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line"><span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">rotateRight(sibling);</span><br><span class="line">sibling = parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color(sibling, colorOf(parent));</span><br><span class="line">black(sibling.right);</span><br><span class="line">black(parent);</span><br><span class="line">rotateLeft(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line"><span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">black(sibling);</span><br><span class="line">red(parent);</span><br><span class="line">rotateRight(parent);</span><br><span class="line"><span class="comment">// 更换兄弟</span></span><br><span class="line">sibling = parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line"><span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line"><span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">black(parent);</span><br><span class="line">red(sibling);</span><br><span class="line"><span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">afterRemove(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line"><span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">rotateLeft(sibling);</span><br><span class="line">sibling = parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color(sibling, colorOf(parent));</span><br><span class="line">black(sibling.left);</span><br><span class="line">black(parent);</span><br><span class="line">rotateRight(parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">predecessor</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点在左子树当中（left.right.right.right....）</span></span><br><span class="line">Node&lt;K, V&gt; p = node.left;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">p = p.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line"><span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.left) &#123;</span><br><span class="line">node = node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node.parent == null</span></span><br><span class="line"><span class="comment">// node == node.parent.right</span></span><br><span class="line"><span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">successor</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点在左子树当中（right.left.left.left....）</span></span><br><span class="line">Node&lt;K, V&gt; p = node.right;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">p = p.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line"><span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">node = node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">node</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; node = root;</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = compare(key, node.key);</span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// cmp &lt; 0</span></span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterPut</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">black(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;K, V&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;K, V&gt; grand = red(parent.parent);</span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">black(parent);</span><br><span class="line">black(uncle);</span><br><span class="line"><span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">afterPut(grand);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line"><span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">black(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">black(node);</span><br><span class="line">rotateLeft(parent);</span><br><span class="line">&#125;</span><br><span class="line">rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line"><span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">black(node);</span><br><span class="line">rotateRight(parent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">black(parent);</span><br><span class="line">&#125;</span><br><span class="line">rotateLeft(grand);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; parent = grand.right;</span><br><span class="line">Node&lt;K, V&gt; child = parent.left;</span><br><span class="line">grand.right = child;</span><br><span class="line">parent.left = grand;</span><br><span class="line">afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node&lt;K, V&gt; grand)</span> </span>&#123;</span><br><span class="line">Node&lt;K, V&gt; parent = grand.left;</span><br><span class="line">Node&lt;K, V&gt; child = parent.right;</span><br><span class="line">grand.left = child;</span><br><span class="line">parent.right = grand;</span><br><span class="line">afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRotate</span><span class="params">(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 让parent称为子树的根节点</span></span><br><span class="line">parent.parent = grand.parent;</span><br><span class="line"><span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">grand.parent.left = parent;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">grand.parent.right = parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// grand是root节点</span></span><br><span class="line">root = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新child的parent</span></span><br><span class="line"><span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">child.parent = grand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新grand的parent</span></span><br><span class="line">grand.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">color</span><span class="params">(Node&lt;K, V&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">node.color = color;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">red</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color(node, RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title">black</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : node.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(K e1, K e2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> comparator.compare(e1, e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ((Comparable&lt;K&gt;)e1).compareTo(e2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyNotNullCheck</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key must not be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">boolean</span> color = RED;</span><br><span class="line">Node&lt;K, V&gt; left;</span><br><span class="line">Node&lt;K, V&gt; right;</span><br><span class="line">Node&lt;K, V&gt; parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line"><span class="keyword">return</span> parent.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line"><span class="keyword">return</span> parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;映射（Map）&quot;&gt;&lt;a href=&quot;#映射（Map）&quot; class=&quot;headerlink&quot; title=&quot;映射（Map）&quot;&gt;&lt;/a&gt;映射（Map）&lt;/h1&gt;&lt;p&gt;Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="映射" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%98%A0%E5%B0%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="映射" scheme="http://yoursite.com/tags/%E6%98%A0%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="http://yoursite.com/2020/07/13/%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/07/13/集合/</id>
    <published>2020-07-13T06:14:53.000Z</published>
    <updated>2020-07-14T08:43:48.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h1><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p><strong>不存放重复的元素，常用于去重</strong></p><p>存放新增 IP，统计新增 IP 量</p><p>存放词汇，统计词汇量</p><h2 id="集合接口定义"><a href="#集合接口定义" class="headerlink" title="集合接口定义"></a>集合接口定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Visitor&lt;E&gt; visitor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> stop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合的内部实现直接利用学过的数据结构实现<strong>（链表，动态数组，红黑树、AVL树）</strong></p><h2 id="集合利用链表实现"><a href="#集合利用链表实现" class="headerlink" title="集合利用链表实现"></a>集合利用链表实现</h2><a href="/2020/07/11/链表/" title="链表的实现">链表的实现</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> list.contains(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = list.indexOf(element);</span><br><span class="line"><span class="keyword">if</span> (index != List.ELEMENT_NOT_FOUND) &#123; <span class="comment">// 存在就覆盖</span></span><br><span class="line">list.set(index, element);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在就添加</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = list.indexOf(element);</span><br><span class="line"><span class="keyword">if</span> (index != List.ELEMENT_NOT_FOUND) &#123;</span><br><span class="line">list.remove(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合利用红黑树实现"><a href="#集合利用红黑树实现" class="headerlink" title="集合利用红黑树实现"></a>集合利用红黑树实现</h2><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> RBTree&lt;E&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">tree = <span class="keyword">new</span> RBTree&lt;&gt;(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tree.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tree.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tree.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tree.contains(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">tree.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">tree.remove(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合（Set）&quot;&gt;&lt;a href=&quot;#集合（Set）&quot; class=&quot;headerlink&quot; title=&quot;集合（Set）&quot;&gt;&lt;/a&gt;集合（Set）&lt;/h1&gt;&lt;h2 id=&quot;集合的特点&quot;&gt;&lt;a href=&quot;#集合的特点&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="集合" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2020/07/12/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/红黑树/</id>
    <published>2020-07-12T05:44:00.000Z</published>
    <updated>2020-07-14T08:43:41.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red Black Tree）"></a>红黑树（Red Black Tree）</h1><h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>红黑树也是一种<strong>自平衡的二叉搜索树</strong></p><p>以前也叫做平衡二叉B树（Symmetric Binary B-tree）</p><p>红黑树必须满足以下 <strong>5 条性质</strong></p><ol><li><p>节点是 <strong>RED</strong> 或者 <strong>BLACK</strong></p></li><li><p>根节点是 <strong>BLACK</strong></p></li><li><p>叶子节点（外部节点，空节点）都是 <strong>BLACK</strong></p></li><li><p><strong>RED</strong> 节点的子节点都是 <strong>BLACK</strong></p><p><strong>RED</strong> 节点的 parent 都是 <strong>BLACK</strong></p><p>从根节点到叶子节点的所有路径上不能有 2 个连续的 <strong>RED</strong> 节点</p></li><li><p>从任一节点到叶子节点的所有路径都包含相同数目的 <strong>BLACK</strong> 节点</p></li></ol><p><img src="/2020/07/12/红黑树/1.png" alt></p><h2 id="红黑树的等价变换"><a href="#红黑树的等价变换" class="headerlink" title="红黑树的等价变换"></a>红黑树的等价变换</h2><p>红黑树 和 4阶B树（2-3-4树）具有等价性</p><p><strong>BLACK</strong> 节点与它的 <strong>RED</strong> 子节点融合在一起，形成1个B树节点</p><p>红黑树的 <strong>BLACK</strong> 节点个数 与 4阶B树的节点总个数相等</p><p><strong>注意：后面展示的红黑树都会省略 NULL 节点</strong></p><p><img src="/2020/07/12/红黑树/2.png" alt></p><h2 id="红黑树-vs-2-3-4树"><a href="#红黑树-vs-2-3-4树" class="headerlink" title="红黑树 vs 2-3-4树"></a>红黑树 vs 2-3-4树</h2><p><img src="/2020/07/12/红黑树/3.png" alt></p><p>如果上图最底层的 <strong>BLACK</strong> 节点是不存在的，在B树中是什么样的情形？</p><p><strong>整棵B树只有1个节点，而且是超级节点</strong></p><h2 id="一些辅助函数"><a href="#一些辅助函数" class="headerlink" title="一些辅助函数"></a>一些辅助函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent：父节点</span></span><br><span class="line"><span class="comment">// sibling：兄弟节点</span></span><br><span class="line"><span class="comment">// uncle：叔父节点（parent 的兄弟节点）</span></span><br><span class="line"><span class="comment">// grand：祖父节点（parent 的父节点）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">color</span><span class="params">(Node&lt;E&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">   ((RBNode&lt;E&gt;)node).color = color;</span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染红</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">red</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> color(node, RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染黑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">black</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : ((RBNode&lt;E&gt;)node).color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是黑色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是红色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否有兄弟节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的添加"><a href="#红黑树的添加" class="headerlink" title="红黑树的添加"></a>红黑树的添加</h2><p>已知</p><ol><li><p>B树中，新元素必定是添加到叶子节点中</p></li><li><p>4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3</p></li></ol><p><strong>建议新添加的节点默认为 RED</strong>，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定）</p><h3 id="有-4-种情况满足红黑树的性质-4-：parent-为BLACK"><a href="#有-4-种情况满足红黑树的性质-4-：parent-为BLACK" class="headerlink" title="有 4 种情况满足红黑树的性质 4 ：parent 为BLACK"></a>有 4 种情况满足红黑树的性质 4 ：parent 为BLACK</h3><p>同样也满足4阶B树的性质</p><p>因此不用做任何额外处理</p><p><img src="/2020/07/12/红黑树/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h3 id="有-8-种情况不满足红黑树的性质-4-：parent-为-RED（-Double-Red-）"><a href="#有-8-种情况不满足红黑树的性质-4-：parent-为-RED（-Double-Red-）" class="headerlink" title="有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）"></a>有 8 种情况不满足红黑树的性质 4 ：parent 为 <strong>RED</strong>（ <strong>Double</strong> <strong>Red</strong> ）</h3><p>其中前 4 种属于B树节点上溢的情况</p><p><img src="/2020/07/12/红黑树/5.png" alt></p><h4 id="添加-–-修复性质4-–-LL-RR"><a href="#添加-–-修复性质4-–-LL-RR" class="headerlink" title="添加 – 修复性质4 – LL\RR"></a>添加 – 修复性质4 – LL\RR</h4><p>判定条件：uncle 不是 <strong>RED</strong></p><p>1.parent 染成 <strong>BLACK</strong>，grand 染成 <strong>RED</strong></p><p>2.grand 进行单旋操作</p><p>LL：右旋转</p><p>RR：左旋转</p><p><img src="/2020/07/12/红黑树/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点染成红色</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">    <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">        black(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">    <span class="keyword">if</span> (!node.isLeftChild()) &#123; <span class="comment">// RR</span></span><br><span class="line">        black(parent);</span><br><span class="line">    &#125; </span><br><span class="line">    rotateLeft(grand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-LR-RL"><a href="#添加-–-修复性质4-–-LR-RL" class="headerlink" title="添加 – 修复性质4 – LR\RL"></a>添加 – 修复性质4 – LR\RL</h4><p>判定条件：uncle 不是 <strong>RED</strong></p><ol><li><p>自己染成 <strong>BLACK</strong>，grand 染成 <strong>RED</strong></p></li><li><p>进行双旋操作</p></li></ol><p>LR：parent 左旋转， grand 右旋转</p><p>RL：parent 右旋转， grand 左旋转</p><p><img src="/2020/07/12/红黑树/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点染成红色</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">   <span class="keyword">if</span> (!node.isLeftChild()) &#123; <span class="comment">// LR</span></span><br><span class="line">      black(node);</span><br><span class="line">      rotateLeft(parent);</span><br><span class="line">   &#125;</span><br><span class="line">   rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">   <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">      black(node);</span><br><span class="line">      rotateRight(parent);</span><br><span class="line">   &#125;</span><br><span class="line">   rotateLeft(grand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-LL"><a href="#添加-–-修复性质4-–-上溢-–-LL" class="headerlink" title="添加 – 修复性质4 – 上溢 – LL"></a>添加 – 修复性质4 – 上溢 – LL</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p>grand 向上合并时，可能继续发生上溢</p><p>若上溢持续到根节点，只需将根节点染成 <strong>BLACK</strong></p><p><img src="/2020/07/12/红黑树/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    black(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">   black(parent);</span><br><span class="line">   black(uncle);</span><br><span class="line">   <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">   afterAdd(grand);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-RR"><a href="#添加-–-修复性质4-–-上溢-–-RR" class="headerlink" title="添加 – 修复性质4 – 上溢 – RR"></a>添加 – 修复性质4 – 上溢 – RR</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">   black(parent);</span><br><span class="line">   black(uncle);</span><br><span class="line">   <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">   afterAdd(grand);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-LR"><a href="#添加-–-修复性质4-–-上溢-–-LR" class="headerlink" title="添加 – 修复性质4 – 上溢 – LR"></a>添加 – 修复性质4 – 上溢 – LR</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/10.png" alt></p><h4 id="添加-–-修复性质4-–-上溢-–-RL"><a href="#添加-–-修复性质4-–-上溢-–-RL" class="headerlink" title="添加 – 修复性质4 – 上溢 – RL"></a>添加 – 修复性质4 – 上溢 – RL</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/11.png" alt></p><h2 id="红黑树添加后完整修复的代码"><a href="#红黑树添加后完整修复的代码" class="headerlink" title="红黑树添加后完整修复的代码"></a>红黑树添加后完整修复的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterAdd</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   Node&lt;E&gt; parent = node.parent;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">      black(node);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 叔父节点</span></span><br><span class="line">   Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line">   <span class="comment">// 祖父节点</span></span><br><span class="line">   Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line">   <span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">      black(parent);</span><br><span class="line">      black(uncle);</span><br><span class="line">      <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">      afterAdd(grand);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 叔父节点不是红色</span></span><br><span class="line">   <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">         black(parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">         black(node);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">      &#125;</span><br><span class="line">      rotateRight(grand);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">         black(node);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">         black(parent);</span><br><span class="line">      &#125;</span><br><span class="line">      rotateLeft(grand);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p><strong>B树中，最后真正被删除的元素都在叶子节点中</strong></p><p><img src="/2020/07/12/红黑树/12.png" alt></p><h3 id="删除-–-RED节点"><a href="#删除-–-RED节点" class="headerlink" title="删除 – RED节点"></a>删除 – RED节点</h3><p>直接删除，不用作任何调整</p><p><img src="/2020/07/12/红黑树/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node)) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-–-BLACK节点"><a href="#删除-–-BLACK节点" class="headerlink" title="删除 – BLACK节点"></a>删除 – BLACK节点</h3><p>有 3 种情况</p><ol><li><p>拥有 2 个 <strong>RED</strong> 子节点的 <strong>BLACK</strong> 节点</p><p>不可能被直接删除，因为会找它的子节点替代删除</p><p>因此不用考虑这种情况</p></li><li><p>拥有 1 个 <strong>RED</strong> 子节点的 <strong>BLACK</strong> 节点</p></li><li><p><strong>BLACK</strong> 叶子节点</p></li></ol><p><strong>下文举例采用: 被删除的节点在右边，兄弟节点在左边，（反之交换左右方向即可）</strong></p><p><img src="/2020/07/12/红黑树/14.png" alt></p><h4 id="删除-拥有-1-个-RED-子节点的-BLACK-节点"><a href="#删除-拥有-1-个-RED-子节点的-BLACK-节点" class="headerlink" title="删除 - 拥有 1 个 RED 子节点的 BLACK 节点"></a>删除 - 拥有 1 个 RED 子节点的 BLACK 节点</h4><p>判定条件：用以替代的子节点是 <strong>RED</strong></p><p>将替代的子节点染成 <strong>BLACK</strong> 即可保持红黑树性质</p><p><img src="/2020/07/12/红黑树/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用以取代node的子节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(replacement)) &#123;</span><br><span class="line">        black(replacement);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为BLACK-sibling-至少有-1-个-RED-子节点"><a href="#删除-BLACK-叶子节点-sibling为BLACK-sibling-至少有-1-个-RED-子节点" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 RED 子节点"></a>删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 <strong>RED</strong> 子节点</h4><p><strong>BLACK</strong> 叶子节点被删除后，会导致B树节点下溢（比如删除88）</p><p>如果 sibling 至少有 1 个 <strong>RED</strong> 子节点<strong>（一个或两个RED子节点）</strong></p><p><strong>兄弟节点的左边是黑色，(没有子节点也算是黑色)</strong></p><ol><li><p>兄弟节点左旋</p></li><li><p>改变兄弟节点为parent的左边</p></li><li><p>后续再按<strong>兄弟节点的左边是红色</strong>执行即可</p></li></ol><p><img src="/2020/07/12/红黑树/17.png" alt></p><p><strong>兄弟节点的左边是红色</strong></p><ol><li><p>兄弟节点继承 parent 的颜色</p></li><li><p>兄弟节点的左边变成黑色</p></li><li><p>parent节点变成黑色</p></li><li><p>parent右旋</p></li></ol><p><img src="/2020/07/12/红黑树/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line">            </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling)) &#123; <span class="comment">// 兄弟节点是黑色</span></span><br><span class="line">            <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(sibling.left) || isRed(sibling.right)) &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">                    rotateLeft(sibling);</span><br><span class="line">                    sibling = parent.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 兄弟节点的左边是红色或兄弟旋转后</span></span><br><span class="line">                color(sibling, colorOf(parent));</span><br><span class="line">                black(sibling.left);</span><br><span class="line">                black(parent);</span><br><span class="line">                rotateRight(parent);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为BLACK-sibling-没有-1-个-RED-子节点"><a href="#删除-BLACK-叶子节点-sibling为BLACK-sibling-没有-1-个-RED-子节点" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 RED 子节点"></a>删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 <strong>RED</strong> 子节点</h4><p>判定条件：sibling 没有 1 个 <strong>RED</strong> 子节点</p><p>将 sibling 染成 <strong>RED</strong>、parent 染成 <strong>BLACK</strong> 即可修复红黑树性质</p><p>如果 parent 是 <strong>BLACK</strong></p><p>会导致 parent 也下溢</p><p>这时只需要把 parent 当做被删除的节点处理即可</p><p><img src="/2020/07/12/红黑树/18.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="comment">// 兄弟节点是黑色</span></span><br><span class="line">        <span class="keyword">if</span>(isBlack(sibling))&#123;</span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">                <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">                black(parent);</span><br><span class="line">                red(sibling);</span><br><span class="line">                <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                    afterRemove(parent, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为RED"><a href="#删除-BLACK-叶子节点-sibling为RED" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为RED"></a>删除 - BLACK 叶子节点 - sibling为RED</h4><p>如果 sibling 是 <strong>RED</strong></p><p>sibling 染成 <strong>BLACK</strong>，parent 染成 <strong>RED</strong>，进行旋转</p><p>于是又回到 sibling 是 <strong>BLACK</strong> 的情况</p><p><img src="/2020/07/12/红黑树/19.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树删除后完整修复的代码"><a href="#红黑树删除后完整修复的代码" class="headerlink" title="红黑树删除后完整修复的代码"></a>红黑树删除后完整修复的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">   <span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line">   <span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">      black(node);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Node&lt;E&gt; parent = node.parent;</span><br><span class="line">   <span class="comment">// 删除的是根节点</span></span><br><span class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">   <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">   <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">   Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">   <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">         black(sibling);</span><br><span class="line">         red(parent);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">         <span class="comment">// 更换兄弟</span></span><br><span class="line">         sibling = parent.right;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">      <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">         <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">         <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">         black(parent);</span><br><span class="line">         red(sibling);</span><br><span class="line">         <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">            afterRemove(parent);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">         <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">         <span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">            rotateRight(sibling);</span><br><span class="line">            sibling = parent.right;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         color(sibling, colorOf(parent));</span><br><span class="line">         black(sibling.right);</span><br><span class="line">         black(parent);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">         black(sibling);</span><br><span class="line">         red(parent);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">         <span class="comment">// 更换兄弟</span></span><br><span class="line">         sibling = parent.left;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">      <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">         <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">         <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">         black(parent);</span><br><span class="line">         red(sibling);</span><br><span class="line">         <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">            afterRemove(parent);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">         <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">         <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">            rotateLeft(sibling);</span><br><span class="line">            sibling = parent.left;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         color(sibling, colorOf(parent));</span><br><span class="line">         black(sibling.left);</span><br><span class="line">         black(parent);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的平衡"><a href="#红黑树的平衡" class="headerlink" title="红黑树的平衡"></a>红黑树的平衡</h2><p>为何那5条性质，就能保证红黑树是平衡的？</p><p>那5条性质，可以保证红黑树等价于4阶B树</p><p><img src="/2020/07/12/红黑树/20.png" alt></p><p>相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍</p><p>是一种弱平衡、黑高度平衡</p><p>红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是 O(logn) 级别</p><h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h2><p>搜索：O(logn)</p><p>添加：O(logn)，O(1) 次的旋转操作</p><p>删除：O(logn)，O(1) 次的旋转操作</p><h2 id="AVL树-vs-红黑树"><a href="#AVL树-vs-红黑树" class="headerlink" title="AVL树 vs 红黑树"></a>AVL树 vs 红黑树</h2><p><strong>AVL树</strong>  <a href="/2020/07/12/AVL树/" title="AVL树的实现">AVL树的实现</a></p><p>平衡标准比较严格：<strong>每个左右子树的高度差不超过1</strong></p><p>最大高度是 1.44  ∗ log2  n + 2 − 1.328（100W个节点，AVL树最大树高28）</p><p>搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整</p><p><strong>红黑树</strong></p><p>平衡标准比较宽松：<strong>没有一条路径会大于其他路径的2倍</strong></p><p>最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40）</p><p>搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整</p><p><strong>总结</strong></p><p>搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树</p><p>相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树</p><p>红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树</p><h2 id="BST-vs-AVL-Tree-vs-Red-Black-Tree"><a href="#BST-vs-AVL-Tree-vs-Red-Black-Tree" class="headerlink" title="BST vs AVL Tree vs Red Black Tree"></a>BST vs AVL Tree vs Red Black Tree</h2><p>10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96</p><p><img src="/2020/07/12/红黑树/21.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红黑树（Red-Black-Tree）&quot;&gt;&lt;a href=&quot;#红黑树（Red-Black-Tree）&quot; class=&quot;headerlink&quot; title=&quot;红黑树（Red Black Tree）&quot;&gt;&lt;/a&gt;红黑树（Red Black Tree）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="http://yoursite.com/2020/07/12/B%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/B树/</id>
    <published>2020-07-12T05:43:47.000Z</published>
    <updated>2020-07-14T08:47:21.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B树（B-tree、B-树）"><a href="#B树（B-tree、B-树）" class="headerlink" title="B树（B - tree、B - 树）"></a>B树（B - tree、B - 树）</h2><p>​    B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现</p><h3 id="B树特点"><a href="#B树特点" class="headerlink" title="B树特点"></a>B树特点</h3><ul><li><p>1个节点可以存储超过 2 个元素、可以拥有超过 2 个子节点</p></li><li><p>拥有二叉搜索树的一些性质</p></li><li><p>平衡，每个节点的所有子树高度一致</p></li><li><p>比较矮</p></li></ul><p><img src="/2020/07/12/B树/1.png" alt></p><h3 id="m阶B树的性质（m≥2）"><a href="#m阶B树的性质（m≥2）" class="headerlink" title="m阶B树的性质（m≥2）"></a>m阶B树的性质（m≥2）</h3><p>假设一个节点存储的元素个数为 x</p><ol><li><p>根节点：1 ≤ x ≤ m − 1</p></li><li><p>非根节点：┌ m/2 ┐ − 1 ≤ x ≤ m − 1</p></li><li><p>如果有子节点，子节点个数 y = x + 1</p></li></ol><ul><li><p>根节点：2 ≤ y ≤ m</p></li><li><p>非根节点：┌ m/2 ┐ ≤ y ≤ m</p></li><li><p>比如 m = 3，2 ≤ y ≤ 3，因此可以称为（2, 3）树、2-3树</p></li><li><p>比如 m = 4，2 ≤ y ≤ 4，因此可以称为（2, 4）树、2-3-4树</p></li><li><p>比如 m = 5，3 ≤ y ≤ 5，因此可以称为（3, 5）树</p></li><li><p>比如 m = 6，3 ≤ y ≤ 6，因此可以称为（3, 6）树</p></li><li><p>比如 m = 7，4 ≤ y ≤ 7，因此可以称为（4, 7）树</p></li></ul><h3 id="B树-VS-二叉搜索树"><a href="#B树-VS-二叉搜索树" class="headerlink" title="B树 VS 二叉搜索树"></a>B树 VS 二叉搜索树</h3><p>B树和二叉搜索树，在逻辑上是等价的</p><p>多代节点合并，可以获得一个超级节点</p><p>2代合并的超级节点，最多拥有 4 个子节点（至少是 4阶B树）</p><p>3代合并的超级节点，最多拥有 8 个子节点（至少是 8阶B树）</p><p>n代合并的超级节点，最多拥有 2n个子节点（ 至少是 2n阶B树）</p><p>m阶B树，最多需要 log2m 代合并</p><h3 id="B树的搜索"><a href="#B树的搜索" class="headerlink" title="B树的搜索"></a>B树的搜索</h3><p>跟二叉搜索树的搜索类似</p><p><img src="/2020/07/12/B树/2.png" alt></p><ol><li><p>先在节点内部从小到大开始搜索元素</p></li><li><p>如果命中，搜索结束</p></li><li><p>如果未命中，再去对应的子节点中搜索元素，重复步骤 1</p></li></ol><h3 id="B树的添加"><a href="#B树的添加" class="headerlink" title="B树的添加"></a>B树的添加</h3><p>新添加的元素必定是添加到叶子节点</p><p>插入55</p><p><img src="/2020/07/12/B树/3.png" alt></p><p>插入95</p><p><img src="/2020/07/12/B树/4.png" alt></p><p>再插入 98 呢？（假设这是一棵 4阶B树）</p><p>最右下角的叶子节点的元素个数将超过限制</p><p>这种现象可以称之为：<strong>上溢（overflow）</strong></p><h4 id="添加-–-上溢的解决-假设5阶"><a href="#添加-–-上溢的解决-假设5阶" class="headerlink" title="添加 – 上溢的解决(假设5阶)"></a>添加 – 上溢的解决(假设5阶)</h4><p><strong>上溢节点的元素个数必然等于m</strong></p><p>假设上溢节点最中间元素的位置为k</p><p>将 k 位置的元素向上与父节点合并</p><p>将 [0, k-1] 和 [k + 1, m - 1] 位置的元素分裂成 2 个子节点</p><p>这 2 个子节点的元素个数，必然都不会低于最低限制（┌ m/2 ┐ − 1）</p><p>一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决</p><p>最极端的情况，有可能一直分裂到根节点</p><p><img src="/2020/07/12/B树/5.png" alt></p><p><img src="/2020/07/12/B树/6.png" alt></p><h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3><h4 id="删除-–-叶子节点"><a href="#删除-–-叶子节点" class="headerlink" title="删除 – 叶子节点"></a>删除 – 叶子节点</h4><p>假如需要删除的元素在叶子节点中，那么直接删除即可</p><p><img src="/2020/07/12/B树/7.png" alt></p><h4 id="删除-–-非叶子节点"><a href="#删除-–-非叶子节点" class="headerlink" title="删除 – 非叶子节点"></a>删除 – 非叶子节点</h4><p>假如需要删除的元素在非叶子节点中</p><ol><li><p>先找到前驱或后继元素，覆盖所需删除元素的值</p></li><li><p>再把前驱或后继元素删除</p></li></ol><p><img src="/2020/07/12/B树/8.png" alt></p><p>非叶子节点的前驱或后继元素，必定在叶子节点中</p><p>所以这里的删除前驱或后继元素 ，就是最开始提到的情况：删除的元素在叶子节点中</p><p><strong>真正的删除元素都是发生在叶子节点中</strong></p><h4 id="删除-–-下溢"><a href="#删除-–-下溢" class="headerlink" title="删除 – 下溢"></a>删除 – 下溢</h4><p>删除 22 ？（假设这是一棵 5阶B树）</p><p>叶子节点被删掉一个元素后，元素个数可能会低于最低限制（ ≥ ┌ m/2 ┐ − 1 ）</p><p>这种现象称为：<strong>下溢（underflow）</strong></p><p><img src="/2020/07/12/B树/9.png" alt></p><h4 id="删除-–-下溢的解决"><a href="#删除-–-下溢的解决" class="headerlink" title="删除 – 下溢的解决"></a>删除 – 下溢的解决</h4><p><strong>下溢节点的元素数量必然等于 ┌ m/2 ┐ − 2</strong></p><ol><li><p>如果下溢节点临近的兄弟节点，有至少 ┌ m/2 ┐ 个元素，可以向其借一个元素</p><p>将父节点的元素 b 插入到下溢节点的 0 位置（最小位置）</p><p>用兄弟节点的元素 a（最大的元素）替代父节点的元素 b</p><p>这种操作其实就是：旋转</p></li></ol><p><img src="/2020/07/12/B树/10.png" alt></p><ol><li><p>如果下溢节点临近的兄弟节点，只有 ┌ m/2 ┐ − 1 个元素</p><p>将父节点的元素 b 挪下来跟左右子节点进行合并</p><p>合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1</p><p>这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播</p></li></ol><p><img src="/2020/07/12/B树/11.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解B树的性质后，就可以来学习红黑树了</p><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;B树（B-tree、B-树）&quot;&gt;&lt;a href=&quot;#B树（B-tree、B-树）&quot; class=&quot;headerlink&quot; title=&quot;B树（B - tree、B - 树）&quot;&gt;&lt;/a&gt;B树（B - tree、B - 树）&lt;/h2&gt;&lt;p&gt;​    B树是一种平衡的多
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://yoursite.com/2020/07/12/AVL%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/AVL树/</id>
    <published>2020-07-12T05:43:33.000Z</published>
    <updated>2020-07-14T08:42:20.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>AVL树是最早发明的自平衡二叉搜索树之一</p><p>AVL 取名于两位发明者的名字</p><p><strong>G. M. Adelson-Velsky 和 E. M. Landis</strong>（来自苏联的科学家）</p><h3 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h3><p><strong>平衡因子</strong>（Balance Factor）：某结点的左右子树的高度差</p><ol><li><p>每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”）</p></li><li><p>每个节点的左右子树高度差不超过 1</p></li><li><p>搜索、添加、删除的时间复杂度是 O(logn)</p></li></ol><p><img src="/2020/07/12/AVL树/1.png" alt></p><h3 id="平衡对比"><a href="#平衡对比" class="headerlink" title="平衡对比"></a>平衡对比</h3><p>输入数据：35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82</p><p><img src="/2020/07/12/AVL树/2.png" alt></p><h3 id="简单的继承结构"><a href="#简单的继承结构" class="headerlink" title="简单的继承结构"></a>简单的继承结构</h3><a href="/2020/07/11/二叉树/" title="二叉树的实现">二叉树的实现</a> <a href="/2020/07/12/二叉搜索树/" title="二叉搜索树的实现">二叉搜索树的实现</a><p><img src="/2020/07/12/AVL树/3.png" alt></p><h3 id="平衡修复"><a href="#平衡修复" class="headerlink" title="平衡修复"></a>平衡修复</h3><h4 id="添加导致的失衡"><a href="#添加导致的失衡" class="headerlink" title="添加导致的失衡"></a>添加导致的失衡</h4><p>示例：往下面这棵子树中添加 13</p><p>最坏情况：可能会导致所有祖先节点都失衡</p><p>父节点、非祖先节点，都不可能失衡</p><p><img src="/2020/07/12/AVL树/4.png" alt></p><h5 id="LL-–-右旋转（R单旋）——-LL（n在g的LL）"><a href="#LL-–-右旋转（R单旋）——-LL（n在g的LL）" class="headerlink" title="LL – 右旋转（R单旋）——- LL（n在g的LL）"></a>LL – 右旋转（R单旋）——- LL（n在g的LL）</h5><p><img src="/2020/07/12/AVL树/5.png" alt></p><p><strong>g.left = p.right</strong></p><p><strong>p.right = g</strong></p><p><strong>让p成为这棵子树的根节点</strong></p><p>仍然是一棵二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3，整棵树都达到平衡</p><p>还需要注意维护的内容，T2、p、g 的 parent 属性，先后更新 g、p 的高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换子树</span></span><br><span class="line">    Node&lt;E&gt; parent = grand.left;</span><br><span class="line">    Node&lt;E&gt; child = parent.right;</span><br><span class="line">    grand.left = child;</span><br><span class="line">    parent.right = grand;</span><br><span class="line">    <span class="comment">// 维护parent和height</span></span><br><span class="line">    afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RR-–-左旋转（L单旋）——-RR（n在g的RR）"><a href="#RR-–-左旋转（L单旋）——-RR（n在g的RR）" class="headerlink" title="RR – 左旋转（L单旋）——- RR（n在g的RR）"></a>RR – 左旋转（L单旋）——- RR（n在g的RR）</h5><p><img src="/2020/07/12/AVL树/6.png" alt></p><p><strong>g.right = p.left</strong></p><p><strong>p.left = g</strong></p><p><strong>让p成为这棵子树的根节点</strong></p><p>仍然是一棵二叉搜索树：T0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3，整棵树都达到平衡</p><p>还需要注意维护的内容，T1、p、g 的 parent 属性，先后更新 g、p 的高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换子树</span></span><br><span class="line">    Node&lt;E&gt; parent = grand.right;</span><br><span class="line">    Node&lt;E&gt; child = parent.left;</span><br><span class="line">    grand.right = child;</span><br><span class="line">    parent.left = grand;</span><br><span class="line">    <span class="comment">// 维护parent和height</span></span><br><span class="line">    afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LR-–-RR左旋转，LL右旋转（双旋）——-LR（n在g的LR）"><a href="#LR-–-RR左旋转，LL右旋转（双旋）——-LR（n在g的LR）" class="headerlink" title="LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR）"></a>LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR）</h5><p><img src="/2020/07/12/AVL树/7.png" alt></p><h5 id="RL-–-LL右旋转，RR左旋转（双旋）——-RL（n在g的RL）"><a href="#RL-–-LL右旋转，RR左旋转（双旋）——-RL（n在g的RL）" class="headerlink" title="RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL）"></a>RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL）</h5><p><img src="/2020/07/12/AVL树/8.png" alt></p><h5 id="旋转之后的修复"><a href="#旋转之后的修复" class="headerlink" title="旋转之后的修复"></a>旋转之后的修复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共代码：不管是左旋转、右旋转，都要执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grand 失衡节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 失衡节点的tallerChild</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child g和p 需要交换的子树（本来是p的子树，后面会变成g的子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRotate</span><span class="params">(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 让parent称为子树的根节点</span></span><br><span class="line">   parent.parent = grand.parent;</span><br><span class="line">   <span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">      grand.parent.left = parent;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">      grand.parent.right = parent;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// grand是root节点</span></span><br><span class="line">      root = parent;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 更新child的parent</span></span><br><span class="line">   <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      child.parent = grand;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 更新grand的parent</span></span><br><span class="line">   grand.parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的节点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; left;</span><br><span class="line">    Node&lt;E&gt; right;</span><br><span class="line">    Node&lt;E&gt; parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有兄弟节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AVL树节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AVLNode</span><span class="params">(E element, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(element, parent);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 每个节点的平衡因子只可能是 1、0、-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balanceFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> leftHeight = left == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">      <span class="keyword">int</span> rightHeight = right == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">      <span class="keyword">return</span> leftHeight - rightHeight;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 更新树高</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> leftHeight = left == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">      <span class="keyword">int</span> rightHeight = right == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">      height = <span class="number">1</span> + Math.max(leftHeight, rightHeight);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 返回树高的子节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">tallerChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> leftHeight = left == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">      <span class="keyword">int</span> rightHeight = right == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">      <span class="keyword">if</span> (leftHeight &gt; rightHeight) <span class="keyword">return</span> left;</span><br><span class="line">      <span class="keyword">if</span> (leftHeight &lt; rightHeight) <span class="keyword">return</span> right;</span><br><span class="line">      <span class="keyword">return</span> isLeftChild() ? left : right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加之后的修复"><a href="#添加之后的修复" class="headerlink" title="添加之后的修复"></a>添加之后的修复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterAdd</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ((node = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBalanced(node)) &#123;</span><br><span class="line">         <span class="comment">// 更新高度</span></span><br><span class="line">         updateHeight(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 恢复平衡</span></span><br><span class="line">         rebalance(node);</span><br><span class="line">         <span class="comment">// 整棵树恢复平衡</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断是否平衡"><a href="#判断是否平衡" class="headerlink" title="判断是否平衡"></a>判断是否平衡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查看树的高度"><a href="#查看树的高度" class="headerlink" title="查看树的高度"></a>查看树的高度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   ((AVLNode&lt;E&gt;)node).updateHeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="恢复平衡"><a href="#恢复平衡" class="headerlink" title="恢复平衡"></a>恢复平衡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grand 高度最低的不平衡节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalance</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild();</span><br><span class="line">    Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild();</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">            rotateRight(grand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">            rotateRight(grand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            rotateLeft(grand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">            rotateLeft(grand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>输入数据：13, 14, 15, 12, 11, 17, 16, 8, 9,1</p><p><img src="/2020/07/12/AVL树/9.png" alt></p><p><img src="/2020/07/12/AVL树/10.png" alt></p><h5 id="统一所有旋转操作的实现"><a href="#统一所有旋转操作的实现" class="headerlink" title="统一所有旋转操作的实现"></a>统一所有旋转操作的实现</h5><p><img src="/2020/07/12/AVL树/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; r, // 子树的根节点</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; b, Node&lt;E&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; d,</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; e, Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 让d成为这棵子树的根节点</span></span><br><span class="line">   d.parent = r.parent;</span><br><span class="line">   <span class="keyword">if</span> (r.isLeftChild()) &#123;</span><br><span class="line">      r.parent.left = d;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.isRightChild()) &#123;</span><br><span class="line">      r.parent.right = d;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root = d;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//b-c</span></span><br><span class="line">   b.right = c;</span><br><span class="line">   <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">      c.parent = b;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// e-f</span></span><br><span class="line">   f.left = e;</span><br><span class="line">   <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      e.parent = f;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// b-d-f</span></span><br><span class="line">   d.left = b;</span><br><span class="line">   d.right = f;</span><br><span class="line">   b.parent = d;</span><br><span class="line">   f.parent = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grand 高度最低的那个不平衡节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalance</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">   Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild();</span><br><span class="line">   Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild();</span><br><span class="line">   <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">         rotate(grand, node, node.right, parent, parent.right, grand);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">         rotate(grand, parent, node.left, node, node.right, grand);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">         rotate(grand, grand, node.left, node, node.right, parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">         rotate(grand, grand, parent.left, parent, node.left, node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除导致的失衡"><a href="#删除导致的失衡" class="headerlink" title="删除导致的失衡"></a>删除导致的失衡</h4><p>示例：删除子树中的 16</p><p>可能会导致父节点或祖先节点失衡（只有1个节点会失衡），其他节点，都不可能失衡</p><p><img src="/2020/07/12/AVL树/12.png" alt></p><h5 id="LL-–-右旋转（单旋）"><a href="#LL-–-右旋转（单旋）" class="headerlink" title="LL – 右旋转（单旋）"></a>LL – 右旋转（单旋）</h5><p>如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡…</p><p>极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整</p><p><img src="/2020/07/12/AVL树/13.png" alt></p><h5 id="RR-–-左旋转（单旋）"><a href="#RR-–-左旋转（单旋）" class="headerlink" title="RR – 左旋转（单旋）"></a>RR – 左旋转（单旋）</h5><p><img src="/2020/07/12/AVL树/14.png" alt></p><h5 id="LR-–-RR左旋转，LL右旋转（双旋）"><a href="#LR-–-RR左旋转，LL右旋转（双旋）" class="headerlink" title="LR – RR左旋转，LL右旋转（双旋）"></a>LR – RR左旋转，LL右旋转（双旋）</h5><p><img src="/2020/07/12/AVL树/15.png" alt></p><h5 id="RL-–-LL右旋转，RR左旋转（双旋）"><a href="#RL-–-LL右旋转，RR左旋转（双旋）" class="headerlink" title="RL – LL右旋转，RR左旋转（双旋）"></a>RL – LL右旋转，RR左旋转（双旋）</h5><p><img src="/2020/07/12/AVL树/16.png" alt></p><h5 id="删除之后的修复"><a href="#删除之后的修复" class="headerlink" title="删除之后的修复"></a>删除之后的修复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ((node = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBalanced(node)) &#123;</span><br><span class="line">         <span class="comment">// 更新高度</span></span><br><span class="line">         updateHeight(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 恢复平衡</span></span><br><span class="line">         rebalance(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>添加</p><p>可能会导致所有祖先节点都失衡</p><p>只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需 O(1) 次调整】</p></li><li><p>删除</p><p>可能会导致父节点或祖先节点失衡（只有1个节点会失衡）</p><p>恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要 O(logn) 次调整】</p></li><li><p>平均时间复杂度</p><p>搜索：O(logn)</p><p>添加：O(logn)，仅需 O(1) 次的旋转操作</p><p>删除：O(logn)，最多需要 O(logn) 次的旋转操作</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;&lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/2020/07/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/二叉搜索树/</id>
    <published>2020-07-12T04:37:53.000Z</published>
    <updated>2020-07-14T08:43:19.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>在 n 个动态的整数中搜索某个整数？（查看其是否存在）</p><p>假设使用动态数组存放元素，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n)</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">31</td><td style="text-align:center">66</td><td style="text-align:center">17</td><td style="text-align:center">15</td><td style="text-align:center">28</td><td style="text-align:center">20</td><td style="text-align:center">59</td><td style="text-align:center">88</td><td style="text-align:center">45</td><td style="text-align:center">56</td></tr></tbody></table></div><ul><li><p>如果维护一个有序的动态数组，使用二分搜索，最坏时间复杂度：O(logn)</p><p>但是添加、删除的平均时间复杂度是 O(n)</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">20</td><td style="text-align:center">28</td><td style="text-align:center">31</td><td style="text-align:center">45</td><td style="text-align:center">56</td><td style="text-align:center">59</td><td style="text-align:center">66</td><td style="text-align:center">88</td></tr></tbody></table></div><ul><li><p>针对这个需求，有没有更好的方案？</p><p>使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)​</p></li></ul><h3 id="什么是二叉搜索树（Binary-Search-Tree）"><a href="#什么是二叉搜索树（Binary-Search-Tree）" class="headerlink" title="什么是二叉搜索树（Binary Search Tree）"></a>什么是二叉搜索树<strong>（Binary</strong> <strong>Search</strong> <strong>Tree）</strong></h3><ol><li><p>二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST，又被称为：二叉查找树、二叉排序树</p><ul><li><p>任意一个节点的值都大于其左子树所有节点的值</p></li><li><p>任意一个节点的值都小于其右子树所有节点的值</p></li><li><p>它的左右子树也是一棵二叉搜索树</p></li></ul></li><li><p>二叉搜索树可以大大提高搜索数据的效率</p></li><li><p>二叉搜索树存储的元素必须具备可比较性</p><ul><li><p>比如 int、double 等</p></li><li><p>如果是自定义类型，需要指定比较方式</p></li><li><p>不允许为 null</p></li></ul></li></ol><p><img src="/2020/07/12/二叉搜索树/1.png" alt></p><h3 id="二叉搜索树的接口设计"><a href="#二叉搜索树的接口设计" class="headerlink" title="二叉搜索树的接口设计"></a>二叉搜索树的接口设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="comment">// 元素的数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span><span class="comment">// 是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">// 清空所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> <span class="comment">// 添加元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span><span class="comment">// 删除元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> <span class="comment">// 是否包含某元素</span></span></span><br></pre></td></tr></table></figure><p>需要注意的是</p><p>对于我们现在使用的二叉树来说，它的元素没有索引的概念</p><h4 id="元素的比较方案设计"><a href="#元素的比较方案设计" class="headerlink" title="元素的比较方案设计"></a>元素的比较方案设计</h4><ol><li><p>允许外界传入一个 Comparator 自定义比较方案</p></li><li><p>如果没有传入 Comparator，强制认定元素实现了 Comparable 接口</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(e1, e2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((Comparable&lt;E&gt;)e1).compareTo(e2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据元素内容获取节点"><a href="#根据元素内容获取节点" class="headerlink" title="根据元素内容获取节点"></a>根据元素内容获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(element, node.element);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// cmp &lt; 0</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = createNode(element, <span class="keyword">null</span>);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">        afterAdd(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的不是第一个节点</span></span><br><span class="line">    <span class="comment">// 找到父节点</span></span><br><span class="line">    Node&lt;E&gt; parent = root;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cmp = compare(element, node.element);</span><br><span class="line">        parent = node;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            node.element = element;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;E&gt; newNode = createNode(element, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">    afterAdd(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><h5 id="删除节点-–-叶子节点（分析）"><a href="#删除节点-–-叶子节点（分析）" class="headerlink" title="删除节点 – 叶子节点（分析）"></a>删除节点 – 叶子节点（分析）</h5><p><img src="/2020/07/12/二叉搜索树/2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接删除</span></span><br><span class="line"><span class="number">1</span>. node == node.parent.left</span><br><span class="line">node.parent.left = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. node == node.parent.right</span><br><span class="line">node.parent.right = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. node.parent == <span class="keyword">null</span></span><br><span class="line">root = <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h5 id="删除节点-度为1的节点（分析）"><a href="#删除节点-度为1的节点（分析）" class="headerlink" title="删除节点 - 度为1的节点（分析）"></a>删除节点 - 度为1的节点（分析）</h5><p><img src="/2020/07/12/二叉搜索树/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用子节点替代原节点的位置</span></span><br><span class="line">child 是 node.left 或 者 child 是 node.right</span><br><span class="line">用 child 替代 node 的位置</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 如果 node 是左子节点</span><br><span class="line">child.parent = node.parent</span><br><span class="line">node.parent.left = child</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 如果 node 是右子节点</span><br><span class="line">child.parent = node.parent</span><br><span class="line">node.parent.right = child</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 如果 node 是根节点</span><br><span class="line">root = child</span><br><span class="line">child.parent = <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h5 id="删除节点-度为2的节点（分析）"><a href="#删除节点-度为2的节点（分析）" class="headerlink" title="删除节点 - 度为2的节点（分析）"></a>删除节点 - 度为2的节点（分析）</h5><p><img src="/2020/07/12/二叉搜索树/4.png" alt></p><p>举例：先删除 5、再删除 4</p><p>先用前驱或者后继节点的值覆盖原节点的值</p><p>然后删除相应的前驱或者后继节点</p><p><strong>如果一个节点的度为 2，那么，它的前驱、后继节点的度只可能是 1 和 0</strong></p><a href="/2020/07/11/二叉树/" title="二叉树的前驱、后继实现">二叉树的前驱、后继实现</a><h5 id="删除节点（代码实现）"><a href="#删除节点（代码实现）" class="headerlink" title="删除节点（代码实现）"></a>删除节点（代码实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断节点是否有两个叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   size--;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 找到度为二节点的后继节点覆盖后，将后继节点s作为度为1的节点执行后面的操作</span></span><br><span class="line">   <span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line">      <span class="comment">// 找到后继节点</span></span><br><span class="line">      Node&lt;E&gt; s = successor(node);</span><br><span class="line">      <span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">      node.element = s.element;</span><br><span class="line">      <span class="comment">// 删除后继节点,使用后面的代码删除度为1的节点</span></span><br><span class="line">      node = s;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 删除node节点（node的度必然是1或者0）</span></span><br><span class="line">   <span class="comment">// 判断node节点有左节点还是右节点，也可能没有节点</span></span><br><span class="line">   Node&lt;E&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点</span></span><br><span class="line">      <span class="comment">// 更改parent</span></span><br><span class="line">      replacement.parent = node.parent;</span><br><span class="line">      <span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line">      <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">         root = replacement;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">         node.parent.left = replacement;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">         node.parent.right = replacement;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">      afterRemove(replacement);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是叶子节点并且是根节点</span></span><br><span class="line">      root = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">      afterRemove(node);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">      <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">         node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">         node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">      afterRemove(node);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的复杂度分析"><a href="#二叉搜索树的复杂度分析" class="headerlink" title="二叉搜索树的复杂度分析"></a>二叉搜索树的复杂度分析</h3><p><img src="/2020/07/12/二叉搜索树/5.png" alt>当 n 比较大时，两者的性能差异比较大</p><p>比如 n = 1000000 时，二叉搜索树的最低高度是 20</p><h4 id="退化成链表的另一种情况"><a href="#退化成链表的另一种情况" class="headerlink" title="退化成链表的另一种情况"></a>退化成链表的另一种情况</h4><p><img src="/2020/07/12/二叉搜索树/6.png" alt></p><p>有没有办法防止二叉搜索树退化成链表？</p><p>让添加、删除、搜索的复杂度维持在 O(logn)</p><h4 id="平衡（Balance）"><a href="#平衡（Balance）" class="headerlink" title="平衡（Balance）"></a>平衡（Balance）</h4><p>平衡：当节点数量固定时，左右子树的高度越接近，这棵二叉树就越平衡（高度越低）</p><p><img src="/2020/07/12/二叉搜索树/7.png" alt></p><h4 id="理想平衡"><a href="#理想平衡" class="headerlink" title="理想平衡"></a>理想平衡</h4><p>最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的</p><p><img src="/2020/07/12/二叉搜索树/8.png" alt></p><h3 id="如何改进二叉搜索树？"><a href="#如何改进二叉搜索树？" class="headerlink" title="如何改进二叉搜索树？"></a>如何改进二叉搜索树？</h3><p>首先，节点的添加、删除顺序是无法限制的，可以认为是随机的</p><p>所以，改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）</p><p><img src="/2020/07/12/二叉搜索树/9.png" alt></p><p>如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大</p><p>比如调整的次数会比较多，反而增加了时间复杂度</p><p>总结来说，比较合理的改进方案是：用尽量少的调整次数达到适度平衡即可</p><p>一棵达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树</p><h3 id="平衡二叉搜索树（Balanced-Binary-Search-Tree）"><a href="#平衡二叉搜索树（Balanced-Binary-Search-Tree）" class="headerlink" title="平衡二叉搜索树（Balanced Binary Search Tree）"></a>平衡二叉搜索树（Balanced Binary Search Tree）</h3><p>英文简称为：BBST</p><p>经典常见的平衡二叉搜索树有</p><ol><li><p>AVL树</p><ul><li>Windows NT 内核中广泛使用</li></ul></li><li><p>红黑树</p><ul><li><p>C++ STL（比如 map、set ）</p></li><li><p>Java 的 TreeMap、TreeSet、HashMap、HashSet</p></li><li><p>Linux 的进程调度</p></li><li><p>Ngix 的 timer 管理</p></li></ul></li></ol><p>一般也称它们为：自平衡的二叉搜索树（Self-balancing Binary Search Tree）</p><a href="/2020/07/12/AVL树/" title="AVL树的实现">AVL树的实现</a><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h2&gt;&lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2020/07/11/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/11/二叉树/</id>
    <published>2020-07-11T08:12:38.000Z</published>
    <updated>2020-07-14T08:43:10.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树（Tree）的基本概念"><a href="#树（Tree）的基本概念" class="headerlink" title="树（Tree）的基本概念"></a>树（Tree）的基本概念</h3><ul><li><p>节点、根节点、父节点、子节点、兄弟节点</p></li><li><p>一棵树可以没有任何节点，称为空树</p></li><li><p>一棵树可以只有 1 个节点，也就是只有根节点</p></li><li><p>子树、左子树、右子树</p></li><li><p>节点的度（degree）：子树的个数</p></li><li><p>树的度：所有节点度中的最大值</p></li><li><p>叶子节点（leaf）：度为 0 的节点</p></li><li><p>非叶子节点：度不为 0 的节点</p></li><li><p>层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算）</p></li><li><p>节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数</p></li><li><p>节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数</p></li><li><p>树的深度：所有节点深度中的最大值</p></li><li><p>树的高度：所有节点高度中的最大值</p></li><li><p>树的深度 等于 树的高度</p></li></ul><h3 id="有序树、无序树、森林"><a href="#有序树、无序树、森林" class="headerlink" title="有序树、无序树、森林"></a>有序树、无序树、森林</h3><ol><li><p>有序树</p><p>树中任意节点的子节点之间有顺序关系</p></li><li><p>无序树，也称为“自由树”</p><p>树中任意节点的子节点之间没有顺序关系</p></li><li><p>森林</p><p>由 m（m ≥ 0）棵互不相交的树组成的集合</p></li></ol><h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><ul><li><p>每个节点的度最大为 2（最多拥有 2 棵子树）</p></li><li><p>左子树和右子树是有顺序的</p></li><li><p>即使某节点只有一棵子树，也要区分左右子树</p></li></ul><p><img src="/2020/07/11/二叉树/1.png" alt></p><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ul><li><p>非空二叉树的第 $i$ 层，最多有 $2^{i − 1}$个节点 （ $i \geq 1$）</p></li><li><p>在高度为 h 的二叉树上最多有 $2^h − 1 $个结点（$h  \geq 1$ ）</p></li></ul><p>对于任何一棵非空二叉树，如果叶子节点个数为 $n0$，度为 $2$ 的节点个数为 $ n2$，则有: $n0 = n2 + 1$</p><p>假设度为$ 1 $的节点个数为 $n1$，那么二叉树的节点总数 $ n = n0 + n1 + n2$</p><p>二叉树的边数 $ T = n1 + 2 * n2 = n – 1 = n0 + n1 + n2 – 1$</p><p>因此 $ n0 = n2 + 1$</p><p><img src="/2020/07/11/二叉树/2.png" alt></p><h4 id="真二叉树（Proper-Binary-Tree）"><a href="#真二叉树（Proper-Binary-Tree）" class="headerlink" title="真二叉树（Proper Binary Tree）"></a>真二叉树（Proper Binary Tree）</h4><p>真二叉树：所有节点的度都要么为 0，要么为 2 </p><p><img src="/2020/07/11/二叉树/3.png" alt></p><h4 id="满二叉树（Full-Binary-Tree）"><a href="#满二叉树（Full-Binary-Tree）" class="headerlink" title="满二叉树（Full Binary Tree）"></a>满二叉树（Full Binary Tree）</h4><p>最后一层节点的度都为 $0$，其他节点的度都为 $2$</p><p>在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多</p><p>满二叉树一定是真二叉树，真二叉树不一定是满二叉树</p><p><img src="/2020/07/11/二叉树/4.png" alt></p><p>假设满二叉树的高度为 $h（ h ≥ 1 ）$，那么</p><p>第 i 层的节点数量：$ 2i − 1$ ， 叶子节点数量： $2h − 1$ ， 总节点数量$ n$</p><p>$n = 2h − 1 = 20 + 21 + 22 + ⋯ + 2h−1$</p><p>$h = log2(n + 1)$</p><h4 id="完全二叉树（Complete-Binary-Tree）"><a href="#完全二叉树（Complete-Binary-Tree）" class="headerlink" title="完全二叉树（Complete Binary Tree）"></a>完全二叉树（Complete Binary Tree）</h4><p>对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应</p><ul><li><p>叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐</p></li><li><p>完全二叉树从根结点至倒数第 2 层是一棵满二叉树</p></li><li><p>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</p></li></ul><p><img src="/2020/07/11/二叉树/5.png" alt></p><h5 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h5><ul><li><p>度为 1 的节点只有左子树</p></li><li><p>度为 1 的节点要么是 1 个，要么是 0 个</p></li><li><p>同样节点数量的二叉树，完全二叉树的高度最小</p></li></ul><ol><li><p>假设完全二叉树的高度为 $h（ h ≥ 1 ）$，那么</p><p>​    至少有 $2h − 1$ 个节点 $（ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−2} + 1 ）$</p><p>​    最多有 $2h − 1$ 个节点（$ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−1}$，满二叉树 ）</p><p>​    总节点数量为 $n$</p><p>​    $2^{h − 1} ≤ n &lt; 2^h    $</p><p>​    $h − 1 ≤ log_2n &lt; h$</p><p>​    $h = floor( log_2n ) + 1$</p><p>​    $floor $是向下取整，另外，$ceiling $是向上取整</p></li><li><p>一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $ 1$ 开始进行编号，对任意第 $ i $ 个节点</p><p>​    如果 $i = 1$，它是根节点</p><p>​    如果 $i &gt; 1$ ，它的父节点编号为 $floor( i / 2 )$</p><p>​    如果 $2i ≤ n$ ，它的左子节点编号为 $2i$</p><p>​    如果 $2i &gt; n$ ，它无左子节点</p><p>​    如果 $2i + 1 ≤ n$ ，它的右子节点编号为 $2i + 1$</p><p>​    如果 $2i + 1 &gt; n$ ，它无右子节点</p></li><li><p>一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $0$ 开始进行编号，对任意第 $i$ 个节点</p><p>​    如果 $i = 0$ ，它是根节点</p><p>​    如果 $i &gt; 0$ ，它的父节点编号为 $floor( (i – 1) / 2 )$</p><p>​    如果 $2i + 1 ≤ n – 1$ ，它的左子节点编号为 $2i + 1$</p><p>​    如果 $2i + 1 &gt; n – 1$ ，它无左子节点</p><p>​    如果 $2i + 2 ≤ n – 1$ ，它的右子节点编号为 $2i + 2$</p><p>​    如果 $2i + 2 &gt; n – 1$ ，它无右子节点</p></li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>如果一棵完全二叉树有 $768$ 个节点，求叶子节点的个数</strong></p><ol><li><p>假设叶子节点个数为 $n0$，度为 $1$ 的节点个数为 $n1$，度为 $2$ 的节点个数为 $n2$</p><p>总结点个数 $n = n0 + n1 + n2$，而且 $n0 = n2 + 1$</p><p>$n = 2n0 + n1 – 1$</p></li><li><p><strong>完全二叉树的 $n1$ 要么为 $0$，要么为 $1$</strong></p><p>$n1$为 $1$ 时，$n = 2n0$，$n$ 必然是偶数</p><p>叶子节点个数 $n0 = n / 2$，非叶子节点个数 $n1 + n2 = n / 2$</p><p>$n1$为 $0$ 时，$n = 2n0 – 1$，$n$ 必然是奇数</p><p>叶子节点个数 $n0 = (n + 1) / 2$，非叶子节点个数 $n1 + n2 = (n – 1) / 2$</p></li><li><p>叶子节点个数 $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$</p><p>非叶子节点个数 $n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )$</p><p>因此叶子节点个数为 $384$</p></li></ol><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的常见遍历方式有4种</p><ul><li><p>前序遍历（Preorder Traversal）</p></li><li><p>中序遍历（Inorder Traversal）</p></li><li><p>后序遍历（Postorder Traversal）</p></li><li><p>层序遍历（Level Order Traversal）</p></li></ul><h4 id="前序遍历（Preorder-Traversal）"><a href="#前序遍历（Preorder-Traversal）" class="headerlink" title="前序遍历（Preorder Traversal）"></a>前序遍历（Preorder Traversal）</h4><p>访问顺序</p><p>根节点、前序遍历左子树、前序遍历右子树</p><p>7、4、2、1、3、5、9、8、11、10、12</p><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/二叉树/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">   preorder(node.left);</span><br><span class="line">   preorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归，利用栈实现"><a href="#非递归，利用栈实现" class="headerlink" title="非递归，利用栈实现"></a>非递归，利用栈实现</h5><p><img src="/2020/07/11/二叉树/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将 root 入 栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 循环执行以下操作，直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出栈顶节点 top，进行访问</span></span><br><span class="line">        Node&lt;E&gt; node = stack.pop();</span><br><span class="line">        <span class="comment">// 访问node节点</span></span><br><span class="line">        System.out.println(node.element);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 top.right 入 栈</span></span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 top.left 入 栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（Inorder-Traversal）"><a href="#中序遍历（Inorder-Traversal）" class="headerlink" title="中序遍历（Inorder Traversal）"></a>中序遍历（Inorder Traversal）</h4><p>访问顺序</p><p>中序遍历左子树、根节点、中序遍历右子树</p><p>1、2、3、4、5、7、8、9、10、11、12</p><h5 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/二叉树/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归，利用栈实现-1"><a href="#非递归，利用栈实现-1" class="headerlink" title="非递归，利用栈实现"></a>非递归，利用栈实现</h5><p><img src="/2020/07/11/二叉树/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Visitor&lt;E&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置 node = root</span></span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">// 向左走</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()) &#123; <span class="comment">// 如果栈为空，结束遍历</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 如果栈不为空，弹出栈顶元素并赋值给 node</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="comment">// 访问node节点</span></span><br><span class="line">            System.out.println(node.element);</span><br><span class="line">            <span class="comment">// 让右节点进行中序遍历</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（Postorder-Traversal）"><a href="#后序遍历（Postorder-Traversal）" class="headerlink" title="后序遍历（Postorder Traversal）"></a>后序遍历（Postorder Traversal）</h4><p>访问顺序</p><p>后序遍历左子树、后序遍历右子树、根节点</p><p>1、3、2、5、4、8、10、12、11、9、7</p><h5 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/二叉树/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(node.left);</span><br><span class="line">    postorder(node.right);</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归，利用栈实现-2"><a href="#非递归，利用栈实现-2" class="headerlink" title="非递归，利用栈实现"></a>非递归，利用栈实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 记录上一次弹出访问的节点</span></span><br><span class="line">    Node&lt;E&gt; prev = <span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将 root 入 栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 循环执行以下操作，直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 查看栈顶元素，不删除</span></span><br><span class="line">        Node&lt;E&gt; top = stack.peek();</span><br><span class="line">        <span class="comment">// 如果栈顶节点是叶子节点 或者 上一次访问的节点是栈顶节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (top.isLeaf() || (prev != <span class="keyword">null</span> &amp;&amp; prev.parent == top)) &#123;</span><br><span class="line">            <span class="comment">// 定义prev，下次再遇到，不会再入栈，避免重复访问</span></span><br><span class="line">            prev = stack.pop();</span><br><span class="line">            <span class="comment">// 访问节点</span></span><br><span class="line">            System.out.println(prev.element);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历（Level-Order-Traversal）"><a href="#层序遍历（Level-Order-Traversal）" class="headerlink" title="层序遍历（Level Order Traversal）"></a>层序遍历（Level Order Traversal）</h4><p>访问顺序</p><p>从上到下、从左到右依次访问每一个节点</p><p>7、4、9、2、5、8、11、1、3、10、12</p><h5 id="非递归，利用队列实现"><a href="#非递归，利用队列实现" class="headerlink" title="非递归，利用队列实现"></a>非递归，利用队列实现</h5><p><img src="/2020/07/11/二叉树/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将根节点入队</span></span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行以下操作，直到队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将队头节点 A 出队，进行访问</span></span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        System.out.println(node.element);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将右子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h3><ul><li><p>前序遍历</p><p>树状结构展示（注意左右子树的顺序）</p></li><li><p>中序遍历</p><p>二叉搜索树的中序遍历按升序或者降序处理节点</p></li><li><p>后序遍历</p><p>适用于一些先子后父的操作</p></li><li><p>层序遍历</p><p>计算二叉树的高度</p><p>判断一棵树是否为完全二叉树</p></li></ul><h3 id="根据遍历结果重构二叉树"><a href="#根据遍历结果重构二叉树" class="headerlink" title="根据遍历结果重构二叉树"></a>根据遍历结果重构二叉树</h3><p>以下结果可以保证重构出唯一的一棵二叉树</p><ul><li><p>前序遍历 + 中序遍历</p></li><li><p>后序遍历 + 中序遍历</p></li></ul><p><img src="/2020/07/11/二叉树/12.png" alt></p><p>前序遍历 + 后序遍历</p><p>​    如果它是一棵真二叉树（Proper Binary Tree），结果是唯一的，不然结果不唯一</p><p><img src="/2020/07/11/二叉树/13.png" alt></p><h4 id="前序遍历-中序遍历重构二叉树"><a href="#前序遍历-中序遍历重构二叉树" class="headerlink" title="前序遍历+中序遍历重构二叉树"></a>前序遍历+中序遍历重构二叉树</h4><p>前序遍历：4 2 1 3 6 5</p><p>中序遍历：1 2 3 4 5 6</p><p><img src="/2020/07/11/二叉树/14.png" alt></p><h3 id="前驱、后继节点"><a href="#前驱、后继节点" class="headerlink" title="前驱、后继节点"></a>前驱、后继节点</h3><h4 id="前驱节点（predecessor）"><a href="#前驱节点（predecessor）" class="headerlink" title="前驱节点（predecessor）"></a>前驱节点（predecessor）</h4><p>前驱节点：中序遍历时的前一个节点</p><p>如果是二叉搜索树，前驱节点就是前一个比它小的节点</p><p><img src="/2020/07/11/二叉树/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;E&gt; <span class="title">predecessor</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点在左子树当中（left.right.right.right....）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node.left != null时</span></span><br><span class="line">    <span class="comment">// 举例：6-》5、13-》12、8-》7</span></span><br><span class="line">    <span class="comment">// predecessor = node.left.right.right.right...</span></span><br><span class="line">    Node&lt;E&gt; p = node.left;</span><br><span class="line">    <span class="comment">// 终止条件：right 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line">    <span class="comment">// node.left == null &amp;&amp; node.parent != null</span></span><br><span class="line">    <span class="comment">// 举例：7-》6、11-》10、9-》8</span></span><br><span class="line">    <span class="comment">// predecessor = node.parent.parent.parent...</span></span><br><span class="line">    <span class="comment">// 终止条件：node 在 parent 的右子树中</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.left) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.left == null &amp;&amp; node.parent == null</span></span><br><span class="line">    <span class="comment">// 那就没有前驱节点</span></span><br><span class="line">    <span class="comment">// 举例：没有左子树的根节点 1 </span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后继节点（successor）"><a href="#后继节点（successor）" class="headerlink" title="后继节点（successor）"></a>后继节点（successor）</h4><p>后继节点：中序遍历时的后一个节点</p><p>如果是二叉搜索树，后继节点就是后一个比它大的节点</p><p><img src="/2020/07/11/二叉树/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;E&gt; <span class="title">successor</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点在左子树当中（right.left.left.left....）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node.right != null</span></span><br><span class="line">    <span class="comment">// 举例：1、8、4、10</span></span><br><span class="line">    <span class="comment">// successor = node.right.left.left.left...</span></span><br><span class="line">    Node&lt;E&gt; p = node.right;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 终止条件：left 为 null</span></span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.right == null &amp;&amp; node.parent != null</span></span><br><span class="line">    <span class="comment">// 举例：6、3、11</span></span><br><span class="line">    <span class="comment">// successor = node.parent.parent.parent...</span></span><br><span class="line">    <span class="comment">// 终止条件：node 在 parent 的左子树中</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.right == null &amp;&amp; node.parent == null</span></span><br><span class="line">    <span class="comment">// 那就没有前驱节点</span></span><br><span class="line">    <span class="comment">// 举例：没有右子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算二叉树的高度"><a href="#计算二叉树的高度" class="headerlink" title="计算二叉树的高度"></a>计算二叉树的高度</h3><h4 id="非递归，利用队列实现-1"><a href="#非递归，利用队列实现-1" class="headerlink" title="非递归，利用队列实现"></a>非递归，利用队列实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的高度</span></span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存储着每一层的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> levelSize = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        levelSize--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (levelSize == <span class="number">0</span>) &#123; <span class="comment">// 意味着即将要访问下一层</span></span><br><span class="line">            levelSize = queue.size();</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(node.left), height(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/二叉树/17.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        </span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;树（Tree）的基本概念&quot;&gt;&lt;a href=&quot;#树（Tree）的基本概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://yoursite.com/2020/07/11/%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/11/队列/</id>
    <published>2020-07-11T07:55:14.000Z</published>
    <updated>2020-07-14T08:42:56.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>队列是一种特殊的线性表，只能在头尾两端进行操作</p><p>队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队</p><p>队头（front）：只能从队头移除元素，一般叫做 deQueue，出队</p><p>先进先出的原则，First In First Out，FIFO</p><p><img src="/2020/07/11/队列/1.png" alt></p><h3 id="队列的代码实现"><a href="#队列的代码实现" class="headerlink" title="队列的代码实现"></a>队列的代码实现</h3><p>队列的内部实现可以直接利用<strong>动态数组、链表</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">// 清空</span></span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123; <span class="comment">//入队</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123; <span class="comment">// 出队</span></span><br><span class="line"><span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取队首元素，不删除</span></span><br><span class="line"><span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列（Deque）"><a href="#双端队列（Deque）" class="headerlink" title="双端队列（Deque）"></a>双端队列（Deque）</h2><p>双端队列是能在头尾两端添加、删除的队列，英文 deque 是 double ended queue 的简称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">// 清空</span></span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueRear</span><span class="params">(E element)</span> </span>&#123; <span class="comment">// 从队尾入队</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueFront</span><span class="params">()</span> </span>&#123; <span class="comment">// 从队头出队</span></span><br><span class="line"><span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueFront</span><span class="params">(E element)</span> </span>&#123; <span class="comment">// 从队头入队</span></span><br><span class="line">list.add(<span class="number">0</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueRear</span><span class="params">()</span> </span>&#123; <span class="comment">// 从队尾出队</span></span><br><span class="line"><span class="keyword">return</span> list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取队列的头元素</span></span><br><span class="line"><span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">rear</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取队列的尾元素</span></span><br><span class="line"><span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列（Circle-Queue）"><a href="#循环队列（Circle-Queue）" class="headerlink" title="循环队列（Circle Queue）"></a>循环队列（Circle Queue）</h2><p>可以进行两端添加、删除操作的循环队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">elements[index(i)] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">elements[index(size)] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">E frontElement = elements[front];</span><br><span class="line">elements[front] = <span class="keyword">null</span>;</span><br><span class="line">front = index(<span class="number">1</span>);</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> frontElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">index += front;</span><br><span class="line"><span class="keyword">return</span> index - (index &gt;= elements.length ? elements.length : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证要有capacity的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">newElements[i] = elements[index(i)];</span><br><span class="line">&#125;</span><br><span class="line">elements = newElements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置front</span></span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环双端队列"><a href="#循环双端队列" class="headerlink" title="循环双端队列"></a>循环双端队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleDeque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">elements[index(i)] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾部入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueRear</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">elements[index(size)] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">E frontElement = elements[front];</span><br><span class="line">elements[front] = <span class="keyword">null</span>;</span><br><span class="line">front = index(<span class="number">1</span>);</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> frontElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueFront</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">front = index(-<span class="number">1</span>);</span><br><span class="line">elements[front] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾部出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rearIndex = index(size - <span class="number">1</span>);</span><br><span class="line">E rear = elements[rearIndex];</span><br><span class="line">elements[rearIndex] = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[index(size - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">index += front;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> index + elements.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index - (index &gt;= elements.length ? elements.length : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证要有capacity的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">newElements[i] = elements[index(i)];</span><br><span class="line">&#125;</span><br><span class="line">elements = newElements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置front</span></span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;队列（Queue）&quot;&gt;&lt;a href=&quot;#队列（Queue）&quot; class=&quot;headerlink&quot; title=&quot;队列（Queue）&quot;&gt;&lt;/a&gt;队列（Queue）&lt;/h2&gt;&lt;h3 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://yoursite.com/2020/07/11/%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/11/栈/</id>
    <published>2020-07-11T07:31:28.000Z</published>
    <updated>2020-07-14T08:45:06.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h2><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>栈是一种特殊的线性表，只能在一端进行操作</p><p>往栈中添加元素的操作，一般叫做 push，入栈</p><p>从栈中移除元素的操作，一般叫做 pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素）</p><p><strong>后进先出</strong>的原则，Last In First Out，LIFO</p><p><img src="/2020/07/11/栈/1.png" alt></p><p><strong>注意：这里说的“栈”与内存中的“栈空间”是两个不同的概念</strong></p><h3 id="栈的代码实现"><a href="#栈的代码实现" class="headerlink" title="栈的代码实现"></a>栈的代码实现</h3><p>栈的内部实现可以直接利用<strong>动态数组、链表</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">// 清空</span></span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E element)</span> </span>&#123; <span class="comment">// 入栈</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">// 出栈</span></span><br><span class="line"><span class="keyword">return</span> list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取栈顶元素，不删除</span></span><br><span class="line"><span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h4><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/栈/2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">// 判断是否是左边，是就入栈</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左边出栈，进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">char</span> left = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (c != map.get(left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h4><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/栈/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 入栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 出栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkOutStack();</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 得到栈顶元素，不删除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkOutStack();</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkOutStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈（stack）&quot;&gt;&lt;a href=&quot;#栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（stack）&quot;&gt;&lt;/a&gt;栈（stack）&lt;/h2&gt;&lt;h3 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yoursite.com/2020/07/11/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/11/链表/</id>
    <published>2020-07-11T04:54:11.000Z</published>
    <updated>2020-07-14T08:43:58.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h2><h3 id="为什么有链表"><a href="#为什么有链表" class="headerlink" title="为什么有链表"></a>为什么有链表</h3><p>动态数组有个明显的缺点，可能会造成<strong>内存空间的大量浪费</strong></p><p>能否用到多少就申请多少内存？</p><p>链表可以办到这一点</p><p><strong>链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的</strong></p><p><img src="/2020/07/11/链表/1.png" alt></p><h3 id="链表的设计"><a href="#链表的设计" class="headerlink" title="链表的设计"></a>链表的设计</h3><p><img src="/2020/07/11/链表/2.png" alt></p><h4 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h4><p>链表的大部分接口和动态数组是一致的</p><p><img src="/2020/07/11/链表/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不存在在返回-1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取index位置的元素</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置index位置的元素</span></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在index位置插入一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除index位置的元素</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测传入的下标是否合法"><a href="#检测传入的下标是否合法" class="headerlink" title="检测传入的下标是否合法"></a>检测传入的下标是否合法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">outOfBounds</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index:"</span> + index + <span class="string">", Size:"</span> + size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        outOfBounds(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        outOfBounds(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="node方法用于获取index位置的节点"><a href="#node方法用于获取index位置的节点" class="headerlink" title="node方法用于获取index位置的节点"></a>node方法用于获取index位置的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    Node&lt;E&gt; node = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"><span class="comment">// element新节点的值，next新节点指向的下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加元素-add-int-index-E-element"><a href="#添加元素-add-int-index-E-element" class="headerlink" title="添加元素-add(int index,E element)"></a>添加元素-add(int index,E element)</h4><p><img src="/2020/07/11/链表/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">add(size, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在编写链表过程中，要注意边界测试，比如 index 为 0 、size – 0 、size 时</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;&gt;(element,first);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 找到插入下标的上一个元素</span></span><br><span class="line">        Node&lt;E&gt; prev = node(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 新创建的节点指向原先prev.next（如上图：1指向2）,再将prev.next指向新节点（如上图：0指向1）</span></span><br><span class="line">        prev.next = <span class="keyword">new</span> Node&lt;&gt;(element,prev.next);</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="/2020/07/11/链表/5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">rangeCheck(index);</span><br><span class="line">Node&lt;E&gt; node = first;</span><br><span class="line">    <span class="comment">// 注意0位置</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">first = first.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 找到待删除元素上一个元素的下标</span></span><br><span class="line">Node&lt;E&gt; prev = node(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// node待删除的元素</span></span><br><span class="line">node = prev.next;</span><br><span class="line">prev.next = node.next;</span><br><span class="line">&#125;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> node.element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// next不需要设置为null</span></span><br><span class="line">first = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表中某个元素的下标"><a href="#判断链表中某个元素的下标" class="headerlink" title="判断链表中某个元素的下标"></a>判断链表中某个元素的下标</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表中允许有null值元素</span></span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node&lt;E&gt; node = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.element == <span class="keyword">null</span>) <span class="keyword">return</span> i;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(node.element)) <span class="keyword">return</span> i;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ELEMENT_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表中是否包含某个元素"><a href="#判断链表中是否包含某个元素" class="headerlink" title="判断链表中是否包含某个元素"></a>判断链表中是否包含某个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(E element) &#123;</span><br><span class="line">return indexOf(element) != ELEMENT_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>使用双向链表可以提升链表的综合性能</p><p><img src="/2020/07/11/链表/14.png" alt></p><h3 id="node方法用于获取index位置的节点-1"><a href="#node方法用于获取index位置的节点-1" class="headerlink" title="node方法用于获取index位置的节点"></a>node方法用于获取index位置的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 分两条路寻找节点</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>))&#123;</span><br><span class="line">        Node&lt;E&gt; node = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; node = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            node = node.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节点-1"><a href="#创建节点-1" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素-add-int-index-E-element-1"><a href="#添加元素-add-int-index-E-element-1" class="headerlink" title="添加元素-add(int index,E element)"></a>添加元素-add(int index,E element)</h3><p><img src="/2020/07/11/链表/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">add(size, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">if</span> (index == size)&#123;</span><br><span class="line">        Node&lt;E&gt; oldLast = last;</span><br><span class="line">        last = <span class="keyword">new</span> Node&lt;&gt;(oldLast,element,<span class="keyword">null</span>);</span><br><span class="line">        oldLast.next = last;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;E&gt; next = node(index);</span><br><span class="line">        Node&lt;E&gt; prev = next.prev;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(prev,element,next);</span><br><span class="line">        next.prev = node;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素-–-remove-int-index"><a href="#删除元素-–-remove-int-index" class="headerlink" title="删除元素 – remove(int index)"></a>删除元素 – remove(int index)</h3><p><img src="/2020/07/11/链表/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; node = node(index);</span><br><span class="line">    Node&lt;E&gt; prev = node.prev;</span><br><span class="line">    Node&lt;E&gt; next = node.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> node.element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表-vs-单向链表"><a href="#双向链表-vs-单向链表" class="headerlink" title="双向链表 vs 单向链表"></a>双向链表 vs 单向链表</h2><p>粗略对比一下删除的操作数量</p><p>单向链表： $1+2+3+…+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$  ${n^2} \over {2}$， 除以$n$ 平均一下是 ${1} \over {2}$ + ${n} \over {2}$</p><p>双向链表：$(1+2+3+…+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ，除以$n$平均一下是 ${1} \over {2}$ + ${n} \over{4}$</p><p>操作数量缩减了近一半</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h4 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h4><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/链表/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转一个链表"><a href="#反转一个链表" class="headerlink" title="反转一个链表"></a>反转一个链表</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/链表/7.png" alt></p><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/链表/8.png" alt></p><p><img src="/2020/07/11/链表/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 定义新的头节点</span></span><br><span class="line">    ListNode newHead = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归-–-头插法"><a href="#非递归-–-头插法" class="headerlink" title="非递归 – 头插法"></a><strong>非递归</strong> <strong>–</strong> 头插法</h5><p><img src="/2020/07/11/链表/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode tmp = head.next;</span><br><span class="line">        <span class="comment">// 每次遍历让head.next成为头节点</span></span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        <span class="comment">// head重新指向tmp，使循环按顺序继续遍历</span></span><br><span class="line">        head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断一个链表是否有环"><a href="#判断一个链表是否有环" class="headerlink" title="判断一个链表是否有环"></a>判断一个链表是否有环</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/链表/11.png" alt></p><p><img src="/2020/07/11/链表/12.png" alt></p><p><img src="/2020/07/11/链表/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针，相遇则有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 慢指针，每次走一步</span></span><br><span class="line">ListNode slow = head;</span><br><span class="line">    <span class="comment">// 快指针，每次走两步</span></span><br><span class="line">ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line"><span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表（Linked-List）&quot;&gt;&lt;a href=&quot;#链表（Linked-List）&quot; class=&quot;headerlink&quot; title=&quot;链表（Linked List）&quot;&gt;&lt;/a&gt;链表（Linked List）&lt;/h2&gt;&lt;h3 id=&quot;为什么有链表&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>动态数组</title>
    <link href="http://yoursite.com/2020/07/09/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/07/09/动态数组/</id>
    <published>2020-07-09T13:07:28.000Z</published>
    <updated>2020-07-14T08:42:46.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种顺序存储的线性表，所有元素的内存地址是连续的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/09/动态数组/1.png" alt></p><p>在很多编程语言中，数组都有个致命的缺点，<strong>无法动态修改容量</strong></p><p>实际开发中，我们更希望数组的容量是可以<strong>动态改变</strong>的</p><h3 id="动态数组（Dynamic-Array）接口设计"><a href="#动态数组（Dynamic-Array）接口设计" class="headerlink" title="动态数组（Dynamic Array）接口设计"></a>动态数组（Dynamic Array）接口设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>; <span class="comment">// 是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">// 添加元素到最后</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 返回indext位置对应的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>; <span class="comment">// 设置indext位置对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>; <span class="comment">// 往index位置添加元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 删除index位置对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>; <span class="comment">// 查看元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清除所有元素</span></span><br></pre></td></tr></table></figure><h4 id="动态数组的设计"><a href="#动态数组的设计" class="headerlink" title="动态数组的设计"></a>动态数组的设计</h4><p><img src="/2020/07/09/动态数组/2.png" alt></p><p>在Java中，成员变量会自动初始化，比如</p><p>int 类型自动初始化为 0</p><p>对象类型自动初始化为 null</p><h4 id="添加元素-add-E-element"><a href="#添加元素-add-E-element" class="headerlink" title="添加元素 - add(E element)"></a>添加元素 - add(E element)</h4><p><img src="/2020/07/09/动态数组/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有索引下标，默认放在数组最后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">    add(size,element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组某个位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检测下标是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素开始，到index下标（逆序），数组元素向后覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">        elements[i] = elements[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素-remove-int-index"><a href="#删除元素-remove-int-index" class="headerlink" title="删除元素 - remove(int index)"></a>删除元素 - remove(int index)</h4><p><img src="/2020/07/09/动态数组/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E old = elements[index];</span><br><span class="line">    <span class="comment">// 从index下标开始，数组元素向前挪动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        elements[i - <span class="number">1</span>] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    elements[--size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何扩容-ensureCapacity-int-capacity"><a href="#如何扩容-ensureCapacity-int-capacity" class="headerlink" title="如何扩容 - ensureCapacity(int capacity)"></a>如何扩容 - ensureCapacity(int capacity)</h4><p><img src="/2020/07/09/动态数组/5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组容量不够时，扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 容量添加1.5倍</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 左移，缩小一半(再加上原来的容量)</span></span><br><span class="line">E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line"><span class="comment">// 将旧数组的元素拷贝到新数组</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">0</span>) System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, size);</span><br><span class="line">elements = newElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.omg.CORBA.Object;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dynamicArray</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所以的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPATICY = <span class="number">10</span>; <span class="comment">//初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>; <span class="comment">//找不到查找的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">dynamicArray</span><span class="params">(<span class="keyword">int</span> capaticy)</span></span>&#123;</span><br><span class="line">        capaticy = Math.max(capaticy, DEFAULT_CAPATICY);</span><br><span class="line">        elements = (E[]) <span class="keyword">new</span> Object[capaticy]; <span class="comment">//初始化数组容量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">dynamicArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPATICY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">        add(size,element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数组某个位置插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数组元素向前覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">elements[i] = elements[i-<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">        elements[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组容量不够时，扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 容量添加1.5倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 左移，缩小一半</span></span><br><span class="line">        E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">// 将旧数组的元素拷贝到新数组</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= <span class="number">0</span>) System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, size);</span><br><span class="line">        elements = newElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        </span><br><span class="line">        E old = elements[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i - <span class="number">1</span>] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        elements[--size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(element) != ELEMENT_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        E old = elements[index];</span><br><span class="line">        elements[index] = element;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.equals(elements[i])) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ELEMENT_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outOfBounds</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index:"</span> + index + <span class="string">", Size:"</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测传入的下标是否越界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            outOfBounds(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            outOfBounds(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dynamicArray&#123;"</span> +</span><br><span class="line">                <span class="string">"size="</span> + size +</span><br><span class="line">                <span class="string">", elements="</span> + Arrays.toString(elements) +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态数组&quot;&gt;&lt;a href=&quot;#动态数组&quot; class=&quot;headerlink&quot; title=&quot;动态数组&quot;&gt;&lt;/a&gt;动态数组&lt;/h2&gt;&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2020/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/07/09/数据结构/</id>
    <published>2020-07-09T12:42:35.000Z</published>
    <updated>2020-07-14T08:44:07.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h3><p>数据结构是计算机存储、组织数据的方式</p><p><img src="/2020/07/09/数据结构/1.png" alt></p><div class="table-container"><table><thead><tr><th style="text-align:center">线性表</th><th style="text-align:center">二叉树</th><th style="text-align:center">邻接矩阵</th></tr></thead><tbody><tr><td style="text-align:center">数组、链表</td><td style="text-align:center">AVL树、红黑树</td><td style="text-align:center">邻接表</td></tr><tr><td style="text-align:center">栈、队列</td><td style="text-align:center">B树、堆、Trie</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">哈希表</td><td style="text-align:center">哈夫曼树、并查集</td></tr></tbody></table></div><p>在实际应用中，根据使用场景来选择最合适的数据结构</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h3 id=&quot;什么是数据结构？&quot;&gt;&lt;a href=&quot;#什么是数据结构？&quot; class=&quot;headerlink&quot; title=&quot;什
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA学习路线</title>
    <link href="http://yoursite.com/2019/09/17/JAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/09/17/JAVA学习路线/</id>
    <published>2019-09-17T03:43:19.000Z</published>
    <updated>2019-09-17T04:32:00.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA学习路线"><a href="#JAVA学习路线" class="headerlink" title="JAVA学习路线"></a>JAVA学习路线</h1><h2 id="1-语言的入门和进阶"><a href="#1-语言的入门和进阶" class="headerlink" title="1. 语言的入门和进阶"></a>1. 语言的入门和进阶</h2><ul><li>Java基础语法,OO编程思想, 集合, IO, 异常, 泛型, 反射, 多线程, 函数式</li></ul><h2 id="2-Web基础和工具"><a href="#2-Web基础和工具" class="headerlink" title="2. Web基础和工具"></a>2. Web基础和工具</h2><ul><li><p>前端基础(html/javascript/css) jquery, ajax, jsp, cookie, session</p></li><li><p>http基础</p></li><li><p>servlet基础</p></li><li><p>git,svn代码管理工具</p></li></ul><h2 id="3-企业级应用框架"><a href="#3-企业级应用框架" class="headerlink" title="3. 企业级应用框架"></a>3. 企业级应用框架</h2><ul><li><p>maven/gradle项目管理工具</p></li><li><p>Spring全家桶(Spring, Spring MVC, Spring Boot)</p></li><li><p>关系型数据库相关(MySQL, jdbc, MyBatis, Hibernate)</p></li><li><p>非关系型数据库(Redis)</p></li><li><p>模板引擎(thymeleaf, freemarker)</p></li></ul><h2 id="4-高级应用框架"><a href="#4-高级应用框架" class="headerlink" title="4. 高级应用框架"></a>4. 高级应用框架</h2><ul><li><p>搜索引擎(elastic search)</p></li><li><p>RPCk框架(Dubbo, Spring Cloud)</p></li><li><p>中间件技术(RabbitMQ, RocketMQ, ActiveMQ, Kafka)</p></li><li><p>虚拟化技术(Docker, Kubernetes)</p></li></ul><h2 id="5-高级话题"><a href="#5-高级话题" class="headerlink" title="5. 高级话题"></a>5. 高级话题</h2><ul><li>jvm优化和排错, GC分析, 数据库高级优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA学习路线&quot;&gt;&lt;a href=&quot;#JAVA学习路线&quot; class=&quot;headerlink&quot; title=&quot;JAVA学习路线&quot;&gt;&lt;/a&gt;JAVA学习路线&lt;/h1&gt;&lt;h2 id=&quot;1-语言的入门和进阶&quot;&gt;&lt;a href=&quot;#1-语言的入门和进阶&quot; class=&quot;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="学习路线" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
</feed>
