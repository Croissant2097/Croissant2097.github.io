<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Croissant2097</title>
  
  <subtitle>Record &amp; Share &amp; Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-12T12:32:29.098Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2020/07/12/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/红黑树/</id>
    <published>2020-07-12T05:44:00.000Z</published>
    <updated>2020-07-12T12:32:29.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red Black Tree）"></a>红黑树（Red Black Tree）</h1><h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>红黑树也是一种<strong>自平衡的二叉搜索树</strong></p><p>以前也叫做平衡二叉B树（Symmetric Binary B-tree）</p><p>红黑树必须满足以下 <strong>5 条性质</strong></p><ol><li><p>节点是 <strong>RED</strong> 或者 <strong>BLACK</strong></p></li><li><p>根节点是 <strong>BLACK</strong></p></li><li><p>叶子节点（外部节点，空节点）都是 <strong>BLACK</strong></p></li><li><p><strong>RED</strong> 节点的子节点都是 <strong>BLACK</strong></p><p><strong>RED</strong> 节点的 parent 都是 <strong>BLACK</strong></p><p>从根节点到叶子节点的所有路径上不能有 2 个连续的 <strong>RED</strong> 节点</p></li><li><p>从任一节点到叶子节点的所有路径都包含相同数目的 <strong>BLACK</strong> 节点</p></li></ol><p><img src="/2020/07/12/红黑树/1.png" alt></p><h2 id="红黑树的等价变换"><a href="#红黑树的等价变换" class="headerlink" title="红黑树的等价变换"></a>红黑树的等价变换</h2><p>红黑树 和 4阶B树（2-3-4树）具有等价性</p><p><strong>BLACK</strong> 节点与它的 <strong>RED</strong> 子节点融合在一起，形成1个B树节点</p><p>红黑树的 <strong>BLACK</strong> 节点个数 与 4阶B树的节点总个数相等</p><p><strong>注意：后面展示的红黑树都会省略 NULL 节点</strong></p><p><img src="/2020/07/12/红黑树/2.png" alt></p><h2 id="红黑树-vs-2-3-4树"><a href="#红黑树-vs-2-3-4树" class="headerlink" title="红黑树 vs 2-3-4树"></a>红黑树 vs 2-3-4树</h2><p><img src="/2020/07/12/红黑树/3.png" alt></p><p>如果上图最底层的 <strong>BLACK</strong> 节点是不存在的，在B树中是什么样的情形？</p><p><strong>整棵B树只有1个节点，而且是超级节点</strong></p><h2 id="一些辅助函数"><a href="#一些辅助函数" class="headerlink" title="一些辅助函数"></a>一些辅助函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent：父节点</span></span><br><span class="line"><span class="comment">// sibling：兄弟节点</span></span><br><span class="line"><span class="comment">// uncle：叔父节点（parent 的兄弟节点）</span></span><br><span class="line"><span class="comment">// grand：祖父节点（parent 的父节点）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">color</span><span class="params">(Node&lt;E&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">   ((RBNode&lt;E&gt;)node).color = color;</span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染红</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">red</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> color(node, RED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染黑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">black</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color(node, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看颜色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : ((RBNode&lt;E&gt;)node).color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是黑色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> colorOf(node) == BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是红色</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> colorOf(node) == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否有兄弟节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的添加"><a href="#红黑树的添加" class="headerlink" title="红黑树的添加"></a>红黑树的添加</h2><p>已知</p><ol><li><p>B树中，新元素必定是添加到叶子节点中</p></li><li><p>4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3</p></li></ol><p><strong>建议新添加的节点默认为 RED</strong>，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定）</p><h3 id="有-4-种情况满足红黑树的性质-4-：parent-为BLACK"><a href="#有-4-种情况满足红黑树的性质-4-：parent-为BLACK" class="headerlink" title="有 4 种情况满足红黑树的性质 4 ：parent 为BLACK"></a>有 4 种情况满足红黑树的性质 4 ：parent 为BLACK</h3><p>同样也满足4阶B树的性质</p><p>因此不用做任何额外处理</p><p><img src="/2020/07/12/红黑树/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h3 id="有-8-种情况不满足红黑树的性质-4-：parent-为-RED（-Double-Red-）"><a href="#有-8-种情况不满足红黑树的性质-4-：parent-为-RED（-Double-Red-）" class="headerlink" title="有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）"></a>有 8 种情况不满足红黑树的性质 4 ：parent 为 <strong>RED</strong>（ <strong>Double</strong> <strong>Red</strong> ）</h3><p>其中前 4 种属于B树节点上溢的情况</p><p><img src="/2020/07/12/红黑树/5.png" alt></p><h4 id="添加-–-修复性质4-–-LL-RR"><a href="#添加-–-修复性质4-–-LL-RR" class="headerlink" title="添加 – 修复性质4 – LL\RR"></a>添加 – 修复性质4 – LL\RR</h4><p>判定条件：uncle 不是 <strong>RED</strong></p><p>1.parent 染成 <strong>BLACK</strong>，grand 染成 <strong>RED</strong></p><p>2.grand 进行单旋操作</p><p>LL：右旋转</p><p>RR：左旋转</p><p><img src="/2020/07/12/红黑树/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点染成红色</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">    <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">        black(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">    <span class="keyword">if</span> (!node.isLeftChild()) &#123; <span class="comment">// RR</span></span><br><span class="line">        black(parent);</span><br><span class="line">    &#125; </span><br><span class="line">    rotateLeft(grand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-LR-RL"><a href="#添加-–-修复性质4-–-LR-RL" class="headerlink" title="添加 – 修复性质4 – LR\RL"></a>添加 – 修复性质4 – LR\RL</h4><p>判定条件：uncle 不是 <strong>RED</strong></p><ol><li><p>自己染成 <strong>BLACK</strong>，grand 染成 <strong>RED</strong></p></li><li><p>进行双旋操作</p></li></ol><p>LR：parent 左旋转， grand 右旋转</p><p>RL：parent 右旋转， grand 左旋转</p><p><img src="/2020/07/12/红黑树/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点染成红色</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叔父节点不是红色</span></span><br><span class="line"><span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">   <span class="keyword">if</span> (!node.isLeftChild()) &#123; <span class="comment">// LR</span></span><br><span class="line">      black(node);</span><br><span class="line">      rotateLeft(parent);</span><br><span class="line">   &#125;</span><br><span class="line">   rotateRight(grand);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">   <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">      black(node);</span><br><span class="line">      rotateRight(parent);</span><br><span class="line">   &#125;</span><br><span class="line">   rotateLeft(grand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-LL"><a href="#添加-–-修复性质4-–-上溢-–-LL" class="headerlink" title="添加 – 修复性质4 – 上溢 – LL"></a>添加 – 修复性质4 – 上溢 – LL</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p>grand 向上合并时，可能继续发生上溢</p><p>若上溢持续到根节点，只需将根节点染成 <strong>BLACK</strong></p><p><img src="/2020/07/12/红黑树/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line"><span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    black(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">   black(parent);</span><br><span class="line">   black(uncle);</span><br><span class="line">   <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">   afterAdd(grand);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-RR"><a href="#添加-–-修复性质4-–-上溢-–-RR" class="headerlink" title="添加 – 修复性质4 – 上溢 – RR"></a>添加 – 修复性质4 – 上溢 – RR</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叔父节点</span></span><br><span class="line">Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line"><span class="comment">// 祖父节点</span></span><br><span class="line">Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">   black(parent);</span><br><span class="line">   black(uncle);</span><br><span class="line">   <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">   afterAdd(grand);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-–-修复性质4-–-上溢-–-LR"><a href="#添加-–-修复性质4-–-上溢-–-LR" class="headerlink" title="添加 – 修复性质4 – 上溢 – LR"></a>添加 – 修复性质4 – 上溢 – LR</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/10.png" alt></p><h4 id="添加-–-修复性质4-–-上溢-–-RL"><a href="#添加-–-修复性质4-–-上溢-–-RL" class="headerlink" title="添加 – 修复性质4 – 上溢 – RL"></a>添加 – 修复性质4 – 上溢 – RL</h4><p>判定条件：uncle 是 <strong>RED</strong></p><ol><li><p>parent、uncle 染成 <strong>BLACK</strong></p></li><li><p>grand 向上合并</p></li></ol><p>grand染成 <strong>RED</strong>，当做是新添加的节点进行处理</p><p><img src="/2020/07/12/红黑树/11.png" alt></p><h2 id="红黑树添加后完整修复的代码"><a href="#红黑树添加后完整修复的代码" class="headerlink" title="红黑树添加后完整修复的代码"></a>红黑树添加后完整修复的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterAdd</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   Node&lt;E&gt; parent = node.parent;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 添加的是根节点 或者 上溢到达了根节点</span></span><br><span class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">      black(node);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果父节点是黑色，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (isBlack(parent)) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 叔父节点</span></span><br><span class="line">   Node&lt;E&gt; uncle = parent.sibling();</span><br><span class="line">   <span class="comment">// 祖父节点</span></span><br><span class="line">   Node&lt;E&gt; grand = red(parent.parent);</span><br><span class="line">   <span class="keyword">if</span> (isRed(uncle)) &#123; <span class="comment">// 叔父节点是红色【B树节点上溢】</span></span><br><span class="line">      black(parent);</span><br><span class="line">      black(uncle);</span><br><span class="line">      <span class="comment">// 把祖父节点当做是新添加的节点</span></span><br><span class="line">      afterAdd(grand);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 叔父节点不是红色</span></span><br><span class="line">   <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">         black(parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">         black(node);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">      &#125;</span><br><span class="line">      rotateRight(grand);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">         black(node);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">         black(parent);</span><br><span class="line">      &#125;</span><br><span class="line">      rotateLeft(grand);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p><strong>B树中，最后真正被删除的元素都在叶子节点中</strong></p><p><img src="/2020/07/12/红黑树/12.png" alt></p><h3 id="删除-–-RED节点"><a href="#删除-–-RED节点" class="headerlink" title="删除 – RED节点"></a>删除 – RED节点</h3><p>直接删除，不用作任何调整</p><p><img src="/2020/07/12/红黑树/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node)) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-–-BLACK节点"><a href="#删除-–-BLACK节点" class="headerlink" title="删除 – BLACK节点"></a>删除 – BLACK节点</h3><p>有 3 种情况</p><ol><li><p>拥有 2 个 <strong>RED</strong> 子节点的 <strong>BLACK</strong> 节点</p><p>不可能被直接删除，因为会找它的子节点替代删除</p><p>因此不用考虑这种情况</p></li><li><p>拥有 1 个 <strong>RED</strong> 子节点的 <strong>BLACK</strong> 节点</p></li><li><p><strong>BLACK</strong> 叶子节点</p></li></ol><p><strong>下文举例采用: 被删除的节点在右边，兄弟节点在左边，（反之交换左右方向即可）</strong></p><p><img src="/2020/07/12/红黑树/14.png" alt></p><h4 id="删除-拥有-1-个-RED-子节点的-BLACK-节点"><a href="#删除-拥有-1-个-RED-子节点的-BLACK-节点" class="headerlink" title="删除 - 拥有 1 个 RED 子节点的 BLACK 节点"></a>删除 - 拥有 1 个 RED 子节点的 BLACK 节点</h4><p>判定条件：用以替代的子节点是 <strong>RED</strong></p><p>将替代的子节点染成 <strong>BLACK</strong> 即可保持红黑树性质</p><p><img src="/2020/07/12/红黑树/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用以取代node的子节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(replacement)) &#123;</span><br><span class="line">        black(replacement);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为BLACK-sibling-至少有-1-个-RED-子节点"><a href="#删除-BLACK-叶子节点-sibling为BLACK-sibling-至少有-1-个-RED-子节点" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 RED 子节点"></a>删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 <strong>RED</strong> 子节点</h4><p><strong>BLACK</strong> 叶子节点被删除后，会导致B树节点下溢（比如删除88）</p><p>如果 sibling 至少有 1 个 <strong>RED</strong> 子节点<strong>（一个或两个RED子节点）</strong></p><p><strong>兄弟节点的左边是黑色，(没有子节点也算是黑色)</strong></p><ol><li><p>兄弟节点左旋</p></li><li><p>改变兄弟节点为parent的左边</p></li><li><p>后续再按<strong>兄弟节点的左边是红色</strong>执行即可</p></li></ol><p><img src="/2020/07/12/红黑树/17.png" alt></p><p><strong>兄弟节点的左边是红色</strong></p><ol><li><p>兄弟节点继承 parent 的颜色</p></li><li><p>兄弟节点的左边变成黑色</p></li><li><p>parent节点变成黑色</p></li><li><p>parent右旋</p></li></ol><p><img src="/2020/07/12/红黑树/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line">            </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(sibling)) &#123; <span class="comment">// 兄弟节点是黑色</span></span><br><span class="line">            <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(sibling.left) || isRed(sibling.right)) &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">                    rotateLeft(sibling);</span><br><span class="line">                    sibling = parent.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 兄弟节点的左边是红色或兄弟旋转后</span></span><br><span class="line">                color(sibling, colorOf(parent));</span><br><span class="line">                black(sibling.left);</span><br><span class="line">                black(parent);</span><br><span class="line">                rotateRight(parent);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为BLACK-sibling-没有-1-个-RED-子节点"><a href="#删除-BLACK-叶子节点-sibling为BLACK-sibling-没有-1-个-RED-子节点" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 RED 子节点"></a>删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 <strong>RED</strong> 子节点</h4><p>判定条件：sibling 没有 1 个 <strong>RED</strong> 子节点</p><p>将 sibling 染成 <strong>RED</strong>、parent 染成 <strong>BLACK</strong> 即可修复红黑树性质</p><p>如果 parent 是 <strong>BLACK</strong></p><p>会导致 parent 也下溢</p><p>这时只需要把 parent 当做被删除的节点处理即可</p><p><img src="/2020/07/12/红黑树/18.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line">    <span class="comment">// 删除的是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="comment">// 兄弟节点是黑色</span></span><br><span class="line">        <span class="keyword">if</span>(isBlack(sibling))&#123;</span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">                <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">                black(parent);</span><br><span class="line">                red(sibling);</span><br><span class="line">                <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">                    afterRemove(parent, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-BLACK-叶子节点-sibling为RED"><a href="#删除-BLACK-叶子节点-sibling为RED" class="headerlink" title="删除 - BLACK 叶子节点 - sibling为RED"></a>删除 - BLACK 叶子节点 - sibling为RED</h4><p>如果 sibling 是 <strong>RED</strong></p><p>sibling 染成 <strong>BLACK</strong>，parent 染成 <strong>RED</strong>，进行旋转</p><p>于是又回到 sibling 是 <strong>BLACK</strong> 的情况</p><p><img src="/2020/07/12/红黑树/19.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node, Node&lt;E&gt; replacement)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = node.parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">    <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">    <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">    Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">        <span class="comment">// .... 代码省略，可查看最后完整代码</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            black(sibling);</span><br><span class="line">            red(parent);</span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            <span class="comment">// 更换兄弟</span></span><br><span class="line">            sibling = parent.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树删除后完整修复的代码"><a href="#红黑树删除后完整修复的代码" class="headerlink" title="红黑树删除后完整修复的代码"></a>红黑树删除后完整修复的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果删除的节点是红色</span></span><br><span class="line">   <span class="comment">// 或者 用以取代删除节点的子节点是红色</span></span><br><span class="line">   <span class="keyword">if</span> (isRed(node)) &#123;</span><br><span class="line">      black(node);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Node&lt;E&gt; parent = node.parent;</span><br><span class="line">   <span class="comment">// 删除的是根节点</span></span><br><span class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 删除的是黑色叶子节点【下溢】</span></span><br><span class="line">   <span class="comment">// 判断被删除的node是左还是右</span></span><br><span class="line">   <span class="keyword">boolean</span> left = parent.left == <span class="keyword">null</span> || node.isLeftChild();</span><br><span class="line">   Node&lt;E&gt; sibling = left ? parent.right : parent.left;</span><br><span class="line">   <span class="keyword">if</span> (left) &#123; <span class="comment">// 被删除的节点在左边，兄弟节点在右边</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">         black(sibling);</span><br><span class="line">         red(parent);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">         <span class="comment">// 更换兄弟</span></span><br><span class="line">         sibling = parent.right;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">      <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">         <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">         <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">         black(parent);</span><br><span class="line">         red(sibling);</span><br><span class="line">         <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">            afterRemove(parent);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">         <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">         <span class="keyword">if</span> (isBlack(sibling.right)) &#123;</span><br><span class="line">            rotateRight(sibling);</span><br><span class="line">            sibling = parent.right;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         color(sibling, colorOf(parent));</span><br><span class="line">         black(sibling.right);</span><br><span class="line">         black(parent);</span><br><span class="line">         rotateLeft(parent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被删除的节点在右边，兄弟节点在左边</span></span><br><span class="line">      <span class="keyword">if</span> (isRed(sibling)) &#123; <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">         black(sibling);</span><br><span class="line">         red(parent);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">         <span class="comment">// 更换兄弟</span></span><br><span class="line">         sibling = parent.left;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 兄弟节点必然是黑色</span></span><br><span class="line">      <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123;</span><br><span class="line">         <span class="comment">// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并</span></span><br><span class="line">         <span class="keyword">boolean</span> parentBlack = isBlack(parent);</span><br><span class="line">         black(parent);</span><br><span class="line">         red(sibling);</span><br><span class="line">         <span class="keyword">if</span> (parentBlack) &#123;</span><br><span class="line">            afterRemove(parent);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 兄弟节点至少有1个红色子节点，向兄弟节点借元素</span></span><br><span class="line">         <span class="comment">// 兄弟节点的左边是黑色，兄弟要先旋转</span></span><br><span class="line">         <span class="keyword">if</span> (isBlack(sibling.left)) &#123;</span><br><span class="line">            rotateLeft(sibling);</span><br><span class="line">            sibling = parent.left;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         color(sibling, colorOf(parent));</span><br><span class="line">         black(sibling.left);</span><br><span class="line">         black(parent);</span><br><span class="line">         rotateRight(parent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的平衡"><a href="#红黑树的平衡" class="headerlink" title="红黑树的平衡"></a>红黑树的平衡</h2><p>为何那5条性质，就能保证红黑树是平衡的？</p><p>那5条性质，可以保证红黑树等价于4阶B树</p><p><img src="/2020/07/12/红黑树/20.png" alt></p><p>相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍</p><p>是一种弱平衡、黑高度平衡</p><p>红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是 O(logn) 级别</p><h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h2><p>搜索：O(logn)</p><p>添加：O(logn)，O(1) 次的旋转操作</p><p>删除：O(logn)，O(1) 次的旋转操作</p><h2 id="AVL树-vs-红黑树"><a href="#AVL树-vs-红黑树" class="headerlink" title="AVL树 vs 红黑树"></a>AVL树 vs 红黑树</h2><p><strong>AVL树</strong>  <a href="/2020/07/12/AVL树/" title="AVL树的实现">AVL树的实现</a></p><p>平衡标准比较严格：<strong>每个左右子树的高度差不超过1</strong></p><p>最大高度是 1.44  ∗ log2  n + 2 − 1.328（100W个节点，AVL树最大树高28）</p><p>搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整</p><p><strong>红黑树</strong></p><p>平衡标准比较宽松：<strong>没有一条路径会大于其他路径的2倍</strong></p><p>最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40）</p><p>搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整</p><p><strong>总结</strong></p><p>搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树</p><p>相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树</p><p>红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树</p><h2 id="BST-vs-AVL-Tree-vs-Red-Black-Tree"><a href="#BST-vs-AVL-Tree-vs-Red-Black-Tree" class="headerlink" title="BST vs AVL Tree vs Red Black Tree"></a>BST vs AVL Tree vs Red Black Tree</h2><p>10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96</p><p><img src="/2020/07/12/红黑树/21.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红黑树（Red-Black-Tree）&quot;&gt;&lt;a href=&quot;#红黑树（Red-Black-Tree）&quot; class=&quot;headerlink&quot; title=&quot;红黑树（Red Black Tree）&quot;&gt;&lt;/a&gt;红黑树（Red Black Tree）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="http://yoursite.com/2020/07/12/B%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/B树/</id>
    <published>2020-07-12T05:43:47.000Z</published>
    <updated>2020-07-12T08:05:38.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B树（B-tree、B-树）"><a href="#B树（B-tree、B-树）" class="headerlink" title="B树（B - tree、B - 树）"></a>B树（B - tree、B - 树）</h2><p>​    B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现</p><h3 id="B树特点"><a href="#B树特点" class="headerlink" title="B树特点"></a>B树特点</h3><ul><li><p>1个节点可以存储超过 2 个元素、可以拥有超过 2 个子节点</p></li><li><p>拥有二叉搜索树的一些性质</p></li><li><p>平衡，每个节点的所有子树高度一致</p></li><li><p>比较矮</p></li></ul><p><img src="/2020/07/12/B树/1.png" alt></p><h3 id="m阶B树的性质（m≥2）"><a href="#m阶B树的性质（m≥2）" class="headerlink" title="m阶B树的性质（m≥2）"></a>m阶B树的性质（m≥2）</h3><p>假设一个节点存储的元素个数为 x</p><ol><li><p>根节点：1 ≤ x ≤ m − 1</p></li><li><p>非根节点：┌ m/2 ┐ − 1 ≤ x ≤ m − 1</p></li><li><p>如果有子节点，子节点个数 y = x + 1</p></li></ol><ul><li><p>根节点：2 ≤ y ≤ m</p></li><li><p>非根节点：┌ m/2 ┐ ≤ y ≤ m</p></li><li><p>比如 m = 3，2 ≤ y ≤ 3，因此可以称为（2, 3）树、2-3树</p></li><li><p>比如 m = 4，2 ≤ y ≤ 4，因此可以称为（2, 4）树、2-3-4树</p></li><li><p>比如 m = 5，3 ≤ y ≤ 5，因此可以称为（3, 5）树</p></li><li><p>比如 m = 6，3 ≤ y ≤ 6，因此可以称为（3, 6）树</p></li><li><p>比如 m = 7，4 ≤ y ≤ 7，因此可以称为（4, 7）树</p></li></ul><h3 id="B树-VS-二叉搜索树"><a href="#B树-VS-二叉搜索树" class="headerlink" title="B树 VS 二叉搜索树"></a>B树 VS 二叉搜索树</h3><p>B树和二叉搜索树，在逻辑上是等价的</p><p>多代节点合并，可以获得一个超级节点</p><p>2代合并的超级节点，最多拥有 4 个子节点（至少是 4阶B树）</p><p>3代合并的超级节点，最多拥有 8 个子节点（至少是 8阶B树）</p><p>n代合并的超级节点，最多拥有 2n个子节点（ 至少是 2n阶B树）</p><p>m阶B树，最多需要 log2m 代合并</p><h3 id="B树的搜索"><a href="#B树的搜索" class="headerlink" title="B树的搜索"></a>B树的搜索</h3><p>跟二叉搜索树的搜索类似</p><p><img src="/2020/07/12/B树/2.png" alt></p><ol><li><p>先在节点内部从小到大开始搜索元素</p></li><li><p>如果命中，搜索结束</p></li><li><p>如果未命中，再去对应的子节点中搜索元素，重复步骤 1</p></li></ol><h3 id="B树的添加"><a href="#B树的添加" class="headerlink" title="B树的添加"></a>B树的添加</h3><p>新添加的元素必定是添加到叶子节点</p><p>插入55</p><p><img src="/2020/07/12/B树/3.png" alt></p><p>插入95</p><p><img src="/2020/07/12/B树/4.png" alt></p><p>再插入 98 呢？（假设这是一棵 4阶B树）</p><p>最右下角的叶子节点的元素个数将超过限制</p><p>这种现象可以称之为：<strong>上溢（overflow）</strong></p><h4 id="添加-–-上溢的解决-假设5阶"><a href="#添加-–-上溢的解决-假设5阶" class="headerlink" title="添加 – 上溢的解决(假设5阶)"></a>添加 – 上溢的解决(假设5阶)</h4><p><strong>上溢节点的元素个数必然等于m</strong></p><p>假设上溢节点最中间元素的位置为k</p><p>将 k 位置的元素向上与父节点合并</p><p>将 [0, k-1] 和 [k + 1, m - 1] 位置的元素分裂成 2 个子节点</p><p>这 2 个子节点的元素个数，必然都不会低于最低限制（┌ m/2 ┐ − 1）</p><p>一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决</p><p>最极端的情况，有可能一直分裂到根节点</p><p><img src="/2020/07/12/B树/5.png" alt></p><p><img src="/2020/07/12/B树/6.png" alt></p><h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3><h4 id="删除-–-叶子节点"><a href="#删除-–-叶子节点" class="headerlink" title="删除 – 叶子节点"></a>删除 – 叶子节点</h4><p>假如需要删除的元素在叶子节点中，那么直接删除即可</p><p><img src="/2020/07/12/B树/7.png" alt></p><h4 id="删除-–-非叶子节点"><a href="#删除-–-非叶子节点" class="headerlink" title="删除 – 非叶子节点"></a>删除 – 非叶子节点</h4><p>假如需要删除的元素在非叶子节点中</p><ol><li><p>先找到前驱或后继元素，覆盖所需删除元素的值</p></li><li><p>再把前驱或后继元素删除</p></li></ol><p><img src="/2020/07/12/B树/8.png" alt></p><p>非叶子节点的前驱或后继元素，必定在叶子节点中</p><p>所以这里的删除前驱或后继元素 ，就是最开始提到的情况：删除的元素在叶子节点中</p><p><strong>真正的删除元素都是发生在叶子节点中</strong></p><h4 id="删除-–-下溢"><a href="#删除-–-下溢" class="headerlink" title="删除 – 下溢"></a>删除 – 下溢</h4><p>删除 22 ？（假设这是一棵 5阶B树）</p><p>叶子节点被删掉一个元素后，元素个数可能会低于最低限制（ ≥ ┌ m/2 ┐ − 1 ）</p><p>这种现象称为：<strong>下溢（underflow）</strong></p><p><img src="/2020/07/12/B树/9.png" alt></p><h4 id="删除-–-下溢的解决"><a href="#删除-–-下溢的解决" class="headerlink" title="删除 – 下溢的解决"></a>删除 – 下溢的解决</h4><p><strong>下溢节点的元素数量必然等于 ┌ m/2 ┐ − 2</strong></p><ol><li><p>如果下溢节点临近的兄弟节点，有至少 ┌ m/2 ┐ 个元素，可以向其借一个元素</p><p>将父节点的元素 b 插入到下溢节点的 0 位置（最小位置）</p><p>用兄弟节点的元素 a（最大的元素）替代父节点的元素 b</p><p>这种操作其实就是：旋转</p></li></ol><p><img src="/2020/07/12/B树/10.png" alt></p><ol><li><p>如果下溢节点临近的兄弟节点，只有 ┌ m/2 ┐ − 1 个元素</p><p>将父节点的元素 b 挪下来跟左右子节点进行合并</p><p>合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1</p><p>这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播</p></li></ol><p><img src="/2020/07/12/B树/11.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解B树的性质后，就可以来学习红黑树了</p><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;B树（B-tree、B-树）&quot;&gt;&lt;a href=&quot;#B树（B-tree、B-树）&quot; class=&quot;headerlink&quot; title=&quot;B树（B - tree、B - 树）&quot;&gt;&lt;/a&gt;B树（B - tree、B - 树）&lt;/h2&gt;&lt;p&gt;​    B树是一种平衡的多
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
      <category term="B树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/B%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://yoursite.com/2020/07/12/AVL%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/AVL树/</id>
    <published>2020-07-12T05:43:33.000Z</published>
    <updated>2020-07-12T07:21:27.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>AVL树是最早发明的自平衡二叉搜索树之一</p><p>AVL 取名于两位发明者的名字</p><p><strong>G. M. Adelson-Velsky 和 E. M. Landis</strong>（来自苏联的科学家）</p><h3 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h3><p><strong>平衡因子</strong>（Balance Factor）：某结点的左右子树的高度差</p><ol><li><p>每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”）</p></li><li><p>每个节点的左右子树高度差不超过 1</p></li><li><p>搜索、添加、删除的时间复杂度是 O(logn)</p></li></ol><p><img src="/2020/07/12/AVL树/1.png" alt></p><h3 id="平衡对比"><a href="#平衡对比" class="headerlink" title="平衡对比"></a>平衡对比</h3><p>输入数据：35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82</p><p><img src="/2020/07/12/AVL树/2.png" alt></p><h3 id="简单的继承结构"><a href="#简单的继承结构" class="headerlink" title="简单的继承结构"></a>简单的继承结构</h3><a href="/2020/07/11/二叉树/" title="二叉树的实现">二叉树的实现</a> <a href="/2020/07/12/二叉搜索树/" title="二叉搜索树的实现">二叉搜索树的实现</a><p><img src="/2020/07/12/AVL树/3.png" alt></p><h3 id="平衡修复"><a href="#平衡修复" class="headerlink" title="平衡修复"></a>平衡修复</h3><h4 id="添加导致的失衡"><a href="#添加导致的失衡" class="headerlink" title="添加导致的失衡"></a>添加导致的失衡</h4><p>示例：往下面这棵子树中添加 13</p><p>最坏情况：可能会导致所有祖先节点都失衡</p><p>父节点、非祖先节点，都不可能失衡</p><p><img src="/2020/07/12/AVL树/4.png" alt></p><h5 id="LL-–-右旋转（R单旋）——-LL（n在g的LL）"><a href="#LL-–-右旋转（R单旋）——-LL（n在g的LL）" class="headerlink" title="LL – 右旋转（R单旋）——- LL（n在g的LL）"></a>LL – 右旋转（R单旋）——- LL（n在g的LL）</h5><p><img src="/2020/07/12/AVL树/5.png" alt></p><p><strong>g.left = p.right</strong></p><p><strong>p.right = g</strong></p><p><strong>让p成为这棵子树的根节点</strong></p><p>仍然是一棵二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3，整棵树都达到平衡</p><p>还需要注意维护的内容，T2、p、g 的 parent 属性，先后更新 g、p 的高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换子树</span></span><br><span class="line">    Node&lt;E&gt; parent = grand.left;</span><br><span class="line">    Node&lt;E&gt; child = parent.right;</span><br><span class="line">    grand.left = child;</span><br><span class="line">    parent.right = grand;</span><br><span class="line">    <span class="comment">// 维护parent和height</span></span><br><span class="line">    afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RR-–-左旋转（L单旋）——-RR（n在g的RR）"><a href="#RR-–-左旋转（L单旋）——-RR（n在g的RR）" class="headerlink" title="RR – 左旋转（L单旋）——- RR（n在g的RR）"></a>RR – 左旋转（L单旋）——- RR（n在g的RR）</h5><p><img src="/2020/07/12/AVL树/6.png" alt></p><p><strong>g.right = p.left</strong></p><p><strong>p.left = g</strong></p><p><strong>让p成为这棵子树的根节点</strong></p><p>仍然是一棵二叉搜索树：T0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3，整棵树都达到平衡</p><p>还需要注意维护的内容，T1、p、g 的 parent 属性，先后更新 g、p 的高度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换子树</span></span><br><span class="line">    Node&lt;E&gt; parent = grand.right;</span><br><span class="line">    Node&lt;E&gt; child = parent.left;</span><br><span class="line">    grand.right = child;</span><br><span class="line">    parent.left = grand;</span><br><span class="line">    <span class="comment">// 维护parent和height</span></span><br><span class="line">    afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LR-–-RR左旋转，LL右旋转（双旋）——-LR（n在g的LR）"><a href="#LR-–-RR左旋转，LL右旋转（双旋）——-LR（n在g的LR）" class="headerlink" title="LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR）"></a>LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR）</h5><p><img src="/2020/07/12/AVL树/7.png" alt></p><h5 id="RL-–-LL右旋转，RR左旋转（双旋）——-RL（n在g的RL）"><a href="#RL-–-LL右旋转，RR左旋转（双旋）——-RL（n在g的RL）" class="headerlink" title="RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL）"></a>RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL）</h5><p><img src="/2020/07/12/AVL树/8.png" alt></p><h5 id="旋转之后的修复"><a href="#旋转之后的修复" class="headerlink" title="旋转之后的修复"></a>旋转之后的修复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共代码：不管是左旋转、右旋转，都要执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grand 失衡节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 失衡节点的tallerChild</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child g和p 需要交换的子树（本来是p的子树，后面会变成g的子树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRotate</span><span class="params">(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 让parent称为子树的根节点</span></span><br><span class="line">   parent.parent = grand.parent;</span><br><span class="line">   <span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">      grand.parent.left = parent;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">      grand.parent.right = parent;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// grand是root节点</span></span><br><span class="line">      root = parent;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 更新child的parent</span></span><br><span class="line">   <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      child.parent = grand;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 更新grand的parent</span></span><br><span class="line">   grand.parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的节点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; left;</span><br><span class="line">    Node&lt;E&gt; right;</span><br><span class="line">    Node&lt;E&gt; parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span> == parent.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有兄弟节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">sibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AVL树节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLNode</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AVLNode</span><span class="params">(E element, Node&lt;E&gt; parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(element, parent);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 每个节点的平衡因子只可能是 1、0、-1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balanceFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> leftHeight = left == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">      <span class="keyword">int</span> rightHeight = right == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">      <span class="keyword">return</span> leftHeight - rightHeight;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 更新树高</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> leftHeight = left == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">      <span class="keyword">int</span> rightHeight = right == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">      height = <span class="number">1</span> + Math.max(leftHeight, rightHeight);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 返回树高的子节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node&lt;E&gt; <span class="title">tallerChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> leftHeight = left == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">      <span class="keyword">int</span> rightHeight = right == <span class="keyword">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">      <span class="keyword">if</span> (leftHeight &gt; rightHeight) <span class="keyword">return</span> left;</span><br><span class="line">      <span class="keyword">if</span> (leftHeight &lt; rightHeight) <span class="keyword">return</span> right;</span><br><span class="line">      <span class="keyword">return</span> isLeftChild() ? left : right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加之后的修复"><a href="#添加之后的修复" class="headerlink" title="添加之后的修复"></a>添加之后的修复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterAdd</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ((node = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBalanced(node)) &#123;</span><br><span class="line">         <span class="comment">// 更新高度</span></span><br><span class="line">         updateHeight(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 恢复平衡</span></span><br><span class="line">         rebalance(node);</span><br><span class="line">         <span class="comment">// 整棵树恢复平衡</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断是否平衡"><a href="#判断是否平衡" class="headerlink" title="判断是否平衡"></a>判断是否平衡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查看树的高度"><a href="#查看树的高度" class="headerlink" title="查看树的高度"></a>查看树的高度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   ((AVLNode&lt;E&gt;)node).updateHeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="恢复平衡"><a href="#恢复平衡" class="headerlink" title="恢复平衡"></a>恢复平衡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grand 高度最低的不平衡节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalance</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild();</span><br><span class="line">    Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild();</span><br><span class="line">    <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">            rotateRight(grand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">            rotateRight(grand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">        <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            rotateLeft(grand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">            rotateLeft(grand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>输入数据：13, 14, 15, 12, 11, 17, 16, 8, 9,1</p><p><img src="/2020/07/12/AVL树/9.png" alt></p><p><img src="/2020/07/12/AVL树/10.png" alt></p><h5 id="统一所有旋转操作的实现"><a href="#统一所有旋转操作的实现" class="headerlink" title="统一所有旋转操作的实现"></a>统一所有旋转操作的实现</h5><p><img src="/2020/07/12/AVL树/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; r, // 子树的根节点</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; b, Node&lt;E&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; d,</span></span></span><br><span class="line"><span class="function"><span class="params">      Node&lt;E&gt; e, Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 让d成为这棵子树的根节点</span></span><br><span class="line">   d.parent = r.parent;</span><br><span class="line">   <span class="keyword">if</span> (r.isLeftChild()) &#123;</span><br><span class="line">      r.parent.left = d;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.isRightChild()) &#123;</span><br><span class="line">      r.parent.right = d;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root = d;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//b-c</span></span><br><span class="line">   b.right = c;</span><br><span class="line">   <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">      c.parent = b;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// e-f</span></span><br><span class="line">   f.left = e;</span><br><span class="line">   <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      e.parent = f;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// b-d-f</span></span><br><span class="line">   d.left = b;</span><br><span class="line">   d.right = f;</span><br><span class="line">   b.parent = d;</span><br><span class="line">   f.parent = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> grand 高度最低的那个不平衡节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalance</span><span class="params">(Node&lt;E&gt; grand)</span> </span>&#123;</span><br><span class="line">   Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild();</span><br><span class="line">   Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild();</span><br><span class="line">   <span class="keyword">if</span> (parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">         rotate(grand, node, node.right, parent, parent.right, grand);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">         rotate(grand, parent, node.left, node, node.right, grand);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// R</span></span><br><span class="line">      <span class="keyword">if</span> (node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">         rotate(grand, grand, node.left, node, node.right, parent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// RR</span></span><br><span class="line">         rotate(grand, grand, parent.left, parent, node.left, node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除导致的失衡"><a href="#删除导致的失衡" class="headerlink" title="删除导致的失衡"></a>删除导致的失衡</h4><p>示例：删除子树中的 16</p><p>可能会导致父节点或祖先节点失衡（只有1个节点会失衡），其他节点，都不可能失衡</p><p><img src="/2020/07/12/AVL树/12.png" alt></p><h5 id="LL-–-右旋转（单旋）"><a href="#LL-–-右旋转（单旋）" class="headerlink" title="LL – 右旋转（单旋）"></a>LL – 右旋转（单旋）</h5><p>如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡…</p><p>极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整</p><p><img src="/2020/07/12/AVL树/13.png" alt></p><h5 id="RR-–-左旋转（单旋）"><a href="#RR-–-左旋转（单旋）" class="headerlink" title="RR – 左旋转（单旋）"></a>RR – 左旋转（单旋）</h5><p><img src="/2020/07/12/AVL树/14.png" alt></p><h5 id="LR-–-RR左旋转，LL右旋转（双旋）"><a href="#LR-–-RR左旋转，LL右旋转（双旋）" class="headerlink" title="LR – RR左旋转，LL右旋转（双旋）"></a>LR – RR左旋转，LL右旋转（双旋）</h5><p><img src="/2020/07/12/AVL树/15.png" alt></p><h5 id="RL-–-LL右旋转，RR左旋转（双旋）"><a href="#RL-–-LL右旋转，RR左旋转（双旋）" class="headerlink" title="RL – LL右旋转，RR左旋转（双旋）"></a>RL – LL右旋转，RR左旋转（双旋）</h5><p><img src="/2020/07/12/AVL树/16.png" alt></p><h5 id="删除之后的修复"><a href="#删除之后的修复" class="headerlink" title="删除之后的修复"></a>删除之后的修复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRemove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ((node = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBalanced(node)) &#123;</span><br><span class="line">         <span class="comment">// 更新高度</span></span><br><span class="line">         updateHeight(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 恢复平衡</span></span><br><span class="line">         rebalance(node);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>添加</p><p>可能会导致所有祖先节点都失衡</p><p>只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需 O(1) 次调整】</p></li><li><p>删除</p><p>可能会导致父节点或祖先节点失衡（只有1个节点会失衡）</p><p>恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要 O(logn) 次调整】</p></li><li><p>平均时间复杂度</p><p>搜索：O(logn)</p><p>添加：O(logn)，仅需 O(1) 次的旋转操作</p><p>删除：O(logn)，最多需要 O(logn) 次的旋转操作</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;&lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
      <category term="AVL树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/AVL%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/2020/07/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/12/二叉搜索树/</id>
    <published>2020-07-12T04:37:53.000Z</published>
    <updated>2020-07-12T06:04:14.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>在 n 个动态的整数中搜索某个整数？（查看其是否存在）</p><p>假设使用动态数组存放元素，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n)</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">31</td><td style="text-align:center">66</td><td style="text-align:center">17</td><td style="text-align:center">15</td><td style="text-align:center">28</td><td style="text-align:center">20</td><td style="text-align:center">59</td><td style="text-align:center">88</td><td style="text-align:center">45</td><td style="text-align:center">56</td></tr></tbody></table></div><ul><li><p>如果维护一个有序的动态数组，使用二分搜索，最坏时间复杂度：O(logn)</p><p>但是添加、删除的平均时间复杂度是 O(n)</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">20</td><td style="text-align:center">28</td><td style="text-align:center">31</td><td style="text-align:center">45</td><td style="text-align:center">56</td><td style="text-align:center">59</td><td style="text-align:center">66</td><td style="text-align:center">88</td></tr></tbody></table></div><ul><li><p>针对这个需求，有没有更好的方案？</p><p>使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)​</p></li></ul><h3 id="什么是二叉搜索树（Binary-Search-Tree）"><a href="#什么是二叉搜索树（Binary-Search-Tree）" class="headerlink" title="什么是二叉搜索树（Binary Search Tree）"></a>什么是二叉搜索树<strong>（Binary</strong> <strong>Search</strong> <strong>Tree）</strong></h3><ol><li><p>二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST</p><p>又被称为：二叉查找树、二叉排序树</p></li></ol><ul><li>任意一个节点的值都大于其左子树所有节点的值</li><li>任意一个节点的值都小于其右子树所有节点的值</li><li>它的左右子树也是一棵二叉搜索树</li></ul><ol><li><p>二叉搜索树可以大大提高搜索数据的效率</p></li><li><p>二叉搜索树存储的元素必须具备可比较性</p></li></ol><ul><li><p>比如 int、double 等</p></li><li><p>如果是自定义类型，需要指定比较方式</p></li><li><p>不允许为 null</p></li></ul><p><img src="/2020/07/12/二叉搜索树/1.png" alt></p><h3 id="二叉搜索树的接口设计"><a href="#二叉搜索树的接口设计" class="headerlink" title="二叉搜索树的接口设计"></a>二叉搜索树的接口设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="comment">// 元素的数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span><span class="comment">// 是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">// 清空所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> <span class="comment">// 添加元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span><span class="comment">// 删除元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> <span class="comment">// 是否包含某元素</span></span></span><br></pre></td></tr></table></figure><p>需要注意的是</p><p>对于我们现在使用的二叉树来说，它的元素没有索引的概念</p><h4 id="元素的比较方案设计"><a href="#元素的比较方案设计" class="headerlink" title="元素的比较方案设计"></a>元素的比较方案设计</h4><ol><li><p>允许外界传入一个 Comparator 自定义比较方案</p></li><li><p>如果没有传入 Comparator，强制认定元素实现了 Comparable 接口</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E e1, E e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(e1, e2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((Comparable&lt;E&gt;)e1).compareTo(e2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据元素内容获取节点"><a href="#根据元素内容获取节点" class="headerlink" title="根据元素内容获取节点"></a>根据元素内容获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(element, node.element);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// cmp &lt; 0</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    elementNotNullCheck(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = createNode(element, <span class="keyword">null</span>);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">        afterAdd(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的不是第一个节点</span></span><br><span class="line">    <span class="comment">// 找到父节点</span></span><br><span class="line">    Node&lt;E&gt; parent = root;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">int</span> cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cmp = compare(element, node.element);</span><br><span class="line">        parent = node;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            node.element = element;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;E&gt; newNode = createNode(element, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新添加节点之后的处理</span></span><br><span class="line">    afterAdd(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><h5 id="删除节点-–-叶子节点（分析）"><a href="#删除节点-–-叶子节点（分析）" class="headerlink" title="删除节点 – 叶子节点（分析）"></a>删除节点 – 叶子节点（分析）</h5><p><img src="/2020/07/12/二叉搜索树/2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接删除</span></span><br><span class="line"><span class="number">1</span>. node == node.parent.left</span><br><span class="line">node.parent.left = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. node == node.parent.right</span><br><span class="line">node.parent.right = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. node.parent == <span class="keyword">null</span></span><br><span class="line">root = <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h5 id="删除节点-度为1的节点（分析）"><a href="#删除节点-度为1的节点（分析）" class="headerlink" title="删除节点 - 度为1的节点（分析）"></a>删除节点 - 度为1的节点（分析）</h5><p><img src="/2020/07/12/二叉搜索树/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用子节点替代原节点的位置</span></span><br><span class="line">child 是 node.left 或 者 child 是 node.right</span><br><span class="line">用 child 替代 node 的位置</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 如果 node 是左子节点</span><br><span class="line">child.parent = node.parent</span><br><span class="line">node.parent.left = child</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 如果 node 是右子节点</span><br><span class="line">child.parent = node.parent</span><br><span class="line">node.parent.right = child</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 如果 node 是根节点</span><br><span class="line">root = child</span><br><span class="line">child.parent = <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h5 id="删除节点-度为2的节点（分析）"><a href="#删除节点-度为2的节点（分析）" class="headerlink" title="删除节点 - 度为2的节点（分析）"></a>删除节点 - 度为2的节点（分析）</h5><p><img src="/2020/07/12/二叉搜索树/4.png" alt></p><p>举例：先删除 5、再删除 4</p><p>先用前驱或者后继节点的值覆盖原节点的值</p><p>然后删除相应的前驱或者后继节点</p><p><strong>如果一个节点的度为 2，那么，它的前驱、后继节点的度只可能是 1 和 0</strong></p><a href="/2020/07/11/二叉树/" title="二叉树的前驱、后继实现">二叉树的前驱、后继实现</a><h5 id="删除节点（代码实现）"><a href="#删除节点（代码实现）" class="headerlink" title="删除节点（代码实现）"></a>删除节点（代码实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断节点是否有两个叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTwoChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   size--;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 找到度为二节点的后继节点覆盖后，将后继节点s作为度为1的节点执行后面的操作</span></span><br><span class="line">   <span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line">      <span class="comment">// 找到后继节点</span></span><br><span class="line">      Node&lt;E&gt; s = successor(node);</span><br><span class="line">      <span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">      node.element = s.element;</span><br><span class="line">      <span class="comment">// 删除后继节点,使用后面的代码删除度为1的节点</span></span><br><span class="line">      node = s;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 删除node节点（node的度必然是1或者0）</span></span><br><span class="line">   <span class="comment">// 判断node节点有左节点还是右节点，也可能没有节点</span></span><br><span class="line">   Node&lt;E&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点</span></span><br><span class="line">      <span class="comment">// 更改parent</span></span><br><span class="line">      replacement.parent = node.parent;</span><br><span class="line">      <span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line">      <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">         root = replacement;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">         node.parent.left = replacement;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">         node.parent.right = replacement;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">      afterRemove(replacement);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123; <span class="comment">// node是叶子节点并且是根节点</span></span><br><span class="line">      root = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">      afterRemove(node);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">      <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">         node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">         node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 删除节点之后的处理</span></span><br><span class="line">      afterRemove(node);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的复杂度分析"><a href="#二叉搜索树的复杂度分析" class="headerlink" title="二叉搜索树的复杂度分析"></a>二叉搜索树的复杂度分析</h3><p><img src="/2020/07/12/二叉搜索树/5.png" alt>当 n 比较大时，两者的性能差异比较大</p><p>比如 n = 1000000 时，二叉搜索树的最低高度是 20</p><h4 id="退化成链表的另一种情况"><a href="#退化成链表的另一种情况" class="headerlink" title="退化成链表的另一种情况"></a>退化成链表的另一种情况</h4><p><img src="/2020/07/12/二叉搜索树/6.png" alt></p><p>有没有办法防止二叉搜索树退化成链表？</p><p>让添加、删除、搜索的复杂度维持在 O(logn)</p><h4 id="平衡（Balance）"><a href="#平衡（Balance）" class="headerlink" title="平衡（Balance）"></a>平衡（Balance）</h4><p>平衡：当节点数量固定时，左右子树的高度越接近，这棵二叉树就越平衡（高度越低）</p><p><img src="/2020/07/12/二叉搜索树/7.png" alt></p><h4 id="理想平衡"><a href="#理想平衡" class="headerlink" title="理想平衡"></a>理想平衡</h4><p>最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的</p><p><img src="/2020/07/12/二叉搜索树/8.png" alt></p><h3 id="如何改进二叉搜索树？"><a href="#如何改进二叉搜索树？" class="headerlink" title="如何改进二叉搜索树？"></a>如何改进二叉搜索树？</h3><p>首先，节点的添加、删除顺序是无法限制的，可以认为是随机的</p><p>所以，改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）</p><p><img src="/2020/07/12/二叉搜索树/9.png" alt></p><p>如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大</p><p>比如调整的次数会比较多，反而增加了时间复杂度</p><p>总结来说，比较合理的改进方案是：用尽量少的调整次数达到适度平衡即可</p><p>一棵达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树</p><h3 id="平衡二叉搜索树（Balanced-Binary-Search-Tree）"><a href="#平衡二叉搜索树（Balanced-Binary-Search-Tree）" class="headerlink" title="平衡二叉搜索树（Balanced Binary Search Tree）"></a>平衡二叉搜索树（Balanced Binary Search Tree）</h3><p>英文简称为：BBST</p><p>经典常见的平衡二叉搜索树有</p><ol><li><p>AVL树</p><ul><li>Windows NT 内核中广泛使用</li></ul></li><li><p>红黑树</p><ul><li><p>C++ STL（比如 map、set ）</p></li><li><p>Java 的 TreeMap、TreeSet、HashMap、HashSet</p></li><li><p>Linux 的进程调度</p></li><li><p>Ngix 的 timer 管理</p></li></ul></li></ol><p>一般也称它们为：自平衡的二叉搜索树（Self-balancing Binary Search Tree）</p><a href="/2020/07/12/AVL树/" title="AVL树的实现">AVL树的实现</a><a href="/2020/07/12/红黑树/" title="红黑树的实现">红黑树的实现</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h2&gt;&lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2020/07/11/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/11/二叉树/</id>
    <published>2020-07-11T08:12:38.000Z</published>
    <updated>2020-07-12T06:35:02.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树（Tree）的基本概念"><a href="#树（Tree）的基本概念" class="headerlink" title="树（Tree）的基本概念"></a>树（Tree）的基本概念</h3><ul><li><p>节点、根节点、父节点、子节点、兄弟节点</p></li><li><p>一棵树可以没有任何节点，称为空树</p></li><li><p>一棵树可以只有 1 个节点，也就是只有根节点</p></li><li><p>子树、左子树、右子树</p></li><li><p>节点的度（degree）：子树的个数</p></li><li><p>树的度：所有节点度中的最大值</p></li><li><p>叶子节点（leaf）：度为 0 的节点</p></li><li><p>非叶子节点：度不为 0 的节点</p></li><li><p>层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算）</p></li><li><p>节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数</p></li><li><p>节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数</p></li><li><p>树的深度：所有节点深度中的最大值</p></li><li><p>树的高度：所有节点高度中的最大值</p></li><li><p>树的深度 等于 树的高度</p></li></ul><h3 id="有序树、无序树、森林"><a href="#有序树、无序树、森林" class="headerlink" title="有序树、无序树、森林"></a>有序树、无序树、森林</h3><ol><li><p>有序树</p><p>树中任意节点的子节点之间有顺序关系</p></li><li><p>无序树，也称为“自由树”</p><p>树中任意节点的子节点之间没有顺序关系</p></li><li><p>森林</p><p>由 m（m ≥ 0）棵互不相交的树组成的集合</p></li></ol><h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><ul><li><p>每个节点的度最大为 2（最多拥有 2 棵子树）</p></li><li><p>左子树和右子树是有顺序的</p></li><li><p>即使某节点只有一棵子树，也要区分左右子树</p></li></ul><p><img src="/2020/07/11/二叉树/1.png" alt></p><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ul><li><p>非空二叉树的第 $i$ 层，最多有 $2^{i − 1}$个节点 （ $i \geq 1$）</p></li><li><p>在高度为 h 的二叉树上最多有 $2^h − 1 $个结点（$h  \geq 1$ ）</p></li></ul><p>对于任何一棵非空二叉树，如果叶子节点个数为 $n0$，度为 $2$ 的节点个数为 $ n2$，则有: $n0 = n2 + 1$</p><p>假设度为$ 1 $的节点个数为 $n1$，那么二叉树的节点总数 $ n = n0 + n1 + n2$</p><p>二叉树的边数 $ T = n1 + 2 * n2 = n – 1 = n0 + n1 + n2 – 1$</p><p>因此 $ n0 = n2 + 1$</p><p><img src="/2020/07/11/二叉树/2.png" alt></p><h4 id="真二叉树（Proper-Binary-Tree）"><a href="#真二叉树（Proper-Binary-Tree）" class="headerlink" title="真二叉树（Proper Binary Tree）"></a>真二叉树（Proper Binary Tree）</h4><p>真二叉树：所有节点的度都要么为 0，要么为 2 </p><p><img src="/2020/07/11/二叉树/3.png" alt></p><h4 id="满二叉树（Full-Binary-Tree）"><a href="#满二叉树（Full-Binary-Tree）" class="headerlink" title="满二叉树（Full Binary Tree）"></a>满二叉树（Full Binary Tree）</h4><p>最后一层节点的度都为 $0$，其他节点的度都为 $2$</p><p>在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多</p><p>满二叉树一定是真二叉树，真二叉树不一定是满二叉树</p><p><img src="/2020/07/11/二叉树/4.png" alt></p><p>假设满二叉树的高度为 $h（ h ≥ 1 ）$，那么</p><p>第 i 层的节点数量：$ 2i − 1$ ， 叶子节点数量： $2h − 1$ ， 总节点数量$ n$</p><p>$n = 2h − 1 = 20 + 21 + 22 + ⋯ + 2h−1$</p><p>$h = log2(n + 1)$</p><h4 id="完全二叉树（Complete-Binary-Tree）"><a href="#完全二叉树（Complete-Binary-Tree）" class="headerlink" title="完全二叉树（Complete Binary Tree）"></a>完全二叉树（Complete Binary Tree）</h4><p>对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应</p><ul><li><p>叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐</p></li><li><p>完全二叉树从根结点至倒数第 2 层是一棵满二叉树</p></li><li><p>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</p></li></ul><p><img src="/2020/07/11/二叉树/5.png" alt></p><h5 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h5><ul><li><p>度为 1 的节点只有左子树</p></li><li><p>度为 1 的节点要么是 1 个，要么是 0 个</p></li><li><p>同样节点数量的二叉树，完全二叉树的高度最小</p></li></ul><ol><li><p>假设完全二叉树的高度为 $h（ h ≥ 1 ）$，那么</p><p>​    至少有 $2h − 1$ 个节点 $（ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−2} + 1 ）$</p><p>​    最多有 $2h − 1$ 个节点（$ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−1}$，满二叉树 ）</p><p>​    总节点数量为 $n$</p><p>​    $2^{h − 1} ≤ n &lt; 2^h    $</p><p>​    $h − 1 ≤ log_2n &lt; h$</p><p>​    $h = floor( log_2n ) + 1$</p><p>​    $floor $是向下取整，另外，$ceiling $是向上取整</p></li><li><p>一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $ 1$ 开始进行编号，对任意第 $ i $ 个节点</p><p>​    如果 $i = 1$，它是根节点</p><p>​    如果 $i &gt; 1$ ，它的父节点编号为 $floor( i / 2 )$</p><p>​    如果 $2i ≤ n$ ，它的左子节点编号为 $2i$</p><p>​    如果 $2i &gt; n$ ，它无左子节点</p><p>​    如果 $2i + 1 ≤ n$ ，它的右子节点编号为 $2i + 1$</p><p>​    如果 $2i + 1 &gt; n$ ，它无右子节点</p></li><li><p>一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $0$ 开始进行编号，对任意第 $i$ 个节点</p><p>​    如果 $i = 0$ ，它是根节点</p><p>​    如果 $i &gt; 0$ ，它的父节点编号为 $floor( (i – 1) / 2 )$</p><p>​    如果 $2i + 1 ≤ n – 1$ ，它的左子节点编号为 $2i + 1$</p><p>​    如果 $2i + 1 &gt; n – 1$ ，它无左子节点</p><p>​    如果 $2i + 2 ≤ n – 1$ ，它的右子节点编号为 $2i + 2$</p><p>​    如果 $2i + 2 &gt; n – 1$ ，它无右子节点</p></li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>如果一棵完全二叉树有 $768$ 个节点，求叶子节点的个数</p><p>假设叶子节点个数为 $n0$，度为 $1$ 的节点个数为 $n1$，度为 $2$ 的节点个数为 $n2$</p><p>总结点个数 $n = n0 + n1 + n2$，而且 $n0 = n2 + 1$</p><p>$n = 2n0 + n1 – 1$</p><p>完全二叉树的 $n1$ 要么为 $0$，要么为 $1$</p><p>$n1$为 $1$ 时，$n = 2n0$，$n$ 必然是偶数</p><p>叶子节点个数 $n0 = n / 2$，非叶子节点个数 $n1 + n2 = n / 2$</p><p>$n1$为 $0$ 时，$n = 2n0 – 1$，$n$ 必然是奇数</p><p>叶子节点个数 $n0 = (n + 1) / 2$，非叶子节点个数 $n1 + n2 = (n – 1) / 2$</p><p>叶子节点个数 $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$</p><p>非叶子节点个数 $n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )$</p><p>因此叶子节点个数为 $384$</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的常见遍历方式有4种</p><ul><li><p>前序遍历（Preorder Traversal）</p></li><li><p>中序遍历（Inorder Traversal）</p></li><li><p>后序遍历（Postorder Traversal）</p></li><li><p>层序遍历（Level Order Traversal）</p></li></ul><h4 id="前序遍历（Preorder-Traversal）"><a href="#前序遍历（Preorder-Traversal）" class="headerlink" title="前序遍历（Preorder Traversal）"></a>前序遍历（Preorder Traversal）</h4><p>访问顺序</p><p>根节点、前序遍历左子树、前序遍历右子树</p><p>7、4、2、1、3、5、9、8、11、10、12</p><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/二叉树/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">   preorder(node.left);</span><br><span class="line">   preorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归，利用栈实现"><a href="#非递归，利用栈实现" class="headerlink" title="非递归，利用栈实现"></a>非递归，利用栈实现</h5><p><img src="/2020/07/11/二叉树/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将 root 入 栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 循环执行以下操作，直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出栈顶节点 top，进行访问</span></span><br><span class="line">        Node&lt;E&gt; node = stack.pop();</span><br><span class="line">        <span class="comment">// 访问node节点</span></span><br><span class="line">System.out.println(node.element);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将 top.right 入 栈</span></span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 top.left 入 栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（Inorder-Traversal）"><a href="#中序遍历（Inorder-Traversal）" class="headerlink" title="中序遍历（Inorder Traversal）"></a>中序遍历（Inorder Traversal）</h4><p>访问顺序</p><p>中序遍历左子树、根节点、中序遍历右子树</p><p>1、2、3、4、5、7、8、9、10、11、12</p><h5 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/二叉树/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归，利用栈实现-1"><a href="#非递归，利用栈实现-1" class="headerlink" title="非递归，利用栈实现"></a>非递归，利用栈实现</h5><p><img src="/2020/07/11/二叉树/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Visitor&lt;E&gt; visitor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置 node = root</span></span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">// 向左走</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()) &#123; <span class="comment">// 如果栈为空，结束遍历</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 如果栈不为空，弹出栈顶元素并赋值给 node</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="comment">// 访问node节点</span></span><br><span class="line">System.out.println(node.element);</span><br><span class="line">            <span class="comment">// 让右节点进行中序遍历</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（Postorder-Traversal）"><a href="#后序遍历（Postorder-Traversal）" class="headerlink" title="后序遍历（Postorder Traversal）"></a>后序遍历（Postorder Traversal）</h4><p>访问顺序</p><p>后序遍历左子树、后序遍历右子树、根节点</p><p>1、3、2、5、4、8、10、12、11、9、7</p><h5 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/二叉树/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(node.left);</span><br><span class="line">    postorder(node.right);</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归，利用栈实现-2"><a href="#非递归，利用栈实现-2" class="headerlink" title="非递归，利用栈实现"></a>非递归，利用栈实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 记录上一次弹出访问的节点</span></span><br><span class="line">    Node&lt;E&gt; prev = <span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;Node&lt;E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将 root 入 栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 循环执行以下操作，直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node&lt;E&gt; top = stack.peek();</span><br><span class="line">        <span class="comment">// 如果栈顶节点是叶子节点 或者 上一次访问的节点是栈顶节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (top.isLeaf() || (prev != <span class="keyword">null</span> &amp;&amp; prev.parent == top)) &#123;</span><br><span class="line">            prev = stack.pop();</span><br><span class="line">            <span class="comment">// 访问节点</span></span><br><span class="line">System.out.println(node.element);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历（Level-Order-Traversal）"><a href="#层序遍历（Level-Order-Traversal）" class="headerlink" title="层序遍历（Level Order Traversal）"></a>层序遍历（Level Order Traversal）</h4><p>访问顺序</p><p>从上到下、从左到右依次访问每一个节点</p><p>7、4、9、2、5、8、11、1、3、10、12</p><h5 id="非递归，利用队列实现"><a href="#非递归，利用队列实现" class="headerlink" title="非递归，利用队列实现"></a>非递归，利用队列实现</h5><p><img src="/2020/07/11/二叉树/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将根节点入队</span></span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行以下操作，直到队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将队头节点 A 出队，进行访问</span></span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">System.out.println(node.element);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 将右子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h3><ul><li><p>前序遍历</p><p>树状结构展示（注意左右子树的顺序）</p></li><li><p>中序遍历</p><p>二叉搜索树的中序遍历按升序或者降序处理节点</p></li><li><p>后序遍历</p><p>适用于一些先子后父的操作</p></li><li><p>层序遍历</p><p>计算二叉树的高度</p><p>判断一棵树是否为完全二叉树</p></li></ul><h3 id="根据遍历结果重构二叉树"><a href="#根据遍历结果重构二叉树" class="headerlink" title="根据遍历结果重构二叉树"></a>根据遍历结果重构二叉树</h3><p>以下结果可以保证重构出唯一的一棵二叉树</p><ul><li><p>前序遍历 + 中序遍历</p></li><li><p>后序遍历 + 中序遍历</p></li></ul><p><img src="/2020/07/11/二叉树/12.png" alt></p><p>前序遍历 + 后序遍历</p><p>​    如果它是一棵真二叉树（Proper Binary Tree），结果是唯一的，不然结果不唯一</p><p><img src="/2020/07/11/二叉树/13.png" alt></p><h4 id="前序遍历-中序遍历重构二叉树"><a href="#前序遍历-中序遍历重构二叉树" class="headerlink" title="前序遍历+中序遍历重构二叉树"></a>前序遍历+中序遍历重构二叉树</h4><p>前序遍历：4 2 1 3 6 5</p><p>中序遍历：1 2 3 4 5 6</p><p><img src="/2020/07/11/二叉树/14.png" alt></p><h3 id="前驱、后继节点"><a href="#前驱、后继节点" class="headerlink" title="前驱、后继节点"></a>前驱、后继节点</h3><h4 id="前驱节点（predecessor）"><a href="#前驱节点（predecessor）" class="headerlink" title="前驱节点（predecessor）"></a>前驱节点（predecessor）</h4><p>前驱节点：中序遍历时的前一个节点</p><p>如果是二叉搜索树，前驱节点就是前一个比它小的节点</p><p><img src="/2020/07/11/二叉树/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;E&gt; <span class="title">predecessor</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点在左子树当中（left.right.right.right....）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node.left != null时</span></span><br><span class="line"><span class="comment">// 举例：6-》5、13-》12、8-》7</span></span><br><span class="line"><span class="comment">// predecessor = node.left.right.right.right...</span></span><br><span class="line">    Node&lt;E&gt; p = node.left;</span><br><span class="line">    <span class="comment">// 终止条件：right 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从父节点、祖父节点中寻找前驱节点</span></span><br><span class="line">    <span class="comment">// node.left == null &amp;&amp; node.parent != null</span></span><br><span class="line">    <span class="comment">// 举例：7-》6、11-》10、9-》8</span></span><br><span class="line"><span class="comment">// predecessor = node.parent.parent.parent...</span></span><br><span class="line">    <span class="comment">// 终止条件：node 在 parent 的右子树中</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.left) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.left == null &amp;&amp; node.parent == null</span></span><br><span class="line"><span class="comment">// 那就没有前驱节点</span></span><br><span class="line"><span class="comment">// 举例：没有左子树的根节点 1 </span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后继节点（successor）"><a href="#后继节点（successor）" class="headerlink" title="后继节点（successor）"></a>后继节点（successor）</h4><p>后继节点：中序遍历时的后一个节点</p><p>如果是二叉搜索树，后继节点就是后一个比它大的节点</p><p><img src="/2020/07/11/二叉树/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Node&lt;E&gt; <span class="title">successor</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点在左子树当中（right.left.left.left....）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node.right != null</span></span><br><span class="line"><span class="comment">// 举例：1、8、4、10</span></span><br><span class="line">    <span class="comment">// successor = node.right.left.left.left...</span></span><br><span class="line">    Node&lt;E&gt; p = node.right;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 终止条件：left 为 null</span></span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.right == null &amp;&amp; node.parent != null</span></span><br><span class="line">    <span class="comment">// 举例：6、3、11</span></span><br><span class="line"><span class="comment">// successor = node.parent.parent.parent...</span></span><br><span class="line">    <span class="comment">// 终止条件：node 在 parent 的左子树中</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.right == null &amp;&amp; node.parent == null</span></span><br><span class="line"><span class="comment">// 那就没有前驱节点</span></span><br><span class="line"><span class="comment">// 举例：没有右子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算二叉树的高度"><a href="#计算二叉树的高度" class="headerlink" title="计算二叉树的高度"></a>计算二叉树的高度</h3><h4 id="非递归，利用队列实现-1"><a href="#非递归，利用队列实现-1" class="headerlink" title="非递归，利用队列实现"></a>非递归，利用队列实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的高度</span></span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存储着每一层的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> levelSize = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        levelSize--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (levelSize == <span class="number">0</span>) &#123; <span class="comment">// 意味着即将要访问下一层</span></span><br><span class="line">            levelSize = queue.size();</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(node.left), height(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/二叉树/17.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        </span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;树（Tree）的基本概念&quot;&gt;&lt;a href=&quot;#树（Tree）的基本概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://yoursite.com/2020/07/11/%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/11/队列/</id>
    <published>2020-07-11T07:55:14.000Z</published>
    <updated>2020-07-11T08:09:25.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>队列是一种特殊的线性表，只能在头尾两端进行操作</p><p>队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队</p><p>队头（front）：只能从队头移除元素，一般叫做 deQueue，出队</p><p>先进先出的原则，First In First Out，FIFO</p><p><img src="/2020/07/11/队列/1.png" alt></p><h3 id="队列的代码实现"><a href="#队列的代码实现" class="headerlink" title="队列的代码实现"></a>队列的代码实现</h3><p>队列的内部实现可以直接利用<strong>动态数组、链表</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">// 清空</span></span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123; <span class="comment">//入队</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123; <span class="comment">// 出队</span></span><br><span class="line"><span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取队首元素，不删除</span></span><br><span class="line"><span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列（Deque）"><a href="#双端队列（Deque）" class="headerlink" title="双端队列（Deque）"></a>双端队列（Deque）</h2><p>双端队列是能在头尾两端添加、删除的队列，英文 deque 是 double ended queue 的简称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">// 清空</span></span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueRear</span><span class="params">(E element)</span> </span>&#123; <span class="comment">// 从队尾入队</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueFront</span><span class="params">()</span> </span>&#123; <span class="comment">// 从队头出队</span></span><br><span class="line"><span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueFront</span><span class="params">(E element)</span> </span>&#123; <span class="comment">// 从队头入队</span></span><br><span class="line">list.add(<span class="number">0</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueRear</span><span class="params">()</span> </span>&#123; <span class="comment">// 从队尾出队</span></span><br><span class="line"><span class="keyword">return</span> list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取队列的头元素</span></span><br><span class="line"><span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">rear</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取队列的尾元素</span></span><br><span class="line"><span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列（Circle-Queue）"><a href="#循环队列（Circle-Queue）" class="headerlink" title="循环队列（Circle Queue）"></a>循环队列（Circle Queue）</h2><p>可以进行两端添加、删除操作的循环队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">elements[index(i)] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">elements[index(size)] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">E frontElement = elements[front];</span><br><span class="line">elements[front] = <span class="keyword">null</span>;</span><br><span class="line">front = index(<span class="number">1</span>);</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> frontElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">index += front;</span><br><span class="line"><span class="keyword">return</span> index - (index &gt;= elements.length ? elements.length : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证要有capacity的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">newElements[i] = elements[index(i)];</span><br><span class="line">&#125;</span><br><span class="line">elements = newElements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置front</span></span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环双端队列"><a href="#循环双端队列" class="headerlink" title="循环双端队列"></a>循环双端队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleDeque</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">elements = (E[]) <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">elements[index(i)] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾部入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueRear</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">elements[index(size)] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">E frontElement = elements[front];</span><br><span class="line">elements[front] = <span class="keyword">null</span>;</span><br><span class="line">front = index(<span class="number">1</span>);</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> frontElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueueFront</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">front = index(-<span class="number">1</span>);</span><br><span class="line">elements[front] = element;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾部出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueueRear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rearIndex = index(size - <span class="number">1</span>);</span><br><span class="line">E rear = elements[rearIndex];</span><br><span class="line">elements[rearIndex] = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[index(size - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">index += front;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> index + elements.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index - (index &gt;= elements.length ? elements.length : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证要有capacity的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">newElements[i] = elements[index(i)];</span><br><span class="line">&#125;</span><br><span class="line">elements = newElements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置front</span></span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;队列（Queue）&quot;&gt;&lt;a href=&quot;#队列（Queue）&quot; class=&quot;headerlink&quot; title=&quot;队列（Queue）&quot;&gt;&lt;/a&gt;队列（Queue）&lt;/h2&gt;&lt;h3 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;header
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://yoursite.com/2020/07/11/%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/11/栈/</id>
    <published>2020-07-11T07:31:28.000Z</published>
    <updated>2020-07-11T08:10:52.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h2><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>栈是一种特殊的线性表，只能在一端进行操作</p><p>往栈中添加元素的操作，一般叫做 push，入栈</p><p>从栈中移除元素的操作，一般叫做 pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素）</p><p><strong>后进先出</strong>的原则，Last In First Out，LIFO</p><p><img src="/2020/07/11/栈/1.png" alt></p><p><strong>注意：这里说的“栈”与内存中的“栈空间”是两个不同的概念</strong></p><h3 id="栈的代码实现"><a href="#栈的代码实现" class="headerlink" title="栈的代码实现"></a>栈的代码实现</h3><p>栈的内部实现可以直接利用<strong>动态数组、链表</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="comment">// 清空</span></span><br><span class="line">list.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="keyword">return</span> list.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E element)</span> </span>&#123; <span class="comment">// 入栈</span></span><br><span class="line">list.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">// 出栈</span></span><br><span class="line"><span class="keyword">return</span> list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取栈顶元素，不删除</span></span><br><span class="line"><span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h4><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/栈/2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>, <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">// 判断是否是左边，是就入栈</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左边出栈，进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">char</span> left = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (c != map.get(left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用站实现队列"><a href="#用站实现队列" class="headerlink" title="用站实现队列"></a>用站实现队列</h4><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/栈/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 入栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 出栈 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkOutStack();</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 得到栈顶元素，不删除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkOutStack();</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkOutStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈（stack）&quot;&gt;&lt;a href=&quot;#栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（stack）&quot;&gt;&lt;/a&gt;栈（stack）&lt;/h2&gt;&lt;h3 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%88/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yoursite.com/2020/07/11/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/11/链表/</id>
    <published>2020-07-11T04:54:11.000Z</published>
    <updated>2020-07-13T05:19:47.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h2><h3 id="为什么有链表"><a href="#为什么有链表" class="headerlink" title="为什么有链表"></a>为什么有链表</h3><p>动态数组有个明显的缺点，可能会造成<strong>内存空间的大量浪费</strong></p><p>能否用到多少就申请多少内存？</p><p>链表可以办到这一点</p><p><strong>链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的</strong></p><p><img src="/2020/07/11/链表/1.png" alt></p><h3 id="链表的设计"><a href="#链表的设计" class="headerlink" title="链表的设计"></a>链表的设计</h3><p><img src="/2020/07/11/链表/2.png" alt></p><h4 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h4><p>链表的大部分接口和动态数组是一致的</p><p><img src="/2020/07/11/链表/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不存在在返回-1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取index位置的元素</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置index位置的元素</span></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在index位置插入一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除index位置的元素</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测传入的下标是否合法"><a href="#检测传入的下标是否合法" class="headerlink" title="检测传入的下标是否合法"></a>检测传入的下标是否合法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">outOfBounds</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index:"</span> + index + <span class="string">", Size:"</span> + size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        outOfBounds(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        outOfBounds(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="node方法用于获取index位置的节点"><a href="#node方法用于获取index位置的节点" class="headerlink" title="node方法用于获取index位置的节点"></a>node方法用于获取index位置的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    Node&lt;E&gt; node = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"><span class="comment">// element新节点的值，next新节点指向的下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E element, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加元素-add-int-index-E-element"><a href="#添加元素-add-int-index-E-element" class="headerlink" title="添加元素-add(int index,E element)"></a>添加元素-add(int index,E element)</h4><p><img src="/2020/07/11/链表/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">add(size, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在编写链表过程中，要注意边界测试，比如 index 为 0 、size – 0 、size 时</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;&gt;(element,first);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 找到插入下标的上一个元素</span></span><br><span class="line">        Node&lt;E&gt; prev = node(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 新创建的节点指向原先prev.next（如上图：1指向2）,再将prev.next指向新节点（如上图：0指向1）</span></span><br><span class="line">        prev.next = <span class="keyword">new</span> Node&lt;&gt;(element,prev.next);</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="/2020/07/11/链表/5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">rangeCheck(index);</span><br><span class="line">Node&lt;E&gt; node = first;</span><br><span class="line">    <span class="comment">// 注意0位置</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">first = first.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 找到待删除元素上一个元素的下标</span></span><br><span class="line">Node&lt;E&gt; prev = node(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// node待删除的元素</span></span><br><span class="line">node = prev.next;</span><br><span class="line">prev.next = node.next;</span><br><span class="line">&#125;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> node.element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空链表"><a href="#清空链表" class="headerlink" title="清空链表"></a>清空链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// next不需要设置为null</span></span><br><span class="line">first = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表中某个元素的下标"><a href="#判断链表中某个元素的下标" class="headerlink" title="判断链表中某个元素的下标"></a>判断链表中某个元素的下标</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表中允许有null值元素</span></span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node&lt;E&gt; node = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.element == <span class="keyword">null</span>) <span class="keyword">return</span> i;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(node.element)) <span class="keyword">return</span> i;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ELEMENT_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表中是否包含某个元素"><a href="#判断链表中是否包含某个元素" class="headerlink" title="判断链表中是否包含某个元素"></a>判断链表中是否包含某个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(E element) &#123;</span><br><span class="line">return indexOf(element) != ELEMENT_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>使用双向链表可以提升链表的综合性能</p><p><img src="/2020/07/11/链表/14.png" alt></p><h3 id="node方法用于获取index位置的节点-1"><a href="#node方法用于获取index位置的节点-1" class="headerlink" title="node方法用于获取index位置的节点"></a>node方法用于获取index位置的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 分两条路寻找节点</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>))&#123;</span><br><span class="line">        Node&lt;E&gt; node = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; node = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            node = node.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节点-1"><a href="#创建节点-1" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    E element;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素-add-int-index-E-element-1"><a href="#添加元素-add-int-index-E-element-1" class="headerlink" title="添加元素-add(int index,E element)"></a>添加元素-add(int index,E element)</h3><p><img src="/2020/07/11/链表/15.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">add(size, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">if</span> (index == size)&#123;</span><br><span class="line">        Node&lt;E&gt; oldLast = last;</span><br><span class="line">        last = <span class="keyword">new</span> Node&lt;&gt;(oldLast,element,<span class="keyword">null</span>);</span><br><span class="line">        oldLast.next = last;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;E&gt; next = node(index);</span><br><span class="line">        Node&lt;E&gt; prev = next.prev;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(prev,element,next);</span><br><span class="line">        next.prev = node;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素-–-remove-int-index"><a href="#删除元素-–-remove-int-index" class="headerlink" title="删除元素 – remove(int index)"></a>删除元素 – remove(int index)</h3><p><img src="/2020/07/11/链表/16.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; node = node(index);</span><br><span class="line">    Node&lt;E&gt; prev = node.prev;</span><br><span class="line">    Node&lt;E&gt; next = node.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> node.element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表-vs-单向链表"><a href="#双向链表-vs-单向链表" class="headerlink" title="双向链表 vs 单向链表"></a>双向链表 vs 单向链表</h2><p>粗略对比一下删除的操作数量</p><p>单向链表： $1+2+3+…+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$  ${n^2} \over {2}$， 除以$n$ 平均一下是 ${1} \over {2}$ + ${n} \over {2}$</p><p>双向链表：$(1+2+3+…+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ，除以$n$平均一下是 ${1} \over {2}$ + ${n} \over{4}$</p><p>操作数量缩减了近一半</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h4 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h4><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/链表/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转一个链表"><a href="#反转一个链表" class="headerlink" title="反转一个链表"></a>反转一个链表</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/链表/7.png" alt></p><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><p><img src="/2020/07/11/链表/8.png" alt></p><p><img src="/2020/07/11/链表/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 定义新的头节点</span></span><br><span class="line">    ListNode newHead = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归-–-头插法"><a href="#非递归-–-头插法" class="headerlink" title="非递归 – 头插法"></a><strong>非递归</strong> <strong>–</strong> 头插法</h5><p><img src="/2020/07/11/链表/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode tmp = head.next;</span><br><span class="line">        <span class="comment">// 每次遍历让head.next成为头节点</span></span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        <span class="comment">// head重新指向tmp，使循环按顺序继续遍历</span></span><br><span class="line">        head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断一个链表是否有环"><a href="#判断一个链表是否有环" class="headerlink" title="判断一个链表是否有环"></a>判断一个链表是否有环</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">leetcode地址</a></p><p><img src="/2020/07/11/链表/11.png" alt></p><p><img src="/2020/07/11/链表/12.png" alt></p><p><img src="/2020/07/11/链表/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针，相遇则有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 慢指针，每次走一步</span></span><br><span class="line">ListNode slow = head;</span><br><span class="line">    <span class="comment">// 快指针，每次走两步</span></span><br><span class="line">ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line"><span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表（Linked-List）&quot;&gt;&lt;a href=&quot;#链表（Linked-List）&quot; class=&quot;headerlink&quot; title=&quot;链表（Linked List）&quot;&gt;&lt;/a&gt;链表（Linked List）&lt;/h2&gt;&lt;h3 id=&quot;为什么有链表&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>动态数组</title>
    <link href="http://yoursite.com/2020/07/09/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/07/09/动态数组/</id>
    <published>2020-07-09T13:07:28.000Z</published>
    <updated>2020-07-13T04:54:41.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种顺序存储的线性表，所有元素的内存地址是连续的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/09/动态数组/1.png" alt></p><p>在很多编程语言中，数组都有个致命的缺点，<strong>无法动态修改容量</strong></p><p>实际开发中，我们更希望数组的容量是可以<strong>动态改变</strong>的</p><h3 id="动态数组（Dynamic-Array）接口设计"><a href="#动态数组（Dynamic-Array）接口设计" class="headerlink" title="动态数组（Dynamic Array）接口设计"></a>动态数组（Dynamic Array）接口设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>; <span class="comment">// 是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">// 添加元素到最后</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 返回indext位置对应的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>; <span class="comment">// 设置indext位置对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>; <span class="comment">// 往index位置添加元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 删除index位置对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>; <span class="comment">// 查看元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清除所有元素</span></span><br></pre></td></tr></table></figure><h4 id="动态数组的设计"><a href="#动态数组的设计" class="headerlink" title="动态数组的设计"></a>动态数组的设计</h4><p><img src="/2020/07/09/动态数组/2.png" alt></p><p>在Java中，成员变量会自动初始化，比如</p><p>int 类型自动初始化为 0</p><p>对象类型自动初始化为 null</p><h4 id="添加元素-add-E-element"><a href="#添加元素-add-E-element" class="headerlink" title="添加元素 - add(E element)"></a>添加元素 - add(E element)</h4><p><img src="/2020/07/09/动态数组/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有索引下标，默认放在数组最后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">    add(size,element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组某个位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检测下标是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素开始，到index下标（逆序），数组元素向后覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">        elements[i] = elements[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    elements[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素-remove-int-index"><a href="#删除元素-remove-int-index" class="headerlink" title="删除元素 - remove(int index)"></a>删除元素 - remove(int index)</h4><p><img src="/2020/07/09/动态数组/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E old = elements[index];</span><br><span class="line">    <span class="comment">// 从index下标开始，数组元素向前挪动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        elements[i - <span class="number">1</span>] = elements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    elements[--size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何扩容-ensureCapacity-int-capacity"><a href="#如何扩容-ensureCapacity-int-capacity" class="headerlink" title="如何扩容 - ensureCapacity(int capacity)"></a>如何扩容 - ensureCapacity(int capacity)</h4><p><img src="/2020/07/09/动态数组/5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组容量不够时，扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line"><span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 容量添加1.5倍</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 左移，缩小一半(再加上原来的容量)</span></span><br><span class="line">E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line"><span class="comment">// 将旧数组的元素拷贝到新数组</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">0</span>) System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, size);</span><br><span class="line">elements = newElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.omg.CORBA.Object;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dynamicArray</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所以的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPATICY = <span class="number">10</span>; <span class="comment">//初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>; <span class="comment">//找不到查找的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">dynamicArray</span><span class="params">(<span class="keyword">int</span> capaticy)</span></span>&#123;</span><br><span class="line">        capaticy = Math.max(capaticy, DEFAULT_CAPATICY);</span><br><span class="line">        elements = (E[]) <span class="keyword">new</span> Object[capaticy]; <span class="comment">//初始化数组容量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">dynamicArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPATICY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">        add(size,element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数组某个位置插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数组元素向前覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">elements[i] = elements[i-<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">        elements[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组容量不够时，扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt;= capacity) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 容量添加1.5倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">// 左移，缩小一半</span></span><br><span class="line">        E[] newElements = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">// 将旧数组的元素拷贝到新数组</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= <span class="number">0</span>) System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, size);</span><br><span class="line">        elements = newElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        </span><br><span class="line">        E old = elements[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i - <span class="number">1</span>] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        elements[--size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(element) != ELEMENT_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        E old = elements[index];</span><br><span class="line">        elements[index] = element;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.equals(elements[i])) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ELEMENT_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outOfBounds</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index:"</span> + index + <span class="string">", Size:"</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测传入的下标是否越界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            outOfBounds(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            outOfBounds(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dynamicArray&#123;"</span> +</span><br><span class="line">                <span class="string">"size="</span> + size +</span><br><span class="line">                <span class="string">", elements="</span> + Arrays.toString(elements) +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态数组&quot;&gt;&lt;a href=&quot;#动态数组&quot; class=&quot;headerlink&quot; title=&quot;动态数组&quot;&gt;&lt;/a&gt;动态数组&lt;/h2&gt;&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2020/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/07/09/数据结构/</id>
    <published>2020-07-09T12:42:35.000Z</published>
    <updated>2020-07-09T12:53:10.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h3><p>数据结构是计算机存储、组织数据的方式</p><p><img src="/2020/07/09/数据结构/1.png" alt></p><div class="table-container"><table><thead><tr><th style="text-align:center">线性表</th><th style="text-align:center">二叉树</th><th style="text-align:center">邻接矩阵</th></tr></thead><tbody><tr><td style="text-align:center">数组、链表</td><td style="text-align:center">AVL树、红黑树</td><td style="text-align:center">邻接表</td></tr><tr><td style="text-align:center">栈、队列</td><td style="text-align:center">B树、堆、Trie</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">哈希表</td><td style="text-align:center">哈夫曼树、并查集</td></tr></tbody></table></div><p>在实际应用中，根据使用场景来选择最合适的数据结构</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h3 id=&quot;什么是数据结构？&quot;&gt;&lt;a href=&quot;#什么是数据结构？&quot; class=&quot;headerlink&quot; title=&quot;什
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法复杂度</title>
    <link href="http://yoursite.com/2020/07/09/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/07/09/算法复杂度/</id>
    <published>2020-07-09T06:44:44.000Z</published>
    <updated>2020-07-09T07:57:12.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="如何评判一个算法的好坏？"><a href="#如何评判一个算法的好坏？" class="headerlink" title="如何评判一个算法的好坏？"></a>如何评判一个算法的好坏？</h3><p>一般从以下维度来评估算法的优劣</p><ul><li>正确性、可读性、健壮性（对不合理输入的反应能力和处理能力）</li><li>时间复杂度（time complexity）：估算程序指令的执行次数（执行时间）</li><li>空间复杂度（space complexity）：估算所需占用的存储空间</li></ul><h3 id="大O表示法（Big-O）"><a href="#大O表示法（Big-O）" class="headerlink" title="大O表示法（Big O）"></a>大O表示法（Big O）</h3><h4 id="一般用大O表示法来描述复杂度，它表示的是数据规模-n-对应的复杂度，忽略常数、系数、低阶"><a href="#一般用大O表示法来描述复杂度，它表示的是数据规模-n-对应的复杂度，忽略常数、系数、低阶" class="headerlink" title="一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度，忽略常数、系数、低阶"></a>一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度，忽略常数、系数、低阶</h4><p>$9  &gt;&gt;  O(1)$</p><p>$2n + 3  &gt;&gt;  O(n)$</p><p>$n^2 + 2n + 6 &gt;&gt; O(n^2)$</p><p>$4n^3 + 3n^2 + 22n + 100 &gt;&gt; O(n^3)$</p><p><strong>注意</strong>：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率</p><h4 id="对数阶的细节"><a href="#对数阶的细节" class="headerlink" title="对数阶的细节"></a><strong>对数阶的细节</strong></h4><p>对数阶一般省略底数</p><p>$log_2n = log_29 ∗ log_9n$</p><p>所以 $log_2n$ 、$log_9n$ 统称为$logn$</p><h3 id="常见的复杂度"><a href="#常见的复杂度" class="headerlink" title="常见的复杂度"></a>常见的复杂度</h3><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>执行次数</strong></th><th style="text-align:center"><strong>复杂度</strong></th><th style="text-align:center"><strong>非正式术语</strong></th></tr></thead><tbody><tr><td style="text-align:center">$12$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">常数阶</td></tr><tr><td style="text-align:center">$2n + 3$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">线性阶</td></tr><tr><td style="text-align:center">$4n^2 + 2n + 6$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">平方阶</td></tr><tr><td style="text-align:center">$4log_2n + 25$</td><td style="text-align:center">$O(logn)$</td><td style="text-align:center">对数阶</td></tr><tr><td style="text-align:center">$3n + 2nlog_3n + 15$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$nlogn$阶</td></tr><tr><td style="text-align:center">$4n^3 + 3n^2 + 22n + 100$</td><td style="text-align:center">$O(n^3)$</td><td style="text-align:center">立方阶</td></tr><tr><td style="text-align:center">$2^n$</td><td style="text-align:center">$O(2n)$</td><td style="text-align:center">指数阶</td></tr></tbody></table></div><p>$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n_n)$</p><h3 id="算法的优化方向"><a href="#算法的优化方向" class="headerlink" title="算法的优化方向"></a>算法的优化方向</h3><p>用尽量少的存储空间</p><p>用尽量少的执行步骤（执行时间）</p><p>根据情况，可以</p><ul><li><p>空间换时间</p></li><li><p>时间换空间</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复杂度&quot;&gt;&lt;a href=&quot;#复杂度&quot; class=&quot;headerlink&quot; title=&quot;复杂度&quot;&gt;&lt;/a&gt;复杂度&lt;/h2&gt;&lt;h3 id=&quot;如何评判一个算法的好坏？&quot;&gt;&lt;a href=&quot;#如何评判一个算法的好坏？&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA学习路线</title>
    <link href="http://yoursite.com/2019/09/17/JAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/09/17/JAVA学习路线/</id>
    <published>2019-09-17T03:43:19.000Z</published>
    <updated>2019-09-17T04:32:00.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA学习路线"><a href="#JAVA学习路线" class="headerlink" title="JAVA学习路线"></a>JAVA学习路线</h1><h2 id="1-语言的入门和进阶"><a href="#1-语言的入门和进阶" class="headerlink" title="1. 语言的入门和进阶"></a>1. 语言的入门和进阶</h2><ul><li>Java基础语法,OO编程思想, 集合, IO, 异常, 泛型, 反射, 多线程, 函数式</li></ul><h2 id="2-Web基础和工具"><a href="#2-Web基础和工具" class="headerlink" title="2. Web基础和工具"></a>2. Web基础和工具</h2><ul><li><p>前端基础(html/javascript/css) jquery, ajax, jsp, cookie, session</p></li><li><p>http基础</p></li><li><p>servlet基础</p></li><li><p>git,svn代码管理工具</p></li></ul><h2 id="3-企业级应用框架"><a href="#3-企业级应用框架" class="headerlink" title="3. 企业级应用框架"></a>3. 企业级应用框架</h2><ul><li><p>maven/gradle项目管理工具</p></li><li><p>Spring全家桶(Spring, Spring MVC, Spring Boot)</p></li><li><p>关系型数据库相关(MySQL, jdbc, MyBatis, Hibernate)</p></li><li><p>非关系型数据库(Redis)</p></li><li><p>模板引擎(thymeleaf, freemarker)</p></li></ul><h2 id="4-高级应用框架"><a href="#4-高级应用框架" class="headerlink" title="4. 高级应用框架"></a>4. 高级应用框架</h2><ul><li><p>搜索引擎(elastic search)</p></li><li><p>RPCk框架(Dubbo, Spring Cloud)</p></li><li><p>中间件技术(RabbitMQ, RocketMQ, ActiveMQ, Kafka)</p></li><li><p>虚拟化技术(Docker, Kubernetes)</p></li></ul><h2 id="5-高级话题"><a href="#5-高级话题" class="headerlink" title="5. 高级话题"></a>5. 高级话题</h2><ul><li>jvm优化和排错, GC分析, 数据库高级优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA学习路线&quot;&gt;&lt;a href=&quot;#JAVA学习路线&quot; class=&quot;headerlink&quot; title=&quot;JAVA学习路线&quot;&gt;&lt;/a&gt;JAVA学习路线&lt;/h1&gt;&lt;h2 id=&quot;1-语言的入门和进阶&quot;&gt;&lt;a href=&quot;#1-语言的入门和进阶&quot; class=&quot;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="学习路线" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
</feed>
