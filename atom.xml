<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Croissant2097</title>
  
  <subtitle>Record &amp; Share &amp; Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-16T09:17:48.483Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最短路径</title>
    <link href="http://yoursite.com/2020/07/15/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/07/15/最短路径/</id>
    <published>2020-07-15T09:12:48.000Z</published>
    <updated>2020-07-16T09:17:48.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径（Shortest-Path）"><a href="#最短路径（Shortest-Path）" class="headerlink" title="最短路径（Shortest Path）"></a>最短路径（Shortest Path）</h1><h2 id="什么是最短路径"><a href="#什么是最短路径" class="headerlink" title="什么是最短路径"></a>什么是最短路径</h2><p>最短路径是指两顶点之间权值之和最小的路径（有向图、无向图均适用，<strong>不能有负权环）</strong></p><p><img src="/2020/07/15/最短路径/1.png" alt></p><p>无权图相当于是全部边权值为 $1$ 的有权图</p><p><img src="/2020/07/15/最短路径/2.png" alt></p><h2 id="最短路径-–-负权边"><a href="#最短路径-–-负权边" class="headerlink" title="最短路径 – 负权边"></a>最短路径 – 负权边</h2><p>有负权边，但没有负权环时，存在最短路径</p><p><img src="/2020/07/15/最短路径/3.png" alt></p><p>$A$ 到 $E$ 的最短路径是：$A → B → E$</p><h2 id="最短路径-–-负权环"><a href="#最短路径-–-负权环" class="headerlink" title="最短路径 – 负权环"></a>最短路径 – 负权环</h2><p>有负权环时，不存在最短路径</p><p><img src="/2020/07/15/最短路径/4.png" alt></p><p>通过负权环， $A$ 到 $E$ 的路径可以无限短</p><p>$A → E → D → F → E → D → F → E → D → F → E → D → F → E → ……$</p><h2 id="求解最短路径的3个经典算法"><a href="#求解最短路径的3个经典算法" class="headerlink" title="求解最短路径的3个经典算法"></a>求解最短路径的3个经典算法</h2><p>最短路径的典型应用之一：<strong>路径规划问题</strong></p><p>单源最短路径算法</p><ol><li><p>$Dijkstra$（迪杰斯特拉算法）</p></li><li><p>$Bellman-Ford$（贝尔曼-福特算法）</p></li></ol><p>多源最短路径算法</p><ol><li>$Floyd$（弗洛伊德算法）</li></ol><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>$Dijkstra$ 属于单源最短路径算法，用于计算一个顶点到其他所有顶点的最短路径</p><p>使用前提：<strong>不能有负权边</strong></p><p>时间复杂度：可优化至 $O(ElogV)$ ，$E$ 是边数量，$V$ 是节点数量</p><p>由荷兰的科学家 $Edsger Wybe Dijkstra$ 发明，曾在 $1972$ 年获得图灵奖</p><h3 id="Dijkstra-–-等价思考"><a href="#Dijkstra-–-等价思考" class="headerlink" title="Dijkstra – 等价思考"></a>Dijkstra – 等价思考</h3><p>$Dijkstra$ 的原理其实跟生活中的一些自然现象完全一样</p><p>把每 $1$ 个顶点想象成是 $1$ 块小石头</p><p>每 $1$ 条边想象成是 $1$ 条绳子，每一条绳子都连接着 $2$ 块小石头，边的权值就是绳子的长度</p><p>将小石头和绳子平放在一张桌子上（下图是一张俯视图，图中黄颜色的是桌子）</p><p><img src="/2020/07/15/最短路径/5.png" alt></p><p>接下来想象一下，手拽着小石头 $A$，慢慢地向上提起来，远离桌面</p><p>$B、D、C、E$会依次离开桌面</p><p>最后绷直的绳子就是 $A$ 到其他小石头的最短路径</p><p><strong>有一个很关键的信息</strong></p><p><strong>后离开桌面的小石头，都是被先离开桌面的小石头拉起来的</strong></p><h3 id="Dijkstra-–-执行过程"><a href="#Dijkstra-–-执行过程" class="headerlink" title="Dijkstra – 执行过程"></a>Dijkstra – 执行过程</h3><p><img src="/2020/07/15/最短路径/6.png" alt></p><p><strong>绿色：已经“离开桌面”，已经确定了最终的最短路径</strong></p><p><strong>红色：更新了最短路径信息</strong></p><p><img src="/2020/07/15/最短路径/7.png" alt></p><p><strong>松弛操作$（Relaxation）$</strong>：更新 $2$ 个顶点之间的最短路径</p><p><strong>这里一般是指：更新源点到另一个点的最短路径</strong></p><p><strong>松弛操作的意义：尝试找出更短的最短路径</strong></p><p>确定 $A$ 到 $D$ 的最短路径后，对 $DC、DE$ 边进行松弛操作，更新了 $A$ 到 $C$、$A$ 到 $E$ 的最短路径</p><p><img src="/2020/07/15/最短路径/8.png" alt></p><h3 id="Dijkstra-–-代码实现"><a href="#Dijkstra-–-代码实现" class="headerlink" title="Dijkstra – 代码实现"></a>Dijkstra – 代码实现</h3><h4 id="边和顶点的定义"><a href="#边和顶点的定义" class="headerlink" title="边和顶点的定义"></a>边和顶点的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; inEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; outEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Vertex(V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">"null"</span> : value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; from;</span><br><span class="line">    Vertex&lt;V, E&gt; to;</span><br><span class="line">    E weight;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EdgeInfo&lt;V, E&gt; <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EdgeInfo&lt;&gt;(from.value, to.value, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from.hashCode() * <span class="number">31</span> + to.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;V, Vertex&lt;V, E&gt;&gt; vertices = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Set&lt;Edge&lt;V, E&gt;&gt; edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;Edge&lt;V, E&gt;&gt; edgeComparator = (Edge&lt;V, E&gt; e1, Edge&lt;V, E&gt; e2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> weightManager.compare(e1.weight, e2.weight);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="边信息的定义"><a href="#边信息的定义" class="headerlink" title="边信息的定义"></a>边信息的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeInfo</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> V from;</span><br><span class="line">    <span class="keyword">private</span> V to;</span><br><span class="line">    <span class="keyword">private</span> E weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeInfo</span><span class="params">(V from, V to, E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(V from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo</span><span class="params">(V to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"EdgeInfo [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路劲信息的定义"><a href="#路劲信息的定义" class="headerlink" title="路劲信息的定义"></a>路劲信息的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PathInfo</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> E weight;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathInfo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathInfo</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; getEdgeInfos() &#123;</span><br><span class="line">        <span class="keyword">return</span> edgeInfos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdgeInfos</span><span class="params">(List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.edgeInfos = edgeInfos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PathInfo [weight="</span> + weight + <span class="string">", edgeInfos="</span> + edgeInfos + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="权值的定义和比较"><a href="#权值的定义和比较" class="headerlink" title="权值的定义和比较"></a>权值的定义和比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WeightManager&lt;Double&gt; weightManager = <span class="keyword">new</span> WeightManager&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double w1, Double w2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w1.compareTo(w2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">add</span><span class="params">(Double w1, Double w2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w1 + w2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="从路径中挑一个最小的路径出来"><a href="#从路径中挑一个最小的路径出来" class="headerlink" title="从路径中挑一个最小的路径出来"></a>从路径中挑一个最小的路径出来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; getMinPath(Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt;&gt; it = paths.entrySet().iterator();</span><br><span class="line">    Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = it.next();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="keyword">if</span> (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            minEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; dijkstra(V begin) &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经是最短路径 存储起点到某个点，（包括路径信息）</span></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还未确定是最短路径</span></span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化从起点出发，直接到的点，存放到paths</span></span><br><span class="line">    paths.put(beginVertex, <span class="keyword">new</span> PathInfo&lt;&gt;(weightManager.zero()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!paths.isEmpty()) &#123;</span><br><span class="line">        Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = getMinPath(paths);</span><br><span class="line">        <span class="comment">// minVertex离开桌面</span></span><br><span class="line">        Vertex&lt;V, E&gt; minVertex = minEntry.getKey();</span><br><span class="line">        PathInfo&lt;V, E&gt; minPath = minEntry.getValue();</span><br><span class="line">        selectedPaths.put(minVertex.value, minPath);</span><br><span class="line">        paths.remove(minVertex);</span><br><span class="line">        <span class="comment">// 对它的minVertex的outEdges进行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : minVertex.outEdges) &#123;</span><br><span class="line">            <span class="comment">// 如果edge.to已经离开桌面，就没必要进行松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (selectedPaths.containsKey(edge.to.value)) <span class="keyword">continue</span>;</span><br><span class="line">            relaxForDijkstra(edge, minPath, paths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selectedPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectedPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 松弛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edge 需要进行松弛的边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromPath edge的from的最短路径信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paths 存放着其他点（对于dijkstra来说，就是还没有离开桌面的点）的最短路径信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relaxForDijkstra</span><span class="params">(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新的可选择的最短路径：beginVertex到edge.from的最短路径 + edge.weight</span></span><br><span class="line">    E newWeight = weightManager.add(fromPath.weight, edge.weight);</span><br><span class="line">    <span class="comment">// 以前的最短路径：beginVertex到edge.to的最短路径</span></span><br><span class="line">    PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to);</span><br><span class="line">    <span class="keyword">if</span> (oldPath != <span class="keyword">null</span> &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldPath = <span class="keyword">new</span> PathInfo&lt;&gt;();</span><br><span class="line">        paths.put(edge.to, oldPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldPath.edgeInfos.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oldPath.weight = newWeight;</span><br><span class="line">    oldPath.edgeInfos.addAll(fromPath.edgeInfos);</span><br><span class="line">    oldPath.edgeInfos.add(edge.info());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra-算法测试"><a href="#Dijkstra-算法测试" class="headerlink" title="Dijkstra - 算法测试"></a>Dijkstra - 算法测试</h3><h4 id="构建有向图"><a href="#构建有向图" class="headerlink" title="构建有向图"></a>构建有向图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;Object, Double&gt; <span class="title">directedGraph</span><span class="params">(Object[][] data)</span> </span>&#123;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = <span class="keyword">new</span> ListGraph&lt;&gt;(weightManager);</span><br><span class="line">    <span class="keyword">for</span> (Object[] edge : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">2</span>) &#123;</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(edge[<span class="number">2</span>].toString());</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无负权值测试"><a href="#无负权值测试" class="headerlink" title="无负权值测试"></a>无负权值测试</h4><p><img src="/2020/07/15/最短路径/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] SP = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">10</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"D"</span>, <span class="number">30</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"E"</span>, <span class="number">100</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">50</span>&#125;, </span><br><span class="line">&#123;<span class="string">"C"</span>, <span class="string">"E"</span>, <span class="number">10</span>&#125;, </span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">20</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"E"</span>, <span class="number">60</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.SP);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra(<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/9.png" alt></p><h4 id="有负权值测试（dijkstra不能有负权边）"><a href="#有负权值测试（dijkstra不能有负权边）" class="headerlink" title="有负权值测试（dijkstra不能有负权边）"></a>有负权值测试（dijkstra不能有负权边）</h4><p><img src="/2020/07/15/最短路径/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT1 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, -<span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"D"</span>, -<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra(<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$dijkstra$ <strong>算法不能有负权边，不然会算错</strong></p><p><img src="/2020/07/15/最短路径/12.png" alt></p><h2 id="Bellman−Ford"><a href="#Bellman−Ford" class="headerlink" title="Bellman−Ford"></a>Bellman−Ford</h2><h3 id="Bellman−Ford-是什么"><a href="#Bellman−Ford-是什么" class="headerlink" title="Bellman−Ford - 是什么"></a>Bellman−Ford - 是什么</h3><p>$Bellman-Ford$ 也属于单源最短路径算法，<strong>支持负权边</strong>，<strong>还能检测出是否有负权环</strong></p><p>算法原理：对所有的边进行 $V – 1$ 次松弛操作（ $V$ 是节点数量），得到所有可能的最短路径</p><p>时间复杂度：$O(EV)$ ，$E$ 是边数量，$V$ 是节点数量</p><p>下图的最好情况是恰好从左到右的顺序对边进行松弛操作</p><p>对所有边仅需进行 $1$ 次松弛操作就能计算出 $A$ 到达其他所有顶点的最短路径</p><p><img src="/2020/07/15/最短路径/13.png" alt></p><p>最坏情况是恰好每次都从右到左的顺序对边进行松弛操作</p><p>对所有边需进行 $V – 1$ 次松弛操作才能计算出 $A$ 到达其他所有顶点的最短路径</p><p><img src="/2020/07/15/最短路径/14.png" alt></p><h3 id="Bellman-Ford-–-实例"><a href="#Bellman-Ford-–-实例" class="headerlink" title="Bellman-Ford – 实例"></a>Bellman-Ford – 实例</h3><p>一共 $8$ 条边</p><p>假设每次松弛操作的顺序是：$DC、DF、BC、ED、EF、BE、AE、AB$</p><p><img src="/2020/07/15/最短路径/15.png" alt></p><p><img src="/2020/07/15/最短路径/16.png" alt></p><p><img src="/2020/07/15/最短路径/17.png" alt></p><p><img src="/2020/07/15/最短路径/18.png" alt></p><p>不难分析出，经过 $4$ 次松弛操作之后，已经计算出了 $A$ 到其他所有顶点的最短路径</p><h3 id="Bellman-Ford-–-代码实现"><a href="#Bellman-Ford-–-代码实现" class="headerlink" title="Bellman-Ford – 代码实现"></a>Bellman-Ford – 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; bellmanFord(V begin) &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化起点权值为0，（A -&gt; A = 0）后续松弛操作才能计算，权值相加和比较不能为null</span></span><br><span class="line">    selectedPaths.put(begin, <span class="keyword">new</span> PathInfo&lt;&gt;(weightManager.zero()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = vertices.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// v - 1 次</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">            PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value);</span><br><span class="line">            <span class="keyword">if</span> (fromPath == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            relax(edge, fromPath, selectedPaths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有环</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">        PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value);</span><br><span class="line">        <span class="keyword">if</span> (fromPath == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (relax(edge, fromPath, selectedPaths)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"有负权环"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selectedPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectedPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 松弛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edge 需要进行松弛的边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromPath edge的from的最短路径信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paths 存放着其他点（对于dijkstra来说，就是还没有离开桌面的点）的最短路径信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">relax</span><span class="params">(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;V, PathInfo&lt;V, E&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新的可选择的最短路径：beginVertex到edge.from的最短路径 + edge.weight</span></span><br><span class="line">    E newWeight = weightManager.add(fromPath.weight, edge.weight);</span><br><span class="line">    <span class="comment">// 以前的最短路径：beginVertex到edge.to的最短路径</span></span><br><span class="line">    PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to.value);</span><br><span class="line">    <span class="keyword">if</span> (oldPath != <span class="keyword">null</span> &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldPath = <span class="keyword">new</span> PathInfo&lt;&gt;();</span><br><span class="line">        paths.put(edge.to.value, oldPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldPath.edgeInfos.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oldPath.weight = newWeight;</span><br><span class="line">    oldPath.edgeInfos.addAll(fromPath.edgeInfos);</span><br><span class="line">    oldPath.edgeInfos.add(edge.info());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford-–-算法测试"><a href="#Bellman-Ford-–-算法测试" class="headerlink" title="Bellman-Ford – 算法测试"></a>Bellman-Ford – 算法测试</h3><h4 id="有负权值测试"><a href="#有负权值测试" class="headerlink" title="有负权值测试"></a>有负权值测试</h4><p><img src="/2020/07/15/最短路径/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT1 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, -<span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"D"</span>, -<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord(<span class="string">"A"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/19.png" alt></p><h4 id="有负权环测试"><a href="#有负权环测试" class="headerlink" title="有负权环测试"></a>有负权环测试</h4><p><img src="/2020/07/15/最短路径/20.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT2 = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, </span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT2);</span><br><span class="line">    Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sp == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">        System.out.println(v + <span class="string">" - "</span> + path);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/21.png" alt></p><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="Floyd-是什么"><a href="#Floyd-是什么" class="headerlink" title="Floyd - 是什么"></a>Floyd - 是什么</h3><p>$Floyd$ 属于多源最短路径算法，能够求出任意 $2$ 个顶点之间的最短路径，支持负权边</p><p>时间复杂度：$O(V3)$，效率比执行 $V$ 次 $Dijkstra$ 算法要好（ $V$ 是顶点数量）</p><p>算法原理</p><p>从任意顶点 $i$ 到任意顶点 $j$ 的最短路径不外乎两种可能</p><p>① 直接从 $i$ 到 $j$</p><p>② 从 $i$ 经过若干个顶点到 $j$</p><p>假设 $dist(i，j)$ 为顶点 $i$ 到顶点 $j$ 的最短路径的距离</p><p>对于每一个顶点 $k$，检查 $dist(i，k) + dist(k，j)＜dist(i，j)$ 是否成立</p><p>如果成立，证明从 $i$ 到 $k$ 再到 $j$ 的路径比 $i$ 直接到 $j$ 的路径短，设置 $dist(i，j) = dist(i，k) + dist(k，j)$</p><p>当我们遍历完所有结点 $k$，$dist(i，j)$ 中记录的便是 $i$ 到 $j$ 的最短路径的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist(i,k)) + dist(k,j) &lt; dist(i,j))&#123;</span><br><span class="line">                dist(i,j) = dist(i,k) + dist(k,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd-代码实现"><a href="#Floyd-代码实现" class="headerlink" title="Floyd - 代码实现"></a>Floyd - 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; floyd() &#123;</span><br><span class="line">    Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 把能直接走的路径存放在map</span></span><br><span class="line">        Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(edge.from.value);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            paths.put(edge.from.value, map);</span><br><span class="line">        &#125;</span><br><span class="line">        PathInfo&lt;V, E&gt; pathInfo = <span class="keyword">new</span> PathInfo&lt;&gt;(edge.weight);</span><br><span class="line">        pathInfo.edgeInfos.add(edge.info());</span><br><span class="line">        map.put(edge.to.value, pathInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vertices.forEach((V v2, Vertex&lt;V, E&gt; vertex2) -&gt; &#123;</span><br><span class="line">        vertices.forEach((V v1, Vertex&lt;V, E&gt; vertex1) -&gt; &#123;</span><br><span class="line">            vertices.forEach((V v3, Vertex&lt;V, E&gt; vertex3) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1.equals(v2) || v2.equals(v3) || v1.equals(v3)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v1 -&gt; v2</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path12 = getPathInfo(v1, v2, paths);</span><br><span class="line">                <span class="keyword">if</span> (path12 == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v2 -&gt; v3</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path23 = getPathInfo(v2, v3, paths);</span><br><span class="line">                <span class="keyword">if</span> (path23 == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v1 -&gt; v3 </span></span><br><span class="line">                PathInfo&lt;V, E&gt; path13 = getPathInfo(v1, v3, paths);</span><br><span class="line"></span><br><span class="line">                E newWeight = weightManager.add(path12.weight, path23.weight);</span><br><span class="line">                <span class="keyword">if</span> (path13 != <span class="keyword">null</span> &amp;&amp; weightManager.compare(newWeight, path13.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path13 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    path13 = <span class="keyword">new</span> PathInfo&lt;V, E&gt;();</span><br><span class="line">                    paths.get(v1).put(v3, path13);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    path13.edgeInfos.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                path13.weight = newWeight;</span><br><span class="line">                path13.edgeInfos.addAll(path12.edgeInfos);</span><br><span class="line">                path13.edgeInfos.addAll(path23.edgeInfos);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PathInfo&lt;V, E&gt; <span class="title">getPathInfo</span><span class="params">(V from, V to, Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths)</span> </span>&#123;</span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(from);</span><br><span class="line">    <span class="keyword">return</span> map == <span class="keyword">null</span> ? <span class="keyword">null</span> : map.get(to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd-算法测试"><a href="#Floyd-算法测试" class="headerlink" title="Floyd - 算法测试"></a>Floyd - 算法测试</h3><p><img src="/2020/07/15/最短路径/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] NEGATIVE_WEIGHT1 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, -<span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">4</span>&#125;, </span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"D"</span>, -<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1);</span><br><span class="line">    Map&lt;Object, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt;&gt; sp = graph.shortestPath();</span><br><span class="line">    sp.forEach((Object from, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; paths) -&gt; &#123;</span><br><span class="line">        System.out.println(from + <span class="string">"---------------------"</span>);</span><br><span class="line">        paths.forEach((Object to, PathInfo&lt;Object, Double&gt; path) -&gt; &#123;</span><br><span class="line">            System.out.println(to + <span class="string">" - "</span> + path);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/最短路径/22.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径（Shortest-Path）&quot;&gt;&lt;a href=&quot;#最短路径（Shortest-Path）&quot; class=&quot;headerlink&quot; title=&quot;最短路径（Shortest Path）&quot;&gt;&lt;/a&gt;最短路径（Shortest Path）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
      <category term="迪杰斯特拉算法" scheme="http://yoursite.com/tags/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    
      <category term="Bellman-Ford" scheme="http://yoursite.com/tags/Bellman-Ford/"/>
    
      <category term="Floyd" scheme="http://yoursite.com/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>生成树</title>
    <link href="http://yoursite.com/2020/07/15/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/15/生成树/</id>
    <published>2020-07-15T08:48:41.000Z</published>
    <updated>2020-07-16T04:54:58.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成树（Spanning-Tree）"><a href="#生成树（Spanning-Tree）" class="headerlink" title="生成树（Spanning Tree）"></a>生成树（Spanning Tree）</h1><h2 id="什么是生成树"><a href="#什么是生成树" class="headerlink" title="什么是生成树"></a>什么是生成树</h2><p>生成树 $（ Spanning Tree ）$，也称为支撑树</p><p>连通图的极小连通子图，它含有图中全部的 $n$ 个顶点，恰好只有 $n – 1$ 条边</p><p><img src="/2020/07/15/生成树/1.png" alt></p><h2 id="最小生成树（Minimum-Spanning-Tree）"><a href="#最小生成树（Minimum-Spanning-Tree）" class="headerlink" title="最小生成树（Minimum Spanning Tree）"></a>最小生成树（Minimum Spanning Tree）</h2><p>最小生成树$（Minimum Spanning Tree$，简称$MST）$</p><p>也称为最小权重生成树$（Minimum Weight Spanning Tree）$、最小支撑树</p><p>是所有生成树中，总权值最小的那棵</p><p>适用于<strong>有权的连通图</strong>（无向）</p><p><img src="/2020/07/15/生成树/2.png" alt></p><h3 id="最小生成树的应用"><a href="#最小生成树的应用" class="headerlink" title="最小生成树的应用"></a>最小生成树的应用</h3><p>最小生成树在许多领域都有重要的作用，例如</p><p>要在 $n$ 个城市之间铺设光缆，使它们都可以通信</p><p>铺设光缆的费用很高，且各个城市之间因为距离不同等因素，铺设光缆的费用也不同</p><p>如何使铺设光缆的总费用最低？</p><h3 id="最小生成树的实现算法"><a href="#最小生成树的实现算法" class="headerlink" title="最小生成树的实现算法"></a>最小生成树的实现算法</h3><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个，否则可能会有多个最小生成树</p><p>求最小生成树的 $2$ 个经典算法</p><p>$Prim$（普里姆算法）</p><p>$Kruskal$（克鲁斯克尔算法）</p><h4 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h4><p>切分$（Cut）$：把图中的节点分为两部分，称为一个切分</p><p>下图有个切分 $C = (S, T)，S = \{A, B, D\}，T = \{C, E\}$</p><p><img src="/2020/07/15/生成树/3.png" alt></p><p>横切边$（Crossing Edge）$：如果一个边的两个顶点，分别属于切分的两部分，这个边称为横切边</p><p>比如上图的边 $BC、BE、DE$就是横切边</p><p>切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树</p><h4 id="边和顶点的定义"><a href="#边和顶点的定义" class="headerlink" title="边和顶点的定义"></a>边和顶点的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; inEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; outEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Vertex(V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">"null"</span> : value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; from;</span><br><span class="line">    Vertex&lt;V, E&gt; to;</span><br><span class="line">    E weight;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EdgeInfo&lt;V, E&gt; <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EdgeInfo&lt;&gt;(from.value, to.value, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from.hashCode() * <span class="number">31</span> + to.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="边信息的定义"><a href="#边信息的定义" class="headerlink" title="边信息的定义"></a>边信息的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeInfo</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> V from;</span><br><span class="line">    <span class="keyword">private</span> V to;</span><br><span class="line">    <span class="keyword">private</span> E weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeInfo</span><span class="params">(V from, V to, E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(V from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo</span><span class="params">(V to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(E weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"EdgeInfo [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prim算法-–-执行过程"><a href="#Prim算法-–-执行过程" class="headerlink" title="Prim算法 – 执行过程"></a>Prim算法 – 执行过程</h4><p>假设 $G = (V，E)$ 是有权的连通图（无向），$A$ 是 $G$ 中最小生成树的边集</p><p>算法从 $S = \{ u0 \}（u0 ∈ V），A = \{ \} $  开始，重复执行下述操作，直到 $S = V $为止</p><p>找到切分 $C = (S，V – S)$ 的最小横切边 $(u0，v0) $并入集合 $A$，同时将 $v0$ 并入集合 $S$</p><p><img src="/2020/07/15/生成树/4.png" alt></p><p><img src="/2020/07/15/生成树/5.png" alt></p><p><img src="/2020/07/15/生成树/6.png" alt></p><h4 id="Prim算法-–-实现"><a href="#Prim算法-–-实现" class="headerlink" title="Prim算法 – 实现"></a>Prim算法 – 实现</h4><a href="/2020/07/14/二叉堆/" title="MinHeap的实现原理">MinHeap的实现原理</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;EdgeInfo&lt;V, E&gt;&gt; prim() &#123;</span><br><span class="line">    Iterator&lt;Vertex&lt;V, E&gt;&gt; it = vertices.values().iterator();</span><br><span class="line">    <span class="keyword">if</span> (!it.hasNext()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Vertex&lt;V, E&gt; vertex = it.next();</span><br><span class="line">    Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Vertex&lt;V, E&gt;&gt; addedVertices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    addedVertices.add(vertex);</span><br><span class="line">    MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = <span class="keyword">new</span> MinHeap&lt;&gt;(vertex.outEdges, edgeComparator);</span><br><span class="line">    <span class="keyword">int</span> verticesSize = vertices.size();</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; addedVertices.size() &lt; verticesSize) &#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = heap.remove();</span><br><span class="line">        <span class="keyword">if</span> (addedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line">        edgeInfos.add(edge.info());</span><br><span class="line">        addedVertices.add(edge.to);</span><br><span class="line">        heap.addAll(edge.to.outEdges);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edgeInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal算法-–-执行过程"><a href="#Kruskal算法-–-执行过程" class="headerlink" title="Kruskal算法 – 执行过程"></a>Kruskal算法 – 执行过程</h4><p>按照边的权重顺序（从小到大）将边加入生成树中，直到生成树中含有 $V – 1$ 条边为止（ $V$ 是顶点数量）</p><p>若加入该边会与生成树形成环，则不加入该边</p><p>从第 $3$ 条边开始，可能会与生成树形成环</p><p><img src="/2020/07/15/生成树/7.png" alt></p><p><img src="/2020/07/15/生成树/8.png" alt></p><p><img src="/2020/07/15/生成树/9.png" alt></p><h4 id="Kruskal算法-–-实现"><a href="#Kruskal算法-–-实现" class="headerlink" title="Kruskal算法 – 实现"></a>Kruskal算法 – 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;EdgeInfo&lt;V, E&gt;&gt; kruskal() &#123;</span><br><span class="line">    <span class="keyword">int</span> edgeSize = vertices.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (edgeSize == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = <span class="keyword">new</span> MinHeap&lt;&gt;(edges, edgeComparator);</span><br><span class="line">    UnionFind&lt;Vertex&lt;V, E&gt;&gt; uf = <span class="keyword">new</span> UnionFind&lt;&gt;();</span><br><span class="line">    vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123;</span><br><span class="line">        uf.makeSet(vertex);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; edgeInfos.size() &lt; edgeSize) &#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = heap.remove(); </span><br><span class="line">        <span class="keyword">if</span> (uf.isSame(edge.from, edge.to)) <span class="keyword">continue</span>; </span><br><span class="line">        edgeInfos.add(edge.info());</span><br><span class="line">        uf.union(edge.from, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edgeInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(ElogE)$</p><h3 id="算法测试"><a href="#算法测试" class="headerlink" title="算法测试"></a>算法测试</h3><h4 id="构建无向图"><a href="#构建无向图" class="headerlink" title="构建无向图"></a>构建无向图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;Object, Double&gt; <span class="title">undirectedGraph</span><span class="params">(Object[][] data)</span> </span>&#123;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = <span class="keyword">new</span> ListGraph&lt;&gt;(weightManager);</span><br><span class="line">    <span class="keyword">for</span> (Object[] edge : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">2</span>) &#123;</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            graph.addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(edge[<span class="number">2</span>].toString());</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], weight);</span><br><span class="line">            graph.addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建有向图"><a href="#构建有向图" class="headerlink" title="构建有向图"></a>构建有向图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;Object, Double&gt; <span class="title">directedGraph</span><span class="params">(Object[][] data)</span> </span>&#123;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = <span class="keyword">new</span> ListGraph&lt;&gt;(weightManager);</span><br><span class="line">    <span class="keyword">for</span> (Object[] edge : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">2</span>) &#123;</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edge.length == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(edge[<span class="number">2</span>].toString());</span><br><span class="line">            graph.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试无向图"><a href="#测试无向图" class="headerlink" title="测试无向图"></a>测试无向图</h4><p><img src="/2020/07/15/生成树/10.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] MST_01 = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_01);</span><br><span class="line">    <span class="comment">// Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim();</span></span><br><span class="line">    Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal();</span><br><span class="line">    <span class="keyword">for</span> (EdgeInfo&lt;Object, Double&gt; info : infos) &#123;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/生成树/12.png" alt></p><h4 id="测试有向图"><a href="#测试有向图" class="headerlink" title="测试有向图"></a>测试有向图</h4><p><img src="/2020/07/15/生成树/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] MST_02 = &#123;</span><br><span class="line">&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">17</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"F"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"A"</span>, <span class="string">"E"</span>, <span class="number">16</span>&#125;,</span><br><span class="line">&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">6</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">5</span>&#125;, &#123;<span class="string">"B"</span>, <span class="string">"F"</span>, <span class="number">11</span>&#125;,</span><br><span class="line">&#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">10</span>&#125;, </span><br><span class="line">&#123;<span class="string">"D"</span>, <span class="string">"E"</span>, <span class="number">4</span>&#125;, &#123;<span class="string">"D"</span>, <span class="string">"F"</span>, <span class="number">14</span>&#125;,</span><br><span class="line">&#123;<span class="string">"E"</span>, <span class="string">"F"</span>, <span class="number">33</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_02);</span><br><span class="line">    Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim();</span><br><span class="line">    <span class="comment">// Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal();</span></span><br><span class="line">    <span class="keyword">for</span> (EdgeInfo&lt;Object, Double&gt; info : infos) &#123;</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/生成树/13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生成树（Spanning-Tree）&quot;&gt;&lt;a href=&quot;#生成树（Spanning-Tree）&quot; class=&quot;headerlink&quot; title=&quot;生成树（Spanning Tree）&quot;&gt;&lt;/a&gt;生成树（Spanning Tree）&lt;/h1&gt;&lt;h2 id=&quot;什
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="Prim" scheme="http://yoursite.com/tags/Prim/"/>
    
      <category term="Kruskal" scheme="http://yoursite.com/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>AOV网</title>
    <link href="http://yoursite.com/2020/07/15/AOV%E7%BD%91/"/>
    <id>http://yoursite.com/2020/07/15/AOV网/</id>
    <published>2020-07-15T08:45:45.000Z</published>
    <updated>2020-07-15T08:47:16.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOV网（Activity-On-Vertex-Network）"><a href="#AOV网（Activity-On-Vertex-Network）" class="headerlink" title="AOV网（Activity On Vertex Network）"></a>AOV网（Activity On Vertex Network）</h2><p>一项大的工程常被分为多个小的子工程</p><p>子工程之间可能存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始</p><p>在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，子工程被称为活动$（Activity）$</p><p>以顶点表示活动、有向边表示活动之间的先后关系，这样的图简称为 $AOV$ 网</p><p>标准的 $AOV$网必须是一个有向无环图$（Directed Acyclic Graph$，简称 $DAG$）</p><p><img src="/2020/07/15/AOV网/1.png" alt></p><p><strong>B依赖于A；C依赖于B；D依赖于B；E依赖于B、C、D；F依赖于E</strong></p><h3 id="拓扑排序（Topological-Sort）"><a href="#拓扑排序（Topological-Sort）" class="headerlink" title="拓扑排序（Topological Sort）"></a>拓扑排序（Topological Sort）</h3><p>前驱活动：有向边起点的活动称为终点的前驱活动</p><p>只有当一个活动的前驱全部都完成后，这个活动才能进行</p><p>后继活动：有向边终点的活动称为起点的后继活动</p><p>将 AOV 网中所有活动排成一个序列，使得每个活动的前驱活动都排在该活动的前面</p><p>比如上图的拓扑排序结果是：A、B、C、D、E、F 或者 A、B、D、C、E、F （结果并不一定是唯一的）</p><h3 id="拓扑排序-–-思路"><a href="#拓扑排序-–-思路" class="headerlink" title="拓扑排序 – 思路"></a>拓扑排序 – 思路</h3><p>可以使用卡恩算法（Kahn于1962年提出）完成拓扑排序</p><p>假设 L 是存放拓扑排序结果的列表</p><p>① 把所有入度为 0 的顶点放入 L 中，然后把这些顶点从图中去掉</p><p>② 重复操作 ①，直到找不到入度为 0 的顶点</p><p>如果此时 L 中的元素个数和顶点总数相同，说明拓扑排序完成</p><p>如果此时 L 中的元素个数少于顶点总数，说明原图中存在环，无法进行拓扑排序</p><p><img src="/2020/07/15/AOV网/2.png" alt></p><h3 id="拓扑排序-–-实现"><a href="#拓扑排序-–-实现" class="headerlink" title="拓扑排序 – 实现"></a>拓扑排序 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;V&gt; <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;V&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;Vertex&lt;V, E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, Integer&gt; ins = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化（将度为0的节点都放入队列）</span></span><br><span class="line">    vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> in = vertex.inEdges.size();</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.offer(vertex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ins.put(vertex, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Vertex&lt;V, E&gt; vertex = queue.poll();</span><br><span class="line">        <span class="comment">// 放入返回结果中</span></span><br><span class="line">        list.add(vertex.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">            <span class="keyword">int</span> toIn = ins.get(edge.to) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (toIn == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(edge.to);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ins.put(edge.to, toIn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AOV网（Activity-On-Vertex-Network）&quot;&gt;&lt;a href=&quot;#AOV网（Activity-On-Vertex-Network）&quot; class=&quot;headerlink&quot; title=&quot;AOV网（Activity On Vertex Netw
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2020/07/15/%E5%9B%BE/"/>
    <id>http://yoursite.com/2020/07/15/图/</id>
    <published>2020-07-15T07:52:11.000Z</published>
    <updated>2020-07-16T04:10:28.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h1><h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><p>图由顶点$（vertex）$和边$（edge）$组成，通常表示为 $G = (V, E)$</p><p>$G$ 表示一个图，$V$ 是顶点集，$E$ 是边集</p><p>顶点集 $V$ 有穷且非空</p><p>任意两个顶点之间都可以用边来表示它们之间的关系，边集 $E$ 可以是空的</p><h2 id="有向图（Directed-Graph）"><a href="#有向图（Directed-Graph）" class="headerlink" title="有向图（Directed Graph）"></a>有向图（Directed Graph）</h2><p>有向图的边是有明确方向的</p><p><img src="/2020/07/15/图/1.png" alt></p><p>有向无环图（Directed Acyclic Graph，简称 DAG）</p><p>如果一个有向图，从任意顶点出发无法经过若干条边回到该顶点，那么它就是一个有向无环图</p><p><img src="/2020/07/15/图/2.png" alt></p><h3 id="出度、入度"><a href="#出度、入度" class="headerlink" title="出度、入度"></a>出度、入度</h3><p>出度、入度适用于有向图</p><p><strong>出度$（Out-degree）$</strong></p><p>一个顶点的出度为 $x$，是指有 $x$ 条边以该顶点为起点</p><p>顶点 $11$ 的出度是 $3$</p><p><strong>入度$（In-degree）$</strong></p><p>一个顶点的入度为 $x$，是指有 $x$ 条边以该顶点为终点</p><p>顶点 $11$ 的入度是 $2$</p><p><img src="/2020/07/15/图/3.png" alt></p><h2 id="无向图（Undirected-Graph）"><a href="#无向图（Undirected-Graph）" class="headerlink" title="无向图（Undirected Graph）"></a>无向图（Undirected Graph）</h2><p>无向图的边是无方向的，效果类似于下面的有向图</p><p><img src="/2020/07/15/图/4.png" alt></p><h2 id="混合图（Mixed-Graph）"><a href="#混合图（Mixed-Graph）" class="headerlink" title="混合图（Mixed Graph）"></a>混合图（Mixed Graph）</h2><p>混合图的边可能是无向的，也可能是有向的</p><p><img src="/2020/07/15/图/5.png" alt></p><h2 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h2><p><strong>平行边</strong></p><p>在无向图中，关联一对顶点的无向边如果多于 $1$ 条，则称这些边为平行边</p><p>在有向图中，关联一对顶点的有向边如果多于 $1$ 条，并且它们的的方向相同，则称这些边为平行边</p><p><strong>多重图（Multigraph）</strong></p><p>有平行边或者有自环的图</p><p><strong>简单图（Simple Graph）</strong></p><p>既没有平行边也不没有自环的图</p><p><img src="/2020/07/15/图/6.png" alt></p><h2 id="无向完全图（Undirected-Complete-Graph）"><a href="#无向完全图（Undirected-Complete-Graph）" class="headerlink" title="无向完全图（Undirected Complete Graph）"></a>无向完全图（Undirected Complete Graph）</h2><p>无向完全图的任意两个顶点之间都存在边</p><p>$n$ 个顶点的无向完全图有 $n(n − 1)/2$ 条边</p><p>$n − 1 + n − 2 + n − 3 + ⋯ + 3 + 2 + 1$</p><p><img src="/2020/07/15/图/7.png" alt></p><h2 id="有向完全图（Directed-Complete-Graph）"><a href="#有向完全图（Directed-Complete-Graph）" class="headerlink" title="有向完全图（Directed Complete Graph）"></a>有向完全图（Directed Complete Graph）</h2><p>有向完全图的任意两个顶点之间都存在方向相反的两条边</p><p>$n$ 个顶点的有向完全图有 $n(n − 1)$ 条边</p><p><img src="/2020/07/15/图/8.png" alt></p><p>稠密图（Dense Graph）：边数接近于或等于完全图</p><p>稀疏图（Sparse Graph）：边数远远少于完全图</p><h2 id="有权图（Weighted-Graph）"><a href="#有权图（Weighted-Graph）" class="headerlink" title="有权图（Weighted Graph）"></a>有权图（Weighted Graph）</h2><p>有权图的边可以拥有权值$（Weight）$</p><p><img src="/2020/07/15/图/9.png" alt></p><h2 id="连通图（Connected-Graph）"><a href="#连通图（Connected-Graph）" class="headerlink" title="连通图（Connected Graph）"></a>连通图（Connected Graph）</h2><p>如果顶点 $x$ 和 $y$ 之间存在可相互抵达的路径（直接或间接的路径），则称 $x$ 和 $y$ 是连通的</p><p>如果无向图 $G$ 中任意 $2$ 个顶点都是连通的，则称 $G$ 为连通图</p><h3 id="连通分量（Connected-Component）"><a href="#连通分量（Connected-Component）" class="headerlink" title="连通分量（Connected Component）"></a>连通分量（Connected Component）</h3><p>连通分量：无向图的极大连通子图</p><p>连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量</p><p>下面的无向图有 $3$ 个连通分量</p><p><img src="/2020/07/15/图/10.png" alt></p><h2 id="强连通图（Strongly-Connected-Graph）"><a href="#强连通图（Strongly-Connected-Graph）" class="headerlink" title="强连通图（Strongly Connected Graph）"></a>强连通图（Strongly Connected Graph）</h2><p>如果有向图 $G$ 中任意 $2$ 个顶点都是连通的，则称 $G$ 为强连通图</p><p><img src="/2020/07/15/图/11.png" alt></p><h3 id="强连通分量（Strongly-Connected-Component）"><a href="#强连通分量（Strongly-Connected-Component）" class="headerlink" title="强连通分量（Strongly Connected Component）"></a>强连通分量（Strongly Connected Component）</h3><p>强连通分量：有向图的极大强连通子图</p><p>强连通图只有一个强连通分量，即其自身；非强连通的有向图有多个强连通分量</p><p><img src="/2020/07/15/图/12.png" alt></p><h2 id="图的实现方案"><a href="#图的实现方案" class="headerlink" title="图的实现方案"></a>图的实现方案</h2><p>图有2种常见的实现方案</p><ol><li><p><strong>邻接矩阵（Adjacency Matrix）</strong></p></li><li><p><strong>邻接表（Adjacency List）</strong></p></li></ol><h3 id="邻接矩阵（Adjacency-Matrix）"><a href="#邻接矩阵（Adjacency-Matrix）" class="headerlink" title="邻接矩阵（Adjacency Matrix）"></a>邻接矩阵（Adjacency Matrix）</h3><ol><li><p>邻接矩阵的存储方式</p><p>一维数组存放顶点信息</p><p>二维数组存放边信息</p></li><li><p>邻接矩阵比较适合稠密图</p><p>不然会比较浪费内存</p></li></ol><p><img src="/2020/07/15/图/13.png" alt></p><h4 id="邻接矩阵-–-有权图"><a href="#邻接矩阵-–-有权图" class="headerlink" title="邻接矩阵 – 有权图"></a>邻接矩阵 – 有权图</h4><p><img src="/2020/07/15/图/14.png" alt></p><h3 id="邻接表（Adjacency-List）"><a href="#邻接表（Adjacency-List）" class="headerlink" title="邻接表（Adjacency List）"></a>邻接表（Adjacency List）</h3><p><img src="/2020/07/15/图/15.png" alt></p><h4 id="邻接表-–-有权图"><a href="#邻接表-–-有权图" class="headerlink" title="邻接表 – 有权图"></a>邻接表 – 有权图</h4><p><img src="/2020/07/15/图/16.png" alt></p><h2 id="图的基础接口"><a href="#图的基础接口" class="headerlink" title="图的基础接口"></a>图的基础接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">edgesSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 顶点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">verticesSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加、删除顶点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(V v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeVertex</span><span class="params">(V v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(V from, V to)</span></span>;</span><br><span class="line"><span class="comment">// 添加有权边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(V from, V to, E weight)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeEdge</span><span class="params">(V from, V to)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="顶点的定义"><a href="#顶点的定义" class="headerlink" title="顶点的定义"></a>顶点的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; inEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&lt;V, E&gt;&gt; outEdges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Vertex(V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">"null"</span> : value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="边的定义"><a href="#边的定义" class="headerlink" title="边的定义"></a>边的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span>&lt;<span class="title">V</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; from;</span><br><span class="line">    Vertex&lt;V, E&gt; to;</span><br><span class="line">    E weight;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from.hashCode() * <span class="number">31</span> + to.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge [from="</span> + from + <span class="string">", to="</span> + to + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某一顶点出发访问图中其余顶点，且每一个顶点仅被访问一次</p><p>图有 $2$ 种常见的遍历方式（有向图、无向图都适用）</p><ol><li><p>广度优先搜索$（Breadth First Search，BFS）$，又称为宽度优先搜索、横向优先搜索</p></li><li><p>深度优先搜索$（Depth First Search，DFS）$</p></li></ol><p>发明“深度优先搜索”算法的 $2$ 位科学家在 $1986$年共同获得计算机领域的最高奖：图灵奖</p><h3 id="广度优先搜索（Breadth-First-Search）"><a href="#广度优先搜索（Breadth-First-Search）" class="headerlink" title="广度优先搜索（Breadth First Search）"></a>广度优先搜索（Breadth First Search）</h3><p>二叉树层序遍历也是一种广度优先搜索</p><p><img src="/2020/07/15/图/17.png" alt></p><p><img src="/2020/07/15/图/18.png" alt></p><h4 id="广度优先搜索-–-思路"><a href="#广度优先搜索-–-思路" class="headerlink" title="广度优先搜索 – 思路"></a>广度优先搜索 – 思路</h4><p><img src="/2020/07/15/图/19.png" alt></p><h4 id="广度优先搜索-–-实现"><a href="#广度优先搜索-–-实现" class="headerlink" title="广度优先搜索 – 实现"></a>广度优先搜索 – 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(&lt;Vertex&lt;V, E&gt;&gt; beginVertex)</span> </span>&#123;</span><br><span class="line">    Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;Vertex&lt;V, E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(beginVertex);</span><br><span class="line">    visitedVertices.add(beginVertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Vertex&lt;V, E&gt; vertex = queue.poll();</span><br><span class="line">        System.out.println(vertex.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visitedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line">            queue.offer(edge.to);</span><br><span class="line">            visitedVertices.add(edge.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth First Search）"></a>深度优先搜索（Depth First Search）</h3><p>二叉树前序遍历也是一种深度优先搜索</p><p><img src="/2020/07/15/图/20.png" alt></p><p><img src="/2020/07/15/图/21.png" alt></p><h4 id="深度优先搜索-–-递归实现"><a href="#深度优先搜索-–-递归实现" class="headerlink" title="深度优先搜索 – 递归实现"></a>深度优先搜索 – 递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(V begin)</span> </span>&#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(beginVertex, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Vertex&lt;V, E&gt; vertex, Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices)</span> </span>&#123;</span><br><span class="line">    System.out.println(vertex.value);</span><br><span class="line">    visitedVertices.add(vertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visitedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(edge.to, visitedVertices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先搜索-–-非递归实现"><a href="#深度优先搜索-–-非递归实现" class="headerlink" title="深度优先搜索 – 非递归实现"></a>深度优先搜索 – 非递归实现</h4><p><img src="/2020/07/15/图/22.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Vertex&lt;V, E&gt; beginVertex)</span> </span>&#123;</span><br><span class="line">    Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Stack&lt;Vertex&lt;V, E&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先访问起点</span></span><br><span class="line">    stack.push(beginVertex);</span><br><span class="line">    visitedVertices.add(beginVertex);</span><br><span class="line">    System.out.println(beginVertex.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Vertex&lt;V, E&gt; vertex = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visitedVertices.contains(edge.to)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            stack.push(edge.from);</span><br><span class="line">            stack.push(edge.to);</span><br><span class="line">            visitedVertices.add(edge.to);</span><br><span class="line">            System.out.println(edge.to.value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图（Graph）&quot;&gt;&lt;a href=&quot;#图（Graph）&quot; class=&quot;headerlink&quot; title=&quot;图（Graph）&quot;&gt;&lt;/a&gt;图（Graph）&lt;/h1&gt;&lt;h2 id=&quot;什么是图&quot;&gt;&lt;a href=&quot;#什么是图&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2020/07/15/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/07/15/并查集/</id>
    <published>2020-07-15T06:51:30.000Z</published>
    <updated>2020-07-15T07:48:22.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集（Union-Find）"><a href="#并查集（Union-Find）" class="headerlink" title="并查集（Union Find）"></a>并查集（Union Find）</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>假设有n个村庄，有些村庄之间有连接的路，有些村庄之间并没有连接的路</p><p><img src="/2020/07/15/并查集/1.png" alt></p><p>设计一个数据结构，能够快速执行2个操作</p><ol><li><p>查询2个村庄之间是否有连接的路</p></li><li><p>连接2个村庄</p></li></ol><p>数组、链表、平衡二叉树、集合（Set）？</p><p>查询、连接的时间复杂度都是：$O(n)$</p><p><strong>并查集能够办到查询、连接的均摊时间复杂度都是 $O(α(n)),α(n) &lt; 5$</strong></p><p><strong>并查集非常适合解决这类“连接”相关的问题</strong></p><h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><p>并查集也叫作不相交集合（Disjoint Set）</p><p>并查集有2个核心操作</p><p><strong>查找$（Find）$：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是指广义的数据集合）</strong></p><p><strong>合并$（Union）$：将两个元素所在的集合合并为一个集合</strong></p><p>有2种常见的实现思路</p><ol><li><p>$Quick Find$</p><p>查找$（Find）$的时间复杂度：$O(1)$</p><p>合并$（Union）$的时间复杂度：$O(n)$</p></li><li><p>$Quick Union$</p><p>查找$（Find）$的时间复杂度：$O(logn)$，可以优化至 $O(α(n)),α(n) &lt; 5$</p><p>合并$（Union）$的时间复杂度：$O(logn)$，可以优化至 $O(α(n)),α(n) &lt; 5$</p></li></ol><h2 id="如何存储数据？"><a href="#如何存储数据？" class="headerlink" title="如何存储数据？"></a>如何存储数据？</h2><p>假设并查集处理的数据都是整型，那么可以用整型数组来存储数据</p><p><img src="/2020/07/15/并查集/2.png" alt></p><p><strong>不难看出</strong></p><p><strong>$0、1、3$ 属于同一集合</strong></p><p><strong>$2$ 单独属于一个集合</strong></p><p><strong>$4、5、6、7$ 属于同一集合</strong></p><p>因此，并查集是可以用数组实现的树形结构（二叉堆、优先级队列也是可以用数组实现的树形结构）</p><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找v所属的集合（根节点）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并v1、v2所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查v1、v2是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(v1) == find(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化时，每个元素各自属于一个单元素集合</p><p><img src="/2020/07/15/并查集/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span>[] parents;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"capacity must be &gt;= 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parents = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">        parents[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><h3 id="Quick-Find-–-Union"><a href="#Quick-Find-–-Union" class="headerlink" title="Quick Find – Union"></a>Quick Find – Union</h3><p>$Quick Find$ 的 $union(v1, v2)$：让 $v1$ 所在集合的所有元素都指向 $v2$ 的根节点</p><p><img src="/2020/07/15/并查集/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v1所在集合的所有元素，都嫁接到v2的父节点上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == p1) &#123;</span><br><span class="line">            parents[i] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$</p><h3 id="Quick-Find-–-Find"><a href="#Quick-Find-–-Find" class="headerlink" title="Quick Find – Find"></a>Quick Find – Find</h3><p><img src="/2020/07/15/并查集/5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父节点就是根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">return</span> parents[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find(0) == 2$ | $find(1) == 2$ | $find(3) == 4$ | $find(2) == 2$</p><p>时间复杂度：$O(1)$</p><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><h3 id="Quick-Union-–-Union"><a href="#Quick-Union-–-Union" class="headerlink" title="Quick Union – Union"></a>Quick Union – Union</h3><p>$Quick Union$ 的 $union(v1, v2)$：让 $v1$ 的根节点指向 $v2$ 的根节点</p><p><img src="/2020/07/15/并查集/6.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v1的根节点嫁接到v2的根节点上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line">    parents[p1] = p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(logn)$</p><h3 id="Quick-Union-–-Find"><a href="#Quick-Union-–-Find" class="headerlink" title="Quick Union – Find"></a>Quick Union – Find</h3><p><img src="/2020/07/15/并查集/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过parent链条不断地向上找，直到找到根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">        v = parents[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$find(0) == 2$ | $find(1) == 2$ | $find(3) == 2$ | $find(2) == 2$</p><p>时间复杂度：$O(logn)$</p><h2 id="Quick-Union-–-优化"><a href="#Quick-Union-–-优化" class="headerlink" title="Quick Union – 优化"></a>Quick Union – 优化</h2><p>在 $Union$ 的过程中，可能会出现树不平衡的情况，甚至退化成链表</p><p><img src="/2020/07/15/并查集/8.png" alt></p><p>有2种常见的优化方案</p><ol><li><p>基于 $size$ 的优化：<strong>元素少的树嫁接到元素多的树</strong></p></li><li><p>基于 $rank$ 的优化：<strong>矮的树嫁接到高的树</strong></p></li></ol><h3 id="Quick-Union-–-基于size的优化"><a href="#Quick-Union-–-基于size的优化" class="headerlink" title="Quick Union – 基于size的优化"></a>Quick Union – 基于size的优化</h3><p><img src="/2020/07/15/并查集/9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizes.length; i++) &#123;</span><br><span class="line">    sizes[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sizes[p1] &lt; sizes[p2]) &#123;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">        sizes[p2] += sizes[p1];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parents[p2] = p1;</span><br><span class="line">        sizes[p1] += sizes[p2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 $size$ 的优化，也可能会存在树不平衡的问题</p><p><img src="/2020/07/15/并查集/10.png" alt></p><h3 id="Quick-Union-–-基于rank的优化"><a href="#Quick-Union-–-基于rank的优化" class="headerlink" title="Quick Union – 基于rank的优化"></a>Quick Union – 基于rank的优化</h3><p><img src="/2020/07/15/并查集/11.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ranks = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">Arrays.fill(ranks, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = find(v1);</span><br><span class="line">    <span class="keyword">int</span> p2 = find(v2);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranks[p1] &lt; ranks[p2]) &#123;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[p1] &gt; ranks[p2]) &#123;</span><br><span class="line">        parents[p2] = p1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parents[p1] = p2;</span><br><span class="line">        ranks[p2]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径压缩（Path-Compression）"><a href="#路径压缩（Path-Compression）" class="headerlink" title="路径压缩（Path Compression）"></a>路径压缩（Path Compression）</h3><p>虽然有了基于 $rank$ 的优化，树会相对平衡一点</p><p>但是随着 $Union$次数的增多，树的高度依然会越来越高</p><p>导致 $find$ 操作变慢，尤其是底层节点（因为 $find$ 是不断向上找到根节点)</p><p>什么是路径压缩？</p><p>在 $find$ 时使路径上的所有节点都指向根节点，从而降低树的高度</p><p><img src="/2020/07/15/并查集/12.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// v == 1, parents[v] == 2</span></span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">if</span> (parents[v] != v) &#123;</span><br><span class="line">        parents[v] = find(parents[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parents[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩使路径上的所有节点都指向根节点，所以实现成本稍高</p><p>还有 $2$ 种更优的做法，不但能降低树高，实现成本也比路径压缩低</p><p>路径分裂$（Path Spliting）$</p><p>路径减半$（Path Halving）$</p><p>路径分裂、路径减半的效率差不多，但都比路径压缩要好</p><h4 id="路径分裂（Path-Spliting）"><a href="#路径分裂（Path-Spliting）" class="headerlink" title="路径分裂（Path Spliting）"></a>路径分裂（Path Spliting）</h4><p>路径分裂：使路径上的每个节点都指向其祖父节点$（parent$ 的 $parent）$</p><p><img src="/2020/07/15/并查集/13.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = parents[v];</span><br><span class="line">        parents[v] = parents[parents[v]];</span><br><span class="line">        v = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径减半（Path-Halving）"><a href="#路径减半（Path-Halving）" class="headerlink" title="路径减半（Path Halving）"></a>路径减半（Path Halving）</h4><p>路径减半：使路径上每隔一个节点就指向其祖父节点$（parent$ 的 $parent）$</p><p><img src="/2020/07/15/并查集/14.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">    rangeCheck(v);</span><br><span class="line">    <span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">        parents[v] = parents[parents[v]];</span><br><span class="line">        v = parents[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity" target="_blank" rel="noopener">摘自《维基百科》</a></p><p><img src="/2020/07/15/并查集/15.png" alt></p><p>大概意思是</p><p>使用路径压缩、分裂或减半 + 基于 $rank$ 或者 $size$ 的优化</p><p>可以确保每个操作的均摊时间复杂度为 $O(𝛼(𝑛)),α(𝑛) &lt; 5$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集（Union-Find）&quot;&gt;&lt;a href=&quot;#并查集（Union-Find）&quot; class=&quot;headerlink&quot; title=&quot;并查集（Union Find）&quot;&gt;&lt;/a&gt;并查集（Union Find）&lt;/h1&gt;&lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>休眠排序</title>
    <link href="http://yoursite.com/2020/07/15/%E4%BC%91%E7%9C%A0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/休眠排序/</id>
    <published>2020-07-15T06:34:20.000Z</published>
    <updated>2020-07-15T06:35:10.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="史上“最强”排序-–-休眠排序"><a href="#史上“最强”排序-–-休眠排序" class="headerlink" title="史上“最强”排序 – 休眠排序"></a>史上“最强”排序 – 休眠排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SleepSort</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(value);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">60</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array) &#123;</span><br><span class="line">            <span class="keyword">new</span> SleepSort(item).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;史上“最强”排序-–-休眠排序&quot;&gt;&lt;a href=&quot;#史上“最强”排序-–-休眠排序&quot; class=&quot;headerlink&quot; title=&quot;史上“最强”排序 – 休眠排序&quot;&gt;&lt;/a&gt;史上“最强”排序 – 休眠排序&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="http://yoursite.com/2020/07/15/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/桶排序/</id>
    <published>2020-07-15T06:00:39.000Z</published>
    <updated>2020-07-15T06:33:20.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><h2 id="什么是桶排序"><a href="#什么是桶排序" class="headerlink" title="什么是桶排序"></a>什么是桶排序</h2><p>执行流程</p><p>① 创建一定数量的桶（比如用数组、链表作为桶）</p><p>② 按照一定的规则（不同类型的数据，规则不同），将序列中的元素均匀分配到对应的桶</p><p>③ 分别对每个桶进行单独排序</p><p>④ 将所有非空桶的元素合并成有序序列</p><p>元素在桶中的索引</p><p>元素值 * 元素数量</p><p><img src="/2020/07/15/桶排序/1.png" alt></p><h2 id="桶排序-–-实现"><a href="#桶排序-–-实现" class="headerlink" title="桶排序 – 实现"></a>桶排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] array = &#123;<span class="number">0.34</span>,<span class="number">0.47</span>,<span class="number">0.29</span>,<span class="number">0.84</span>,<span class="number">0.45</span>,<span class="number">0.38</span>,<span class="number">0.35</span>,<span class="number">0.76</span>&#125;;</span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line">List&lt;Double&gt;[] buckets = <span class="keyword">new</span> List[array.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> v : array) &#123;</span><br><span class="line">    <span class="keyword">int</span> bucketIndex = (<span class="keyword">int</span>) (v * array.length);</span><br><span class="line">    List&lt;Double&gt; bucket = buckets[bucketIndex];</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bucket = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        buckets[bucketIndex] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket.add(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每个桶进行排序</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (List&lt;Double&gt; bucket : buckets) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    bucket.sort(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (Double d : bucket) &#123;</span><br><span class="line">        array[index++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度：$O(n + m)$，$m$ 是桶的数量</p><p>时间复杂度：$O(n) + m ∗ O( \frac{n} {m} ∗ log\frac{n}{m}) = O(n + n ∗ log\frac{n}{m}) = O(n + n ∗ logn − n ∗ logm)$</p><p>因 此 为 $O(n + k)$ ，$k$ 为 $n ∗ logn − n ∗ logm$</p><p>属于稳定排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序（Bucket-Sort）&quot;&gt;&lt;a href=&quot;#桶排序（Bucket-Sort）&quot; class=&quot;headerlink&quot; title=&quot;桶排序（Bucket Sort）&quot;&gt;&lt;/a&gt;桶排序（Bucket Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是桶排序&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://yoursite.com/2020/07/15/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/基数排序/</id>
    <published>2020-07-15T06:00:22.000Z</published>
    <updated>2020-07-15T06:21:11.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><h2 id="什么是基数排序"><a href="#什么是基数排序" class="headerlink" title="什么是基数排序"></a>什么是基数排序</h2><p>基数排序非常适合用于整数排序（尤其是非负整数），因此本课程只演示对非负整数进行基数排序</p><p>执行流程：依次对个位数、十位数、百位数、千位数、万位数…进行排序（从低位到高位）</p><p><img src="/2020/07/15/基数排序/1.png" alt></p><p>个位数、十位数、百位数的取值范围都是固定的 $0$ ~ $9$，可以使用计数排序对它们进行排序</p><p><strong>如果先对高位排序，再对低位排序，是不可行的</strong></p><h2 id="基数排序-–-实现"><a href="#基数排序-–-实现" class="headerlink" title="基数排序 – 实现"></a>基数排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 个位数: array[i] / 1 % 10 = 3</span></span><br><span class="line">    <span class="comment">// 十位数：array[i] / 10 % 10 = 9</span></span><br><span class="line">    <span class="comment">// 百位数：array[i] / 100 % 10 = 5</span></span><br><span class="line">    <span class="comment">// 千位数：array[i] / 1000 % 10 = ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> divider = <span class="number">1</span>; divider &lt;= max; divider *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(divider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> divider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer / divider % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累加次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newArray[--counts[array[i] / divider % <span class="number">10</span>]] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">        array[i] = newArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好、最坏、平均时间复杂度：$O(d ∗ (n + k))$ ，$d$ 是最大值的位数，$k$ 是进制。属于稳定排序</p><p>空间复杂度：$O(n + k)$，$k$ 是进制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基数排序（Radix-Sort）&quot;&gt;&lt;a href=&quot;#基数排序（Radix-Sort）&quot; class=&quot;headerlink&quot; title=&quot;基数排序（Radix Sort）&quot;&gt;&lt;/a&gt;基数排序（Radix Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是基数排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/15/计数排序/</id>
    <published>2020-07-15T06:00:02.000Z</published>
    <updated>2020-07-15T06:16:25.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p>冒泡、选择、插入、归并、快速、希尔、堆排序，都是基于比较的排序</p><p>平均时间复杂度目前最低是 $O(nlogn)$ </p><p>计数排序、桶排序、基数排序，都不是基于比较的排序</p><p>它们是典型的用空间换时间，在某些时候，平均时间复杂度可以比 $O(nlogn)$ 更低</p><h2 id="什么是计数排序"><a href="#什么是计数排序" class="headerlink" title="什么是计数排序"></a>什么是计数排序</h2><p>计数排序于1954年由Harold H. Seward提出，适合对一定范围内的整数进行排序</p><p>计数排序的核心思想：</p><p><strong>统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引</strong></p><h2 id="计数排序-–-最简单的实现"><a href="#计数排序-–-最简单的实现" class="headerlink" title="计数排序 – 最简单的实现"></a>计数排序 – 最简单的实现</h2><p><img src="/2020/07/15/计数排序/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间，存储每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> + max];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer]++;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据整数的出现次数，对整数进行排序</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (counts[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的实现存在以下问题</p><ul><li><p><strong>无法对负整数进行排序</strong></p></li><li><p><strong>极其浪费内存空间</strong></p></li><li><p><strong>是个不稳定的排序</strong></p></li></ul><h2 id="计数排序-–-改进思路"><a href="#计数排序-–-改进思路" class="headerlink" title="计数排序 – 改进思路"></a>计数排序 – 改进思路</h2><p>假设 $array$ 中的最小值是 $min$</p><p>$array$ 中的元素 $k$ 对应的 $counts$ 索引是 $k – min$</p><p>$array$ 中的元素 $k$ 在有序序列中的索引</p><p>$counts[k – min] – p$</p><p>$p$ 代表着是倒数第几个 $k$</p><p><img src="/2020/07/15/计数排序/2.png" alt></p><p><img src="/2020/07/15/计数排序/3.png" alt></p><p><img src="/2020/07/15/计数排序/4.png" alt></p><p><img src="/2020/07/15/计数排序/5.png" alt></p><p><img src="/2020/07/15/计数排序/6.png" alt></p><h2 id="计数排序-–-改进实现"><a href="#计数排序-–-改进实现" class="headerlink" title="计数排序 – 改进实现"></a>计数排序 – 改进实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">        counts[integer - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 累加次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        newArray[--counts[array[i] - min]] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newArray.length; i++) &#123;</span><br><span class="line">        array[i] = newArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好、最坏、平均时间复杂度：$O(n + k)$</strong></p><p><strong>空间复杂度：$O(n + k)$</strong></p><p><strong>$k$ 是整数的取值范围</strong></p><p><strong>属于稳定排序</strong></p><h2 id="计数排序-–-对自定义对象进行排序"><a href="#计数排序-–-对自定义对象进行排序" class="headerlink" title="计数排序 – 对自定义对象进行排序"></a>计数排序 – 对自定义对象进行排序</h2><p>如果自定义对象可以提供用以排序的整数类型，依然可以使用计数排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [age="</span> + age </span><br><span class="line">            + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person[] persons = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">"A"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(-<span class="number">13</span>, <span class="string">"B"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">17</span>, <span class="string">"C"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">"D"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(-<span class="number">13</span>, <span class="string">"E"</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">"F"</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最值</span></span><br><span class="line"><span class="keyword">int</span> max = persons[<span class="number">0</span>].age;</span><br><span class="line"><span class="keyword">int</span> min = persons[<span class="number">0</span>].age;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; persons.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (persons[i].age &gt; max) &#123;</span><br><span class="line">        max = persons[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (persons[i].age &lt; min) &#123;</span><br><span class="line">        min = persons[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开辟内存空间，存储次数</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 统计每个整数出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    counts[person.age - min]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 累加次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">    counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后往前遍历元素，将它放到有序数组中的合适位置</span></span><br><span class="line">Person[] newArray = <span class="keyword">new</span> Person[persons.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = persons.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    newArray[--counts[persons[i].age - min]] = persons[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序数组赋值到array</span></span><br><span class="line">System.arraycopy(newArray, <span class="number">0</span>, persons, <span class="number">0</span>, newArray.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序之后的结果</p><p>① $Person [age=-13, name=B]$</p><p>② $Person [age=-13, name=E]$</p><p>③ $Person [age=12, name=D]$</p><p>④ $Person [age=17, name=C]$</p><p>⑤ $Person [age=20, name=A]$</p><p>⑥ $Person [age=20, name=F]$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数排序（Counting-Sort）&quot;&gt;&lt;a href=&quot;#计数排序（Counting-Sort）&quot; class=&quot;headerlink&quot; title=&quot;计数排序（Counting Sort）&quot;&gt;&lt;/a&gt;计数排序（Counting Sort）&lt;/h1&gt;&lt;p&gt;冒泡
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/希尔排序/</id>
    <published>2020-07-14T11:06:42.000Z</published>
    <updated>2020-07-14T11:32:07.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><h2 id="什么是希尔排序"><a href="#什么是希尔排序" class="headerlink" title="什么是希尔排序"></a>什么是希尔排序</h2><ol><li><p>1959年由唐纳德·希尔（Donald Shell）提出</p></li><li><p>希尔排序把序列看作是一个矩阵，分成 𝑚 列，逐列进行排序</p><p>𝑚 从某个整数逐渐减为1</p><p>当 𝑚 为1时，整个序列将完全有序</p></li><li><p>因此，希尔排序也被称为递减增量排序（Diminishing Increment Sort）</p></li><li><p>矩阵的列数取决于步长序列（step sequence）</p><p>比如，如果步长序列为 ${1,5,19,41,109,…}$，就代表依次分成109列、41列、19列、5列、1列进行排序</p><p>不同的步长序列，执行效率也不同</p></li></ol><h2 id="希尔排序-–-实例"><a href="#希尔排序-–-实例" class="headerlink" title="希尔排序 – 实例"></a>希尔排序 – 实例</h2><p>希尔本人给出的步长序列是 $𝑛/2^𝑘$，比如 $𝑛$ 为 $16$ 时，步长序列是 {$1, 2, 4, 8$}</p><p><strong>分成8列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/1.png" alt></p><p><strong>分成4列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/2.png" alt></p><p><strong>分成2列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/3.png" alt></p><p><strong>分成1列进行排序</strong></p><p><img src="/2020/07/14/希尔排序/4.png" alt></p><p><strong>不难看出来，从8列变为1列的过程中，逆序对的数量在逐渐减少</strong></p><p>因此希尔排序底层一般使用插入排序对每一列进行排序，很多资料认为希尔排序是插入排序的改进版</p><h2 id="假设有11个元素，步长序列是-1-2-5"><a href="#假设有11个元素，步长序列是-1-2-5" class="headerlink" title="假设有11个元素，步长序列是{1, 2, 5}"></a>假设有11个元素，步长序列是{1, 2, 5}</h2><p><img src="/2020/07/14/希尔排序/5.png" alt></p><p>假设元素在第 $col$ 列、第 $row$ 行，步长（总列数）是 $step$</p><p>那么这个元素在数组中的索引是 $col + row * step$</p><p>比如 $9$ 在排序前是第 $2$ 列、第 $0$ 行，那么它排序前的索引是 $2 + 0 * 5 = 2$</p><p>比如 $4$ 在排序前是第 $2$ 列、第 $1$ 行，那么它排序前的索引是 $2 + 1 * 5 = 7$</p><h2 id="希尔排序-–-实现"><a href="#希尔排序-–-实现" class="headerlink" title="希尔排序 – 实现"></a>希尔排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; shellSequence = shellStepSequence();</span><br><span class="line">    <span class="keyword">for</span> (Integer shell : shellSequence) &#123;</span><br><span class="line">        sort(shell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分成step列进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// col : 第几列，column的简称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; step; col++) &#123; <span class="comment">// 对第col列进行排序</span></span><br><span class="line">        <span class="comment">// col、col+step、col+2*step、col+3*step</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = col + step; begin &lt; array.length; begin += step) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = begin;</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(cur, cur - step);</span><br><span class="line">                cur -= step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况是步长序列只有 $1$，且序列几乎有序，时间复杂度为 $O(n)$</p><p>空间复杂度为 $O(1)$，属于不稳定排序</p><h3 id="希尔排序-–-步长序列"><a href="#希尔排序-–-步长序列" class="headerlink" title="希尔排序 – 步长序列"></a>希尔排序 – 步长序列</h3><p>希尔本人给出的步长序列，最坏情况时间复杂度是 $O(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">shellStepSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> step = array.length;</span><br><span class="line">    <span class="keyword">while</span> ((step &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stepSequence.add(step);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stepSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前已知的最好的步长序列，最坏情况时间复杂度是 $O(n^{4/3})$ ，1986年由<strong>Robert Sedgewick</strong>提出</p><script type="math/tex; mode=display">\begin{cases}9 \left(2^k - 2^{\frac{k}{2}}\right) +1, & \text {k even} \\8 \cdot 2^k - 6 \cdot 2^{\frac{(k+1)}{2}} + 1, & \text {k odd} \\\end{cases} \\1,5,19,41,109,...</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">SedgewickStepSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; stepSequence = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pow = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            step = <span class="number">1</span> + <span class="number">9</span> * (pow * pow - pow);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pow1 = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, (k - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pow2 = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            step = <span class="number">1</span> + <span class="number">8</span> * pow1 * pow2 - <span class="number">6</span> * pow2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt;= array.length) <span class="keyword">break</span>;</span><br><span class="line">        stepSequence.add(<span class="number">0</span>, step);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stepSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;希尔排序（Shell-Sort）&quot;&gt;&lt;a href=&quot;#希尔排序（Shell-Sort）&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell Sort）&quot;&gt;&lt;/a&gt;希尔排序（Shell Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是希尔排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/快速排序/</id>
    <published>2020-07-14T10:53:40.000Z</published>
    <updated>2020-07-14T11:05:38.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick    Sort）"></a>快速排序（Quick    Sort）</h1><h2 id="什么是快速排序"><a href="#什么是快速排序" class="headerlink" title="什么是快速排序"></a>什么是快速排序</h2><p>1960年由查尔斯·安东尼·理查德·霍尔（Charles Antony Richard Hoare，缩写为C. A. R. Hoare）提出</p><p>昵称为东尼·霍尔（Tony Hoare）</p><h2 id="快速排序-–-执行流程"><a href="#快速排序-–-执行流程" class="headerlink" title="快速排序 – 执行流程"></a>快速排序 – 执行流程</h2><p>① 从序列中选择一个轴点元素（pivot）</p><p>​    假设每次选择 0 位置的元素为轴点元素</p><p>② 利用 pivot 将序列分割成 2 个子序列</p><p>​    将小于 pivot 的元素放在pivot前面（左侧）</p><p>​    将大于 pivot 的元素放在pivot后面（右侧）</p><p>​    等于pivot的元素放哪边都可以</p><p>③ 对子序列进行 ① ② 操作</p><p>​    直到不能再分割（子序列中只剩下1个元素）</p><p><img src="/2020/07/14/快速排序/1.png" alt></p><p><strong>快速排序的本质</strong></p><p><strong>逐渐将每一个元素都转换成轴点元素</strong></p><h2 id="快速排序-–-轴点构造"><a href="#快速排序-–-轴点构造" class="headerlink" title="快速排序 – 轴点构造"></a>快速排序 – 轴点构造</h2><p><img src="/2020/07/14/快速排序/2.png" alt></p><h2 id="快速排序-–-时间复杂度"><a href="#快速排序-–-时间复杂度" class="headerlink" title="快速排序 – 时间复杂度"></a>快速排序 – 时间复杂度</h2><ol><li><p>在轴点左右元素数量比较均匀的情况下，同时也是最好的情况</p><p>$T(n) = 2 ∗ T(n/2) + O(n) = O(nlogn)$</p></li><li><p>如果轴点左右元素数量极度不均匀，最坏情况</p><p>$T(n) = T(n − 1) + O(n) = O(n^2)$</p></li><li><p>为了降低最坏情况的出现概率，一般采取的做法是</p><p>随机选择轴点元素</p></li><li><p>最好、平均时间复杂度：$O(nlogn)$</p><p>最坏时间复杂度：$O(n^2)$</p><p>由于递归调用的缘故，空间复杂度：$O(logn)$</p><p>属于不稳定排序</p></li></ol><p><img src="/2020/07/14/快速排序/3.png" alt></p><h2 id="快速排序-–-实现"><a href="#快速排序-–-实现" class="headerlink" title="快速排序 – 实现"></a>快速排序 – 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(<span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 [begin, end) 范围的元素进行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定轴点位置 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> mid = pivotIndex(begin, end);</span><br><span class="line">    <span class="comment">// 对子序列进行快速排序</span></span><br><span class="line">    sort(begin, mid); </span><br><span class="line">    sort(mid + <span class="number">1</span>, end); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造出 [begin, end) 范围的轴点元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 轴点元素的最终位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机选择一个元素跟begin位置进行交换</span></span><br><span class="line">    swap(begin, begin + (<span class="keyword">int</span>)(Math.random() * (end - begin)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份begin位置的元素</span></span><br><span class="line">    T pivot = array[begin];</span><br><span class="line">    <span class="comment">// end指向最后一个元素</span></span><br><span class="line">    end--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(pivot, array[end]) &lt; <span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">                array[begin++] = array[end];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp(pivot, array[begin]) &gt; <span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">                begin++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">                array[end--] = array[begin];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将轴点元素放入最终的位置</span></span><br><span class="line">    array[begin] = pivot;</span><br><span class="line">    <span class="comment">// 返回轴点元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序-–-与轴点相等的元素"><a href="#快速排序-–-与轴点相等的元素" class="headerlink" title="快速排序 – 与轴点相等的元素"></a>快速排序 – 与轴点相等的元素</h3><p><img src="/2020/07/14/快速排序/4.png" alt></p><p>如果序列中的所有元素都与轴点元素相等，利用目前的算法实现，轴点元素可以将序列分割成 2 个均匀的子序列</p><p><strong>思考：cmp 位置的判断分别改为 ≤、≥ 会起到什么效果？</strong></p><p><img src="/2020/07/14/快速排序/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(pivot, array[end]) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 右边元素 &gt; 轴点元素</span></span><br><span class="line">            end--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边元素 &lt;= 轴点元素</span></span><br><span class="line">            array[begin++] = array[end];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(pivot, array[begin]) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 左边元素 &lt; 轴点元素</span></span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左边元素 &gt;= 轴点元素</span></span><br><span class="line">            array[end--] = array[begin];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>轴点元素分割出来的子序列极度不均匀</strong></p><p><strong>导致出现最坏时间复杂度</strong> $O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序（Quick-Sort）&quot;&gt;&lt;a href=&quot;#快速排序（Quick-Sort）&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quick    Sort）&quot;&gt;&lt;/a&gt;快速排序（Quick    Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/归并排序/</id>
    <published>2020-07-14T10:11:09.000Z</published>
    <updated>2020-07-14T10:52:34.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><h2 id="什么是归并排序"><a href="#什么是归并排序" class="headerlink" title="什么是归并排序"></a>什么是归并排序</h2><p>1945年由约翰·冯·诺伊曼（John von Neumann）首次提出</p><p>执行流程</p><p>① 不断地将当前序列平均分割成2个子序列</p><p>​    直到不能再分割（序列中只剩1个元素）</p><p>② 不断地将2个子序列合并成一个有序序列</p><p>​    直到最终只剩下1个有序序列</p><p><img src="/2020/07/14/归并排序/1.png" alt></p><h2 id="归并排序-–-divide实现"><a href="#归并排序-–-divide实现" class="headerlink" title="归并排序 – divide实现"></a>归并排序 – divide实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一段临时的数组空间，在merge操作中使用</span></span><br><span class="line">    leftArray = (T[]) <span class="keyword">new</span> Comparable[array.length &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    sort(<span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sort(begin, mid);</span><br><span class="line">    sort(mid, end);</span><br><span class="line">    merge(begin, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-–-merge"><a href="#归并排序-–-merge" class="headerlink" title="归并排序 – merge"></a>归并排序 – merge</h2><h3 id="归并排序-–-merge细节"><a href="#归并排序-–-merge细节" class="headerlink" title="归并排序 – merge细节"></a>归并排序 – merge细节</h3><p><img src="/2020/07/14/归并排序/2.png" alt></p><p>需要 merge 的 2 组序列存在于同一个数组中，并且是挨在一起的</p><p><img src="/2020/07/14/归并排序/3.png" alt></p><p>为了更好地完成 merge 操作，最好将其中 1 组序列备份出来，比如 $[begin, mid)$</p><p><img src="/2020/07/14/归并排序/4.png" alt></p><p>$li == 0，le == mid – begin$</p><p>$ri == mid，re == end$</p><h3 id="归并排序-–-merge-–-左边先结束"><a href="#归并排序-–-merge-–-左边先结束" class="headerlink" title="归并排序 – merge – 左边先结束"></a>归并排序 – merge – 左边先结束</h3><p><img src="/2020/07/14/归并排序/5.png" alt></p><h3 id="归并排序-–-merge-–-右边先结束"><a href="#归并排序-–-merge-–-右边先结束" class="headerlink" title="归并排序 – merge – 右边先结束"></a>归并排序 – merge – 右边先结束</h3><p><img src="/2020/07/14/归并排序/6.png" alt></p><h3 id="归并排序-–-merge实现"><a href="#归并排序-–-merge实现" class="headerlink" title="归并排序 – merge实现"></a>归并排序 – merge实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> li = <span class="number">0</span>, le = mid - begin;</span><br><span class="line">    <span class="keyword">int</span> ri = mid, re = end;</span><br><span class="line">    <span class="keyword">int</span> ai = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份左边数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = li; i &lt; le; i++) &#123;</span><br><span class="line">        leftArray[i] = array[begin + i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左边还没有结束</span></span><br><span class="line">    <span class="keyword">while</span> (li &lt; le) &#123; </span><br><span class="line">        <span class="keyword">if</span> (ri &lt; re &amp;&amp; cmp(array[ri], leftArray[li]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[ai++] = array[ri++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array[ai++] = leftArray[li++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-–-复杂度分析"><a href="#归并排序-–-复杂度分析" class="headerlink" title="归并排序 – 复杂度分析"></a>归并排序 – 复杂度分析</h2><p>归并排序花费的时间</p><p>$T(n) = 2 ∗ T (n/2) + O(n)$</p><p>$T(1) = O(1)$</p><p>$T(n) /n = T(n/2) / (n/2) + O(1)$</p><p>令 $S(n) = T(n) /n$</p><p>$S(1) = O(1)$</p><p>$S(n) = S(n/2) + O(1) = S(n/4)+ O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)$</p><p>$T(n) = n ∗ S(n) = O(nlogn)$</p><p>由于归并排序总是平均分割子序列，所以最好、最坏、平均时间复杂度都是 $O(nlogn)$ ，属于稳定排序</p><p>从代码中不难看出：归并排序的空间复杂度是 $O(n/2 + logn) = O(n)$</p><p>$n/2$ 用于临时存放左侧数组，$logn$ 是因为递归调用</p><h2 id="常见的递推式与复杂度"><a href="#常见的递推式与复杂度" class="headerlink" title="常见的递推式与复杂度"></a>常见的递推式与复杂度</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>递推式</strong></th><th style="text-align:center"><strong>复杂度</strong></th></tr></thead><tbody><tr><td style="text-align:center">$T(n) = T(n/2) + O(1)$</td><td style="text-align:center">$O(logn)$</td></tr><tr><td style="text-align:center">$T(n) = T(n − 1) + O(1)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = T(n/2) + O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n/2) + O(1)  $</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n/2) + O(n)$</td><td style="text-align:center">$O(nlogn)$</td></tr><tr><td style="text-align:center">$T(n) = T(n − 1) + O(n)$</td><td style="text-align:center">$O(n^2)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n − 1) + O(1)$</td><td style="text-align:center">$O(2^n)$</td></tr><tr><td style="text-align:center">$T(n) = 2 ∗ T(n − 1) + O(n)$</td><td style="text-align:center">$O(2^n)$</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序（Merge-Sort）&quot;&gt;&lt;a href=&quot;#归并排序（Merge-Sort）&quot; class=&quot;headerlink&quot; title=&quot;归并排序（Merge Sort）&quot;&gt;&lt;/a&gt;归并排序（Merge Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是归并排序&quot;&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2020/07/14/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/插入排序/</id>
    <published>2020-07-14T09:32:46.000Z</published>
    <updated>2020-07-14T10:06:40.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><h2 id="什么是插入排序"><a href="#什么是插入排序" class="headerlink" title="什么是插入排序"></a>什么是插入排序</h2><p>插入排序非常类似于扑克牌的排序</p><p>执行流程</p><p>① 在执行过程中，插入排序会将序列分为2部分</p><p>​    头部是已经排好序的，尾部是待排序的</p><p>② 从头开始扫描每一个元素</p><p>​    每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序</p><p><img src="/2020/07/14/插入排序/1.png" alt></p><h2 id="插入排序-实现-无优化"><a href="#插入排序-实现-无优化" class="headerlink" title="插入排序 - 实现(无优化)"></a>插入排序 - 实现(无优化)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = begin;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(cur, cur - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(cur, cur - <span class="number">1</span>);</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-–-逆序对（Inversion）"><a href="#插入排序-–-逆序对（Inversion）" class="headerlink" title="插入排序 – 逆序对（Inversion）"></a>插入排序 – 逆序对（Inversion）</h2><ul><li><p><strong>什么是逆序对？</strong></p><p>数组 <2,3,8,6,1> 的逆序对为：<2,1> <3,1> <8,1> <8,6> <6,1>，共5个逆序对</6,1></8,6></8,1></3,1></2,1></2,3,8,6,1></p><p>插入排序的时间复杂度与逆序对的数量成正比关系</p><p>逆序对的数量越多，插入排序的时间复杂度越高</p></li><li><p>最坏、平均时间复杂度：$O(n^2)$</p><p>最好时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p><p>属于稳定排序</p></li><li><p>当逆序对的数量极少时，插入排序的效率特别高</p><p>甚至速度比 $O(nlogn)$级别的快速排序还要快</p><p>数据量不是特别大的时候，插入排序的效率也是非常好的</p></li></ul><p><img src="/2020/07/14/插入排序/2.png" alt></p><h2 id="插入排序-–-优化"><a href="#插入排序-–-优化" class="headerlink" title="插入排序 – 优化"></a>插入排序 – 优化</h2><p>思路是将【交换】转为【挪动】</p><p>① 先将待插入的元素备份</p><p>② 头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置</p><p>③ 将待插入元素放到最终的合适位置</p><p><img src="/2020/07/14/插入排序/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = begin;</span><br><span class="line">    T v = array[cur];</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(v, array[cur - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        array[cur] = array[cur - <span class="number">1</span>];</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    array[cur] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-–-二分搜索优化"><a href="#插入排序-–-二分搜索优化" class="headerlink" title="插入排序 – 二分搜索优化"></a>插入排序 – 二分搜索优化</h2><h3 id="二分搜索（Binary-Search）"><a href="#二分搜索（Binary-Search）" class="headerlink" title="二分搜索（Binary Search）"></a>二分搜索（Binary Search）</h3><p>如何确定一个元素在数组中的位置？（假设数组里面全都是整数）</p><p>如果是无序数组，从第 0 个位置开始遍历搜索，平均时间复杂度：$O(n)$</p><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">31</td><td style="text-align:center">66</td><td style="text-align:center">17</td><td style="text-align:center">15</td><td style="text-align:center">28</td><td style="text-align:center">20</td><td style="text-align:center">59</td><td style="text-align:center">88</td><td style="text-align:center">45</td><td style="text-align:center">56</td></tr></tbody></table></div><p>如果是有序数组，可以使用二分搜索，最坏时间复杂度：$O(logn)$</p><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">20</td><td style="text-align:center">28</td><td style="text-align:center">31</td><td style="text-align:center">45</td><td style="text-align:center">56</td><td style="text-align:center">59</td><td style="text-align:center">66</td><td style="text-align:center">88</td></tr></tbody></table></div><h3 id="二分搜索-–-思路"><a href="#二分搜索-–-思路" class="headerlink" title="二分搜索 – 思路"></a>二分搜索 – 思路</h3><p>假设在 $[begin, end)$ 范围内搜索某个元素 v，$mid == (begin + end) /2$</p><p>如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索</p><p>如果 $v &gt; m$，去 $[mid + 1, end)$ 范围内二分搜索</p><p>如果 $v == m$，直接返回 mid</p><p><img src="/2020/07/14/插入排序/4.png" alt></p><h3 id="二分搜索-–-实例"><a href="#二分搜索-–-实例" class="headerlink" title="二分搜索 – 实例"></a>二分搜索 – 实例</h3><p><img src="/2020/07/14/插入排序/5.png" alt></p><h3 id="二分搜索-–-实现"><a href="#二分搜索-–-实现" class="headerlink" title="二分搜索 – 实现"></a>二分搜索 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; array[mid]) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序-–-二分搜索优化-1"><a href="#插入排序-–-二分搜索优化-1" class="headerlink" title="插入排序 – 二分搜索优化"></a>插入排序 – 二分搜索优化</h3><p>在元素 v 的插入过程中，可以先二分搜索出合适的插入位置，然后再将元素 v 插入</p><p><img src="/2020/07/14/插入排序/6.png" alt></p><p>要求二分搜索返回的插入位置：第1个大于 v 的元素位置</p><ul><li><p>如果 v 是 5，返回 2</p></li><li><p>如果 v 是 1，返回 0</p></li><li><p>如果 v 是 15，返回 7</p></li><li><p>如果 v 是 8，返回 5</p></li></ul><h3 id="插入排序-–-二分搜索优化-–-思路"><a href="#插入排序-–-二分搜索优化-–-思路" class="headerlink" title="插入排序 – 二分搜索优化 – 思路"></a>插入排序 – 二分搜索优化 – 思路</h3><p>假设在 $[begin, end)$ 范围内搜索某个元素 $v$，$mid == (begin + end) /2$</p><p>如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索</p><p>如果 $v ≥ m$，去 $[mid + 1, end)$ 范围内二分搜索</p><p><img src="/2020/07/14/插入排序/7.png" alt></p><h3 id="插入排序-–-二分搜索优化-–-实例"><a href="#插入排序-–-二分搜索优化-–-实例" class="headerlink" title="插入排序 – 二分搜索优化 – 实例"></a>插入排序 – 二分搜索优化 – 实例</h3><p><img src="/2020/07/14/插入排序/8.png" alt></p><p><img src="/2020/07/14/插入排序/9.png" alt></p><h3 id="插入排序-–-二分搜索优化-–-实现"><a href="#插入排序-–-二分搜索优化-–-实现" class="headerlink" title="插入排序 – 二分搜索优化 – 实现"></a>插入排序 – 二分搜索优化 – 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">    insert(begin, search(begin));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将source位置的元素插入到dest位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    T v = array[source];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = source; i &gt; dest; i--) &#123;</span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    array[dest] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二分搜索找到 index 位置元素的待插入位置</span></span><br><span class="line"><span class="comment">// 已经排好序数组的区间范围是 [0, index)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = index;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmp(array[index], array[mid]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用了二分搜索后，只是减少了比较次数，但插入排序的平均时间复杂度依然是 $O(n^2)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插入排序（Insertion-Sort）&quot;&gt;&lt;a href=&quot;#插入排序（Insertion-Sort）&quot; class=&quot;headerlink&quot; title=&quot;插入排序（Insertion Sort）&quot;&gt;&lt;/a&gt;插入排序（Insertion Sort）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/堆排序/</id>
    <published>2020-07-14T09:32:36.000Z</published>
    <updated>2020-07-14T09:39:41.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><h2 id="什么是堆排序"><a href="#什么是堆排序" class="headerlink" title="什么是堆排序"></a>什么是堆排序</h2><p><strong>堆排序可以认为是对选择排序的一种优化</strong></p><p><strong><a href="/2020/07/14/选择排序/" title="选择排序的实现">选择排序的实现</a></strong>  / <strong><a href="/2020/07/14/二叉堆/" title="二叉堆的实现">二叉堆的实现</a></strong></p><p>执行流程</p><p>① 对序列进行原地建堆（heapify）</p><p>② 重复执行以下操作，直到堆的元素数量为 1</p><p>​    交换堆顶元素与尾元素</p><p>​    堆的元素数量减 1</p><p>​    对 0 位置进行 1 次 siftDown 操作</p><p><img src="/2020/07/14/堆排序/1.png" alt></p><h2 id="堆排序-实现"><a href="#堆排序-实现" class="headerlink" title="堆排序 - 实现"></a>堆排序 - 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地建堆</span></span><br><span class="line">heapSize = array.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (heapSize &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    siftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 交换堆顶元素和尾部元素</span></span><br><span class="line">    swap(<span class="number">0</span>, --heapSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对0位置进行siftDown（恢复堆的性质）</span></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    T element = array[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> half = heapSize &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; half) &#123; <span class="comment">// index必须是非叶子节点</span></span><br><span class="line">        <span class="comment">// 默认是左边跟父节点比</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        T child = array[childIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightIndex = childIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点比左子节点大</span></span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; heapSize &amp;&amp; </span><br><span class="line">            cmp(array[rightIndex], child) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            child = array[childIndex = rightIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大于等于子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cmp(element, child) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        array[index] = child;</span><br><span class="line">        index = childIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    array[index] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好、最坏、平均时间复杂度：O(nlogn)，空间复杂度：O(1)，属于不稳定排序</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆排序（Heap-Sort）&quot;&gt;&lt;a href=&quot;#堆排序（Heap-Sort）&quot; class=&quot;headerlink&quot; title=&quot;堆排序（Heap Sort）&quot;&gt;&lt;/a&gt;堆排序（Heap Sort）&lt;/h1&gt;&lt;h2 id=&quot;什么是堆排序&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2020/07/14/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/选择排序/</id>
    <published>2020-07-14T09:30:04.000Z</published>
    <updated>2020-07-14T10:07:57.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><p>执行流程</p><p>① 从序列中找出最大的那个元素，然后与最末尾的元素交换位置</p><p>​    执行完一轮后，最末尾的那个元素就是最大的元素</p><p>② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(max, begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = begin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(max, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序的交换次数要远远少于冒泡排序，平均性能优于冒泡排序</p><p>最好、最坏、平均时间复杂度：$O(n^2)$，空间复杂度：$O(1)$，属于不稳定排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序（Selection-Sort）&quot;&gt;&lt;a href=&quot;#选择排序（Selection-Sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序（Selection Sort）&quot;&gt;&lt;/a&gt;选择排序（Selection Sort）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2020/07/14/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/14/冒泡排序/</id>
    <published>2020-07-14T09:16:27.000Z</published>
    <updated>2020-07-14T10:09:09.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><h2 id="冒泡排序（无优化实现）"><a href="#冒泡排序（无优化实现）" class="headerlink" title="冒泡排序（无优化实现）"></a>冒泡排序（无优化实现）</h2><p>冒泡排序也叫做起泡排序</p><p>执行流程（统一以升序为例子）</p><p>① 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置</p><p>​    执行完一轮后，最末尾那个元素就是最大的元素</p><p>② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①，直到全部元素有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="comment">// 比大小</span></span><br><span class="line">        <span class="keyword">if</span> (cmp(begin, begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            swap(begin, begin - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-–-优化①"><a href="#冒泡排序-–-优化①" class="headerlink" title="冒泡排序 – 优化①"></a>冒泡排序 – 优化①</h2><p>如果序列已经完全有序，可以提前终止冒泡排序</p><p><img src="/2020/07/14/冒泡排序/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp(begin, begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(begin, begin - <span class="number">1</span>);</span><br><span class="line">            sorted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-–-优化②"><a href="#冒泡排序-–-优化②" class="headerlink" title="冒泡排序 – 优化②"></a>冒泡排序 – 优化②</h2><p>如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数</p><p><img src="/2020/07/14/冒泡排序/2.png" alt></p><p><strong>最后1次交换的位置是 6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">int</span> sortedIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">        <span class="comment">// if (array[begin] &lt; array[begin - 1]) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (cmp(begin, begin - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(begin, begin - <span class="number">1</span>);</span><br><span class="line">            sortedIndex = begin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = sortedIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最坏、平均时间复杂度：$O(n^2)$</strong></p><p><strong>最好时间复杂度：</strong>$O(n)$</p><p><strong>空间复杂度：</strong>$O(1)$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;&lt;a href=&quot;#冒泡排序（Bubble-Sort）&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序（Bubble Sort）&quot;&gt;&lt;/a&gt;冒泡排序（Bubble Sort）&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序（
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>10大排序算法</title>
    <link href="http://yoursite.com/2020/07/14/10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/14/10大排序算法/</id>
    <published>2020-07-14T09:10:41.000Z</published>
    <updated>2020-07-14T09:29:11.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10大排序算法"><a href="#10大排序算法" class="headerlink" title="10大排序算法"></a>10大排序算法</h1><p>以下表格是基于数组进行排序的一般性结论</p><p>冒泡、选择、插入、归并、快速、希尔、堆排序，属于比较排序（Comparison Sorting）</p><p><img src="/2020/07/14/10大排序算法/1.png" alt></p><h2 id="排序算法的稳定性（Stability）"><a href="#排序算法的稳定性（Stability）" class="headerlink" title="排序算法的稳定性（Stability）"></a>排序算法的稳定性（Stability）</h2><p>如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法</p><p>排序前：5, 1, 3𝑎, 4, 7, 3𝑏</p><p>稳定的排序： 1, 3𝑎, 3𝑏, 4, 5, 7</p><p>不稳定的排序：1, 3𝑏, 3𝑎, 4,  5, 7</p><h2 id="原地算法（In-place-Algorithm）"><a href="#原地算法（In-place-Algorithm）" class="headerlink" title="原地算法（In-place Algorithm）"></a>原地算法（In-place Algorithm）</h2><p>不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入</p><p>空间复杂度为𝑂(1) 的都可以认为是原地算法</p><p>非原地算法，称为 Not-in-place 或者 Out-of-place</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10大排序算法&quot;&gt;&lt;a href=&quot;#10大排序算法&quot; class=&quot;headerlink&quot; title=&quot;10大排序算法&quot;&gt;&lt;/a&gt;10大排序算法&lt;/h1&gt;&lt;p&gt;以下表格是基于数组进行排序的一般性结论&lt;/p&gt;
&lt;p&gt;冒泡、选择、插入、归并、快速、希尔、堆排序，属
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://yoursite.com/2020/07/14/Trie/"/>
    <id>http://yoursite.com/2020/07/14/Trie/</id>
    <published>2020-07-14T07:22:50.000Z</published>
    <updated>2020-07-14T08:42:37.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树</p><p>Trie 搜索字符串的效率主要跟字符串的长度有关</p><p>假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词</p><p><img src="/2020/07/14/Trie/1.png" alt></p><h2 id="Trie代码实现"><a href="#Trie代码实现" class="headerlink" title="Trie代码实现"></a>Trie代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node&lt;V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.word ? node.value : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">add</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> len = key.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = key.charAt(i); </span><br><span class="line"><span class="keyword">boolean</span> emptyChildren = node.children == <span class="keyword">null</span>;</span><br><span class="line">Node&lt;V&gt; childNode = emptyChildren ? <span class="keyword">null</span> : node.children.get(c);</span><br><span class="line"><span class="keyword">if</span> (childNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">childNode = <span class="keyword">new</span> Node&lt;&gt;(node);</span><br><span class="line">childNode.character = c;</span><br><span class="line">node.children = emptyChildren ? <span class="keyword">new</span> HashMap&lt;&gt;() : node.children;</span><br><span class="line">node.children.put(c, childNode);</span><br><span class="line">&#125;</span><br><span class="line">node = childNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node.word) &#123; <span class="comment">// 已经存在这个单词</span></span><br><span class="line">V oldValue = node.value;</span><br><span class="line">node.value = value;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个单词</span></span><br><span class="line">node.word = <span class="keyword">true</span>;</span><br><span class="line">node.value = value;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 找到最后一个节点</span></span><br><span class="line">Node&lt;V&gt; node = node(key);</span><br><span class="line"><span class="comment">// 如果不是单词结尾，不用作任何处理</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || !node.word) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br><span class="line">V oldValue = node.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果还有子节点</span></span><br><span class="line"><span class="keyword">if</span> (node.children != <span class="keyword">null</span> &amp;&amp; !node.children.isEmpty()) &#123;</span><br><span class="line">node.word = <span class="keyword">false</span>;</span><br><span class="line">node.value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有子节点</span></span><br><span class="line">Node&lt;V&gt; parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((parent = node.parent) != <span class="keyword">null</span>) &#123;</span><br><span class="line">parent.children.remove(node.character);</span><br><span class="line"><span class="keyword">if</span> (parent.word || !parent.children.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">node = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node(prefix) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;V&gt; <span class="title">node</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;V&gt; node = root;</span><br><span class="line"><span class="keyword">int</span> len = key.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span> || node.children == <span class="keyword">null</span> || node.children.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">char</span> c = key.charAt(i); </span><br><span class="line">node = node.children.get(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyCheck</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span> || key.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key must not be empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">Node&lt;V&gt; parent;</span><br><span class="line">HashMap&lt;Character, Node&lt;V&gt;&gt; children;</span><br><span class="line">Character character;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">boolean</span> word; <span class="comment">// 是否为单词的结尾（是否为一个完整的单词）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;V&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Trie 的优点：搜索前缀的效率主要跟前缀的长度有关</strong></p><p><strong>Trie 的缺点：需要耗费大量的内存，因此还有待改进</strong></p><p>更多Trie 相关的数据结构和算法</p><p>Double-array Trie、Suffix Tree、Patricia Tree、Crit-bit Tree、AC自动机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Trie&quot;&gt;&lt;a href=&quot;#Trie&quot; class=&quot;headerlink&quot; title=&quot;Trie&quot;&gt;&lt;/a&gt;Trie&lt;/h1&gt;&lt;p&gt;Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树&lt;/p&gt;
&lt;p&gt;Trie 搜索字符串的效率主要跟字符串的
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://yoursite.com/2020/07/14/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/14/哈夫曼树/</id>
    <published>2020-07-14T07:13:27.000Z</published>
    <updated>2020-07-14T08:43:25.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼编码（Huffman-Coding）"><a href="#哈夫曼编码（Huffman-Coding）" class="headerlink" title="哈夫曼编码（Huffman Coding）"></a>哈夫曼编码（Huffman Coding）</h1><p>哈夫曼编码，又称为霍夫曼编码，它是现代压缩算法的基础</p><p>假设要把字符串【ABBBCCCCCCCCDDDDDDEE】转成二进制编码进行传输</p><p>可以转成ASCII编码（65 ~ 69，1000001~1000101），但是有点冗长，如果希望编码更短呢？</p><p>可以先约定5个字母对应的二进制</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">001</td><td style="text-align:center">010</td><td style="text-align:center">011</td><td style="text-align:center">100</td></tr></tbody></table></div><p>对应的二进制编码：000001001001010010010010010010010010011011011011011011100100</p><p>一共20个字母，转成了60个二进制位</p><p>如果使用哈夫曼编码，可以压缩至41个二进制位，约为原来长度的68.3%</p><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>先计算出每个字母的出现频率（权值，这里直接用出现次数），【ABBBCCCCCCCCDDDDDDEE】</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table></div><p>利用这些权值，构建一棵哈夫曼树（又称为霍夫曼树、最优二叉树）</p><p>如何构建一棵哈夫曼树？（假设有 n 个权值）</p><ol><li><p>以权值作为根节点构建 n 棵二叉树，组成森林</p></li><li><p>在森林中选出 2 个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点为其左右子树根节点之和</p></li><li><p>从森林中删除刚才选取的 2 棵树，并将新树加入森林</p></li><li><p>重复 2、3 步骤，直到森林只剩一棵树为止，该树即为哈夫曼树</p></li></ol><h2 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h2><p><img src="/2020/07/14/哈夫曼树/1.png" alt></p><p>left为0，right为1，可以得出5个字母对应的哈夫曼编码</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>A</strong></th><th style="text-align:center"><strong>B</strong></th><th style="text-align:center"><strong>C</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">1110</td><td style="text-align:center">110</td><td style="text-align:center">0</td><td style="text-align:center">10</td><td style="text-align:center">1111</td></tr></tbody></table></div><p>【ABBBCCCCCCCCDDDDDDEE】的哈夫曼编码是</p><p>1110110110110000000001010101010101111</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>n 个权值构建出来的哈夫曼树拥有 n 个叶子节点</p><p>每个哈夫曼编码都不是另一个哈夫曼编码的前缀</p><p>哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近</p><p>带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径长度。与最终的哈夫曼编码总长度成正比关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈夫曼编码（Huffman-Coding）&quot;&gt;&lt;a href=&quot;#哈夫曼编码（Huffman-Coding）&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼编码（Huffman Coding）&quot;&gt;&lt;/a&gt;哈夫曼编码（Huffman Coding）&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>优先级队列</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/14/优先级队列/</id>
    <published>2020-07-14T07:04:06.000Z</published>
    <updated>2020-07-15T09:09:15.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先级队列（Priority-Queue）"><a href="#优先级队列（Priority-Queue）" class="headerlink" title="优先级队列（Priority Queue）"></a>优先级队列（Priority Queue）</h1><p><strong><a href="/2020/07/11/队列/" title="队列实现">队列实现</a></strong></p><h2 id="优先级队列的接口设计"><a href="#优先级队列的接口设计" class="headerlink" title="优先级队列的接口设计"></a>优先级队列的接口设计</h2><p>普通的队列是 FIFO 原则，也就是先进先出</p><p><strong>优先级队列则是按照优先级高低进行出队，比如将优先级最高的元素作为队头优先出队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> BinaryHeap&lt;E&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">heap = <span class="keyword">new</span> BinaryHeap&lt;&gt;(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">heap.add(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> heap.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先级队列的应用场景举例"><a href="#优先级队列的应用场景举例" class="headerlink" title="优先级队列的应用场景举例"></a>优先级队列的应用场景举例</h2><ol><li><p>医院的夜间门诊</p><p>队列元素是病人</p><p>优先级是病情的严重情况、挂号时间</p></li><li><p>操作系统的多任务调度</p><p>队列元素是任务</p><p>优先级是任务类型</p></li></ol><h2 id="优先队列的底层实现"><a href="#优先队列的底层实现" class="headerlink" title="优先队列的底层实现"></a>优先队列的底层实现</h2><p>根据优先队列的特点，很容易想到：可以直接利用二叉堆作为优先队列的底层实现</p><p> <strong><a href="/2020/07/14/二叉堆/" title="二叉堆实现">二叉堆实现</a></strong></p><p>可以通过 Comparator 或 Comparable 去自定义优先级高低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> boneBreak;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> boneBreak)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.boneBreak = boneBreak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.boneBreak - person.boneBreak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", boneBreak="</span> + boneBreak + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Person&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">2</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Rose"</span>, <span class="number">10</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"Jake"</span>, <span class="number">5</span>));</span><br><span class="line">queue.enQueue(<span class="keyword">new</span> Person(<span class="string">"James"</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">System.out.println(queue.deQueue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先级队列（Priority-Queue）&quot;&gt;&lt;a href=&quot;#优先级队列（Priority-Queue）&quot; class=&quot;headerlink&quot; title=&quot;优先级队列（Priority Queue）&quot;&gt;&lt;/a&gt;优先级队列（Priority Queue）&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
