<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表（HashTable）先来分析TreeMap（红黑树映射实现） 时间复杂度（平均） 添加、删除、搜索：O(logn) 特点 Key 必须具备可比较性 元素的分布是有顺序的 在实际应用中，很多时候的需求 Map 中存储的元素不需要讲究顺序 Map 中的 Key 不需要具备可比较性 不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)，那就是采取哈希表来实现 Map 什么是哈希表（HashTable）哈希表也叫做散列表（ hash 有“剁碎”的意思） 添加、搜索、删除的流程都是类似的 利用哈希函数生成 key 对应的 index【O(1)】 根据 index 操作定位数组元素【O(1)】 哈希表是【空间换时间】的典型应用 哈希函数，也叫做散列函数 哈希表内部的数组元素，很多地方也叫 Bucket（桶），整个数组叫 Buckets 或者 Bucket Array 哈希冲突（Hash Collision）哈希冲突也叫做哈希碰撞 2 个不同的 key，经过哈希函数计算出相同的结果 key1 ≠ key2 ，hash(key1) = hash(key2) 解决哈希冲突的常见方法 开放定址法（Open Addressing） 按照一定规则向其他地址探测，直到遇到空桶 再哈希法（Re-Hashing） 设计多个哈希函数 链地址法（Separate Chaining） 比如通过链表将同一index的元素串起来 JDK1.8的哈希冲突解决方案JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突 默认使用单向链表将元素串起来 在添加元素时，可能会由单向链表转为红黑树来存储元素 比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时 当红黑树节点数量少到一定程度时，又会转为单向链表 哈希函数哈希表中哈希函数的实现步骤大概如下 先生成 key 的哈希值（必须是整数） 再让 key 的哈希值跟数组的大小进行相关运算，生成一个索引值 123private int hash(K key) &#123; return hash_code(key) % table.length;&#125; 为了提高效率，可以使用 &amp; 位运算取代 % 运算【前提：将数组的长度设计为 2 的幂（2n）】 1100 1010 1011 1100 &amp; 1111 &amp; 1111 1010 1100 123private int hash(K key) &#123; return hash_code(key) % (table.length - 1);&#125; 良好的哈希函数 让哈希值更加均匀分布 → 减少哈希冲突次数 → 提升哈希表的性能 如何生成key的哈希值key 的常见种类可能有 整数、浮点数、字符串、自定义对象 不同种类的 key，哈希值的生成方式不一样，但目标是一致的 尽量让每个 key 的哈希值是唯一的 尽量让 key 的所有信息参与运算 在Java中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null 整数的哈希值整数值当做哈希值 比如 10 的哈希值就是 10 123public static int hashCode(int value)&#123; return value;&#125; 浮点数的哈希值将存储的二进制格式转为整数值 123public static int hashCode(float value)&#123; return floatToIntBits(value);&#125; Long和Double的哈希值123public static int hashCode(long value)&#123; return (int)(value ^ (value &gt;&gt;&gt; 32));&#125; 1234public static int hashCode(double value)&#123; long bits = doubleToLongBits(value); return (int)(bits ^ (bits &gt;&gt;&gt; 32));&#125; >&gt;&gt; 和 ^ 的作用是？ 高32bit 和 低32bit 混合计算出 32bit 的哈希值 充分利用所有信息计算出哈希值 字符串的哈希值字符串是由若干个字符组成的 比如字符串 jack，由 j、a、c、k 四个字符组成（字符的本质就是一个整数） 因此，jack 的哈希值可以表示为 $ j ∗ n^3 + a ∗ n^2 + c ∗ n^1 + k ∗ n^0$，等价于 $[ ( j ∗ n + a ) ∗ n + c ] ∗ n + k$ 在JDK中，乘数 n 为 31，为什么使用 31？ 31 是一个奇素数，JVM会将 31 * i 优化成 (i &lt;&lt; 5) – i 31 * i = (2^5 - 1) * i = i * 2^5 - i = (i < 5) -i]]></content>
      <categories>
        <category>算法</category>
        <category>映射</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>映射</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[映射]]></title>
    <url>%2F2020%2F07%2F13%2F%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[映射（Map）Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C、Swift 等） Map 的每一个 key 是唯一的 Map的接口设计12345678910111213141516public interface Map&lt;K, V&gt; &#123; int size(); boolean isEmpty(); void clear(); V put(K key, V value); V get(K key); V remove(K key); boolean containsKey(K key); boolean containsValue(V value); void traversal(Visitor&lt;K, V&gt; visitor); public static abstract class Visitor&lt;K, V&gt; &#123; boolean stop; public abstract boolean visit(K key, V value); &#125;&#125; 类似 Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现 Map利用红黑树实现红黑树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479public class TreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private static final boolean RED = false; private static final boolean BLACK = true; private int size; private Node&lt;K, V&gt; root; private Comparator&lt;K&gt; comparator; public TreeMap() &#123; this(null); &#125; public TreeMap(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; root = null; size = 0; &#125; @Override public V put(K key, V value) &#123; keyNotNullCheck(key); // 添加第一个节点 if (root == null) &#123; root = new Node&lt;&gt;(key, value, null); size++; // 新添加节点之后的处理 afterPut(root); return null; &#125; // 添加的不是第一个节点 // 找到父节点 Node&lt;K, V&gt; parent = root; Node&lt;K, V&gt; node = root; int cmp = 0; do &#123; cmp = compare(key, node.key); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // 相等 node.key = key; V oldValue = node.value; node.value = value; return oldValue; &#125; &#125; while (node != null); // 看看插入到父节点的哪个位置 Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // 新添加节点之后的处理 afterPut(newNode); return null; &#125; @Override public V get(K key) &#123; Node&lt;K, V&gt; node = node(key); return node != null ? node.value : null; &#125; @Override public V remove(K key) &#123; return remove(node(key)); &#125; @Override public boolean containsKey(K key) &#123; return node(key) != null; &#125; @Override public boolean containsValue(V value) &#123; if (root == null) return false; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;K, V&gt; node = queue.poll(); if (valEquals(value, node.value)) return true; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return false; &#125; @Override public void traversal(Visitor&lt;K, V&gt; visitor) &#123; if (visitor == null) return; traversal(root, visitor); &#125; private void traversal(Node&lt;K, V&gt; node, Visitor&lt;K, V&gt; visitor) &#123; if (node == null || visitor.stop) return; traversal(node.left, visitor); if (visitor.stop) return; visitor.visit(node.key, node.value); traversal(node.right, visitor); &#125; private boolean valEquals(V v1, V v2) &#123; return v1 == null ? v2 == null : v1.equals(v2); &#125; private V remove(Node&lt;K, V&gt; node) &#123; if (node == null) return null; size--; V oldValue = node.value; if (node.hasTwoChildren()) &#123; // 度为2的节点 // 找到后继节点 Node&lt;K, V&gt; s = successor(node); // 用后继节点的值覆盖度为2的节点的值 node.key = s.key; node.value = s.value; // 删除后继节点 node = s; &#125; // 删除node节点（node的度必然是1或者0） Node&lt;K, V&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // node是度为1的节点 // 更改parent replacement.parent = node.parent; // 更改parent的left、right的指向 if (node.parent == null) &#123; // node是度为1的节点并且是根节点 root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // 删除节点之后的处理 afterRemove(replacement); &#125; else if (node.parent == null) &#123; // node是叶子节点并且是根节点 root = null; &#125; else &#123; // node是叶子节点，但不是根节点 if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // 删除节点之后的处理 afterRemove(node); &#125; return oldValue; &#125; private void afterRemove(Node&lt;K, V&gt; node) &#123; // 如果删除的节点是红色 // 或者 用以取代删除节点的子节点是红色 if (isRed(node)) &#123; black(node); return; &#125; Node&lt;K, V&gt; parent = node.parent; if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;K, V&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125; private Node&lt;K, V&gt; predecessor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） Node&lt;K, V&gt; p = node.left; if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.parent == null // node == node.parent.right return node.parent; &#125; private Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） Node&lt;K, V&gt; p = node.right; if (p != null) &#123; while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; private Node&lt;K, V&gt; node(K key) &#123; Node&lt;K, V&gt; node = root; while (node != null) &#123; int cmp = compare(key, node.key); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null; &#125; private void afterPut(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) &#123; black(node); return; &#125; // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node&lt;K, V&gt; uncle = parent.sibling(); // 祖父节点 Node&lt;K, V&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterPut(grand); return; &#125; // 叔父节点不是红色 if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125; &#125; private void rotateLeft(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.right; Node&lt;K, V&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void rotateRight(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.left; Node&lt;K, V&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent; &#125; private Node&lt;K, V&gt; color(Node&lt;K, V&gt; node, boolean color) &#123; if (node == null) return node; node.color = color; return node; &#125; private Node&lt;K, V&gt; red(Node&lt;K, V&gt; node) &#123; return color(node, RED); &#125; private Node&lt;K, V&gt; black(Node&lt;K, V&gt; node) &#123; return color(node, BLACK); &#125; private boolean colorOf(Node&lt;K, V&gt; node) &#123; return node == null ? BLACK : node.color; &#125; private boolean isBlack(Node&lt;K, V&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean isRed(Node&lt;K, V&gt; node) &#123; return colorOf(node) == RED; &#125; private int compare(K e1, K e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;K&gt;)e1).compareTo(e2); &#125; private void keyNotNullCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null"); &#125; &#125; private static class Node&lt;K, V&gt; &#123; K key; V value; boolean color = RED; Node&lt;K, V&gt; left; Node&lt;K, V&gt; right; Node&lt;K, V&gt; parent; public Node(K key, V value, Node&lt;K, V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; public Node&lt;K, V&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>映射</category>
        <category>TreeMap</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2020%2F07%2F13%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合（Set）集合的特点不存放重复的元素，常用于去重 存放新增 IP，统计新增 IP 量 存放词汇，统计词汇量 集合接口定义1234567891011121314public interface Set&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(E element); void add(E element); void remove(E element); void traversal(Visitor&lt;E&gt; visitor); public static abstract class Visitor&lt;E&gt; &#123; boolean stop; public abstract boolean visit(E element); &#125;&#125; 集合的内部实现直接利用学过的数据结构实现（链表，动态数组，红黑树、AVL树） 集合利用链表实现链表的实现 1234567891011121314151617181920212223242526272829303132333435363738394041public class ListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); @Override public int size() &#123; return list.size(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public void clear() &#123; list.clear(); &#125; @Override public boolean contains(E element) &#123; return list.contains(element); &#125; @Override public void add(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; // 存在就覆盖 list.set(index, element); &#125; else &#123; // 不存在就添加 list.add(element); &#125; &#125; @Override public void remove(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; list.remove(index); &#125; &#125;&#125; 集合利用红黑树实现红黑树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142public class TreeSet&lt;E&gt; implements Set&lt;E&gt; &#123; private RBTree&lt;E&gt; tree; public TreeSet() &#123; this(null); &#125; public TreeSet(Comparator&lt;E&gt; comparator) &#123; tree = new RBTree&lt;&gt;(comparator); &#125; @Override public int size() &#123; return tree.size(); &#125; @Override public boolean isEmpty() &#123; return tree.isEmpty(); &#125; @Override public void clear() &#123; tree.clear(); &#125; @Override public boolean contains(E element) &#123; return tree.contains(element); &#125; @Override public void add(E element) &#123; tree.add(element); &#125; @Override public void remove(E element) &#123; tree.remove(element); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>集合</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2020%2F07%2F12%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树（Red Black Tree）什么是红黑树红黑树也是一种自平衡的二叉搜索树 以前也叫做平衡二叉B树（Symmetric Binary B-tree） 红黑树必须满足以下 5 条性质 节点是 RED 或者 BLACK 根节点是 BLACK 叶子节点（外部节点，空节点）都是 BLACK RED 节点的子节点都是 BLACK RED 节点的 parent 都是 BLACK 从根节点到叶子节点的所有路径上不能有 2 个连续的 RED 节点 从任一节点到叶子节点的所有路径都包含相同数目的 BLACK 节点 红黑树的等价变换红黑树 和 4阶B树（2-3-4树）具有等价性 BLACK 节点与它的 RED 子节点融合在一起，形成1个B树节点 红黑树的 BLACK 节点个数 与 4阶B树的节点总个数相等 注意：后面展示的红黑树都会省略 NULL 节点 红黑树 vs 2-3-4树 如果上图最底层的 BLACK 节点是不存在的，在B树中是什么样的情形？ 整棵B树只有1个节点，而且是超级节点 一些辅助函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// parent：父节点// sibling：兄弟节点// uncle：叔父节点（parent 的兄弟节点）// grand：祖父节点（parent 的父节点）// 指定颜色private Node&lt;E&gt; color(Node&lt;E&gt; node, boolean color) &#123; if (node == null) return node; ((RBNode&lt;E&gt;)node).color = color; return node;&#125;// 染红private Node&lt;E&gt; red(Node&lt;E&gt; node) &#123; return color(node, RED);&#125;// 染黑private Node&lt;E&gt; black(Node&lt;E&gt; node) &#123; return color(node, BLACK);&#125;// 查看颜色private boolean colorOf(Node&lt;E&gt; node) &#123; return node == null ? BLACK : ((RBNode&lt;E&gt;)node).color;&#125;// 判断是否是黑色private boolean isBlack(Node&lt;E&gt; node) &#123; return colorOf(node) == BLACK;&#125;// 判断是否是红色private boolean isRed(Node&lt;E&gt; node) &#123; return colorOf(node) == RED;&#125;// 查看是否有兄弟节点public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null;&#125; 红黑树的添加已知 B树中，新元素必定是添加到叶子节点中 4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3 建议新添加的节点默认为 RED，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定） 有 4 种情况满足红黑树的性质 4 ：parent 为BLACK同样也满足4阶B树的性质 因此不用做任何额外处理 12// 如果父节点是黑色，直接返回if (isBlack(parent)) return; 有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）其中前 4 种属于B树节点上溢的情况 添加 – 修复性质4 – LL\RR判定条件：uncle 不是 RED 1.parent 染成 BLACK，grand 染成 RED 2.grand 进行单旋操作 LL：右旋转 RR：左旋转 123456789101112131415161718192021// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点染成红色Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 return;&#125;// 叔父节点不是红色if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (!node.isLeftChild()) &#123; // RR black(parent); &#125; rotateLeft(grand);&#125; 添加 – 修复性质4 – LR\RL判定条件：uncle 不是 RED 自己染成 BLACK，grand 染成 RED 进行双旋操作 LR：parent 左旋转， grand 右旋转 RL：parent 右旋转， grand 左旋转 1234567891011121314151617181920212223// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点染成红色Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 return;&#125;// 叔父节点不是红色if (parent.isLeftChild()) &#123; // L if (!node.isLeftChild()) &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; rotateLeft(grand);&#125; 添加 – 修复性质4 – 上溢 – LL判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 grand 向上合并时，可能继续发生上溢 若上溢持续到根节点，只需将根节点染成 BLACK 12345678910111213141516// 添加的是根节点 或者 上溢到达了根节点if (parent == null) &#123; black(node); return;&#125;// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return;&#125; 添加 – 修复性质4 – 上溢 – RR判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 123456789101112// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return;&#125; 添加 – 修复性质4 – 上溢 – LR判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 添加 – 修复性质4 – 上溢 – RL判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 红黑树添加后完整修复的代码12345678910111213141516171819202122232425262728293031323334353637383940414243protected void afterAdd(Node&lt;E&gt; node) &#123; Node&lt;E&gt; parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) &#123; black(node); return; &#125; // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node&lt;E&gt; uncle = parent.sibling(); // 祖父节点 Node&lt;E&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return; &#125; // 叔父节点不是红色 if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125;&#125; 红黑树的删除B树中，最后真正被删除的元素都在叶子节点中 删除 – RED节点直接删除，不用作任何调整 1234protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // 如果删除的节点是红色 if (isRed(node)) return;&#125; 删除 – BLACK节点有 3 种情况 拥有 2 个 RED 子节点的 BLACK 节点 不可能被直接删除，因为会找它的子节点替代删除 因此不用考虑这种情况 拥有 1 个 RED 子节点的 BLACK 节点 BLACK 叶子节点 下文举例采用: 被删除的节点在右边，兄弟节点在左边，（反之交换左右方向即可） 删除 - 拥有 1 个 RED 子节点的 BLACK 节点判定条件：用以替代的子节点是 RED 将替代的子节点染成 BLACK 即可保持红黑树性质 1234567protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // 用以取代node的子节点是红色 if (isRed(replacement)) &#123; black(replacement); return; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 RED 子节点BLACK 叶子节点被删除后，会导致B树节点下溢（比如删除88） 如果 sibling 至少有 1 个 RED 子节点（一个或两个RED子节点） 兄弟节点的左边是黑色，(没有子节点也算是黑色) 兄弟节点左旋 改变兄弟节点为parent的左边 后续再按兄弟节点的左边是红色执行即可 兄弟节点的左边是红色 兄弟节点继承 parent 的颜色 兄弟节点的左边变成黑色 parent节点变成黑色 parent右旋 1234567891011121314151617181920212223242526272829303132protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125;else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isBlack(sibling)) &#123; // 兄弟节点是黑色 // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 if (isRed(sibling.left) || isRed(sibling.right)) &#123; // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; // 兄弟节点的左边是红色或兄弟旋转后 color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 RED 子节点判定条件：sibling 没有 1 个 RED 子节点 将 sibling 染成 RED、parent 染成 BLACK 即可修复红黑树性质 如果 parent 是 BLACK 会导致 parent 也下溢 这时只需要把 parent 当做被删除的节点处理即可 123456789101112131415161718192021222324252627protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 // 兄弟节点是黑色 if(isBlack(sibling))&#123; if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent, null); &#125; &#125; &#125; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为RED如果 sibling 是 RED sibling 染成 BLACK，parent 染成 RED，进行旋转 于是又回到 sibling 是 BLACK 的情况 1234567891011121314151617181920protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; &#125;&#125; 红黑树删除后完整修复的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void afterRemove(Node&lt;E&gt; node) &#123; // 如果删除的节点是红色 // 或者 用以取代删除节点的子节点是红色 if (isRed(node)) &#123; black(node); return; &#125; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125;&#125; 红黑树的平衡为何那5条性质，就能保证红黑树是平衡的？ 那5条性质，可以保证红黑树等价于4阶B树 相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍 是一种弱平衡、黑高度平衡 红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是 O(logn) 级别 平均时间复杂度搜索：O(logn) 添加：O(logn)，O(1) 次的旋转操作 删除：O(logn)，O(1) 次的旋转操作 AVL树 vs 红黑树AVL树 AVL树的实现 平衡标准比较严格：每个左右子树的高度差不超过1 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W个节点，AVL树最大树高28） 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整 红黑树 平衡标准比较宽松：没有一条路径会大于其他路径的2倍 最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40） 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整 总结 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树 BST vs AVL Tree vs Red Black Tree10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>红黑树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树]]></title>
    <url>%2F2020%2F07%2F12%2FB%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树（B - tree、B - 树）​ B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现 B树特点 1个节点可以存储超过 2 个元素、可以拥有超过 2 个子节点 拥有二叉搜索树的一些性质 平衡，每个节点的所有子树高度一致 比较矮 m阶B树的性质（m≥2）假设一个节点存储的元素个数为 x 根节点：1 ≤ x ≤ m − 1 非根节点：┌ m/2 ┐ − 1 ≤ x ≤ m − 1 如果有子节点，子节点个数 y = x + 1 根节点：2 ≤ y ≤ m 非根节点：┌ m/2 ┐ ≤ y ≤ m 比如 m = 3，2 ≤ y ≤ 3，因此可以称为（2, 3）树、2-3树 比如 m = 4，2 ≤ y ≤ 4，因此可以称为（2, 4）树、2-3-4树 比如 m = 5，3 ≤ y ≤ 5，因此可以称为（3, 5）树 比如 m = 6，3 ≤ y ≤ 6，因此可以称为（3, 6）树 比如 m = 7，4 ≤ y ≤ 7，因此可以称为（4, 7）树 B树 VS 二叉搜索树B树和二叉搜索树，在逻辑上是等价的 多代节点合并，可以获得一个超级节点 2代合并的超级节点，最多拥有 4 个子节点（至少是 4阶B树） 3代合并的超级节点，最多拥有 8 个子节点（至少是 8阶B树） n代合并的超级节点，最多拥有 2n个子节点（ 至少是 2n阶B树） m阶B树，最多需要 log2m 代合并 B树的搜索跟二叉搜索树的搜索类似 先在节点内部从小到大开始搜索元素 如果命中，搜索结束 如果未命中，再去对应的子节点中搜索元素，重复步骤 1 B树的添加新添加的元素必定是添加到叶子节点 插入55 插入95 再插入 98 呢？（假设这是一棵 4阶B树） 最右下角的叶子节点的元素个数将超过限制 这种现象可以称之为：上溢（overflow） 添加 – 上溢的解决(假设5阶)上溢节点的元素个数必然等于m 假设上溢节点最中间元素的位置为k 将 k 位置的元素向上与父节点合并 将 [0, k-1] 和 [k + 1, m - 1] 位置的元素分裂成 2 个子节点 这 2 个子节点的元素个数，必然都不会低于最低限制（┌ m/2 ┐ − 1） 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决 最极端的情况，有可能一直分裂到根节点 B树的删除删除 – 叶子节点假如需要删除的元素在叶子节点中，那么直接删除即可 删除 – 非叶子节点假如需要删除的元素在非叶子节点中 先找到前驱或后继元素，覆盖所需删除元素的值 再把前驱或后继元素删除 非叶子节点的前驱或后继元素，必定在叶子节点中 所以这里的删除前驱或后继元素 ，就是最开始提到的情况：删除的元素在叶子节点中 真正的删除元素都是发生在叶子节点中 删除 – 下溢删除 22 ？（假设这是一棵 5阶B树） 叶子节点被删掉一个元素后，元素个数可能会低于最低限制（ ≥ ┌ m/2 ┐ − 1 ） 这种现象称为：下溢（underflow） 删除 – 下溢的解决下溢节点的元素数量必然等于 ┌ m/2 ┐ − 2 如果下溢节点临近的兄弟节点，有至少 ┌ m/2 ┐ 个元素，可以向其借一个元素 将父节点的元素 b 插入到下溢节点的 0 位置（最小位置） 用兄弟节点的元素 a（最大的元素）替代父节点的元素 b 这种操作其实就是：旋转 如果下溢节点临近的兄弟节点，只有 ┌ m/2 ┐ − 1 个元素 将父节点的元素 b 挪下来跟左右子节点进行合并 合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播 总结了解B树的性质后，就可以来学习红黑树了 红黑树的实现]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>B树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2020%2F07%2F12%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVL树起源AVL树是最早发明的自平衡二叉搜索树之一 AVL 取名于两位发明者的名字 G. M. Adelson-Velsky 和 E. M. Landis（来自苏联的科学家） AVL树特点平衡因子（Balance Factor）：某结点的左右子树的高度差 每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”） 每个节点的左右子树高度差不超过 1 搜索、添加、删除的时间复杂度是 O(logn) 平衡对比输入数据：35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82 简单的继承结构二叉树的实现 二叉搜索树的实现 平衡修复添加导致的失衡示例：往下面这棵子树中添加 13 最坏情况：可能会导致所有祖先节点都失衡 父节点、非祖先节点，都不可能失衡 LL – 右旋转（R单旋）——- LL（n在g的LL） g.left = p.right p.right = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T2、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateRight(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; RR – 左旋转（L单旋）——- RR（n在g的RR） g.right = p.left p.left = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T1、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateLeft(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR） RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL） 旋转之后的修复12345678910111213141516171819202122232425/** * 公共代码：不管是左旋转、右旋转，都要执行 * @param grand 失衡节点 * @param parent 失衡节点的tallerChild * @param child g和p 需要交换的子树（本来是p的子树，后面会变成g的子树 */protected void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent;&#125; 节点的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 二叉树的节点protected static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; left; Node&lt;E&gt; right; Node&lt;E&gt; parent; public Node(E element, Node&lt;E&gt; parent) &#123; this.element = element; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; // 是否有兄弟节点 public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125;&#125;// AVL树节点private static class AVLNode&lt;E&gt; extends Node&lt;E&gt; &#123; int height = 1; public AVLNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; // 每个节点的平衡因子只可能是 1、0、-1 public int balanceFactor() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; return leftHeight - rightHeight; &#125; // 更新树高 public void updateHeight() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; height = 1 + Math.max(leftHeight, rightHeight); &#125; // 返回树高的子节点 public Node&lt;E&gt; tallerChild() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; if (leftHeight &gt; rightHeight) return left; if (leftHeight &lt; rightHeight) return right; return isLeftChild() ? left : right; &#125;&#125; 添加之后的修复12345678910111213protected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); // 整棵树恢复平衡 break; &#125; &#125;&#125; 判断是否平衡123private boolean isBalanced(Node&lt;E&gt; node) &#123; return Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= 1;&#125; 查看树的高度123private void updateHeight(Node&lt;E&gt; node) &#123; ((AVLNode&lt;E&gt;)node).updateHeight();&#125; 恢复平衡1234567891011121314151617181920// grand 高度最低的不平衡节点private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotateRight(grand); &#125; else &#123; // LR rotateLeft(parent); rotateRight(grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotateRight(parent); rotateLeft(grand); &#125; else &#123; // RR rotateLeft(grand); &#125; &#125;&#125; 示例输入数据：13, 14, 15, 12, 11, 17, 16, 8, 9,1 统一所有旋转操作的实现 123456789101112131415161718192021222324252627282930313233protected void rotate( Node&lt;E&gt; r, // 子树的根节点 Node&lt;E&gt; b, Node&lt;E&gt; c, Node&lt;E&gt; d, Node&lt;E&gt; e, Node&lt;E&gt; f) &#123; // 让d成为这棵子树的根节点 d.parent = r.parent; if (r.isLeftChild()) &#123; r.parent.left = d; &#125; else if (r.isRightChild()) &#123; r.parent.right = d; &#125; else &#123; root = d; &#125; //b-c b.right = c; if (c != null) &#123; c.parent = b; &#125; // e-f f.left = e; if (e != null) &#123; e.parent = f; &#125; // b-d-f d.left = b; d.right = f; b.parent = d; f.parent = d;&#125; 123456789101112131415161718192021/** * 恢复平衡 * @param grand 高度最低的那个不平衡节点 */private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotate(grand, node, node.right, parent, parent.right, grand); &#125; else &#123; // LR rotate(grand, parent, node.left, node, node.right, grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotate(grand, grand, node.left, node, node.right, parent); &#125; else &#123; // RR rotate(grand, grand, parent.left, parent, node.left, node); &#125; &#125;&#125; 删除导致的失衡示例：删除子树中的 16 可能会导致父节点或祖先节点失衡（只有1个节点会失衡），其他节点，都不可能失衡 LL – 右旋转（单旋）如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡… 极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整 RR – 左旋转（单旋） LR – RR左旋转，LL右旋转（双旋） RL – LL右旋转，RR左旋转（双旋） 删除之后的修复1234567891011protected void afterRemove(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); &#125; &#125;&#125; 总结 添加 可能会导致所有祖先节点都失衡 只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需 O(1) 次调整】 删除 可能会导致父节点或祖先节点失衡（只有1个节点会失衡） 恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要 O(logn) 次调整】 平均时间复杂度 搜索：O(logn) 添加：O(logn)，仅需 O(1) 次的旋转操作 删除：O(logn)，最多需要 O(logn) 次的旋转操作]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>AVL树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2020%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉搜索树思考 在 n 个动态的整数中搜索某个整数？（查看其是否存在） 假设使用动态数组存放元素，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n) 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 如果维护一个有序的动态数组，使用二分搜索，最坏时间复杂度：O(logn) 但是添加、删除的平均时间复杂度是 O(n) 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 针对这个需求，有没有更好的方案？ 使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)​ 什么是二叉搜索树（Binary Search Tree） 二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST，又被称为：二叉查找树、二叉排序树 任意一个节点的值都大于其左子树所有节点的值 任意一个节点的值都小于其右子树所有节点的值 它的左右子树也是一棵二叉搜索树 二叉搜索树可以大大提高搜索数据的效率 二叉搜索树存储的元素必须具备可比较性 比如 int、double 等 如果是自定义类型，需要指定比较方式 不允许为 null 二叉搜索树的接口设计123456int size() // 元素的数量boolean isEmpty() // 是否为空void clear() // 清空所有元素void add(E element) // 添加元素void remove(E element) // 删除元素boolean contains(E element) // 是否包含某元素 需要注意的是 对于我们现在使用的二叉树来说，它的元素没有索引的概念 元素的比较方案设计 允许外界传入一个 Comparator 自定义比较方案 如果没有传入 Comparator，强制认定元素实现了 Comparable 接口 12345678910111213141516private Comparator&lt;E&gt; comparator;public BST() &#123; this(null);&#125;public BST(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator;&#125;private int compare(E e1, E e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;E&gt;)e1).compareTo(e2);&#125; 根据元素内容获取节点12345678910111213private Node&lt;E&gt; node(E element) &#123; Node&lt;E&gt; node = root; while (node != null) &#123; int cmp = compare(element, node.element); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null;&#125; 添加节点12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(E element) &#123; elementNotNullCheck(element); // 添加第一个节点 if (root == null) &#123; root = createNode(element, null); size++; // 新添加节点之后的处理 afterAdd(root); return; &#125; // 添加的不是第一个节点 // 找到父节点 Node&lt;E&gt; parent = root; Node&lt;E&gt; node = root; int cmp = 0; do &#123; cmp = compare(element, node.element); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // 相等 node.element = element; return; &#125; &#125; while (node != null); // 看看插入到父节点的哪个位置 Node&lt;E&gt; newNode = createNode(element, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // 新添加节点之后的处理 afterAdd(newNode);&#125; 删除节点删除节点 – 叶子节点（分析） 123456789// 直接删除1. node == node.parent.left node.parent.left = null2. node == node.parent.right node.parent.right = null3. node.parent == null root = null 删除节点 - 度为1的节点（分析） 123456789101112131415// 用子节点替代原节点的位置child 是 node.left 或 者 child 是 node.right用 child 替代 node 的位置1. 如果 node 是左子节点 child.parent = node.parent node.parent.left = child2. 如果 node 是右子节点 child.parent = node.parent node.parent.right = child3. 如果 node 是根节点 root = child child.parent = null 删除节点 - 度为2的节点（分析） 举例：先删除 5、再删除 4 先用前驱或者后继节点的值覆盖原节点的值 然后删除相应的前驱或者后继节点 如果一个节点的度为 2，那么，它的前驱、后继节点的度只可能是 1 和 0 二叉树的前驱、后继实现 删除节点（代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 判断节点是否有两个叶子节点public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null;&#125;private void remove(Node&lt;E&gt; node) &#123; if (node == null) return; size--; // 找到度为二节点的后继节点覆盖后，将后继节点s作为度为1的节点执行后面的操作 if (node.hasTwoChildren()) &#123; // 度为2的节点 // 找到后继节点 Node&lt;E&gt; s = successor(node); // 用后继节点的值覆盖度为2的节点的值 node.element = s.element; // 删除后继节点,使用后面的代码删除度为1的节点 node = s; &#125; // 删除node节点（node的度必然是1或者0） // 判断node节点有左节点还是右节点，也可能没有节点 Node&lt;E&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // node是度为1的节点 // 更改parent replacement.parent = node.parent; // 更改parent的left、right的指向 if (node.parent == null) &#123; // node是度为1的节点并且是根节点 root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // 删除节点之后的处理 afterRemove(replacement); &#125; else if (node.parent == null) &#123; // node是叶子节点并且是根节点 root = null; // 删除节点之后的处理 afterRemove(node); &#125; else &#123; // node是叶子节点，但不是根节点 if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // 删除节点之后的处理 afterRemove(node); &#125;&#125; 二叉搜索树的复杂度分析当 n 比较大时，两者的性能差异比较大 比如 n = 1000000 时，二叉搜索树的最低高度是 20 退化成链表的另一种情况 有没有办法防止二叉搜索树退化成链表？ 让添加、删除、搜索的复杂度维持在 O(logn) 平衡（Balance）平衡：当节点数量固定时，左右子树的高度越接近，这棵二叉树就越平衡（高度越低） 理想平衡最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的 如何改进二叉搜索树？首先，节点的添加、删除顺序是无法限制的，可以认为是随机的 所以，改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度） 如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大 比如调整的次数会比较多，反而增加了时间复杂度 总结来说，比较合理的改进方案是：用尽量少的调整次数达到适度平衡即可 一棵达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树 平衡二叉搜索树（Balanced Binary Search Tree）英文简称为：BBST 经典常见的平衡二叉搜索树有 AVL树 Windows NT 内核中广泛使用 红黑树 C++ STL（比如 map、set ） Java 的 TreeMap、TreeSet、HashMap、HashSet Linux 的进程调度 Ngix 的 timer 管理 一般也称它们为：自平衡的二叉搜索树（Self-balancing Binary Search Tree） AVL树的实现 红黑树的实现]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>二叉搜索树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2020%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树树（Tree）的基本概念 节点、根节点、父节点、子节点、兄弟节点 一棵树可以没有任何节点，称为空树 一棵树可以只有 1 个节点，也就是只有根节点 子树、左子树、右子树 节点的度（degree）：子树的个数 树的度：所有节点度中的最大值 叶子节点（leaf）：度为 0 的节点 非叶子节点：度不为 0 的节点 层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算） 节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数 节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数 树的深度：所有节点深度中的最大值 树的高度：所有节点高度中的最大值 树的深度 等于 树的高度 有序树、无序树、森林 有序树 树中任意节点的子节点之间有顺序关系 无序树，也称为“自由树” 树中任意节点的子节点之间没有顺序关系 森林 由 m（m ≥ 0）棵互不相交的树组成的集合 二叉树（Binary Tree）二叉树的特点 每个节点的度最大为 2（最多拥有 2 棵子树） 左子树和右子树是有顺序的 即使某节点只有一棵子树，也要区分左右子树 二叉树的性质 非空二叉树的第 $i$ 层，最多有 $2^{i − 1}$个节点 （ $i \geq 1$） 在高度为 h 的二叉树上最多有 $2^h − 1 $个结点（$h \geq 1$ ） 对于任何一棵非空二叉树，如果叶子节点个数为 $n0$，度为 $2$ 的节点个数为 $ n2$，则有: $n0 = n2 + 1$ 假设度为$ 1 $的节点个数为 $n1$，那么二叉树的节点总数 $ n = n0 + n1 + n2$ 二叉树的边数 $ T = n1 + 2 * n2 = n – 1 = n0 + n1 + n2 – 1$ 因此 $ n0 = n2 + 1$ 真二叉树（Proper Binary Tree）真二叉树：所有节点的度都要么为 0，要么为 2 满二叉树（Full Binary Tree）最后一层节点的度都为 $0$，其他节点的度都为 $2$ 在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多 满二叉树一定是真二叉树，真二叉树不一定是满二叉树 假设满二叉树的高度为 $h（ h ≥ 1 ）$，那么 第 i 层的节点数量：$ 2i − 1$ ， 叶子节点数量： $2h − 1$ ， 总节点数量$ n$ $n = 2h − 1 = 20 + 21 + 22 + ⋯ + 2h−1$ $h = log2(n + 1)$ 完全二叉树（Complete Binary Tree）对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应 叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐 完全二叉树从根结点至倒数第 2 层是一棵满二叉树 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树的性质 度为 1 的节点只有左子树 度为 1 的节点要么是 1 个，要么是 0 个 同样节点数量的二叉树，完全二叉树的高度最小 假设完全二叉树的高度为 $h（ h ≥ 1 ）$，那么 ​ 至少有 $2h − 1$ 个节点 $（ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−2} + 1 ）$ ​ 最多有 $2h − 1$ 个节点（$ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−1}$，满二叉树 ） ​ 总节点数量为 $n$ ​ $2^{h − 1} ≤ n &lt; 2^h $ ​ $h − 1 ≤ log_2n &lt; h$ ​ $h = floor( log_2n ) + 1$ ​ $floor $是向下取整，另外，$ceiling $是向上取整 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $ 1$ 开始进行编号，对任意第 $ i $ 个节点 ​ 如果 $i = 1$，它是根节点 ​ 如果 $i &gt; 1$ ，它的父节点编号为 $floor( i / 2 )$ ​ 如果 $2i ≤ n$ ，它的左子节点编号为 $2i$ ​ 如果 $2i &gt; n$ ，它无左子节点 ​ 如果 $2i + 1 ≤ n$ ，它的右子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n$ ，它无右子节点 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $0$ 开始进行编号，对任意第 $i$ 个节点 ​ 如果 $i = 0$ ，它是根节点 ​ 如果 $i &gt; 0$ ，它的父节点编号为 $floor( (i – 1) / 2 )$ ​ 如果 $2i + 1 ≤ n – 1$ ，它的左子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n – 1$ ，它无左子节点 ​ 如果 $2i + 2 ≤ n – 1$ ，它的右子节点编号为 $2i + 2$ ​ 如果 $2i + 2 &gt; n – 1$ ，它无右子节点 面试题如果一棵完全二叉树有 $768$ 个节点，求叶子节点的个数 假设叶子节点个数为 $n0$，度为 $1$ 的节点个数为 $n1$，度为 $2$ 的节点个数为 $n2$ 总结点个数 $n = n0 + n1 + n2$，而且 $n0 = n2 + 1$ $n = 2n0 + n1 – 1$ 完全二叉树的 $n1$ 要么为 $0$，要么为 $1$ $n1$为 $1$ 时，$n = 2n0$，$n$ 必然是偶数 叶子节点个数 $n0 = n / 2$，非叶子节点个数 $n1 + n2 = n / 2$ $n1$为 $0$ 时，$n = 2n0 – 1$，$n$ 必然是奇数 叶子节点个数 $n0 = (n + 1) / 2$，非叶子节点个数 $n1 + n2 = (n – 1) / 2$ 叶子节点个数 $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$ 非叶子节点个数 $n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )$ 因此叶子节点个数为 $384$ 二叉树的遍历二叉树的常见遍历方式有4种 前序遍历（Preorder Traversal） 中序遍历（Inorder Traversal） 后序遍历（Postorder Traversal） 层序遍历（Level Order Traversal） 前序遍历（Preorder Traversal）访问顺序 根节点、前序遍历左子树、前序遍历右子树 7、4、2、1、3、5、9、8、11、10、12 递归实现 123456private void preorder(Node&lt;E&gt; node) &#123; if (node == null) return; System.out.println(node.element); preorder(node.left); preorder(node.right);&#125; 非递归，利用栈实现 123456789101112131415161718192021public void preorder() &#123; if (root == null) return; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 弹出栈顶节点 top，进行访问 Node&lt;E&gt; node = stack.pop(); // 访问node节点 System.out.println(node.element); if (node.right != null) &#123; // 将 top.right 入 栈 stack.push(node.right); &#125; // 将 top.left 入 栈 if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 中序遍历（Inorder Traversal）访问顺序 中序遍历左子树、根节点、中序遍历右子树 1、2、3、4、5、7、8、9、10、11、12 递归实现 123456private void inorder(Node&lt;E&gt; node) &#123; if (node == null) return; inorder(node.left); System.out.println(node.element); inorder(node.right);&#125; 非递归，利用栈实现 12345678910111213141516171819202122public void inorder(Visitor&lt;E&gt; visitor) &#123; if (root == null) return; // 设置 node = root Node&lt;E&gt; node = root; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); while (true) &#123; if (node != null) &#123; stack.push(node); // 向左走 node = node.left; &#125; else if (stack.isEmpty()) &#123; // 如果栈为空，结束遍历 return; &#125; else &#123; // 如果栈不为空，弹出栈顶元素并赋值给 node node = stack.pop(); // 访问node节点 System.out.println(node.element); // 让右节点进行中序遍历 node = node.right; &#125; &#125;&#125; 后序遍历（Postorder Traversal）访问顺序 后序遍历左子树、后序遍历右子树、根节点 1、3、2、5、4、8、10、12、11、9、7 递归实现 123456private void postorder(Node&lt;E&gt; node) &#123; if (node == null) return; postorder(node.left); postorder(node.right); System.out.println(node.element);&#125; 非递归，利用栈实现123456789101112131415161718192021222324252627282930public boolean isLeaf() &#123; return left == null &amp;&amp; right == null;&#125;public void postorder() &#123; if (root == null) return; // 记录上一次弹出访问的节点 Node&lt;E&gt; prev = null; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 查看栈顶元素，不删除 Node&lt;E&gt; top = stack.peek(); // 如果栈顶节点是叶子节点 或者 上一次访问的节点是栈顶节点的子节点 if (top.isLeaf() || (prev != null &amp;&amp; prev.parent == top)) &#123; // 定义prev，下次再遇到，不会再入栈，避免重复访问 prev = stack.pop(); // 访问节点 System.out.println(prev.element); &#125; else &#123; if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125;&#125; 层序遍历（Level Order Traversal）访问顺序 从上到下、从左到右依次访问每一个节点 7、4、9、2、5、8、11、1、3、10、12 非递归，利用队列实现 123456789101112131415161718192021222324public void levelOrder() &#123; if (root == null) return; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.offer(root); // 循环执行以下操作，直到队列为空 while (!queue.isEmpty()) &#123; // 将队头节点 A 出队，进行访问 Node&lt;E&gt; node = queue.poll(); System.out.println(node.element); // 将左子节点入队 if (node.left != null) &#123; queue.offer(node.left); &#125; // 将右子节点入队 if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; 遍历的应用 前序遍历 树状结构展示（注意左右子树的顺序） 中序遍历 二叉搜索树的中序遍历按升序或者降序处理节点 后序遍历 适用于一些先子后父的操作 层序遍历 计算二叉树的高度 判断一棵树是否为完全二叉树 根据遍历结果重构二叉树以下结果可以保证重构出唯一的一棵二叉树 前序遍历 + 中序遍历 后序遍历 + 中序遍历 前序遍历 + 后序遍历 ​ 如果它是一棵真二叉树（Proper Binary Tree），结果是唯一的，不然结果不唯一 前序遍历+中序遍历重构二叉树前序遍历：4 2 1 3 6 5 中序遍历：1 2 3 4 5 6 前驱、后继节点前驱节点（predecessor）前驱节点：中序遍历时的前一个节点 如果是二叉搜索树，前驱节点就是前一个比它小的节点 123456789101112131415161718192021222324252627282930protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） // node.left != null时 // 举例：6-》5、13-》12、8-》7 // predecessor = node.left.right.right.right... Node&lt;E&gt; p = node.left; // 终止条件：right 为 null if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 // node.left == null &amp;&amp; node.parent != null // 举例：7-》6、11-》10、9-》8 // predecessor = node.parent.parent.parent... // 终止条件：node 在 parent 的右子树中 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.left == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有左子树的根节点 1 return node.parent;&#125; 后继节点（successor）后继节点：中序遍历时的后一个节点 如果是二叉搜索树，后继节点就是后一个比它大的节点 1234567891011121314151617181920212223242526272829protected Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） // node.right != null // 举例：1、8、4、10 // successor = node.right.left.left.left... Node&lt;E&gt; p = node.right; if (p != null) &#123; // 终止条件：left 为 null while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // node.right == null &amp;&amp; node.parent != null // 举例：6、3、11 // successor = node.parent.parent.parent... // 终止条件：node 在 parent 的左子树中 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; // node.right == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有右子树的根节点 return node.parent;&#125; 计算二叉树的高度非递归，利用队列实现123456789101112131415161718192021222324252627282930public int height() &#123; if (root == null) return 0; // 树的高度 int height = 0; // 存储着每一层的元素数量 int levelSize = 1; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;E&gt; node = queue.poll(); levelSize--; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; if (levelSize == 0) &#123; // 意味着即将要访问下一层 levelSize = queue.size(); height++; &#125; &#125; return height;&#125; 递归1234567public int height() &#123; return height(root);&#125;private int height(Node&lt;E&gt; node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 练习翻转二叉树leetcode地址 1234567891011121314class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列（Queue）什么是队列队列是一种特殊的线性表，只能在头尾两端进行操作 队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队 队头（front）：只能从队头移除元素，一般叫做 deQueue，出队 先进先出的原则，First In First Out，FIFO 队列的代码实现队列的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Queue&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueue(E element) &#123; //入队 list.add(element); &#125; public E deQueue() &#123; // 出队 return list.remove(0); &#125; public E front() &#123; // 获取队首元素，不删除 return list.get(0); &#125;&#125; 双端队列（Deque）双端队列是能在头尾两端添加、删除的队列，英文 deque 是 double ended queue 的简称 123456789101112131415161718192021222324252627282930313233343536373839public class Deque&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueueRear(E element) &#123; // 从队尾入队 list.add(element); &#125; public E deQueueFront() &#123; // 从队头出队 return list.remove(0); &#125; public void enQueueFront(E element) &#123; // 从队头入队 list.add(0, element); &#125; public E deQueueRear() &#123; // 从队尾出队 return list.remove(list.size() - 1); &#125; public E front() &#123; // 获取队列的头元素 return list.get(0); &#125; public E rear() &#123; // 获取队列的尾元素 return list.get(list.size() - 1); &#125;&#125; 循环队列（Circle Queue）可以进行两端添加、删除操作的循环队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CircleQueue&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleQueue() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; public void enQueue(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; public E deQueue() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; public E front() &#123; return elements[front]; &#125; private int index(int index) &#123; index += front; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125; 循环双端队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class CircleDeque&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleDeque() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; // 从尾部入队 public void enQueueRear(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; // 从头部出队 public E deQueueFront() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; // 从头部入队 public void enQueueFront(E element) &#123; ensureCapacity(size + 1); front = index(-1); elements[front] = element; size++; &#125; // 从尾部出队 public E deQueueRear() &#123; int rearIndex = index(size - 1); E rear = elements[rearIndex]; elements[rearIndex] = null; size--; return rear; &#125; public E front() &#123; return elements[front]; &#125; public E rear() &#123; return elements[index(size - 1)]; &#125; private int index(int index) &#123; index += front; if (index &lt; 0) &#123; return index + elements.length; &#125; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2020%2F07%2F11%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈（stack）什么是栈栈是一种特殊的线性表，只能在一端进行操作 往栈中添加元素的操作，一般叫做 push，入栈 从栈中移除元素的操作，一般叫做 pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素） 后进先出的原则，Last In First Out，LIFO 注意：这里说的“栈”与内存中的“栈空间”是两个不同的概念 栈的代码实现栈的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Stack&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;&gt;(); public void clear() &#123; // 清空 list.clear(); &#125; public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void push(E element) &#123; // 入栈 list.add(element); &#125; public E pop() &#123; // 出栈 return list.remove(list.size() - 1); &#125; public E top() &#123; // 获取栈顶元素，不删除 return list.get(list.size() - 1); &#125;&#125; 练习有效的括号leetcode地址 123456789101112131415161718192021222324class Solution &#123; private static HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); static &#123; map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']'); &#125; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; char c = s.charAt(i); // 判断是否是左边，是就入栈 if (map.containsKey(c))&#123; stack.push(c); &#125;else &#123; // 左边出栈，进行比较 if (stack.isEmpty()) return false; char left = stack.pop(); if (c != map.get(left)) return false; &#125; &#125; return stack.isEmpty(); &#125;&#125; 用栈实现队列leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; /** 入栈 */ public void push(int x) &#123; inStack.push(x); &#125; /** 出栈 */ public int pop() &#123; checkOutStack(); return outStack.pop(); &#125; /** 得到栈顶元素，不删除 */ public int peek() &#123; checkOutStack(); return outStack.peek(); &#125; /** 判断是否为空 */ public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; private void checkOutStack()&#123; if (outStack.isEmpty())&#123; while (!inStack.isEmpty())&#123; outStack.push(inStack.pop()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表（Linked List）为什么有链表动态数组有个明显的缺点，可能会造成内存空间的大量浪费 能否用到多少就申请多少内存？ 链表可以办到这一点 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的 链表的设计 接口设计链表的大部分接口和动态数组是一致的 1234567891011121314151617181920212223242526272829303132333435// 接口定义public interface List&lt;E&gt; &#123; // 元素不存在在返回-1 static final int ELEMENT_NOT_FOUND = -1; // 清除所有元素 void clear(); // 元素的数量 int size(); // 是否为空 boolean isEmpty(); // 是否包含某个元素 boolean contains(E element); // 添加元素到尾部 void add(E element); // 获取index位置的元素 E get(int index); // 设置index位置的元素 E set(int index, E element); // 在index位置插入一个元素 void add(int index, E element); // 删除index位置的元素 E remove(int index); // 查看元素的索引 int indexOf(E element);&#125; 检测传入的下标是否合法123456789101112131415protected void outOfBounds(int index) &#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);&#125;protected void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125;&#125;protected void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125;&#125; node方法用于获取index位置的节点12345678private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node;&#125; 创建节点123456789private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; next; // element新节点的值，next新节点指向的下一个节点 public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 1234567891011121314151617// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; // 在编写链表过程中，要注意边界测试，比如 index 为 0 、size – 0 、size 时 rangeCheckForAdd(index); if (index == 0)&#123; first = new Node&lt;&gt;(element,first); &#125;else&#123; // 找到插入下标的上一个元素 Node&lt;E&gt; prev = node(index - 1); // 新创建的节点指向原先prev.next（如上图：1指向2）,再将prev.next指向新节点（如上图：0指向1） prev.next = new Node&lt;&gt;(element,prev.next); &#125; size++;&#125; 删除元素 12345678910111213141516public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = first; // 注意0位置 if (index == 0)&#123; first = first.next; &#125;else&#123; // 找到待删除元素上一个元素的下标 Node&lt;E&gt; prev = node(index - 1); // node待删除的元素 node = prev.next; prev.next = node.next; &#125; size--; return node.element;&#125; 清空链表12345public void clear() &#123; size = 0; // next不需要设置为null first = null;&#125; 判断链表中某个元素的下标1234567891011121314151617public int indexOf(E element) &#123; // 链表中允许有null值元素 if (element == null)&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) return i; node = node.next; &#125; &#125;else&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) return i; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND;&#125; 判断链表中是否包含某个元素123public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND;&#125; 双向链表使用双向链表可以提升链表的综合性能 node方法用于获取index位置的节点1234567891011121314151617private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); // 分两条路寻找节点 if (index &lt; (size &gt;&gt; 1))&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node; &#125;else &#123; Node&lt;E&gt; node = last; for (int i = size - 1; i &gt; index; i--) &#123; node = node.prev; &#125; return node; &#125;&#125; 创建节点1234567891011private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next) &#123; this.prev = prev; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 12345678910111213141516171819202122// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); if (index == size)&#123; Node&lt;E&gt; oldLast = last; last = new Node&lt;&gt;(oldLast,element,null); oldLast.next = last; &#125;else&#123; Node&lt;E&gt; next = node(index); Node&lt;E&gt; prev = next.prev; Node&lt;E&gt; node = new Node&lt;&gt;(prev,element,next); next.prev = node; if (prev == null)&#123; first = node; &#125;else&#123; prev.next = node; &#125; &#125;&#125; 删除元素 – remove(int index) 1234567891011121314151617181920public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = node(index); Node&lt;E&gt; prev = node.prev; Node&lt;E&gt; next = node.next; if (prev == null)&#123; first = next; &#125;else&#123; prev.next = next; &#125; if (next == null)&#123; last = prev; &#125;else&#123; next.prev = prev; &#125; size--; return node.element;&#125; 双向链表 vs 单向链表粗略对比一下删除的操作数量 单向链表： $1+2+3+…+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$ ${n^2} \over {2}$， 除以$n$ 平均一下是 ${1} \over {2}$ + ${n} \over {2}$ 双向链表：$(1+2+3+…+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ，除以$n$平均一下是 ${1} \over {2}$ + ${n} \over{4}$ 操作数量缩减了近一半 练习删除链表中的节点leetcode地址 123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 反转一个链表leetcode地址 递归实现 12345678910// 递归public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; // 定义新的头节点 ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; 非递归 – 头插法 1234567891011121314// 迭代public ListNode reverseList2(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode newHead = null; while (head != null)&#123; ListNode tmp = head.next; // 每次遍历让head.next成为头节点 head.next = newHead; newHead = head; // head重新指向tmp，使循环按顺序继续遍历 head = tmp; &#125; return newHead;&#125; 判断一个链表是否有环leetcode地址 123456789101112131415// 快慢指针，相遇则有环public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; // 慢指针，每次走一步 ListNode slow = head; // 快指针，每次走两步 ListNode fast = head.next; while (fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数组]]></title>
    <url>%2F2020%2F07%2F09%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组数组是一种顺序存储的线性表，所有元素的内存地址是连续的 1int[] array = new int[]&#123;11,22,33&#125;; 在很多编程语言中，数组都有个致命的缺点，无法动态修改容量 实际开发中，我们更希望数组的容量是可以动态改变的 动态数组（Dynamic Array）接口设计12345678910int size(); // 元素的数量boolean isEmpty(); // 是否为空boolean contains(E element); // 是否包含某个元素void add(E element); // 添加元素到最后E get(int index); // 返回indext位置对应的元素E set(int index,E element); // 设置indext位置对应的元素void add(int index,E element); // 往index位置添加元素E remove(int index); // 删除index位置对应的元素int indexOf(E element); // 查看元素的位置void clear(); //清除所有元素 动态数组的设计 在Java中，成员变量会自动初始化，比如 int 类型自动初始化为 0 对象类型自动初始化为 null 添加元素 - add(E element) 12345678910111213141516171819//没有索引下标，默认放在数组最后public void add(E element)&#123; add(size,element);&#125;// 向数组某个位置插入元素public void add(int index,E element)&#123; // 检测下标是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacity(size + 1); // 从最后一个元素开始，到index下标（逆序），数组元素向后覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++;&#125; 删除元素 - remove(int index) 1234567891011public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; // 从index下标开始，数组元素向前挪动 for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old;&#125; 如何扩容 - ensureCapacity(int capacity) 1234567891011// 数组容量不够时，扩容private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半(再加上原来的容量) E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import org.omg.CORBA.Object;import java.util.Arrays;@SuppressWarnings("unchecked")public class dynamicArray&lt;E&gt;&#123; /** * 元素的数量 */ private int size; /** * 所以的元素 */ private E[] elements; private static final int DEFAULT_CAPATICY = 10; //初始容量 private static final int ELEMENT_NOT_FOUND = -1; //找不到查找的元素 public dynamicArray(int capaticy)&#123; capaticy = Math.max(capaticy, DEFAULT_CAPATICY); elements = (E[]) new Object[capaticy]; //初始化数组容量 &#125; public dynamicArray()&#123; this(DEFAULT_CAPATICY); &#125; /** * 清除所有元素 */ public void clear()&#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; public void add(E element)&#123; add(size,element); &#125; // 向数组某个位置插入元素 public void add(int index,E element)&#123; rangeCheckForAdd(index); ensureCapacity(size + 1); // 数组元素向前覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++; &#125; // 数组容量不够时，扩容 private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半 E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements; &#125; public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old; &#125; public boolean contains(E element)&#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; public E get(int index)&#123; rangeCheck(index); return elements[index]; &#125; public E set(int index,E element)&#123; rangeCheck(index); E old = elements[index]; elements[index] = element; return old; &#125; public int indexOf(E element)&#123; if (element == null)&#123; for (int i = 0; i &lt; size; i++) &#123; if (elements[i] == null) return i; &#125; &#125;else&#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(elements[i])) return i; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private void outOfBounds(int index)&#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size); &#125; // 检测传入的下标是否越界 private void rangeCheck(int index)&#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125; &#125; private void rangeCheckForAdd(int index)&#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125; &#125; @Override public String toString() &#123; return "dynamicArray&#123;" + "size=" + size + ", elements=" + Arrays.toString(elements) + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构什么是数据结构？数据结构是计算机存储、组织数据的方式 线性表 二叉树 邻接矩阵 数组、链表 AVL树、红黑树 邻接表 栈、队列 B树、堆、Trie 哈希表 哈夫曼树、并查集 在实际应用中，根据使用场景来选择最合适的数据结构]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2020%2F07%2F09%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[复杂度如何评判一个算法的好坏？一般从以下维度来评估算法的优劣 正确性、可读性、健壮性（对不合理输入的反应能力和处理能力） 时间复杂度（time complexity）：估算程序指令的执行次数（执行时间） 空间复杂度（space complexity）：估算所需占用的存储空间 大O表示法（Big O）一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度，忽略常数、系数、低阶$9 &gt;&gt; O(1)$ $2n + 3 &gt;&gt; O(n)$ $n^2 + 2n + 6 &gt;&gt; O(n^2)$ $4n^3 + 3n^2 + 22n + 100 &gt;&gt; O(n^3)$ 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率 对数阶的细节对数阶一般省略底数 $log_2n = log_29 ∗ log_9n$ 所以 $log_2n$ 、$log_9n$ 统称为$logn$ 常见的复杂度 执行次数 复杂度 非正式术语 $12$ $O(1)$ 常数阶 $2n + 3$ $O(n)$ 线性阶 $4n^2 + 2n + 6$ $O(n^2)$ 平方阶 $4log_2n + 25$ $O(logn)$ 对数阶 $3n + 2nlog_3n + 15$ $O(nlogn)$ $nlogn$阶 $4n^3 + 3n^2 + 22n + 100$ $O(n^3)$ 立方阶 $2^n$ $O(2n)$ 指数阶 $O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n_n)$ 算法的优化方向用尽量少的存储空间 用尽量少的执行步骤（执行时间） 根据情况，可以 空间换时间 时间换空间]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习路线]]></title>
    <url>%2F2019%2F09%2F17%2FJAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JAVA学习路线1. 语言的入门和进阶 Java基础语法,OO编程思想, 集合, IO, 异常, 泛型, 反射, 多线程, 函数式 2. Web基础和工具 前端基础(html/javascript/css) jquery, ajax, jsp, cookie, session http基础 servlet基础 git,svn代码管理工具 3. 企业级应用框架 maven/gradle项目管理工具 Spring全家桶(Spring, Spring MVC, Spring Boot) 关系型数据库相关(MySQL, jdbc, MyBatis, Hibernate) 非关系型数据库(Redis) 模板引擎(thymeleaf, freemarker) 4. 高级应用框架 搜索引擎(elastic search) RPCk框架(Dubbo, Spring Cloud) 中间件技术(RabbitMQ, RocketMQ, ActiveMQ, Kafka) 虚拟化技术(Docker, Kubernetes) 5. 高级话题 jvm优化和排错, GC分析, 数据库高级优化]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
</search>
