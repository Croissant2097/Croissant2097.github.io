<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP UDP]]></title>
    <url>%2F2020%2F10%2F30%2FTCP-UDP%2F</url>
    <content type="text"><![CDATA[UDP 和 TCP 的特点与区别用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 、TCP 首部格式 UDP 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式比 UDP 复杂。 序号：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 控制位：八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。 CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小； ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1； URG：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关； ACK：该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1； PSH：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存； RST：该位设为 1，表示 TCP 连接出现异常必须强制断开连接； SYN：用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定； FIN：该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。 每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包； 窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 什么是 TCP 的三次握手和四次挥手？TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。 TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接；采用四次挥手来关闭一个连接。 一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。 当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会（提供网络利用率这部分有讲到）。 ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。 一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。 序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而IP 不提供重复消除或者保证次序正确的功能。 另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。 TCP 的三次握手（为什么三次？）三次握手： 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 为什么三次？1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 2、换个易于理解的视角来看为什么要 3 次握手。 客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。 而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。 经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。 每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？ 而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。 其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。 比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。 TCP 的四次挥手（为什么四次？）四次挥手： 客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。 服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 服务端发起自己的 FIN 段，ACK=K+1, Seq=L。 客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？1、TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。 2、这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。 注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。 3、客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 4、因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 短连接和长连接的区别短连接：Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。 短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。 长连接：Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。 长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。 TCP粘包、拆包及解决办法为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？由前两节可知，UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。 而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。 什么是粘包、拆包？假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下： 第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。 第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。 第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。 为什么会发生 TCP 粘包、拆包？ 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 粘包、拆包解决办法由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下： 消息定长：发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。 将消息分为消息头和消息体：消息头中包含表示消息总长度（或者消息体长度）的字段。 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： RRTs = (1-a)*(RTTs) + a * RTT其中，$0 ≤ a ＜ 1$，$RTTs$ 随着 $a$ 的增加更容易受到 $RTT$ 的影响。超时时间 $RTO$ 应该略大于 $RTTs$，TCP 使用的超时时间计算如下： RTO = RTTs + 4 * RTTd其中 $RTTd$ 为偏差的加权平均值。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅包含一个字节来获取最新的窗口大小信息。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制： 慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 提供网络利用率Nagle 算法发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。 已发送的数据都已经收到确认应答。 可以发送最大段长度的数据时。 延迟确认应答接收方收到数据之后可以并不立即返回确认应答，而是延迟一段时间的机制。 在没有收到 2*最大段长度的数据为止不做确认应答。 其他情况下，最大延迟 0.5秒 发送确认应答。 TCP 文件传输中，大多数是每两个数据段返回一次确认应答。 捎带应答在一个 TCP 包中既发送数据又发送确认应答的一种机制，由此，网络利用率会提高，计算机的负荷也会减轻，但是这种应答必须等到应用处理完数据并将作为回执的数据返回为止。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2020%2F10%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络TCP/IP四层模型数据链路层（以太网协议、MAC地址）以太网协议 —— 以太网。一组电信号是一个数据包，叫一个帧（frame），每个帧分成两个部分，标头（head）和数（data），标头包含一些说明性的东西，比如说发送者、接收者和数据类型之类的。 以太网协议规定了，接入网络里的所有设备，都得有个网卡，以太网协议里的那个数据包，在数据链路层传输的数据包，必须从一个电脑的网卡传输到另外一个电脑的网卡，而这个网卡地址就叫做所谓的mac地址。每块网卡出厂的时候，就有一个唯一的mac地址，48位的二进制，但是一般用12个16进制数字表示，前6个16进制是厂商编号，后6个16进制是网卡流水号。 所以在以太网里传输数据包的时候，必须指定接收者的mac地址才能传输数据。 但是以太网的数据包怎么从一个mac地址发送到另一个mac地址？这个不是精准推送的，以太网里面，如果一个电脑发个数据包出去，会广播给局域网内的所有电脑设备的网卡 ，然后每台电脑都从数据包里获取接收者的mac地址，跟自己的mac地址对比一下，如果一样，就说明这是发给自己的数据包。 但是上面这种广播的方式，仅仅针对一个子网（局域网）内的电脑，会广播，否则一个电脑不能广播数据包给全世界所有的其他电脑吧，是仅仅广播给一个子网里面的电脑的。 网络层（IP）网络层里有IP协议，IP协议定义的地址就叫做IP地址。IP地址有IPv4和IPv6两个版本，目前广泛使用的是IPv4，是32个二进制数字组成的，但是一般用4个十进制数字表示，范围从0.0.0.0到255.255.255.255之间。 一套IP地址，IP地址就可以让我们区分哪些电脑是一个子网的。 ARP：用来在一个局域网内让各个设备都知道每个设备的 ip 地址和mac地址的对应关系 子网掩码：用来划分子网。 传输层（TCP、端口号）网络层，是基于ip协议，进行主机和主机间的寻址和通信的，然后传输层，其实是建立某个主机的某个端口，到另外一个主机的某个端口的连接和通信的。 传输层的 tcp 协议，仅仅只是规定了一套基于端口的点对点的通信协议，包括如何建立连接，如何发送和读取消息，但是实际上如果你要基于 tcp 协议来开发，你一般是用socket，java socket网络编程。 应用层（HTTP、HTTPS、DNS、FTP等）通过传输层的 tcp 协议可以传输数据，但是人家收到数据之后，怎么来解释？ 最常见的，应用层的协议就是http协议，进行网络通信。 网络设置，一般包含了ip地址、子网掩码、网关地址、DNS地址。ip地址和子网掩码用来划分子网的，判断哪些 ip 地址在一个子网内。同时你的 ip 地址和 mac 地址关联起来的，唯一定位了你的网卡。网关地址，你就认为是路由器上的那个网卡的 ip 地址吧，路由器的网卡也有 mac 地址，mac 地址对应了一个 ip 地址。 DNS地址是啥呢？Domain Name System，域名解析器。 TCP三次握手 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1； 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1； 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放； 首先，在三次握手建立连接的阶段，是不会传输 TCP 报文段的，传输的是 传输控制块（TCB），传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。 为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？因为 TCP 是要保证数据的不丢失且可靠，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就不能保证数据的不丢失了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失； 而第三次握手的时候，客户端已经知道服务器端准备好了，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。 可不可以只握手两次？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 肯定是不可以的，三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为何不能三次挥手呢？ 首先如果去掉最后一次挥手，那么服务器端就不知道自己要关闭的报文有没有传输成功，可能半路上就失败了，但是此时客户端不知道，导致客户端一直在等待服务器关闭，但是此时服务器端直接就关闭了； 如果中间的两次挥手合并，那是肯定不行的，因为此时服务器端可能还有很多报文未处理完，此时直接关闭肯定会对传输有很大影响。 复位连接（卡在路上的第一次握手，服务器返回第二次握手后，客户端得给服务器返回第三次握手，要求服务器释放资源） 为什么客户端在收到 服务器端发来的 FIN 包后要等 2 个最长报文段传输时间？防止最后自己发去的 ack 没传送到服务器，如果服务器没收到客户端的 ack，肯定会选择重发一次 FIN 包，那么此时如果客户端已经关闭了，客户端就不能再发 ack 确认收到了，至于为何是 2 个报文段传输时间，因为刚好一去一回嘛… 2 个最长报文传输时间没有 FIN 包发来，就说明服务器已经关闭了，客户端也就可以安心关闭了。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 http1.0,http1.1,http2.0具体有哪些区别http 1.0要指定keep-alive来开启持久连接，默认是短连接，就是浏览器每次请求都要重新建立一次tcp连接，完事儿了就释放tcp连接。 http 1.1默认支持长连接，http 1.1还支持host头，也就可以支持虚拟主机；而且对断点续传有支持。 http 2.0，支持多路复用，基于一个tcp连接并行发送多个请求以及接收响应，解决了http 1.1对同一时间同一个域名的请求有限制的问题。二进制分帧，将传输数据拆分为更小的帧（数据包），frame（数据包，帧），提高了性能，实现低延迟高吞吐。 HTTP 和HTTPShttp协议都是明文的，是没有加密的，所以其实现在一般大部分应用都是用https协议的。之前是基于SSL协议对http进行加密，后来又升级到了TSL协议来加密，现在称之为SSL / TSL吧。 HTTP 的不足之处 通信内容使用明文——内容可能被窃听 不验证通信方的身份——可能遭遇伪装 无法验证报文的完整性——报文有可能已遭篡改 HTTPS = HTTP + 加密 + 认证 + 数字签名 解决上述的三个问题 HTTPS的工作原理（1）浏览器把自己支持的加密规则发送给网站 （2）网站从这套加密规则里选出来一套加密算法和hash算法，然后把自己的身份信息用证书的方式发回给浏览器，证书里有网站地址、加密公钥、证书颁发机构（hash算法用来保证验证消息是否没有被篡改，专业术语叫做 数字签名） （3）浏览器验证证书的合法性，然后浏览器地址栏上会出现一把小锁；浏览器接着生成一串随机数密码，然后用证书里的公钥进行加密，这块走的非对称加密；用约定好的hash算法生成握手消息的hash值，然后用密码对消息进行加密，然后把所有东西都发给网站，这块走的是对称加密。这里的总的消息分成三部分，用公钥加密的随机密码，消息的hash值，和用随机密码加密的消息 （4）网站，从消息里面可以取出来公钥加密后的随机密码，用本地的私钥对消息解密取出来密码，然后用密码解密浏览器发来的握手消息，计算消息的hash值，并验证与浏览器发送过来的hash值是否一致，最后用密码加密一段握手消息，发给浏览器 （5）浏览器解密握手消息，然后计算消息的hash值，如果跟网站发来的hash一样，握手就结束，之后所有的数据都会由之前浏览器生成的随机密码，然后用对称加密来进行进行加密。 常用的非对称加密是RSA算法，对称加密是AES、RC4等，hash算法就是MD5 非对称加密，有个人说我加密的时候是用了一个公钥去加密，然后你解密的时候是用私钥去解密；我加密的时候用的算法，跟解密的时候用的算法，是一样的，对称加密。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC常用同步工具类]]></title>
    <url>%2F2020%2F10%2F03%2FJUC%E5%B8%B8%E7%94%A8%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[JUC常用同步工具类——CountDownLatch，CyclicBarrier，Semaphore CountDownLatch 是一个线程等待其他线程， CyclicBarrier 是多个线程互相等待。 CountDownLatch 的计数是减 1 直到 0，CyclicBarrier 是加 1，直到指定值。 CountDownLatch 是一次性的， CyclicBarrier 可以循环利用。 CyclicBarrier 可以在最后一个线程达到屏障之前，选择先执行一个操作。 Semaphore ，需要拿到许可才能执行，并可以选择公平和非公平模式。]]></content>
      <categories>
        <category>Java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Security + JWT + Redis]]></title>
    <url>%2F2020%2F08%2F09%2FSpringBoot-Security-JWT%2F</url>
    <content type="text"><![CDATA[https://github.com/freeMak/boot-security 本篇是对开源项目集合 SpringSecurity、JWT、Redis 进行权限控制的学习记录（仅包含登录时的授权与进入首页认证） 对登录授权实现的分析SecurityConfig① SecurityConfig继承 WebSecurityConfigurerAdapter，重写configure(HttpSecurity http)方法 123456@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; &#125;&#125; ② 定义加密Bean BCryptPasswordEncoder 1234@Beanpublic BCryptPasswordEncoder bCryptPasswordEncoder() &#123; return new BCryptPasswordEncoder();&#125; ③ 关闭 csrf 保护 1http.csrf().disable(); ④ 关闭session 1http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); ⑤ 放行的普通文件和接口 12345http.authorizeRequests() .antMatchers("/", "/*.html", "/favicon.ico", "/css/**", "/js/**", "/fonts/**", "/layui/**", "/img/**", "/v2/api-docs/**", "/swagger-resources/**", "/webjars/**", "/pages/**", "/druid/**", "/statics/**") .permitAll().anyRequest().authenticated(); ⑥ 登录 登录接口，SpringSecurity 为我们提供登录处理，不用自己写Controller successHandler 认证成功后的处理逻辑，注入authenticationSuccessHandler failureHandler 认证失败后的处理逻辑，注入authenticationFailureHandler authenticationEntryPoint 认证异常后的处理逻辑，注入authenticationEntryPoint authenticationSuccessHandler、authenticationFailureHandler、authenticationEntryPoint 处理器，自己编写 后面仅对authenticationSuccessHandler展开分析。 处理逻辑在com.boot.security.server.config.SecurityHandlerConfig中 123http.formLogin().loginProcessingUrl("/login") .successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler).and() .exceptionHandling().authenticationEntryPoint(authenticationEntryPoint); ⑦ 退出 与登录类似 logoutSuccessHandler 处理器，也是后面展开讲 1http.logout().logoutUrl("/logout").logoutSuccessHandler(logoutSuccessHandler); ⑧ 解决不允许显示在iframe的问题和开启缓存 123// 解决不允许显示在iframe的问题http.headers().frameOptions().disable();http.headers().cacheControl(); ⑨ 过滤器 12// 过滤器 com.boot.security.server.filter.TokenFilterhttp.addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class); SecurityHandlerConfig认证成功AuthenticationSuccessHandler 后的分析1234567891011121314151617181920212223@Beanpublic AuthenticationSuccessHandler loginSuccessHandler() &#123; return new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; // ① 得到用户认证信息 // LoginUser ----&gt; com.boot.security.server.dto.LoginUser // com.boot.security.server.utils.UserUtil // 主要实现在 com.boot.security.server.service.impl.UserDetailsServiceImpl LoginUser loginUser = (LoginUser) authentication.getPrincipal(); // ② 生成 jwt Token // com.boot.security.server.service.impl.TokenServiceJWTImpl Token token = tokenService.saveToken(loginUser); // ③ 给前端返回 Jwt Token ResponseUtil.responseJson(response, HttpStatus.OK.value(), token); &#125; &#125;;&#125; ① 得到用户认证信息LoginUser类（包括用户的基本信息 SysUser 类 和权限信息 Permission 类） 12345678910111213141516171819public class LoginUser extends SysUser implements UserDetails &#123; // 用户的权限 private List&lt;Permission&gt; permissions; private String token; /** 登陆时间戳（毫秒） */ private Long loginTime; /** 过期时间戳 */ private Long expireTime; @Override @JsonIgnore public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; // 返回权限不为空的集合 Set（去重） return permissions.parallelStream().filter(p -&gt; !StringUtils.isEmpty(p.getPermission())) .map(p -&gt; new SimpleGrantedAuthority(p.getPermission())).collect(Collectors.toSet()); &#125; get set 方法（省略）&#125; SysUser类（用户的基本信息） 123456789101112131415161718192021public class SysUser extends BaseEntity&lt;Long&gt; &#123; private String username; private String password; private String nickname; private String headImgUrl; private String phone; private String telephone; private String email; @JsonFormat(pattern = "yyyy-MM-dd") private Date birthday; private Integer sex; private Integer status; private String intro; public interface Status &#123; int DISABLED = 0; int VALID = 1; int LOCKED = 2; &#125; get set 方法（省略）&#125; Permission类（用户的权限） 123456789101112public class Permission extends BaseEntity&lt;Long&gt; &#123; private Long parentId; private String name; private String css; private String href; private Integer type; private String permission; private Integer sort; private List&lt;Permission&gt; child; get set 方法（省略）&#125; UserDetailsServiceImpl 实现 Spring Security 提供的 UserDetailsService 接口，实现 loadUserByUsername 方法 此方法可以获取登录时用户输入的用户名（手机号或邮箱或用户名） 12345678910111213141516171819202122232425262728293031323334@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserService userService; @Autowired private PermissionDao permissionDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // com.boot.security.server.service.impl.UserServiceImpl // 根据姓名得到该用户 SysUser sysUser = userService.getUser(username); if (sysUser == null) &#123; throw new AuthenticationCredentialsNotFoundException("用户名不存在"); &#125; else if (sysUser.getStatus() == Status.LOCKED) &#123; throw new LockedException("用户被锁定,请联系管理员"); &#125; else if (sysUser.getStatus() == Status.DISABLED) &#123; throw new DisabledException("用户已作废"); &#125; LoginUser loginUser = new LoginUser(); // sysUser 拷贝到 loginUser BeanUtils.copyProperties(sysUser, loginUser); // 根据用户 id 读取权限信息 List&lt;Permission&gt; permissions = permissionDao.listByUserId(sysUser.getId()); loginUser.setPermissions(permissions); return loginUser; &#125;&#125; 根据姓名从数据库中查询改用户的信息（DAO的简单实现就不展开了） 12345678910public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public SysUser getUser(String username) &#123; return userDao.getUser(username); &#125;&#125; 最后得到的用户信息举例如下： 123456789101112loginUser = LoginUser &#123; permissions = [ Permission &#123; parentId = 0, name = '用户管理', css = 'fa-users', href = '', type = 1, permission = '', sort = 1, child = null &#125;, Permission &#123; parentId = 12, name = '删除', css = '', href = '', type = 2, permission = 'sys:role:del', sort = 100, child = null &#125; ], token = 'null', loginTime = null, expireTime = null&#125; ② 生成 jwt Token编写 TokenServiceJWTImpl实现类 1234567891011121314151617181920212223242526@Primary@Servicepublic class TokenServiceJWTImpl implements TokenService &#123; /** * token过期秒数 */ @Value("$&#123;token.expire.seconds&#125;") private Integer expireSeconds; // 注入redisTemplate @Autowired private RedisTemplate&lt;String, LoginUser&gt; redisTemplate; /** * 私钥 */ @Value("$&#123;token.jwtSecret&#125;") private String jwtSecret; private static Key KEY = null; private static final String LOGIN_USER_KEY = "LOGIN_USER_KEY"; saveToken.. cacheLoginUser.. createJWTToken..(省略)&#125; 返回 JWT Token 12345678910111213@Overridepublic Token saveToken(LoginUser loginUser) &#123; // 随机生成一个 Token 用于存放在redis （k值 就是Token） loginUser.setToken(UUID.randomUUID().toString()); // 将 用户信息loginUser 和 Token 存入redis缓存中 （不是JWT Token） cacheLoginUser(loginUser); // 生成jwt String jwtToken = createJWTToken(loginUser); return new Token(jwtToken, loginUser.getLoginTime());&#125; 将用户的基本信息、权限信息、Token（此Token不是JWT Token），存入 Redis中 123456private void cacheLoginUser(LoginUser loginUser) &#123; loginUser.setLoginTime(System.currentTimeMillis()); loginUser.setExpireTime(loginUser.getLoginTime() + expireSeconds * 1000); // 根据uuid将loginUser缓存 redisTemplate.boundValueOps(getTokenKey(loginUser.getToken())).set(loginUser, expireSeconds, TimeUnit.SECONDS);&#125; Redis中的数据举例如下： K值：tokens:7a5104ff-5391-440b-82aa-5e0c853e83c4（通过该K值查找Value） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123; "@class": "com.boot.security.server.dto.LoginUser", "id": 1, "createTime": [ "java.util.Date", 1491808898000 ], "updateTime": [ "java.util.Date", 1499304019000 ], "username": "admin", "password": "$2a$10$iYM/H7TrSaLs7XyIWQdGwe1xf4cdmt3nwMja6RT0wxG5YY1RjN0EK", "nickname": "管理员", "headImgUrl": null, "phone": "", "telephone": "", "email": "", "birthday": [ "java.util.Date", "1998-06-30" ], "sex": 0, "status": 1, "intro": null, "permissions": [ "java.util.ArrayList", [ &#123; "@class": "com.boot.security.server.model.Permission", "id": 1, "createTime": [ "java.util.Date", 1596958614806 ], "updateTime": [ "java.util.Date", 1596958614806 ], "parentId": 0, "name": "用户管理", "css": "fa-users", "href": "", "type": 1, "permission": "", "sort": 1, "child": null &#125;, &#123; "@class": "com.boot.security.server.model.Permission", "id": 2, "createTime": [ "java.util.Date", 1596958614807 ], "updateTime": [ "java.util.Date", 1596958614807 ], "parentId": 1, "name": "用户查询", "css": "fa-user", "href": "pages/user/userList.html", "type": 1, "permission": "", "sort": 2, "child": null &#125; ] ], "token": "7a5104ff-5391-440b-82aa-5e0c853e83c4", "loginTime": 1596958614912, "expireTime": 1596965814912&#125; 生成JWT Token (JWT Token 中载荷部分值存放 UUID.randomUUID() 生成的Token，用户从Redis中读取信息) 123456789private String createJWTToken(LoginUser loginUser) &#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(LOGIN_USER_KEY, loginUser.getToken());// 放入一个随机字符串，通过该串可找到登陆用户 String jwtToken = Jwts.builder().setClaims(claims).signWith(SignatureAlgorithm.HS256, getKeyInstance()) .compact(); return jwtToken;&#125; ③ 给前端返回 Jwt Token前端将JWT Token存放在 localStorage 或者 头信息中 123456789101112131415161718192021222324252627function login(obj) &#123; $(obj).attr("disabled", true); var username = $.trim($('#username').val()); var password = $.trim($('#password').val()); if (username == "" || password == "") &#123; $("#info").html('用户名或者密码不能为空'); $(obj).attr("disabled", false); &#125; else &#123; $.ajax(&#123; type : 'post', url : '/login', data : $("#login-form").serialize(), success : function(data) &#123; // 将后台返回的 jwt立牌 存放在 cookie中 localStorage.setItem("token", data.token); location.href = '/index.html'; &#125;, error : function(xhr, textStatus, errorThrown) &#123; var msg = xhr.responseText; var response = JSON.parse(msg); $("#info").html(response.message); $(obj).attr("disabled", false); &#125; &#125;); &#125;&#125; 登录授权后的权限认证分析SecurityConfigSecurityConfig继承 WebSecurityConfigurerAdapter，重写configure(AuthenticationManagerBuilder auth)方法 123456789@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // com.boot.security.server.service.impl.UserDetailsServiceImpl auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder()); &#125;&#125; OncePerRequestFilter定义一个前置请求的过滤器，去获取Token，检测Toekn 1234567891011@Componentpublic class TokenFilter extends OncePerRequestFilter &#123; public static final String TOKEN_KEY = "token"; @Autowired private TokenService tokenService; @Autowired private UserDetailsService userDetailsService; private static final Long MINUTES_10 = 10 * 60 * 1000L;&#125; 根据参数或者header获取token 1234567public static String getToken(HttpServletRequest request) &#123; String token = request.getParameter(TOKEN_KEY); if (StringUtils.isBlank(token)) &#123; token = request.getHeader(TOKEN_KEY); &#125; return token;&#125; 校验时间：过期时间与当前时间对比，临近过期10分钟内的话，自动刷新缓存 1234567891011private LoginUser checkLoginTime(LoginUser loginUser) &#123; long expireTime = loginUser.getExpireTime(); long currentTime = System.currentTimeMillis(); if (expireTime - currentTime &lt;= MINUTES_10) &#123; String token = loginUser.getToken(); loginUser = (LoginUser) userDetailsService.loadUserByUsername(loginUser.getUsername()); loginUser.setToken(token); tokenService.refresh(loginUser); &#125; return loginUser;&#125; 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserService userService; @Autowired private PermissionDao permissionDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // com.boot.security.server.model.SysUser // com.boot.security.server.service.impl.UserServiceImpl // 系统管理用户的基本信息 // 根据姓名得到该用户 SysUser sysUser = userService.getUser(username); if (sysUser == null) &#123; throw new AuthenticationCredentialsNotFoundException("用户名不存在"); &#125; else if (sysUser.getStatus() == Status.LOCKED) &#123; throw new LockedException("用户被锁定,请联系管理员"); &#125; else if (sysUser.getStatus() == Status.DISABLED) &#123; throw new DisabledException("用户已作废"); &#125; LoginUser loginUser = new LoginUser(); // sysUser 拷贝到 loginUser BeanUtils.copyProperties(sysUser, loginUser); // 根据 id 读取权限信息 List&lt;Permission&gt; permissions = permissionDao.listByUserId(sysUser.getId()); loginUser.setPermissions(permissions); return loginUser; &#125;&#125; 实现接口定义的doFilterInternal()方法 123456789101112131415161718192021@Overrideprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; // 根据参数或者header获取token String token = getToken(request); if (StringUtils.isNotBlank(token)) &#123; // 根据token从redis读取用户信息 LoginUser loginUser = tokenService.getLoginUser(token); if (loginUser != null) &#123; // 校验过期时间与当前时间，临近过期10分钟内的话，自动刷新缓存 loginUser = checkLoginTime(loginUser); UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(loginUser,null, loginUser.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authentication); &#125; &#125; filterChain.doFilter(request, response);&#125; 1234567891011121314151617181920212223242526@Overridepublic LoginUser getLoginUser(String jwtToken) &#123; String uuid = getUUIDFromJWT(jwtToken); if (uuid != null) &#123; return redisTemplate.boundValueOps(getTokenKey(uuid)).get(); &#125; return null;&#125;private String getUUIDFromJWT(String jwtToken) &#123; if ("null".equals(jwtToken) || StringUtils.isBlank(jwtToken)) &#123; return null; &#125; try &#123; Map&lt;String, Object&gt; jwtClaims = Jwts.parser().setSigningKey(getKeyInstance()).parseClaimsJws(jwtToken).getBody(); return MapUtils.getString(jwtClaims, LOGIN_USER_KEY); &#125; catch (ExpiredJwtException e) &#123; log.error("&#123;&#125;已过期", jwtToken); &#125; catch (Exception e) &#123; log.error("&#123;&#125;", e); &#125; return null;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
        <tag>Redis</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-注解]]></title>
    <url>%2F2020%2F08%2F06%2FSpring-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解基础概念什么是注解编程？ 在 类 或者 方法 上加入特定的注解（@xxx），完成特定功能的开发。 12@Componentpublic class XXX&#123;&#125; 为什么要学习注解编程？ 注解开发方便，代码简单， 开发速度大大提高。 注解开发是 Spring 开发潮流 Spring 2.x 引入注解，Spring 3.x 完善注解，SpringBoot 普及、推广 注解编程。 注解的作用 替换 XML 这种配置形式，简化配置。 替换接口，实现调用双方的契约性。 通过注解的方式，在功能调用者和功能提供者之间达成契约，进而进行功能的调用。因为注解的应用的更为方便灵活，所以在现在的开发中，更推荐通过注解的方式完成。 Spring 注解的发展历程 Spring 2.x： 开始支持注解编程 @Component、@Service、@Scope…目的：提供的这些注解只是为了某些 XML 的配置，作为 XML 开发的有益补充。 Spring 3.x： @Configuration、@Bean…目的：彻底替换 XML，基于纯注解 Spring 4.x： SpringBoot 提倡使用注解进行开发 Spring 注解开发的一个问题Spring 基于注解进行配置后，还能否解耦合呢？ 在 Spring 框架应用注解时，如果对注解配置的内容不满意，可以通过 Spring 配置文件覆盖。 Spring 基础注解(Spring 2.x)这个阶段的注解，仅仅是简化 XML 的配置，并不能完全替代 XML。 搭建开发环境作用：让Spring框架在设置包及其子包中扫描对应的注解，使其生效。 1&lt;context:component-scan base-package="com.Cro"/&gt; 对象创建相关注解@Component作用：替换原有 Spring 配置文件中的 &lt;bean&gt; 标签 id 属性：在 @Component 中提供了默认的设置方式，首字母小写（UserDAO —&gt; userDAO） class 属性：通过反射获得的 class 的内容 @Component 细节： 如何显式指定工厂创建对象的 id 值 1@Component("u") Spring 配置文件覆盖注解配置内容 123456applicationContext.xml&lt;bean id="user" class="com.Cro.bean.User"&gt; &lt;property name="id" value="10"/&gt;&lt;/bean&gt;id值、class值 要和 注解 中的设置保持一致, 否则 Spring 会创建新的对象。 @Repository、@Service、@Contoller@Repository、@Service、@Controller 都是 @Component 的 衍生注解。 本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component； 它们的存在是为了：更加准确的表达一个类型的作用。 12345678@Repository ----&gt; XXXDAOpublic class UserDAO &#123;&#125;@Servicepublic class UserService &#123;&#125;@Controllerpublic class UserController &#123;&#125; 注意：Spring 整合 Mybatis 开发过程中，不使用 @Repository、@Component @Scope作用：控制简单对象创建次数注意：不添加 @Scope，Spring 提供默认值 singleton XML 配置： 1&lt;bean id="customer" class="com.Cro.Customer" scope="singleton | prototype"/&gt; 注解： 123456789创建单例对象@Component@Scope("singleton")public class Customer &#123;&#125;创建多例对象@Component@Scope("prototype")public class Customer &#123;&#125; @Lazy作用：延迟创建单实例对象 注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，再创建这个对象。 XML 配置： 1&lt;bean id="account" class="com.Cro.Account" lazy="true"/&gt; 注解： 1234567@Component@Lazypublic class Account &#123; public Account() &#123; System.out.println("Account.Account"); &#125;&#125; 生命周期注解 @PostConstruct、@PreDestroy初始化相关方法： @PostConstruct 12InitializingBean&lt;bean init-method=""/&gt; 销毁方法：@PreDestory 12DisposableBean&lt;bean destory-method=""/&gt; 注意： 上述的两个注解并不是 Spring 提供的，由 JSR(JavaEE规范)520 提供 再次验证，通过注解实现了接口的契约性 注入相关注解用户自定义类型 @Autowired @Autowired 细节① @Autowired 注解 基于类型进行注入 [推荐]注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类） 12@Autowiredprivate UserDAO userDAO; ② @Autowired、@Qualifier 注解联合实现 基于名字进行注入 [了解]注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同 123@Autowired@Qualifier("userDAOImpl")private UserDAO userDAO; ③ @Autowired 注解放置位置 放置在对应成员变量的 setter 方法上，调用 setter 方法赋值 直接放置在成员变量上，Spring 通过反射直接对成员变量进行赋值 [推荐] ④ JavaEE 规范中类似功能的注解 JSR250 提供的 @Resource(name=&quot;userDAOImpl&quot;) 基于名字进行注入，等价于 @Autowired 与 @Qualifier 联合实现的效果。注意：@Resource 注解如果名字没有配对成功，会继续 按照类型进行注入。 JSR330 提供的 @Injection 作用与 @Autowired 完全一致，基于类型进行注入 —-&gt; 一般用在 EJB3.0 中 JDK类型@Value 注解开发步骤： 设置配置文件 xxx.properties id = 10; name = xiaoxiao Spring的工厂读取这个配置文件 &lt;context:property-placeholder location=&quot;&quot; /&gt; 代码 属性@Value(&quot;${key}&quot;) @PropertySource 作用：用于替换Spring配置文件中的&lt;context:property-placeholder location=&quot;&quot; /&gt;标签 开发步骤 设置配置文件 xxx.properties id = 10; name = xiaoxiao 应用 @PropertySource(&quot;classpath:/xxx.properties&quot;) 代码 属性@Value(&quot;${key}&quot;) @Value注解的使用细节 @Value 注解不能应用在静态成员变量上 如果应用，赋值(注入)失败 @Value + @Properties 这种方式，不能注入集合类型 Spring提供新的配置形式 YAML、YML 注解扫描详解12&lt;context:component-scan base-package="com.Cro" /&gt;当前包 及其 子包 ① 排除方式 123456789101112&lt;context:component-scan base-package="com.Cro" &gt; &lt;context:exclude-filter type="" expression="" /&gt; type:assignable: 排除特定的类型 不进行扫描 annotation: 排除特定的注解 不进行扫描 aspectj: 切入点表达式 包切入点: com.Cro.bean..* 类切入点: *..User regex: 正则表达式 custom: 自定义排除策略，框架底层开发&lt;/context:component-scan&gt;排除策略可以叠加使用 ② 包含方式 12345678910111213141516&lt;context:component-scan base-package="com.Cro" use-default-filters="false"&gt; &lt;context:exclude-filter type="" expression="" /&gt;&lt;/context:component-scan&gt;1. use-default-filters="false" 作用：让Spring默认的注解扫描方式失效2. &lt;context:exclude-filter type="" expression="" /&gt; 作用：指定扫描哪些注解 type:assignable: 排除特定的类型 进行扫描 annotation: 排除特定的注解 进行扫描 aspectj: 切入点表达式 包切入点: com.Cro.bean..* 类切入点: *..User regex: 正则表达式 custom: 自定义排除策略，框架底层开发包含策略可以叠加使用 Spring高级注解(Spring3.x及以上)@Configuration(配置Bean )Spring在3.x提供的新注解，用于替换XML配置文件 12@Configurationpublic class AppConfig&#123;&#125; ① 配置 Bean 在应用的过程中 替换了XML具体什么内容？(替换了XML的全部工作) ② AnnotationConfigApplicationContext 12345671. 创建工厂代码 ApplicationContext ctx = new AnnotationConfigApplicationContext();2. 指定配置文件 1. 指定配置Bean的Class ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); 2. 指定配置Bean所在的路径 ApplicationContext ctx = new AnnotationConfigApplicationContext("com.Cro"); 配置Bean的细节基于注解开发使用日志不能集成Log4j 集成logback 引入相关jar 1234567891011121314151617&lt;!-- slf4j + logback: --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 实现lsf4j接口并整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 引入logback配置文件 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; @Configuration注解的本质本质：也是@Component注解的衍生注解，可以应用 &lt;context:component-scan&gt;进行扫描（了解） @Bean注解@Bean 注解在 配置bean 中进行使用，等同于XML配置文件中的&lt;bean&gt;标签 @Bean注解的基本使用对象的创建 简单对象 直接能够通过new方式创建的对象 User、UserService、UserDAO 1234@Beanpublic User user()&#123; return new User();&#125; 复杂对象 不能通过new的方式直接创建的对象 Connection、SqlSessionFactory 12345678910111213@Beanpublic Connection conn()&#123; Connection conn = null; try&#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring?useSSL=false","root","1234"); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; catch (SQLException e)&#123; e.printStackTrace(); &#125; return conn;&#125; 自定义id值1234@Bean("u")public User user()&#123; return new User();&#125; 控制对象创建次数12345@Bean@Scope("singleton | prototype") //默认值 singleton（单例）public User user()&#123; return new User();&#125; @Bean注解的注入用户自定义类型的注入 JDK类型的注入耦合采用 @Value、@PropertySource解决 @ComponentScan注解@ComponentScan注解在配置bean中进行使用，等同于XML配置文件中的&lt;context:component-scan&gt;标签 目的：进行相关注解的扫描( @Component、@Value ... @Autowired ) 排除、包含的使用 排除 包含 Spring工厂创建对象的多种配置方式 配置优先级@Component及其衍生注解 &lt; @Bean &lt; 配置文件bean标签 优先级高的配置 可以覆盖优先级低的配置 配置覆盖：id 值 要保持一致 整合多个配置信息 为什么会有多个配置信息 拆分多个配置bean的开发，是一种模块化开发的形式，也体现了面向对象各司其职的设计模式 多配置信息整合的方式 多个配置Bean的整合 配置Bean与@component相关注解的整合 配置Bean与 springXML 配置文件的整合 整合多种配置需要关注哪些要点 如何使多配置的信息汇总成一个整体 如何实现跨配置的注入 多个配置Bean的整合多配置的信息汇总 base-package进行多个配置Bean的整合 @Import 可以创建对象 多配置bean的整合 在工厂创建时，指定多个配置Bean的Class对象 [了解] 跨配置进行注入 配置Bean与@component相关注解的整合 配置Bean与 XML 配置文件的整合 配置Bean的底层实现 纯注解版AOP开发 纯注解版Spring+MyBatis整合 MapperLocations编码时通配的写法 配置Bean数据耦合的问题 纯注解版事务编程 Spring框架中YML的使用什么是YML Properties进行配置的问题 Spring与YML的整合思路]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Mvc]]></title>
    <url>%2F2020%2F08%2F06%2FSpringMvc%2F</url>
    <content type="text"><![CDATA[MVC 框架整合思想为什么要整合 MVC 框架 MVC 框架提供了控制器（Controller）调用 Service Controller ——&gt; Service ——&gt; DAO 请求响应的处理 接收请求参数 request.getParameter(&quot;&quot;) 控制程序的运行流程 视图解析（JSP、JSON、Freemarker、Thymeleaf） Spring 可以整合哪些 MVC 框架？ struts1 webwork jsf struts2 springMVC 搭建 Web 运行环境1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.14.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.14.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.14.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.14.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Spring 整合 MVC 框架的核心思路准备工厂Web 开发过程中如何创建工厂? 1ApplicationContext ctx = new WebXmlApplicationContext("/applicationContext.xml"); 如何保证工厂唯一，同时被共用？ 共用：工厂存储在 ServletContext 这个作用域中，ServletContext.setAttribute(&quot;xxx&quot;, ctx); 唯一：在 ServletContext 对象创建的同时 ——&gt; 创建工厂。ServletContextListener 在 ServletContext 对象创建的同时，被调用（只会被调用一次），把创建工厂的代码写在 ServletContextListener 中，也会保证只调用一次，保证了工厂的唯一性。 Spring 封装了一个 ContextLoaderListener，主要做了两件事： 创建工厂 把工厂存在 ServletContext 中 ContextLoaderListener使用方式：web.xml 中 12345678&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listen-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 代码整合依赖注入：把 Service 对象注入到控制器对象]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-事务]]></title>
    <url>%2F2020%2F08%2F06%2FSpring-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是事务？ 事务时保证业务操作完整性的一种数据库机制。 事务的 4 大特点： A、C、I、D A 原子性 C 一致性 I 隔离性 D 持久性 如何控制事务?（JDBC、Mybatis） JDBC Connection.setAutoCommit(false); Connection.commit(); Connection.rollback(); Mybatis Mybatis 自动开启事务 sqlSession.commit();底层还是调用的 Connection sqlSession.rollback(); 底层还是调用的 Connection 结论：控制事务的底层，都是通过 Connection 对象完成的。 Spring 控制事务的开发Spring是通过AOP的方式进行事务开发 搭建开发环境 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编码 类 UserServiceImpl.java 1234@Transactionalpublic class UserServiceImpl implements UserService &#123; private UserDAO userDAO;&#125; 配置文件applicationContext.xml 12345678910&lt;bean id="userService" class="com.Cro.service.UserServiceImpl"&gt; &lt;property name="userDAO" ref="userDAO"/&gt;&lt;/bean&gt;&lt;!--DataSourceTransactionManager--&gt;&lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager"/&gt; 细节进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib。 1&lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager" proxy-target-class="true"/&gt; Spring 中的事务属性（Transaction Attribute）什么是事务属性？ 属性：描述物体特征的一系列值（性别、身高、体重） 事务属性：描述事务特征的一系列值 隔离属性 传播属性 只读属性 超时属性 异常属性 如何添加事务属性？ 1@Transactional(isolation=, propagation=, readOnly=,timeout=,rollbackFor,noRollbackFor=,) 隔离属性（ISOLATION）概念：描述了事务解决并发问题的特征。 什么是并发？多个事务（用户）在同一时间，访问操作了相同的数据。同一时间：0.000 几秒左右 并发会产生那些问题？ 脏读 不可重复读 幻影读 并发问题如何解决？通过隔离属性解决，隔离属性中设置不同过的值，解决并发处理的过程中的问题。 事务并发产生的问题： 脏读一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象解决方案：@Transactional(isolation=Isolation.READ_COMMITTED) 不可重复读一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象注意：1.不是脏读 2.在一个事务中解决方案：@Transactional(isolation=Isolation.REPEATABLE_READ)本质：一把行锁（对数据库表的某一行加锁） 幻影读一个事务中，多次对整表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题解决方案：@Transactional(isolation=Isolation.SERIALIZABLE)本质：表锁（对数据库某个表加锁） 安全与效率对比： 并发安全：READ_COMMITTED &lt; READ_ONLY &lt; SERIALIZABLE 运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE 数据库对隔离属性的支持： 隔离属性的值 MySQL Oracle ISOLATION_READ_COMMITTED 支持 支持 ISOLATION_REPEATABLE_READ 支持 不支持 ISOLATION_SERIALIZABLE 支持 支持 Oracle 不支持 REPEATABLE_READ，那该如何解决不可重复读？ 采用 多版本比对 的方式解决不可重复读问题。 默认的隔离属性： Spring 会指定为 ISOLATION_DEFAULT，调用不同数据库所设置的默认隔离属性MySQL：REPEATABLE_READOracle：READ_COMMITTED 查看数据库的默认隔离属性：MySQL：SELECT @@tx_isolation;Oracle：较麻烦，建议百度。 隔离属性在实验中的建议： 推荐使用 Spring 默认指定的 ISOLATION_DEFAULT 未来的实战中，遇到并发访问的情况，很少见 如果真的遇到并发问题，解决方案：乐观锁Hibernate(JPA)：versionMyBatis：通过拦截器自定义开发 传播属性（PROPAGATION） 概念：描述了事务解决 嵌套 问题 的特征。 事务的嵌套：指的是一个大的事务中，包含了若干个小的事务。 事务嵌套产生的问题： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性。 传播属性的值及其用法： 传播属性的值 外部不存在事务 外部存在事务 用法 备注 REQUIRED 开启新的事务 融合到外部事务中 @Transactional(propagation = Propagation.REQUIRED) 增、删、改方法 SUPPORTS 不开启事务 融合到外部事务中 @Transactional(propagation = Propagation.SUPPORTS) 查询方法 REQUIRES_NEW 开启新的事务 挂起外部事务，创建新的事务 @Transactional(propagation = Propagation.REQUIRES_NEW) 日志记录方法中 NOT_SUPPORTED 不开启事务 挂起外部事务 @Transactional(propagation = Propagation.NOT_SUPPORTED) 极其不常用 NEVER 不开启事务 抛出异常 @Transactional(propagation = Propagation.NEVER) 极其不常用 MANDATORY 抛出异常 融合到外部事物中 @Transactional(propagation = Propagation.MANDATORY) 极其不常用 Spring 中传播属性的默认值是：REQUIRED 推荐传播属性的使用方式： 增删改 方法：使用默认值 REQUIRED 查询 方法：显示指定传播属性的值为 SUPPORTS 只读属性（readOnly）针对于 只进行查询操作的业务方法，可以加入只读属性，提高运行效率。 默认值：false 1@Transactional(readOnly = true) 超时属性（timeout）指定了事务等待的最长时间。 为什么事务会进行等待？ 当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。 等待时间，单位是 秒 如何使用：@Transactional(timeout = 2) 超时属性的默认值：-1 -1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可） 异常属性Spring 事务处理过程中： 默认对于 RuntimeException 及其子类，采用 回滚 的策略。 默认对于 Exception 及其子类，采用 提交 的策略。 使用方法： 123@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx) 建议：实战中使用 RuntimeException 及其子类，使用事务异常属性的默认值。 事务属性常见配置总结 隔离属性 默认值 传播属性 Required（默认值）增删改、Supports 查询操作 只读属性 readOnly=false 增删改，true 查询操作 超时属性 默认值 -1 异常属性 默认值 增删改操作：@Transactional 查询操作：@Transactional(propagation = Propagation.SUPPORTS, readOnly = true) 基于标签的事务配置方式(事务开发的第二种方式)基于标签的事务配置：(不推荐) 123456789101112131415&lt;!--DataSourceTransactionManager--&gt;&lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="register" isolation="DEFAULT" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id="pc" expression="execution(* com.Cro.service.UserServiceImpl.register(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pc"/&gt;&lt;/aop:config&gt; 基于标签的事务配置在 实战 中的应用方式： 123456789101112131415&lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="register"/&gt; &lt;tx:method name="modify*"/&gt; 编程时候, service中负责进行增删改操作的方法 都以 modify 开头 查询操作 命名无所谓 &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id="pc" expression="execution(* com.Cro.service..*.*(..))"/&gt; 应用的过程中, 将 service 都放到 service 包下 &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pc"/&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Mybatis]]></title>
    <url>%2F2020%2F08%2F06%2FSpring%E6%95%B4%E5%90%88Mybatis%2F</url>
    <content type="text"><![CDATA[持久层整合1、Spring 框架为什么要与持久层技术进行整合？ JavaEE开发需要持久层进行数据库的访问操作 JDBC、Hibernate、MyBatis 进行持久开发过程存在大量的代码冗余 Spring 基于模板设计模式对于上述的持久层技术进行了封装 2、Spring 可以与哪些持久层技术进行整合？ JDBC —— JDBCTemplate Hibernate（JPA）—— HibernateTemplate MyBatis —— SqlSessionFactoryBean、MapperScannerConfigure Mybatis 开发步骤回顾① 实体类 User 1234567891011121314public class User implements Serializable &#123; private Integer id; private String name; private String password; public User() &#123;&#125; public User(Integer id, String name, String password) &#123; this.id = id; this.name = name; this.password = password; &#125; // get set方法...&#125; ② 实体别名 mybatis-config.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Confi 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias="user" type="com.Cro.mybatis.User"/&gt; &lt;/typeAliases&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=false"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; ③ 表 t_users 12345create table t_users values ( id int(11) primary key auto_increment, name varchar(12), password varchar(12)); ④ 创建 DAO 接口：UserDAO 123public interface UserDAO &#123; public void save(User user);&#125; ⑤ 实现Mapper文件：UserDAOMapper.xml 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.Cro.mybatis.UserDAO"&gt; &lt;insert id="save" parameterType="user"&gt; insert into t_users(name, password) values (#&#123;name&#125;, #&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; ⑥ 注册 Mapper 文件 mybatis-config.xml 123&lt;mappers&gt; &lt;mapper resource="UserDAOMapper.xml"/&gt;&lt;/mappers&gt; ⑦ MybatisAPI 调用 123456789101112131415public class TestMybatis &#123; public static void main(String[] args) throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); UserDAO userDAO = session.getMapper(UserDAO.class); User user = new User(); user.setName("xiaoxiao"); user.setPassword("123456"); userDAO.save(user); session.commit(); &#125;&#125; Mybatis 开发中存在的问题问题：配置繁琐、代码冗余 12345671. 实体2. 实体别名 配置繁琐3. 表4. 创建 DAO 接口5. 实现 Mapper 文件6. 注册 Mapper 文件 配置繁琐7. Mybatis API 调用 代码冗余 Spring 与 Mybatis 整合思路 Spring 与 Mybatis 整合的开发步骤 配置文件（ApplicationContext.xml）进行相关配置（只需要配置一次） 编码 1.实体类 2.表 3.创建DAO接口 4.Mapper文件配置 Spring 与 Mybatis 整合的编码搭建开发环境 pom.xml1234567891011121314151617181920212223242526272829&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt; Spring 配置文件的配置1234567891011121314151617181920212223242526272829303132&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--连接池--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=false"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/bean&gt; &lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 指定实体类所在的包 --&gt; &lt;property name="typeAliasesPackage" value="com.Cro.entity"/&gt; &lt;!--指定配置文件（映射文件）的路径，还有通用配置--&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;value&gt;classpath:com.Cro.dao/*Mapper.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--创建DAO对象 MapperScannerConfigure--&gt; &lt;bean id="scanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactoryBean"/&gt; &lt;!--指定DAO接口放置的包--&gt; &lt;property name="basePackage" value="com.Cro.dao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 1234注意 MapperScannerConfigurer这种方式不推荐使用。可以看下官网的话：在 MyBatis-Spring 1.0.2 之前，sqlSessionFactoryBean 和 sqlSessionTemplateBean 属性是唯一可用的属性。但由于 MapperScannerConfigurer 在启动过程中比 PropertyPlaceholderConfigurer 运行得更早，经常会产生错误。基于这个原因，上述的属性已被废弃，现在建议使用 sqlSessionFactoryBeanName 和sqlSessionTemplateBeanName 属性。 编码① 实体 com.Cro.entity.User 123456public class User implements Serializable &#123; private Integer id; private String name; private String password; // get set...&#125; ② 表 t_user 12345create table t_users values ( id int(11) primary key auto_increment, name varchar(12), password varchar(12)); ③ DAO接口 com.Cro.dao.UserDAO 123public interface UserDAO &#123; public void save(User user);&#125; ④ Mapper文件配置 UserDAOMapper.xml 123&lt;insert id="save" parameterType="User"&gt; insert into t_user (name,password) values (#&#123;name&#125;,#&#123;password&#125;)&lt;/insert&gt; ⑤ 测试 1234567891011121314/** * 用于测试: Spring 与 Mybatis 的整合 */@Testpublic void test() &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("/applicationContext.xml"); UserDAO userDAO = (UserDAO) ctx.getBean("userDAO"); User user = new User(); user.setName("xiaojr"); user.setPassword("999999"); userDAO.save(user);&#125; Spring 与 Mybatis 整合细节问题：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？ Mybatis 提供的连接池对象 —&gt; 创建 ConnectionConnection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。 Druid（C3P0、DBCP）作为连接池 —&gt; 创建 ConnectionConnection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。 答案：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。 注意：实战中，还是会手工控制事务（多条SQL一起成功，一起失败），后续 Spring 通过 事务控制 解决这个问题。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-AOP]]></title>
    <url>%2F2020%2F08%2F05%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[后置处理 BeanBeanPostProcessor 作用：对 Spring 工厂所创建的对象，进行再加工。（AOP 的底层实现） 后置处理 Bean 原理分析 实现 BeanPostProcessor 接口中规定的两个方法： 作用：Spring 创建完对象，并进行注入后，可以运行 Before ⽅法进行加工；（初始化前） 通过方法的参数获得 Spring 创建好的对象，最终通过返回值交给 Spring 框架。 123public Object postProcessBeforeInitialization(Object bean, String beanName) &#123; return bean;&#125; 作⽤：Spring 执行完对象的初始化操作后，可以运行 After ⽅法进行加工；（初始化后） 通过方法的参数获得 Spring 创建好的对象，最终通过返回值交给 Spring 框架。 123public Object postProcessAfterInitialization(Object bean, String beanName) &#123; return bean;&#125; 实战中：很少处理 Spring 的初始化操作，没有必要区分 Before，After。只需要实现其中一个，建议是 After 方法即可。 注意：只实现其中一个 After方法 Before 要返回一个空实现 return bean对象 BeanPostProcessor 开发步骤 类 实现 BeanPostProcessor 接口 12345678910111213public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return null; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; Category category = (Category) bean; category.setName("xiaoxiao"); return category; &#125;&#125; Spring 配置文件中进行配置 1&lt;bean id="myBeanPostProcessor" class="com.Cro.beanpost.MyBeanPostProcessor"/&gt; 细节：BeanPostProcessor 会对 Spring 工厂创建的所有对象进行加工。如果工厂创建了多个不同的对象，要注意区别传入的对象： 123456789@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof Category) &#123; Category category = (Category) bean; category.setName("xiaoxiao"); return category; &#125; return bean;&#125; 静态代理设计模式为什么需要代理设计模式问题：在 JavaEE 分层开发开发中，哪个层次（DAO、Service、Controller）对于我们来讲最重要？Service 层 Service 层中包含了哪些代码？ 核心功能（代码量较多）：业务运算，DAO 调用 额外功能（附加功能，不属于业务，可有可无，代码量小）：事务、日志、性能 … 额外功能书写在 Service 层好不好? Service 层的调用者的角度（Controller)：需要在 Service 层书写额外功能。 软件设计者：Service 层不需要额外功能。 拿现实生活中的例子来做对比，解决方案是 引入一个代理。 代理设计模式概念：通过代理类，为原始类（⽬标类）增加额外的功能 好处：利于原始类（目标类）的维护 名词解释目标类 / 原始类：指的是 业务类 (核心功能 —&gt; 业务运算、DAO调用) 目标方法 / 原始方法：目标类（原始类）中的方法就是目标方法（原始方法） 额外功能 / 附加功能：日志、事务、性能 … 代理开发的核心要素代理类 = 目标类(原始类) + 额外功能 + 原始类(目标类)实现相同的接口 123456789101112131415房东 ---&gt; 目标类public interface UserService &#123; m1 m2 &#125; public UserServiceImpl implements UserServiceImpl &#123; m1 ---&gt; 业务运算、调用DAO m2 &#125;----------------------------------------------------中介 --- 代理类：要实现目标类相同的接口 public UserServiceProxy implements UserService &#123; m1 m2&#125; 静态代理编码静态代理：为每⼀个原始类，手工编写⼀个代理类（.java .class） 1public class User &#123;&#125; 1234public interface UserService &#123; void register(User user); boolean login(String name, String password);&#125; 123456789101112public class UserServiceImpl implements UserService &#123; @Override public void register(User user) &#123; System.out.println("UserServiceImpl.register 业务运算 + DAO"); &#125; @Override public boolean login(String name, String password) &#123; System.out.println("UserServiceImpl.login 业务运算 + DAO"); return true; &#125;&#125; 12345678910111213141516/** * 静态代理类编码实现 */public class UserServiceProxy implements UserService &#123; // 实现原始类相同的接口 private UserService userService = new UserServiceImpl(); // 代理类中必须有原始类 @Override public void register(User user) &#123; System.out.println("---log---"); // 额外功能 userService.register(user); &#125; @Override public boolean login(String name, String password) &#123; System.out.println("---log---"); // 额外功能 return userService.login(name, password); &#125;&#125; 静态代理存在的问题 静态类文件数量过多，不利于项目管理 UserServiceImpl、UserServiceProxy OrderServiceImpl、OrderServiceProxy… 额外功能维护性差：在代理类中修改额外功能较为麻烦 动态代理开发概念：通过代理类为原始类（目标类）增加额外功能 好处：利于原始类（目标类）的维护 搭建开发环境123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.14.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; Spring 动态代理的开发步骤(4步) ① 创建原始对象（目标对象） 1234public interface UserService &#123; void register(User user); boolean login(String name, String password);&#125; 123456789101112public class UserServiceImpl implements UserService &#123; @Override public void register(User user) &#123; System.out.println("UserServiceImpl.register 业务运算 + DAO"); &#125; @Override public boolean login(String name, String password) &#123; System.out.println("UserServiceImpl.login 业务运算 + DAO"); return true; &#125;&#125; ② 额外功能 MethodBeforeAdvice 接口 123456789public class Before implements MethodBeforeAdvice &#123; /** * 作用: 把需要运行在原始方法执行之前运行的额外功能, 书写在 before 方法中 */ @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println("---method before advice log---"); &#125;&#125; 12&lt;!-- 额外功能 --&gt;&lt;bean id="before" class="com.Cro.aop.Before"/&gt; ③ 定义 切入点：额外功能的加入 ⽬的: 由程序员根据⾃⼰的需要，决定额外功能加入给哪个原始方法(register、login) 123456&lt;!--切入点:额外功能的加入--&gt;&lt;!--⽬的: 由程序员根据⾃⼰的需要，决定额外功能加入给哪个原始方法(register、login)--&gt;&lt;!-- 简单的测试：所有方法都作为切入点，都加入额外的功能--&gt;&lt;aop:config&gt; &lt;aop:pointcut id="pc" expression="execution(* * (..))"/&gt;&lt;/aop:config&gt; ④ 组装（②、③ 整合） 12345678&lt;bean id="userService" class="com.Cro.aop.UserServiceImpl"/&gt;&lt;!-- 额外功能 --&gt;&lt;bean id="before" class="com.Cro.aop.Before"/&gt;&lt;aop:config&gt; &lt;aop:pointcut id="pc" expression="execution(* * (..))"/&gt; &lt;!--表达的含义: 所有的方法 都加入before的额外功能--&gt; &lt;aop:advisor advice-ref="before" pointcut-ref="pc"/&gt;&lt;/aop:config&gt; ⑤ 调用 目的：获得 Spring 工厂创建的动态代理对象，并进行调用 注意： Spring 的工厂通过原始对象的 id 值获得的是代理对象 获得代理对象后，可以通过声明接口类型，进行对象的存储 12345678910/** * 用于测试动态代理 */@Testpublic void test1() &#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("/applicationContext.xml"); UserService userService = (UserService) ctx.getBean("userService"); userService.login("admin", "1234"); userService.register(new User());&#125; 动态代理细节分析① Spring 创建的动态代理类在哪里？ Spring 框架在运行时，通过动态字节码技术，在 JVM 创建的，运行在 JVM 内部，等程序结束后，会和 JVM 一起消失。 什么是 动态字节码技术？ 通过第三方动态字节码框架，在 JVM 中创建对应类的字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失。 结论： 动态代理不需要定义类文件，都是 JVM 运行过程中动态创建的；所以不会造成静态代理的缺点：类⽂件数量过多，影响项目管理的问题。 ② 动态代理编程简化代理的开发 在额外功能不改变的前提下，创建其他目标类（原始类）的代理对象时，只需要指定原始（目标）对象即可。 ③ 动态代理使得 额外功能的维护性大大增强。 额外功能的详解MethodBeforeAdvice 分析 MethodBeforeAdvice 接口作用：额外功能运行在原始方法执行之前，进行额外功能操作。 before 方法的 3 个参数在实战中，该如何使用？(基本用不到) before 方法的参数，在实战中，会根据需要进行使用，不⼀定都会用到，也有可能都不用。 12345678910111213141516171819202122232425public class Before implements MethodBeforeAdvice &#123; /** * 作用: 把需要运行在原始方法执行之前运行的额外功能, 书写在 before 方法中 * * Method: 额外功能所增加给的那个原始方法 * 1. login * 2. register * -------- * showOrder * * Object[]: 额外功能所增加给的那个原始方法的参数 * 1. String name,String password * 2. User * -------- * * Object: 额外功能所增加给的那个原始对象 * 1、2 UserServiceImpl * --------------- * OrderServiceImpl */ @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println("---new method before advice log---"); &#125;&#125; MethodInterceptor（方法拦截器） 功能比 MethodBeforeAdvice 强 methodinterceptor 接口：额外功能可以根据需要运行在原始方法执行 前、后、前后。 参数：MethodInvocation：额外功能所增加给的那个原始方法 (login, register) 返回值：Object：原始方法的返回值 (没有就返回 null) invocation.proceed()：原始方法运行 (执行自己的业务) 额外功能运行在原始方法 之前： 1234567891011public class Around implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("---额外功能运行在原始方法执行之前---"); Object ret = invocation.proceed(); // 原始方法运行, 获取原始方法的返回值 return ret; &#125;&#125; 额外功能运行在原始方法 之后： 1234567891011public class Around implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; Object ret = invocation.proceed(); // 原始方法运行, 获取原始方法的返回值 System.out.println("---额外功能运行在原始方法执行之后---"); return ret; &#125;&#125; 额外功能运行在原始方法 之前、之后： 什么样的额外功能 运行在原始方法执行之前、之后都要添加？（事务） 12345678910111213public class Around implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("---额外功能运行在原始方法执行之前---"); Object ret = invocation.proceed(); // 原始方法运行, 获取原始方法的返回值 System.out.println("---额外功能运行在原始方法执行之后---"); return ret; &#125;&#125; 额外功能运行在原始方法抛出异常的时候： 123456789101112public class Around implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; Object ret = null; try &#123; ret = invocation.proceed(); // 原始方法运行, 获取原始方法的返回值 &#125; catch (Throwable throwable) &#123; System.out.println("---额外功能运行在原始方法抛异常的时候---"); &#125; return ret; &#125;&#125; MethodInterceptor 影响原始方法的返回值： 原始方法的返回值，直接作为invoke方法的返回值返回，MethodInterceptor不会影响原始方法的返回值 12345678public class Around implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("---log---"); Object ret = invocation.proceed(); return false; &#125;&#125; 切入点详解切入点决定额外功能加入位置（方法） 12&lt;!--execution(* * (..)) 匹配了所有方法--&gt;&lt;aop:pointcut id="pc" expression="execution(* * (..))"/&gt; execution()：切入点函数 * *(..)：切入点表达式 切入点表达式方法切入点123定义一个方法public void add（int i, int j） * * (..) 123456* * (..) --&gt; 所有方法* ---&gt; 修饰符 返回值* ---&gt; 方法名() ---&gt; 参数表.. ---&gt; 对于参数没有要求 (参数有没有，参数有⼏个都行，参数是什么类型的都行) 定义 login 和 register方法作为切入点： 12345&lt;!-- 定义login作为切入点 --&gt;&lt;aop:pointcut id="pc" expression="execution(* login (..))"/&gt;&lt;!-- 定义register作为切入点 --&gt;&lt;aop:pointcut id="pc" expression="execution(* register (..))"/&gt; 定义方法名为 login 且 有两个字符串类型的参数 作为切入点； 12345678&lt;aop:pointcut id="pc" expression="execution(* login (String,String))"/&gt;&lt;&lt;!-- ⾮ java.lang java.lang 包中的类型, 必须要写全限定名 --&gt;&lt;aop:pointcut id="pc" expression="execution(* register (com.Cro.a.UserServiceImpl))"/&gt;&lt;!-- ..可以和具体的参数类型连用 --&gt;&lt;aop:pointcut id="pc" expression="execution(* login(String, ..))"/&gt;&lt;!-- === login(String), login(String,String), login(String,com.Cro.a.UserServiceImpl) --&gt; 精准方法切入点限定 123&lt;aop:pointcut id="pc" expression="execution(* com.Cro.a.UserServiceImpl.login(..))"/&gt;&lt;aop:pointcut id="pc" expression="execution(* com.Cro.a.UserServiceImpl.login(String, String))"/&gt; 类切入点指定 特定类作为切入点(额外功能加入的位置)，这个类中的所有方法，都会加上对应的额外功能。 语法1 12# 类中所有的方法加入了额外功能&lt;aop:pointcut id="pc" expression="execution(* com.Cro.a.UserServiceImpl.*(..))"/&gt; 语法2 12345# 忽略包1. 类只存在一级包&lt;aop:pointcut id="pc" expression="execution(* *.UserServiceImpl.*(..))"/&gt;2. 类存在多级包&lt;aop:pointcut id="pc" expression="execution(* *..UserServiceImpl.*(..))"/&gt; 包切入点（实战中用的多）指定包作为额外功能加入的位置，自然包中的所有类及其方法都会加入额外的功能。 语法1： 12# 切入点包中的所有类，必须在proxy中，不能在proxy包的⼦包中&lt;aop:pointcut id="pc" expression="execution(* com.Cro.proxy.*.*(..))"/&gt; 语法2： 12# 切入点当前包及其⼦包都生效&lt;aop:pointcut id="pc" expression="execution(* com.Cro.proxy..*.*(..))"/&gt; 切入点函数（execution、args、within）切入点函数：用于执行切入点表达式 exectuionexecution 是最为重要的切入点函数，功能最全；可以执行执行 方法切入点表达式、类切入点表达式、包切入点表达式；弊端：execution 执⾏切入点表达式 ，书写麻烦 1execution(* com.Cro.proxy..*.*(..)) 注意：其他的 切入点函数 简化的是 execution 的书写复杂度，功能上完全⼀致。 argsargs 作用：主要用于 函数(方法) 参数的匹配； 1234567切入点：方法参数必须得是 2 个字符串类型的参数# 使用 execution&lt;aop:pointcut id="pc" expression="execution(* *(String, String))"/&gt;# 使用 args&lt;aop:pointcut id="pc" expression="args(String, String)"/&gt; withinwithin 作用：主要用于进行 类、包切入点表达式 的匹配。 1234567切入点: UserServiceImpl 这个类# 使用 execution&lt;aop:pointcut id="pc" expression="expression(* *..UserServiceImpl.*(..))"/&gt;# 使用 within&lt;aop:pointcut id="pc" expression="within(*..UserServiceImpl)"/&gt; 1234567切入点: com.Cro.proxy 这个包# 使用 execution&lt;aop:pointcut id="pc" expression="execution(* com.Cro.proxy..*.*(..)"/&gt;# 使用 within&lt;aop:pointcut id="pc" expression="within(com.Cro.proxy..*)"/&gt; @annotation作用：为具有特殊注解的 方法 加入额外功能。 例如我们自定义了一个注解：Log 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log &#123;&#125; 然后我们要为使用了 Log注解的方法加入额外功能。 1&lt;aop:pointcut id="pc" expression="@annotation(com.Cro.Log)"/&gt; 切入点函数的逻辑运算（and、or）切入点函数的逻辑运算 指的是：整合多个切入点函数⼀起配合工作，进⽽完成更为复杂的需求。 and 与操作： 123456789# 案例: 方法名叫 login 同时 参数是 2个字符串# execution&lt;aop:pointcut id="pc" expression="execution(* login(String, String))"/&gt;# execution and args&lt;aop:pointcut id="pc" expression="execution(* login(..)) and args(String, String))"/&gt;# 注意：与操作不同⽤于同种类型的切⼊点函数# 以下这个是错误的, 因为不存在同时叫 login 和 register 的方法&lt;aop:pointcut id="pc" expression="execution(* login(..)) and execution(* register(..))"/&gt; or 或操作： 12案例: 方法名叫 register 或 login 的⽅法作为切⼊点&lt;aop:pointcut id="pc" expression="execution(* login(..)) or execution(* register(..))"/&gt; AOP 编程AOP 概念 POP (Producer Oriented Programing） 面向过程（方法、函数）编程 —— C 以过程为基本单位的程序开发，通过过程间的彼此协同，相互调用，完成程序的构建。 OOP (Object Oritened Programing) 面向对象编程 —— Java 以对象为基本单位的程序开发，通过对象间的彼此协同，相互调用，完成程序的构建。 AOP (Aspect Oriented Programing) 面向切面编程 = Spring动态代理开发 以切面为基本单位的程序开发，通过切面间的彼此协同，相互调用，完成程序的构建。 切面 = 切入点 + 额外功能 AOP 的概念： 本质就是 Spring 的动态代理开发，通过代理类为原始类增加额外功能。 好处：利于原始类的维护 注意：AOP 编程不可能取代 OOP，AOP 是 OOP 编程的补充。 AOP 编程的开发步骤 原始对象 额外功能 (MethodInterceptor) 切入点 组装切面 (额外功能+切入点) 切面的名词解释切面 = 切入点 + 额外功能 几何学：面 = 点 + 相同的性质 AOP 的底层实现原理核心问题： AOP 如何创建动态代理类(动态字节码技术) Spring 工厂如何加工创建代理对象(通过原始对象的 id 值，获得的是代理对象) 动态代理类的创建JDK 的动态代理（原理 + 编码） Proxy.newPorxyInstance 方法参数详解 编码 12345678910111213141516171819202122232425262728public class TestJDKProxy &#123; /** 1. 借⽤类加载器 TestJDKProxy 或 UserServiceImpl 都可以 2. JDK8.x 前必须加 final final UserService userService = new UserServiceImpl(); */ public static void main(String[] args) &#123; // 1. 创建原始对象 UserService userService = new UserServiceImpl(); // 2. JDK 动态代理 InvocationHandler handler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("---- proxy log ----"); // 原始方法运行 Object ret = method.invoke(userService, args); return ret; &#125; &#125;; UserService userServiceProxy = (UserService) Proxy.newProxyInstance(TestJDKProxy.class.getClassLoader(), userService.getClass().getInterfaces(), handler); userServiceProxy.login("xiaoxiao", "123456"); userServiceProxy.register(new User()); &#125;&#125; CGlib 的动态代理CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）。 CGlib 编码 12345678910111213141516171819202122232425262728293031323334public class TestCglib &#123; public static void main(String[] args) &#123; // 1. 创建原始对象 UserService userService = new UserService(); /* 2. 通过 cglib 方式创建动态代理对象 对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler); Enhancer.setClassLoader() Enhancer.setSuperClass() Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib) Enhancer.createProxy() ---&gt; 创建代理对象 */ Enhancer enhancer = new Enhancer(); enhancer.setClassLoader(TestCglib.class.getClassLoader()); enhancer.setSuperclass(userService.getClass()); MethodInterceptor interceptor = new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("--- cglib log ----"); Object ret = method.invoke(userService, args); // 执行原始方法 return ret; &#125; &#125;; enhancer.setCallback(interceptor); UserService userServiceProxy = (UserService) enhancer.create(); userServiceProxy.login("xiaoxiao", "123456"); userServiceProxy.register(new User()); &#125;&#125; 总结 JDK 动态代理Proxy.newProxyInstance：通过接口创建代理的实现类 Cglib 动态代理Enhancer：通过继承⽗类创建的代理类 Spring 工厂如何加工原始对象 思路分析：主要通过 BeanPostProcessor 将原始对象加工为代理对象 编码 1234567891011121314151617181920public class ProxyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; InvocationHandler handler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("--- new log ---"); // 进行加工 Object ret = method.invoke(bean, args); // 原始方法 return ret; &#125; &#125;; return Proxy.newProxyInstance(ProxyBeanPostProcessor.class.getClassLoader(), bean.getClass().getInterfaces(), handler); &#125;&#125; 1234&lt;bean id="userService" class="com.Cro.factory.UserServiceImpl"/&gt;&lt;!--1. 实现 BeanPostProcessor 进行加工--&gt;&lt;!--2. 配置文件中对 BeanPostProcessor 进行配置--&gt;&lt;bean id="proxyBeanPostProcessor" class="com.Cro.factory.ProxyBeanPostProcessor"/&gt; 基于注解的 AOP 编程的开发开发步骤① 原始功能 1234public interface UserService &#123; void register(User user); boolean login(String name, String password);&#125; 1234567891011121314public class UserServiceImpl implements UserService &#123; @Override public void register(User user) &#123; System.out.println("UserServiceImpl.register 业务运算 + DAO"); // throw new RuntimeException("测试异常"); &#125; @Log @Override public boolean login(String name, String password) &#123; System.out.println("UserServiceImpl.login 业务运算 + DAO"); return true; &#125;&#125; ② 额外功能、③ 切入点、④ 组装切面 ②、③、④ 都放在了 MyAspect 类中完成： 通过@Aspect 切面类 定义了 额外功能 Around 定义了 切入点 @Around 123456789101112131415161718192021222324252627/* 1. 额外功能 public class MyAround implements MethodInterceptor &#123; public Object invoke(MethodInvocation invocation) &#123; Object ret = invocation.proceed(); return ret; &#125; &#125; &lt;bean id="around" class="com.Cro.dynamic.Around"/&gt; 2. 切入点 &lt;aop:config&gt; &lt;aop:pointcut id="pc" expression="execution(* login(..)))"/&gt; &lt;aop:advisor advice-ref="around" pointcut-ref="pc"/&gt; &lt;/aop:config&gt; */@Aspectpublic class MyAspect &#123; @Around("execution(* login(..))") //1. 额外功能 // 2. 切入点 public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("---- aspect log ----"); Object ret = joinPoint.proceed(); return ret; &#125;&#125; 1234567891011121314151617&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="userService" class="com.Cro.aspect.UserServiceImpl"/&gt; &lt;!-- 切面: 1. 额外功能 2. 切入点 3. 组装切面 --&gt; &lt;bean id="around" class="com.Cro.aspect.MyAspect"/&gt; &lt;!--告知 Spring 基于注解进行 AOP 编程--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 切入点复用切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。 通过这种方式定义切入点表达式，后续更加有利于切入点复用。 12345678910111213141516171819@Aspectpublic class MyAspect &#123; @Pointcut("execution(* login(..))") public void myPoincut() &#123;&#125; @Around(value = "myPoincut()") public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("---- aspect log ----"); Object ret = joinPoint.proceed(); return ret; &#125; @Around(value = "myPoincut()") public Object around1(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("---- aspect transaction ----"); Object ret = joinPoint.proceed(); return ret; &#125;&#125; 切换动态代理的创建方式（JDK、Cglib）AOP 底层实现：2 种代理创建方式： JDK：通过 实现接口，做新的实现类 创建代理对象 Cglib：通过 继承父类，做新的子类 创建代理对象 默认情况 AOP 编程 底层应用 JDK动态代理创建方式。 基于注解的 AOP 开发 中切换为 Cglib： 1&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 传统的 AOP 开发 中切换为 Cglib： 1&lt;aop:config proxy-target-class="true"&gt;&lt;/aop:config&gt; AOP 开发中的一个坑（业务方法互相调用）坑！：在同⼀个业务类中，进⾏业务方法间的相互调用，只有最外层的方法，才是加入了额外功能(内部的方法，通过普通的方式调用，都调用的是原始方法)。如果想让内层的方法也调用代理对象的方法，就要实现 AppicationContextAware 获得⼯厂，进而获得代理对象。 12345678910111213141516171819202122232425public class UserServiceImpl implements UserService, ApplicationContextAware &#123; private ApplicationContext ctx; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; ctx = applicationContext; &#125; @Override public void register(User user) &#123; System.out.println("UserServiceImpl.register 业务运算 + DAO"); // this.login("xiaoxiao", "123456"); // 调用原始对象的 login 方法 ---&gt; 核心功能（没有额外功能） // 为什么不在这里创建一个工厂获取代理对象呢？ // Spring的工厂是重量级资源, 一个应用中应该只创建一个工厂. // 因此通过 ApplicationContextAware 拿到已经创建好的工厂 UserService userService = (UserService) ctx.getBean("userService"); userService.login("xiaoxiao", "123456"); &#125; @Override public boolean login(String name, String password) &#123; System.out.println("UserServiceImpl.login 业务运算 + DAO"); return true; &#125;&#125; AOP 知识总结]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-对象的生命周期]]></title>
    <url>%2F2020%2F08%2F05%2FSpring-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[对象的生命周期什么是对象的⽣命周期？ ⼀个对象 创建、存活、消亡 的⼀个完整过程。 为什么要学习对象的⽣命周期？ 由 Spring 负责对象的 创建、存活、销毁，了解⽣命周期，有利于我们使用好 Spring 为我们创建的对象。 ⽣命周期的 3 个阶段： 创建阶段 —&gt; 初始化阶段 —&gt; 销毁阶段 创建阶段Spring 工厂何时创建对象？ scope=&quot;prototype&quot;：Spring 工厂会在获取对象 ctx.getBean(&quot;xxx&quot;) 的同时，创建对象。 scope=&quot;singleton&quot;：Spring 工厂创建的同时，创建对象。 通过配置 &lt;bean lazy-init=&quot;true&quot;/&gt;(懒加载) 也可以实现工厂在获取对象 ctx.getBean(&quot;xxx&quot;) 的同时，创建对象。(相当于单例prototype) 初始化阶段什么时候？Spring 工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作。 初始化方法提供：程序员根据需求，提供初始化方法，最终完成初始化操作。 初始化方法调用：Spring 工厂进行调用。 提供初始化方法的两种方式： InitializingBean 接口 afterPropertiesSet()： 1234567public class Product implements InitializingBean &#123; //程序员根据需求实现的方法, 完成初始化操作 @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("Product.afterPropertiesSet"); &#125;&#125; 对象中提供一个普通的初始化方法，配置文件种配置 init-method：(遗留系统的解决方案) 12345public class Product &#123; public void myInit() &#123; System.out.println("Product.myInit"); &#125;&#125; 1&lt;bean id="product" class="com.Cro.life.Product" init-method="myInit"/&gt; 初始化操作的细节分析： 如果⼀个对象既实现 InitializingBean 同时⼜提供的 普通的初始化方法，执行顺序? 先执行 InitializingBean，再执行 普通初始化方法。 注入⼀定发生在初始化操作的前面。 初始化操作到底是什么？ 资源的初始化：数据库、IO、网络、… 销毁阶段Spring 销毁对象前，会调用对象的销毁方法，完成销毁操作。 Spring 什么时候销毁所创建的对象？ctx.close(); 销毁方法提供：程序员根据业务需求，定义销毁方法，完成销毁操作 销毁方法调用：Spring 工厂进行调用。 开发流程与初始化操作一样，提供销毁方法的两种方式： DisposableBean 接口： 1234567public class Product implements DisposableBean &#123; // 程序员根据⾃⼰的需求, 定义销毁方法, 完成销毁操作 @Override public void destroy() throws Exception &#123; System.out.println("Product.destroy"); &#125;&#125; 对象中提供一个普通的销毁方法，配置文件种配置 destroy-method： 123456public class Product &#123; // 程序员根据⾃⼰的需求, 定义销毁方法, 完成销毁操作 public void myDestory() &#123; System.out.println("Product.myDestory"); &#125;&#125; 1&lt;bean id="product" class="com.Cro.life.Product" destroy-method="myDestory"/&gt; 销毁阶段细节分析： 销毁方法的操作只适用于 scope=&quot;singleton&quot;，初始化操作没有这个要求。 销毁操作到底是什么？ 资源的释放：io.close()、connection.close()、… 对象的生命周期总结12345678910111213141516171819202122232425262728293031323334353637public class Product implements InitializingBean, DisposableBean &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println("Product.setName"); this.name = name; &#125; Product() &#123; // 创建 System.out.println("Product.Product"); &#125; // 程序员根据需求实现的方法, 完成初始化操作 public void myInit() &#123; System.out.println("Product.myInit"); &#125; // 程序员根据需求实现的方法, 完成初始化操作 @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("Product.afterPropertiesSet"); &#125; public void myDestory() &#123; System.out.println("Product.myDestory"); &#125; // 程序员根据⾃⼰的需求, 定义销毁方法, 完成销毁操作 @Override public void destroy() throws Exception &#123; System.out.println("Product.destroy"); &#125;&#125; 123&lt;bean id="product" class="com.Cro.life.Product" init-method="myInit" destroy-method="myDestory"&gt; &lt;property name="name" value="xiaoxiao"/&gt;&lt;/bean&gt; 配置文件参数化配置文件参数化：把 Spring 配置文件中需要经常修改的字符串信息，转移到⼀个更小的配置文件中。 Spring 的配置文件中是否存在需要经常修改的字符串？ 存在：以数据库连接相关的参数… 经常变化字符串，在 Spring 的配置文件中，直接修改不利于项目维护（修改） 转移到⼀个小的配置文件（.properties）利于维护（修改） 优点：利于 Spring 配置文件的维护（修改） 配置文件参数的开发步骤 提供⼀个小的配置文件（.properities） 名字：没有要求 放置位置：没有要求 1234jdbc.driverClassName = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/spring?useSSL=falsejdbc.username = rootjdbc.password = 1234 Spring 的配置文件与小配置文件进行整合： 123&lt;!--Spring的配置文件与⼩配置文件进行整合--&gt;&lt;!--resources 下的文件在整个程序编译完后会被放到 classpath 目录下，src.main.java中的文件也是--&gt;&lt;context:property-placeholder location="classpath:/db.properties"/&gt; 在 Spring 配置文件中通过 ${key} 获取小配置文件中对应的值： 123456&lt;bean id="conn" class="com.Cro.factorybean.ConnectionFactoryBean"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; 自定义类型转换器类型转换器作用：Spring 通过 类型转换器 把 配置文件 中 字符串 类型的数据，转换成了对象中成员变量对应类型的数据，进而完成了注入。 自定义类型转换器产生原因：当 Spring 内部没有提供特定类型转换器时，而程序员在应用的过程中还需要使用，那么就需要程序员⾃⼰定义类型转换器。(如:Spring 没有提供 Date 日期转换器) [开发步骤]： 类 implements Converter 接口（核心：接口回调） 12345678910111213141516171819202122public class MyDateConverter implements Converter&lt;String, Date&gt; &#123; /* convert方法作用: String ---&gt; Date SimpleDateFormat sdf = new SimpleDateFormat(); sdf.parset(String) ---&gt; Date 参数: source : 代表的是配置文件中, 日期字符串 &lt;value&gt;2020-10-11&lt;/value&gt; return : 当把转换好的 Date 作为 convert 方法的返回值后,Spring ⾃动的为birthday属性进行注入（赋值） */ @Override public Date convert(String source) &#123; Date date = null; try &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); date = sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 在 Spring 的配置文件中进行配置； 先创建 MyDateConverter 对象，再注册类型转换器； 123456789101112131415161718&lt;!--Spring 创建 MyDateConverter 对象--&gt;&lt;bean id="myDateConverter" class="com.Cro.converter.MyDateConverter"/&gt;&lt;!--目的：告知Spring框架，我们所创建的MyDateConverter是一个类型转换器--&gt;&lt;!--Spring 为我们提供用于注册类型转换器的类 ConversionServiceFactoryBean --&gt;&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; // set注入 &lt;set&gt; &lt;ref bean="myDateConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="person" class="com.Cro.converter.Person"&gt; &lt;property name="name" value="xiaoxiao"/&gt; &lt;property name="birthday" value="2020-11-11"/&gt;&lt;/bean&gt; 自定义类型转换器细节 MyDateConverter 中的日期的格式，通过 依赖注入 的方式，由配置文件完成赋值。 1234567891011121314151617181920212223public class MyDateConverter implements Converter&lt;String, Date&gt; &#123; private String pattern; @Override public Date convert(String source) &#123; Date date = null; try &#123; SimpleDateFormat sdf = new SimpleDateFormat(pattern); date = sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; public String getPattern() &#123; return pattern; &#125; public void setPattern(String pattern) &#123; this.pattern = pattern; &#125;&#125; 1234&lt;!-- 配置文件完成对日期格式的赋值 --&gt;&lt;bean id="myDateConverter" class="com.Cro.converter.MyDateConverter"&gt; &lt;property name="pattern" value="yyyy-MM-dd"/&gt;&lt;/bean&gt; ConversionSeviceFactoryBean 定义 id 属性，值必须是 conversionService； 1234567&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;ref bean="myDateConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; Spring 框架其实内置了日期类型的转换器：日期格式必须是 2020/05/01。 1234&lt;bean id="person" class="com.Cro.converter.Person"&gt; &lt;property name="name" value="xiaoxiao"/&gt; &lt;property name="birthday" value="2020/11/11"/&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-IOC]]></title>
    <url>%2F2020%2F08%2F05%2FSpring-IOC%2F</url>
    <content type="text"><![CDATA[反转控制 与 依赖注入反转控制（IOC Inverse of Control）反转控制（IOC Inverse of Control)，也称为 转移控制。 控制：对于成员变量赋值的控制权； 反转控制：把对于成员变量赋值的控制权，从代码中转移（反转）到 Spring ⼯⼚和配置⽂件中完成。 好处：解耦合； 底层实现：工厂设计模式； 依赖注入 (Dependency Injection - DI) 注⼊：通过 Spring 的⼯⼚及配置⽂件，为对象（bean，组件）的成员变量赋值； 依赖注⼊：当⼀个类需要另⼀个类时，就意味着依赖，⼀旦出现依赖，就可以把另⼀个类作为本类的成员变量，最终通过 Spring 配置⽂件进⾏注⼊（赋值）。 好处：解耦合； 分享Bromon的blog上对IoC与DI浅显易懂的讲解IoC(控制反转) 首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 DI(依赖注入) IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 Spring工厂创建复杂对象（3种方式）什么是复杂对象 简单对象：可以直接通过 new 构造方法创建的对象； 1234UserServiceUserDAOCustomerPerson 复杂对象：不能直接通过 new 构造方法创建的对象。 12ConnectionSqlSessionFactory 1. FactoryBean 接口实现 FactoryBean 接口：实现 getObject，getObjectType，isSingleton 方法； getObject()：用于书写创建复杂对象时的代码。 getObjectType()：返回创建的复杂对象的类型。 isSingleton：用于决定是否单例。 12345678910111213141516171819202122public class ConnectionFactoryBean implements FactoryBean&lt;Connection&gt; &#123; // 用于书写创建复杂对象时的代码 @Override public Connection getObject() throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring", "root", "1234"); return conn; &#125; // 返回创建的复杂对象的类型 @Override public Class&lt;Connection&gt; getObjectType() &#123; return Connection.class; &#125; // 是否单例 @Override public boolean isSingleton() &#123; return false; // 每一次都创建新的复杂对象 // return true; // 只创建一次这种类型的复杂对象 &#125;&#125; Spring 配置文件的配置：如果 class 中指定的类型是 FactoryBean 接⼝的实现类，那么通过 id 值获得的是这个类所创建的复杂对象。 比如下面 class 指定的是 ConnectionFactoryBean，获得的是 Connection 对象。 12&lt;!--class 指定了 ConnectionFactoryBean, 获得的是该类创建的复杂对象 Connection --&gt;&lt;bean id="conn" class="com.Cro.factorybean.ConnectionFactoryBean"/&gt; FactoryBean 细节 如果就想获得 FactoryBean类型的对象，加个 &amp;，ctx.getBean(&quot;&amp;conn&quot;) 1ConnectionFactoryBean cfb = (ConnectionFactoryBean) ctx.getBean("&amp;conn"); isSingleton（是否单例） 方法返回 true 只会创建⼀个复杂对象，返回 false 每⼀次都会创建新的对象； 需要根据这个对象的特点 ，决定是返回 true（SqlSessionFactory ） 还是 false（Connection）； mysql ⾼版本连接创建时，需要制定 SSL 证书，否则会警告； 解决方案：url = jdbc:mysql://localhost:3306/spring?useSSL=false 1Sat May 23 23:18:04 CST 2020 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 依赖注入（DI）：把 ConnectionFactoryBean 中依赖的 4 个字符串信息 ，通过配置⽂件进行注⼊。 12345678910111213141516171819202122@Getter@Setter // 提供 get set 方法public class ConnectionFactoryBean implements FactoryBean&lt;Connection&gt; &#123; // 将依赖的字符串信息变为成员变量, 利用配置文件进行注入。 private String driverClassName; private String url; private String username; private String password; @Override public Connection getObject() throws Exception &#123; Class.forName(driverClassName); Connection conn = DriverManager.getConnection(url, username, password); return conn; &#125; @Override public Class&lt;Connection&gt; getObjectType() &#123; return Connection.class; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125; 1234567&lt;!--体会依赖注入, 好处: 解耦合, 今后要修改连接数据库的信息只需要修改配置文件, 无需改动代码--&gt;&lt;bean id="conn" class="com.Cro.factorybean.ConnectionFactoryBean"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring?useSSL=false"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt;&lt;/bean&gt; FactoryBean 实现原理[简易版]原理：接口回调。 问题： 为什么 Spring 规定 FactoryBean 接口实现 getObject() 为什么 ctx.getBean(&quot;conn&quot;) 获得的是复杂对象 Connection 而非 ConnectionFactoryBean Spring 内部运行流程： 配置文件中通过 id conn 获得 ConnectionFactoryBean 类的对象 ，进而通过 instanceof 判断出是 FactoryBean 接⼝的实现类； Spring 按照规定 getObject() —-&gt; Connection； 返回 Connection； FactoryBean 总结Spring 中用于创建复杂对象的⼀种方式，也是 Spring 原生提供的，后续 Spring 整合其他框架时会⼤量应⽤ FactoryBean 方式。 2. 实例工厂 避免 Spring 框架的侵⼊； 整合遗留系统； [开发步骤]： ConnectionFactory 类（遗留系统） 123456789101112public class ConnectionFactory &#123; public Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring?useSSL=false", "root", "1234"); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; 配置文件： 12345&lt;!--实例工厂--&gt;&lt;!-- 先创建出工厂实例 --&gt;&lt;bean id="connFactory" class="com.Cro.factorybean.ConnectionFactory"/&gt; &lt;!-- 通过工厂实例里的方法创建复杂对象 --&gt;&lt;bean id="conn" factory-bean="connFactory" factory-method="getConnection"/&gt; 3. 静态工厂 避免 Spring 框架的侵⼊； 整合遗留系统； [开发步骤]： StaticConnectionFactory 类 12345678910111213public class StaticFactoryBean &#123; // 静态方法 public static Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/spring?useSSL=false", "root", "1234"); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; 配置文件： 12&lt;!--静态工厂--&gt;&lt;bean id="conn" class="com.yusael.Cro.StaticFactoryBean" factory-method="getConnection"/&gt; Spring工厂创建对象的总结 控制 Spring 工厂创建对象的次数1. 控制简单对象的创建次数配置文件中进行配置： sigleton：只会创建⼀次简单对象，默认值； prototype：每⼀次都会创建新的对象； 1234567&lt;!--控制简单对象创建次数--&gt;&lt;!--单例--&gt;&lt;bean id="scope" scope="singleton" class="com.Cro.scope.Scope"/&gt;&lt;!--每⼀次都会创建新的对象；&lt;bean id="scope" scope="prototype" class="com.Cro.scope.Scope"/&gt;--&gt; 2. 控制复杂对象的创建次数如果是 FactoryBean 方式创建的复杂对象： 1234567public class xxxFactoryBean implements FactoryBean &#123; public boolean isSingleton() &#123; return true; // 只会创建⼀次 // return false; // 每⼀次都会创建新的 &#125; // 省略其余实现方法......&#125; 如果是实例工厂或者静态工厂，没有 isSingleton ⽅法，与简单对象一样通过 scope 控制。 为什么要控制对象的创建次数？好处：节省不必要的内存浪费。 什么样的对象只创建⼀次？ 重量级的、可以被共用的、线程安全的… 1234SqlSessionFactoryDAOService...... 什么样的对象每⼀次都要创建新的？ 不能被共用的，线程不安全的… 1234ConnectionSqlSession | SessionStruts2 - Action......]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Spring]]></title>
    <url>%2F2020%2F08%2F05%2FSpring-%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[引言EJB（Enterprise Java Bean）存在的问题：EJB 是重量级的框架。 运行环境苛刻 代码移植性差 什么是 Spring?Spring是⼀个轻量级的 JavaEE 解决⽅案，整合众多优秀的设计模式。 什么是轻量级? 对于运⾏环境是没有额外要求的；开源：tomcat、resion、jetty收费：weblogic、websphere 代码移植性⾼：不需要实现额外接⼝。 JavaEE 的解决方案： 设计模式 ⼴义概念：⾯向对象设计中，解决特定问题的经典代码。 狭义概念：GOF4⼈帮定义的23种设计模式：⼯⼚、适配器、装饰器、⻔⾯、代理、模板… 工厂设计模式 概念：通过⼯⼚类，创建对象； 12User user = new User();UserDAO userDAO = new UserDAOImpl(); 好处：解耦合。 耦合：指定是代码间的强关联关系，⼀⽅的改变会影响到另⼀⽅；问题：不利于代码维护；简单：把接⼝的实现类，硬编码在程序中； 1UserService userService = new UserServiceImpl(); 简单工厂的设计 (反射+配置文件)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class BeanFactory &#123; private static Properties env = new Properties(); static&#123; try &#123; //第一步 获得IO输入流 InputStream inputStream = BeanFactory.class.getResourceAsStream("/applicationContext.properties"); //第二步 文件内容 封装 Properties集合中 key = userService value = com.baizhixx.UserServiceImpl env.load(inputStream); inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /* 对象的创建方式： 1. 直接调用构造方法 创建对象 UserService userService = new UserServiceImpl(); 2. 通过反射的形式 创建对象 解耦合 Class clazz = Class.forName("com.Cro.basic.UserServiceImpl"); UserService userService = (UserService)clazz.newInstance(); */ public static UserService getUserService() &#123; UserService userService = null; try &#123; //com.Cro.basic.UserServiceImpl Class clazz = Class.forName(env.getProperty("userService")); userService = (UserService) clazz.newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return userService; &#125; public static UserDAO getUserDAO()&#123; UserDAO userDAO = null; try &#123; Class clazz = Class.forName(env.getProperty("userDAO")); userDAO = (UserDAO) clazz.newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return userDAO; &#125;&#125; 配置文件 applicationContext.properties： 1234567# Properties 集合 存储 Properties文件的内容# 特殊Map key=String value=String# Properties [userService = com.Cro.xxx.UserServiceImpl]# Properties.getProperty(&quot;userService&quot;)userService = com.Cro.basic.UserServiceImpluserDAO = com.Cro.basic.UserDAOImpl 通用工厂的设计问题：简单工厂会存在⼤量的代码冗余。 通用工厂的代码： 12345678910111213141516171819202122232425262728293031323334import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class BeanFactory &#123; private static Properties env = new Properties(); static&#123; try &#123; //第一步 获得IO输入流 InputStream inputStream = BeanFactory.class.getResourceAsStream("/applicationContext.properties"); //第二步 文件内容 封装 Properties集合中 key = value env.load(inputStream); inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /* key 小配置文件中的key [userDAO,userService] */ public static Object getBean(String key)&#123; Object ret = null; try &#123; Class clazz = Class.forName(env.getProperty(key)); ret = clazz.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ret; &#125;&#125; 通用工厂的使用方式 定义类型 (类) 通过配置⽂件的配置告知⼯⼚applicationContext.properties 中 key = value； 通过⼯⼚获得类的对象Object ret = BeanFactory.getBean(&quot;key&quot;); 总结：Spring本质：工厂 ApplicationContext (applicationContext.xml) 第一个 Spring 程序环境搭建依赖查询网站：https://mvnrepository.com/； 配置 Spring 的 jar 包： 1234567891011&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring 的配置文件： 配置⽂件的放置位置：任意位置，没有硬性要求； 配置⽂件的命名 ：没有硬性要求，建议：applicationContext.xml； Spring 的核心APIApplicationContext 作用：Spring 提供的 ApplicationContext 这个工厂，用于对象的创建； 好处：解耦合 ApplicationContext 是接口类型； 接口：屏蔽实现的差异 非web环境 ：ClassPathXmlApplicationContext (main junit) web环境 ：XmlWebApplicationContext 重量级资源： ApplicationContext 工厂的对象占⽤⼤量内存。 不会频繁的创建对象 ，⼀个应用只会创建⼀个工厂对象。 ApplicationContext 工厂：⼀定是线程安全的(多线程并发访问)。 程序开发 创建类型：Person.java 1public class Person &#123;&#125; 配置文件的配置： 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- id属性 名字（唯一); class属性 配置全限定类名--&gt; &lt;bean id="person" class="com.Cro.basic.Person"/&gt;&lt;/beans&gt; 通过工厂类，获得对象 1234567891011/** * 用于测试Spring的第一个程序 */@Testpublic void test() &#123; // 1、获取spring的工厂 ApplicationContext ctx = new ClassPathXmlApplicationContext("/applicationContext.xml"); // 2、通过工厂类获得对象 Person person = (Person)ctx.getBean("person"); System.out.println(person);&#125; 细节分析名词解释：Spring 工厂创建的对象，叫做 bean 或者 组件(componet)； Spring 工厂的相关的方法getBean：传入 id 值 和 类名 获取对象，不需要强制类型转换。 123// 通过这种⽅式获得对象，就不需要强制类型转换Person person = ctx.getBean("person", Person.class);System.out.println("person = " + person); getBean：只指定类名，Spring 的配置文件中只能有一个 bean 是这个类型。 123// 使用这种方式的话, 当前Spring的配置文件中 只能有一个bean class是Person类型Person person = ctx.getBean(Person.class);System.out.println("person = " + person); getBeanDefinitionNames：获取 Spring 配置文件中所有的 bean 标签的 id 值。 12345// 获取的是Spring工厂配置文件中所有bean标签的id值 personString[] beanDefinitionNames = ctx.getBeanDefinitionNames();for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println("beanDefinitionName = " + beanDefinitionName);&#125; getBeanNamesForType：根据 类型 获得 Spring 配置文件中对应的 id 值。 12345// 根据类型获得Spring配置文件中对应的id值String[] beanNamesForType = ctx.getBeanNamesForType(Person.class);for (String id : beanNamesForType) &#123; System.out.println("id = " + id);&#125; containsBeanDefinition：用于判断是否存在指定 id 值的 bean，不能判断 name 值。 123456// 用于判断是否存在指定id值的bean,不能判断name值if (ctx.containsBeanDefinition("person")) &#123; System.out.println(true);&#125; else &#123; System.out.println(false);&#125; containsBean：用于判断是否存在指定 id 值的 bean，也可以判断 name 值。 123456// 用于判断是否存在指定id值的bean,也可以判断name值if (ctx.containsBean("p")) &#123; System.out.println(true);&#125; else &#123; System.out.println(false);&#125; 配置文件中的细节如果 bean 只配置 class 属性：1&lt;bean class="com.Cro.basic.Person"&gt;&lt;/bean&gt; 会自动生成一个 id，com.Cro.basic.Person#1 可以使用 getBeanNamesForType 验证。 应⽤场景： 如果这个 bean 只需要使⽤⼀次，那么就可以省略 id 值； 如果这个 bean 会使⽤多次，或者被其他 bean 引⽤则需要设置 id 值； name 属性： 作⽤：⽤于在 Spring 的配置⽂件中，为 bean 对象定义别名（小名） name 与 id 的相同点： ctx.getBean(&quot;id&quot;) 或 ctx.getBean(&quot;name&quot;) 都可以创建对象； &lt;bean id=&quot;person&quot; class=&quot;Person&quot;/&gt; 与 &lt;bean name=&quot;person&quot; class=&quot;Person&quot;/&gt;等效； name 与 id 的区别： 别名可以定义多个,但是 id 属性只能有⼀个值； XML 的 id 属性的值，命名要求：必须以字⺟开头，可以包含 字⺟、数字、下划线、连字符；不能以特殊字符开头 /person；XML 的 name 属性的值，命名没有要求，/person 可以。但其实 XML 发展到了今天：ID属性的限制已经不存在，/person也可以。 Spring工厂的底层实现原理(简易版)Spring工厂是可以调用对象私有的构造方法创建对象的(反射) 思考问题：未来在开发过程中，是不是所有的对象，都会交给 Spring ⼯⼚来创建呢？ 回答：理论上是的，但是有特例 ：实体对象(entity) 是不会交给Spring创建，它由持久层框架进⾏创建。 Spring5.x 与 日志框架 的整合Spring 与⽇志框架进⾏整合，⽇志框架就可以在控制台中，输出Spring框架运⾏过程中的⼀些重要的信息。 好处：便于了解Spring框架的运⾏过程，利于程序的调试。 默认日志框架 Spring 1.x、2.x、3.x 早期都是基于commonslogging.jar Spring 5.x 默认整合的⽇志框架 logback、log4j2 Spring 如何整合⽇志框架？ Spring5.x 整合 log4j： 引⼊ log4j.jar 包； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 引⼊log4.properties 配置⽂件； 123456789# resources文件夹根目录下### 配置根log4j.rootLogger = debug,console### 日志输出到控制台显示log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target=System.outlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n 注入(Injection)什么是注入？注入：通过 Spring 工厂及配置⽂件，为所创建对象的成员变量赋值。 为什么要注入？ 通过编码的⽅式，为成员变量进⾏赋值，存在耦合。 注入的好处：解耦合。 12345678public void test() &#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("/applicationContext.xml"); Person person = (Person) ctx.getBean("person"); // 通过代码为变量赋值, 存在耦合, 如果我们以后想修改变量的值, 需要修改代码, 重新编译 person.setId(1); person.setName("suns"); System.out.println(person);&#125; 如何进行注入[开发步骤] 为类的成员变量提供 set get ⽅法 配置 spring 的配置⽂件 12345678&lt;bean id="person" name="p" class="com.Cro.basic.Person"&gt; &lt;property name="id"&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;property name="name"&gt; &lt;value&gt;newsuns&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; Spring注入的原理分析(简易版)Spring 底层通过调用对象属性对应的 set 方法，完成成员变量的赋值，这种⽅式也称为 Set注入。 Set注入详解Set注入的变量类型： JDK内置类型 8种基本类型 + String、数组类型、set集合、list集合、Map计划和、Properties集合。 用户自定义类型 针对于不同类型的成员变量，在property标签中，需要嵌套其他标签: JDK内置类型String+8种基本类型123456&lt;property name="id"&gt; &lt;value&gt;10&lt;/value&gt;&lt;/property&gt;&lt;property name="name"&gt; &lt;value&gt;yusael&lt;/value&gt;&lt;/property&gt; 数组 1234567&lt;property name="emails"&gt; &lt;list&gt; &lt;value&gt;abc@qq.com&lt;/value&gt; &lt;value&gt;123@qq.com&lt;/value&gt; &lt;value&gt;hello@qq.com&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; Set集合 1234567&lt;property name="tels"&gt; &lt;set&gt; &lt;value&gt;13811111111&lt;/value&gt; &lt;value&gt;13911111111&lt;/value&gt; &lt;value&gt;13811111111&lt;/value&gt;&lt;!--set会自动去重--&gt; &lt;/set&gt;&lt;/property&gt; List集合 1234567&lt;property name="addresses"&gt; &lt;list&gt; &lt;value&gt;zpark&lt;/value&gt; &lt;value&gt;Earth&lt;/value&gt; &lt;value&gt;hell&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; Map集合 123456789101112&lt;property name="qqs"&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt;&lt;value&gt;hello&lt;/value&gt;&lt;/key&gt; &lt;value&gt;12312312312&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt;&lt;value&gt;world&lt;/value&gt;&lt;/key&gt; &lt;value&gt;21314214214&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; Properites(特殊的Map key = String,value = String) 1234567&lt;property name="p"&gt; &lt;props&gt; &lt;prop key="key1"&gt;value1&lt;/prop&gt; &lt;prop key="key2"&gt;value2&lt;/prop&gt; &lt;prop key="key3"&gt;value3&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 复杂JDK类型（Date、…） 需要程序员⾃定义类型转换器，处理。 用户自定义类型第一种方式[开发步骤]： 为成员变量提供 set get ⽅法 配置⽂件中进⾏注入（赋值） 12345&lt;bean id="userService" class="com.Cro.service.UserServiceImpl"&gt; &lt;property name="userDAO"&gt; &lt;bean class="com.Cro.dao.UserDAOImpl"/&gt; &lt;/property&gt;&lt;/bean&gt; 第二种方式第⼀种赋值⽅式存在的问题： 配置⽂件代码冗余； 被注入的对象 （UserDAO）多次创建，浪费(JVM)内存资源。 [开发步骤]： 为成员变量提供 set get ⽅法； 配置⽂件中进⾏配置； 1234567&lt;bean id="userDAO" class="com.Cro.service.UserDAOImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.Cro.dao.UserServiceImpl"&gt; &lt;property name="userDAO"&gt; &lt;ref bean="userDAO"/&gt; &lt;/property&gt;&lt;/bean&gt; Spring4.x 废除了 &lt;ref local=&quot;&quot;/&gt; 基本等效 &lt;ref bean=&quot;&quot;/&gt;； Set注入的简化基于属性的简化12345678JDK 类型注入&lt;property name="id"&gt; &lt;value&gt;10&lt;/value&gt;&lt;/property&gt;JDK类型注入简化：value 属性只能简化 8种基本类型 + String 注入标签；&lt;property name="id" value="10"/&gt; 1234567891011121314用户自定义类型注入&lt;bean id="userDAO" class="com.Cro.dao.UserDAOImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.Cro.service.UserServiceImpl"&gt; &lt;property name="userDAO"&gt; &lt;ref bean="userDAO"/&gt; &lt;/property&gt;&lt;/bean&gt;用户自定义类型注入简化&lt;bean id="userDAO" class="com.Cro.dao.UserDAOImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.Cro.service.UserServiceImpl"&gt; &lt;property name="userDAO" ref="userDAO"/&gt;&lt;/bean&gt; 基于p命名空间的简化12345678910111213JDK 类型注入&lt;bean id="person" name="p" class="com.Cro.basic.Person"&gt; &lt;property name="id"&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;property name="name"&gt; &lt;value&gt;xiaojr&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;JDK 类型注入 - 基于p命名空间的简化&lt;bean id="person" name="p" class="com.Cro.basic.Person" p:name="xiaojr" p:id="100"/&gt; 123456789101112用户自定义类型注入&lt;bean id="userDAO" class="com.Cro.dao.UserDAOImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.Cro.service.UserServiceImpl"&gt; &lt;property name="userDAO"&gt; &lt;ref bean="userDAO"/&gt; &lt;/property&gt;&lt;/bean&gt;用户自定义类型注入 - 基于p命名空间的简化。&lt;bean id="userDAO" class="com.Cro.dao.UserDAOImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.Cro.service.UserServiceImpl" p:userDAO-ref="userDAO"/&gt; 构造注入 注入：通过 Spring 的配置⽂件，为成员变量赋值； Set注入：Spring 调用 Set 方法 通过 配置⽂件 为成员变量赋值； 构造注入：Spring 调用 构造方法 通过 配置⽂件 为成员变量赋值； 开发步骤 提供有参构造⽅法 123456789public class Customer &#123; private String name; private int age; public Customer(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; spring 配置文件 12345678&lt;bean id="customer" class="com.Cro.constructor.Customer"&gt; &lt;constructor-arg&gt; &lt;value&gt;xiaoxiao&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg&gt; &lt;value&gt;21&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 构造方法重载参数个数不同 参数个数不同时，通过控制 &lt;constructor-arg&gt; 标签的数量进⾏区分； 如果只有一个参数的话，只需要一对 &lt;constructor-arg&gt; 标签： 12345&lt;bean id="customer" class="com.Cro.constructor.Customer"&gt; &lt;constructor-arg&gt; &lt;value&gt;xiaobai&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 构造参数个数相同时， 通过在标签引入 type 属性 进⾏类型的区分 &lt;constructor-arg type=&quot;&quot;&gt; 12345&lt;bean id="customer" class="com.Cro.constructor.Customer"&gt; &lt;constructor-arg type="int"&gt; &lt;value&gt;20&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 注入总结未来的实战中，应用 set注入 还是 构造注入？ 答：set 注入更多。 构造注入麻烦（重载） Spring 框架底层⼤量应用了 set注入。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring5.X</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode]]></title>
    <url>%2F2020%2F07%2F29%2FLeetcode%2F</url>
    <content type="text"><![CDATA[LeetCode_移动零 遇到 $0$ 跳过，遇到非 $0$ ，跟 $cur$ 位置交换，$cur++$ 12345678910111213class Solution &#123; public void moveZeroes(int[] nums) &#123; if (nums == null) return; for (int i = 0, cur = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) continue; if (cur != i) &#123; nums[cur] = nums[i]; nums[i] = 0; &#125; cur++; &#125; &#125;&#125; LeetCode_两数之和 利用 $hashmap$ 来存放之前扫描过的元素 时间复杂度 $O(n)$ 空间复杂度 $O(n)$ 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null) return null; // 用来存放之前扫描过的元素 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; Integer idx = map.get(target - nums[i]); if (idx != null) return new int[]&#123;idx, i&#125;; map.put(nums[i], i); &#125; return null; &#125;&#125; LeetCode_三数之和 排序 + 双指针 时间复杂度 $O(n^2)$ 空间复杂度 $O(1)$ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (nums == null) return null; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length &lt; 3) return res; // 排序 Arrays.sort(nums); // i用来扫描三元组的第一个元素 int lastIdx = nums.length - 3; int lastR = nums.length - 1; for (int i = 0; i &lt;= lastIdx; i++) &#123; // 去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int l = i + 1, r = lastR, remain = -nums[i]; while (l &lt; r) &#123; int sumLr = nums[l] + nums[r]; if (sumLr == remain) &#123; // 找到了符合条件的三元组 res.add(Arrays.asList(nums[i], nums[l], nums[r])); // 跳过相同的值（去重） while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; // 往中间逼近 l++; r--; &#125; else if (sumLr &lt; remain) &#123; l++; &#125; else &#123; // sumLr &gt; remain r--; &#125; &#125; &#125; return res; &#125;&#125; LeetCode_Pow(x,n) 最简单的做法 将 $n$ 个 $x$ 进行相乘 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 快速幂（分治） 时间复杂度：$O(logn)$ 非递归空间复杂度：$O(1)$ 递归空间复杂度：$O(logn)$ 递归$3^{20} = 3^{10} * 3^{10}$ $ 3^{21} = 3^{10} \ast 3^{10} \ast 3$ $ 3^{-20} = 3^{-10} * 3^{-10}$ $ 3^{-21} = 3^{-10} \ast 3^{-10} \ast 3^{-1}$ $ 3^{-21} = 3^{-11} \ast 3^{-11} \ast 3$ （当 $n$ 为负数是，$n &gt;&gt; 1$ 会向上取整） 12345678910class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1; if (n == -1) return 1 / x; double half = myPow(x, n &gt;&gt; 1); half *= half; // 是否为奇数 return ((n &amp; 1) == 1) ? (half * x) : half; &#125;&#125; 非递归$3^{21}$ $21 = (10101)_2$ $21 = (1 \ast 2^4) + (0 \ast 2^3) + (1 \ast 2^2) + (0 \ast 2^1) + (1 \ast 2^0)$ $3^{21} = 3^{(1 \ast 2^4) + (0 \ast 2^3) + (1 \ast 2^2) + (0 \ast 2^1) + (1 \ast 2^0)}$ $3^{21} = 3^{1 \ast 2^4} \ast 3^{0 \ast 2^3} \ast 3^{1 \ast 2^2} \ast 3^{0 \ast 2^1} \ast 3^{1 \ast 2^0}$ $3^{2^1} = 3^{2^0} \ast 3^{2^0} = 3 ^ 1 \ast 3^1 = 3^2$ $3^{2^2} = 3^{2^1} \ast 3^{2^1} = 3^2 \ast 3^2 = 3^4$ $3^{2^3} = 3^{2^2} \ast 3^{2^2} = 3^4 \ast 3^4 = 3^8$ $3^{2^4} = 3^{2^3} \ast 3^{2^3} = 3^8 \ast 3^8 = 3^{16}$ 12345678910111213141516class Solution &#123; public double myPow(double x, int n) &#123; long y = (n &lt; 0) ? -((long) n) : n; double res = 1.0; while (y &gt; 0) &#123; if ((y &amp; 1) == 1) &#123; // 如果最后一个二进制位是1，就累乘上x res *= x; &#125; x *= x; // 舍弃掉最后一个二进制位 y &gt;&gt;= 1; &#125; return (n &lt; 0) ? (1 / res) : res; &#125;&#125; 快速幂补充请设计一个算法求 $x$ 的 $y$ 次幂模 $z$ 的结果：$x^y\%z$ 假设 $x、y$ 都可能是很大的整数 $y \geq 0,z \neq 0$ 公式须知 $(a \ast b) \% p == ((a \% p) \ast (b \% p)) \% p$ 12345678910111213141516171819202122232425262728293031// 非递归public static int powMod(int x, int y, int z) &#123; if (y &lt; 0 || z == 0) return 0; int res = 1 % z; x %= z; while (y &gt; 0) &#123; if ((y &amp; 1) == 1) &#123; // 如果最后一个二进制位是1，就累乘上x res = (res * x) % z; &#125; x = (x * x) % z; // 舍弃掉最后一个二进制位 y &gt;&gt;= 1; &#125; return res;&#125;// 递归// 2^100 % 6 = (2^50 * 2^50) % 6 = ((2^50 % 6) * (2^50 % 6)) % 6// 2^101 % 6 = (2^50 * 2^50 * 2) % 6 = ((2^50 % 6) * (2^50 % 6) * (2 % 6)) % 6public static int powMod(int x, int y, int z) &#123; if (y &lt; 0 || z == 0) return 0; if (y == 0) return 1 % z; int half = powMod(x, y &gt;&gt; 1, z); half *= half; if ((y &amp; 1) == 0) &#123; // 偶数 return half % z; &#125; else &#123; // 奇数 return (half * (x % z)) % z; &#125;&#125; LeetCode_圆圈中最后剩下的数字 计算公式：$f(n,m) = (f(n-1,m) + m) \% n$ 这其实就是著名的约瑟夫环问题 有 $n$ 个人，编号分别为 $0、1、…、n-1$ ，每当报数到第 $m$ 个人时，就杀掉他，求最后胜利者编号 公式推导 $f(11,3) == 6$ 从 $A$ 开始报数，最后能活下来的是 $G$ 从 $A$ 开始报数，杀掉 $C$ 之后，剩下 $10$ 个人，接下来从 $D$ 开始报数，最后能活下来的依然是 $G$ 从 $11$ 人变为 $10$ 人，胜利者的编号由 $6$ 变为 $3$，所以 $f(10,3) = f(11,3) -3$ 也就是说 $f(11,3) = f(10,3) + 3$ 通用结论：$f(n,m) = (f(n-1,m) + m) \% n$ 最后的 $\%n$ 是为了防止索引越界 123456789class Solution &#123; public int lastRemaining(int n, int m) &#123; int res = 0; for (int i = 2; i &lt;= n; i++) &#123; res = (res + m) % i; &#125; return res; &#125;&#125; LeetCode_螺旋矩阵 遍历顺序：黄蓝绿紫（一圈一圈遍历） 当 $top &gt; bottom || left &gt; right$ 退出循环 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; if (matrix == null) return null; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (matrix.length == 0) return res; int top = 0; int bottom = matrix.length - 1; int left = 0; int right = matrix[0].length - 1; while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123; // left top -&gt; right top for (int i = left; i &lt;= right; i++) &#123; res.add(matrix[top][i]); &#125; top++; // right top -&gt; right bottom for (int i = top; i &lt;= bottom; i++) &#123; res.add(matrix[i][right]); &#125; right--; // 奇数行、偶数列的时候有问题 if (top &gt; bottom || left &gt; right) break; // right bottom -&gt; left bottom for (int i = right; i &gt;= left; i--) &#123; res.add(matrix[bottom][i]); &#125; bottom--; // left bottom -&gt; left top for (int i = bottom; i &gt;= top; i--) &#123; res.add(matrix[i][left]); &#125; left++; &#125; return res; &#125;&#125; LeetCode_LRU缓存机制$LRU（Least Recently Used）$：最近最少使用、最近最久未使用 是操作系统常用的一种页面置换算法，选择最近最久未使用的页面予以淘汰 $LRUCache$ 的常见实现方式是：哈希表 + 双向链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class LRUCache &#123; private Map&lt;Integer, Node&gt; map; private int capacity; // 虚拟头结点 private Node first; // 虚拟尾结点 private Node last; public LRUCache(int capacity) &#123; map = new HashMap&lt;&gt;(capacity); this.capacity = capacity; first = new Node(); last = new Node(); first.next = last; last.prev = first; &#125; public int get(int key) &#123; Node node = map.get(key); if (node == null) return -1; removeNode(node); addAfterFirst(node); return node.value; &#125; /** * @param node 将node节点插入到first节点的后面 */ private void addAfterFirst(Node node) &#123; // node与first.next node.next = first.next; first.next.prev = node; // node与first first.next = node; node.prev = first; &#125; /** * @param node 从双向链表中删除node节点 */ private void removeNode(Node node) &#123; node.next.prev = node.prev; node.prev.next = node.next; &#125; public void put(int key, int value) &#123; Node node = map.get(key); if (node != null) &#123; node.value = value; removeNode(node); &#125; else &#123; // 添加一对新的key-value if (map.size() == capacity) &#123; // 淘汰最近最少使用的node\ removeNode(map.remove(last.prev.key));// map.remove(last.prev.key);// removeNode(last.prev); &#125; map.put(key, node = new Node(key, value)); &#125; addAfterFirst(node); &#125; private static class Node &#123; public int key; public int value; public Node prev; public Node next; public Node(int key, int value) &#123; this.key = key; this.value = value; &#125; public Node() &#123;&#125; &#125;&#125; LeetCode_整数反转 12345678910111213class Solution &#123; public int reverse(int x) &#123; int res = 0; while (x != 0) &#123; int prevRes = res; int mod = x % 10; res = prevRes * 10 + mod; if ((res - mod) / 10 != prevRes) return 0; x /= 10; &#125; return res; &#125;&#125; LeetCode_会议室 123456789101112131415class Solution &#123; public boolean canAttendMeetings(int[][] intervals) &#123; if (intervals == null || intervals.length == 0) return true; // 按照会议的开始时间，从小到大排序 Arrays.sort(intervals, (m1, m2) -&gt; m1[0] - m2[0]); // 遍历每一个会议 for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[i][0] &lt; intervals[i - 1][1]) return false; &#125; return true; &#125;&#125; LeetCode_会议室 ll 最小堆最小堆（存放每一个会议的结束时间） 12345678910111213141516171819202122232425class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; if (intervals == null || intervals.length == 0) return 0; // 按照会议的开始时间，从小到大排序 nlogn Arrays.sort(intervals, (m1, m2) -&gt; m1[0] - m2[0]); // 创建一个最小堆（存放每一个会议的结束时间） PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); // 添加0号会议的结束时间 heap.add(intervals[0][1]); // 堆顶的含义：目前占用的会议室中最早结束的时间 for (int i = 1; i &lt; intervals.length; i++) &#123; // nlogn // i号会议的开始时间 &gt;= 堆顶 if (intervals[i][0] &gt;= heap.peek()) &#123; heap.remove(); &#125; // 将i号会议的结束时间加入堆中 heap.add(intervals[i][1]); &#125; return heap.size(); &#125;&#125; 分开排序 12345678910111213141516171819202122232425262728class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; if (intervals == null || intervals.length == 0) return 0; // 存放所有会议的开始时间 int[] begins = new int[intervals.length]; // 存放所有会议的结束时间 int[] ends = new int[intervals.length]; for (int i = 0; i &lt; intervals.length; i++) &#123; begins[i] = intervals[i][0]; ends[i] = intervals[i][1]; &#125; // 排序 Arrays.sort(begins); Arrays.sort(ends); int room = 0, endIdx = 0; for (int begin : begins) &#123; if (begin &gt;= ends[endIdx]) &#123; // 能重复利用会议室 endIdx++; &#125; else &#123; // 需要新开一个会议室 room++; &#125; &#125; return room; &#125;&#125; LeetCode_盛最多水的容器 双指针，$l,r$ 向中间逼近 $height[l] &lt;= height[r]$ 时，$l++$ $height[l] &gt; height[r]$ 时，$r—$ 1234567891011121314151617181920class Solution &#123; public int maxArea(int[] height) &#123; if (height == null || height.length == 0) return 0; int l = 0, r = height.length - 1, water = 0; while (l &lt; r) &#123; if (height[l] &lt;= height[r]) &#123; int minH = height[l]; water = Math.max(water, (r - l) * minH); // 跳过比当前左右最小高度还小的 while (l &lt; r &amp;&amp; height[l] &lt;= minH) l++; &#125; else &#123; int minH = height[r]; water = Math.max(water, (r - l) * minH); while (l &lt; r &amp;&amp; height[r] &lt;= minH) r--; &#125; &#125; return water; &#125;&#125; LeetCode_接雨水 二维数组 $(O(n) O(n))$1234567891011121314151617181920212223242526272829class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) return 0; int lastIdx = height.length - 2; int[] leftMaxes = new int[height.length]; for (int i = 1; i &lt;= lastIdx; i++) &#123; leftMaxes[i] = Math.max(leftMaxes[i - 1], height[i - 1]); &#125; int[] rightMaxes = new int[height.length]; for (int i = lastIdx; i &gt;= 1; i--) &#123; rightMaxes[i] = Math.max(rightMaxes[i + 1], height[i + 1]); &#125; // 遍历每一根柱子，看看每一根柱子上能放多少水 int water = 0; for (int i = 1; i &lt;= lastIdx; i++) &#123; // 求出左边最大、右边最大中的较小者 int min = Math.min(leftMaxes[i], rightMaxes[i]); // 说明这根柱子不能放水 if (min &lt;= height[i]) continue; // 说明这根柱子能放水 water += min - height[i]; &#125; return water; &#125;&#125; 一维数组 $(O(n) O(n))$123456789101112131415161718192021222324252627class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) return 0; int lastIdx = height.length - 2; // 动态优化 计算出每根柱子右边的最大值 int[] rightMaxes = new int[height.length]; for (int i = lastIdx; i &gt;= 1; i--) &#123; rightMaxes[i] = Math.max(rightMaxes[i + 1], height[i + 1]); &#125; // 遍历每一根柱子，看看每一根柱子上能放多少水 int water = 0, leftMax = 0; for (int i = 1; i &lt;= lastIdx; i++) &#123; leftMax = Math.max(leftMax, height[i - 1]); // 求出左边最大、右边最大中的较小者 int min = Math.min(leftMax, rightMaxes[i]); // 说明这根柱子不能放水 if (min &lt;= height[i]) continue; // 说明这根柱子能放水 water += min - height[i]; &#125; return water; &#125;&#125; 最优实现 $(O(n) O(1))$ 1234567891011121314151617class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) return 0; int l = 0,r = height.length - 1,lowerMax = 0,water = 0; while (l &lt; r) &#123; // height[l]、height[r] 中较小的那个 // 如果 l++ 右边高度有比左边大或等于 int lower = height[height[l] &lt;= height[r] ? l++ : r--]; // 目前为止遇到的最大的 lower lowerMax = Math.max(lowerMax,lower); water += lowerMax - lower; &#125; return water; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_DFS]]></title>
    <url>%2F2020%2F07%2F29%2FLeetcode-DFS%2F</url>
    <content type="text"><![CDATA[LeetCode_电话号码的字母组合 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; private char[][] lettersArray = &#123; &#123;'a', 'b', 'c'&#125;, &#123;'d', 'e', 'f'&#125;, &#123;'g', 'h', 'i'&#125;, &#123;'j', 'k', 'l'&#125;, &#123;'m', 'n', 'o'&#125;, &#123;'p', 'q', 'r', 's'&#125;, &#123;'t', 'u', 'v'&#125;, &#123;'w', 'x', 'y', 'z'&#125; &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits == null) return null; List&lt;String&gt; list = new ArrayList&lt;&gt;(); char[] chars = digits.toCharArray(); if (chars.length == 0) return list; char[] string = new char[chars.length]; dfs(0, chars, string, list); return list; &#125; /** * @param idx 正在搜索第idx层 */ private void dfs(int idx, char[] chars, char[] string, List&lt;String&gt; list) &#123; // 已经进入到最后一层了，不能再往下搜索 if (idx == chars.length) &#123; // 得到了一个正确的解 list.add(new String(string)); return; &#125; // 先枚举这一层可以做的所有选择 char[] letters = lettersArray[chars[idx] - '2']; for (char letter : letters) &#123; string[idx] = letter; dfs(idx + 1, chars, string, list); &#125; &#125;&#125; LeetCode_全排列 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (nums == null) return null; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (nums.length == 0) return list; dfs(0, nums, list); return list; &#125; /** * @param idx 正在搜索第idx层 */ private void dfs(int idx, int[] nums, List&lt;List&lt;Integer&gt;&gt; list) &#123; // 不能再往下搜索 if (idx == nums.length) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int value : nums) &#123; result.add(value); &#125; list.add(result); return; &#125; // 枚举这一层所有可以做出的选择 for (int i = idx; i &lt; nums.length; i++) &#123; swap(nums, idx, i); dfs(idx + 1, nums, list); // 恢复现场 swap(nums, idx, i); &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125; LeetCode_全排列 II保证一个数字在 $idx$ 位置只会出现一次 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; if (nums == null) return null; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (nums.length == 0) return list; dfs(0, nums, list); return list; &#125; /** * @param idx 正在搜索第idx层 */ private void dfs(int idx, int[] nums, List&lt;List&lt;Integer&gt;&gt; list) &#123; // 不能再往下搜索 if (idx == nums.length) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int value : nums) &#123; result.add(value); &#125; list.add(result); return; &#125; // 枚举这一层所有可以做出的选择 for (int i = idx; i &lt; nums.length; i++) &#123; // 要保证一个数字在idx位置只会出现一次 if (isRepeat(nums, idx, i)) continue; swap(nums, idx, i); dfs(idx + 1, nums, list); swap(nums, idx, i); &#125; &#125; private boolean isRepeat(int[] nums, int idx, int i) &#123; for (int j = idx; j &lt; i; j++) &#123; if (nums[j] == nums[i]) return true; &#125; return false; &#125; private void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125; LeetCode_括号生成 左右括号的选择情况 左括号的数量 $&gt; 0$ 当左括号、右括号的数量一样时，只能选择左括号 (右括号的数量 $&gt;0$ ) &amp;&amp; (右括号的数量 $!=$ 左括号的数量) ，才能选右括号 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (n &lt; 0) return list; dfs(0, n, n, new char[n &lt;&lt; 1], list); return list; &#125; /** * * @param idx 搜索的层号 * @param leftRemain 左括号的剩余数量 * @param rightRemain 右括号的剩余数量 * @param string 用来存放每一层的选择 */ private void dfs(int idx, int leftRemain, int rightRemain, char[] string, List&lt;String&gt; list) &#123; if (idx == string.length) &#123; list.add(new String(string)); return; &#125; // 枚举这一层所有可能的选择 // 选择一种可能之后，进入下一层搜索 // 什么情况可以选择左括号？左括号的数量 &gt; 0 // 选择左括号，然后进入下一层搜索 if (leftRemain &gt; 0) &#123; string[idx] = '('; dfs(idx + 1, leftRemain - 1, rightRemain, string, list); &#125; // 当左括号、右括号的数量一样时，只能选择左括号 // 什么情况可以选择右括号？(右括号的数量 &gt; 0) &amp;&amp; (右括号的数量 != 左括号的数量) // 选择右括号，然后进入下一层搜索 if (rightRemain &gt; 0 &amp;&amp; leftRemain != rightRemain) &#123; string[idx] = ')'; dfs(idx + 1, leftRemain, rightRemain - 1, string, list); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-树]]></title>
    <url>%2F2020%2F07%2F28%2FLeetcode-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[LeetCode_二叉树的最近公共祖先 去以 $root$ 为根节点的二叉树中查找 $p、q$ 的最近公共祖先 ① 如果 $p、q$ 同时存在于这棵二叉树中，就能成功返回它们的最近公共祖先 ② 如果 $p、q$ 都不存在于这棵二叉树中，返回 $null$ ③ 如果只有 $p$ 存在于这棵二叉树中，返回 $p$ ④ 如果只有 $q$ 存在于这棵二叉树中，返回 $q$ 1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; // 去以root.left为根节点的二叉树中查找p、q的最近公共祖先 TreeNode left = lowestCommonAncestor(root.left, p, q); // 去以root.right为根节点的二叉树中查找p、q的最近公共祖先 TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) return root; return (left != null) ? left : right; &#125;&#125; LeetCode_恢复二叉搜索树 中序遍历的结果分别为 $11、17、18、$$28、22$$、37、42、44、62$ $11、17、$$44$$、22、28、37、42、$$18$$、62$ 第 $1$ 个错误节点：第 $1$ 个逆序对中的较大节点 第 $2$ 个错误节点：最后 $1$ 个逆序对中的较小节点 递归实现$（O(n)、O(n)）$123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; /** * 上一次中序遍历过的节点 */ private TreeNode prev; /** * 第一个错误节点 */ private TreeNode first; /** * 第二个错误节点 */ private TreeNode second; private void find(TreeNode node) &#123; // 出现了逆序对 if (prev != null &amp;&amp; prev.val &gt; node.val) &#123; // 第2个错误节点：最后一个逆序对中较小的那个节点 second = node; // 第1个错误节点：第一个逆序对中较大的那个节点 if (first != null) return; first = prev; &#125; prev = node; &#125; public void recoverTree(TreeNode root) &#123; findWrongNodes(root); // 交换2个错误节点的值 int tmp = first.val; first.val = second.val; second.val = tmp; &#125; private void findWrongNodes(TreeNode root) &#123; if (root == null) return; findWrongNodes(root.left); find(root); findWrongNodes(root.right); &#125;&#125; $Morris$ 实现中序遍历$（O(n)、O(1)）$使用 $Morris$ 方法遍历二叉树，可以实现时间复杂度 $O(n)$ 、空间复杂度 $O(1)$ 执行步骤（假设遍历到当前节点是 $N$） ① 如果 $N.left != NULL$，找到 $N$ 的前驱节点 $P$ 如果 $P.right == NULL$ $P.right = N$ （添加图中红线） $N = N.left$ 回到 ① 如果 $P.right == N$ $P.right = NULL $ （删除图中红线） 打印 $N$ （找到该值，执行你所需要的操作） $N = N.right$ 回到 ① ② 如果 $N.left == NULL$ ​ 打印 $N$ ​ $N = N.right$ ​ 回到 ① ③ 重复①、②直到 $N == NULL$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123; // 中序遍历：时间复杂度O(n)、空间复杂度O(1) /** * 上一次中序遍历过的节点 */ private TreeNode prev; /** * 第一个错误节点 */ private TreeNode first; /** * 第二个错误节点 */ private TreeNode second; private void find(TreeNode node) &#123; // 出现了逆序对 if (prev != null &amp;&amp; prev.val &gt; node.val) &#123; // 第2个错误节点：最后一个逆序对中较小的那个节点 second = node; // 第1个错误节点：第一个逆序对中较大的那个节点 if (first != null) return; first = prev; &#125; prev = node; &#125; public void recoverTree(TreeNode root) &#123; TreeNode node = root; while (node != null) &#123; if (node.left != null) &#123; // 找到前驱节点(predecessor)、后继节点(successor) TreeNode pred = node.left; while (pred.right != null &amp;&amp; pred.right != node) &#123; pred = pred.right; &#125; if (pred.right == null) &#123; pred.right = node; node = node.left; &#125; else &#123; // pred.right == node find(node); pred.right = null; node = node.right; &#125; &#125; else &#123; find(node); node = node.right; &#125; &#125; // 交换2个错误节点的值 int tmp = first.val; first.val = second.val; second.val = tmp; &#125;&#125; LeetCode_最大BST子树 自顶向下 1public int largestBSTSubtree(TreeNode root); $largestBSTSubtree$ 的作用：返回以 $root$ 为根节点的二叉树的最大 $BST$ 子树的节点数量 $largestBSTSubtree$ 的实现： 如果以 $root$ 为根节点的二叉树 $S$ 是 $BST$ ,就返回 $S$ 的节点数量 否则，就返回 $largestBSTSubtree(root.left)、largestBSTSubtree(root.right)$ 中的最大值 时间复杂度分析 $largestBSTSubtree$ 使用了前序遍历，时间复杂度是 $O(n)$ 判断一棵树是否为 $BST$，时间复杂度是 $O(n)$ 所以，总体时间复杂度是 $O(n^2)$ 如何优化？ 由于是自顶向下的遍历方式，所以在判断一棵树是否为 $BST$ 方面，存在重复的遍历判断 可以考虑改为自底向上的遍历方式：后序遍历 自底向上 1public int getInfo(TreeNode root); $getInfo$ 的作用：返回以 $root$ 为根节点的二叉树的最大 $BST$ 子树的信息 $getInfo$ 的实现： 计算 $li = getInfo(root.left),ri = getInfo(root.right)$ 如果下面的条件成立，说明以 $root$ 为根节点的二叉树就是最大 $BST$ 子树 $li == null || (li.root == root.left$ $\&amp;$ $\&amp;$ $li.max &lt; root.val)$ $ri == null || (ri.root == root.right$ $\&amp;$ $\&amp;$ $li.max &gt; root.val$ 如果 $li != null$ $\&amp;$ $\&amp;$ $ri != null$ 如果 $li.size &gt; ri.size$ ，返回 $li$ ；否则返回 $ri$ 如果 $li != null$ ，返回 $li$ ；否则返回 $ri$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution&#123; public int largestBSTSubtree(TreeNode root) &#123; return (root == null) ? 0 : getInfo(root).size; &#125; /** * 返回以root为根节点的二叉树的最大BST子树信息 * @param root * @return */ private Info getInfo(TreeNode root) &#123; if (root == null) return null; // li(left info)：左子树的最大BST子树信息 Info li = getInfo(root.left); // ri(right info)：右子树的最大BST子树信息 Info ri = getInfo(root.right); /* 有4种情况，以root为根节点的二叉树就是一棵BST，最大BST子树就是其本身 ① li != null &amp;&amp; ri != null &amp;&amp; li.root == root.left &amp;&amp; root.val &gt; li.max &amp;&amp; ri.root == root.right &amp;&amp; root.val &lt; ri.min ② li != null &amp;&amp; ri == null &amp;&amp; li.root == root.left &amp;&amp; root.val &gt; li.max ③ li == null &amp;&amp; ri != null &amp;&amp; ri.root == root.right &amp;&amp; root.val &lt; ri.min ④ li == null &amp;&amp; ri == null */ int leftBstSize = -1, rightBstSize = -1, max = root.val, min = root.val; if (li == null) &#123; leftBstSize = 0; &#125; else if (li.root == root.left &amp;&amp; root.val &gt; li.max) &#123; leftBstSize = li.size; min = li.min; &#125; if (ri == null) &#123; rightBstSize = 0; &#125; else if (ri.root == root.right &amp;&amp; root.val &lt; ri.min) &#123; rightBstSize = ri.size; max = ri.max; &#125; if (leftBstSize &gt;= 0 &amp;&amp; rightBstSize &gt;= 0) &#123; return new Info(root, 1 + leftBstSize + rightBstSize, max, min); &#125; // 以root为根节点的二叉树并不是BST // 返回最大BST子树的节点数量较多的那个Info if (li != null &amp;&amp; ri != null) return (li.size &gt; ri.size) ? li : ri; // 返回li、ri中不为null的那个Info return (li != null) ? li : ri; &#125; // 最大BST子树的信息 private static class Info &#123; /** 根节点 */ public TreeNode root; /** 节点总数 */ public int size; /** 最大值 */ public int max; /** 最小值 */ public int min; public Info(TreeNode root, int size, int max, int min) &#123; this.root = root; this.size = size; this.max = max; this.min = min; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-动态规划]]></title>
    <url>%2F2020%2F07%2F27%2FLeetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[LeetCode_礼物的最大价值 假设 $dp[row][col]$ 是走到 $[row][col]$ 位置时的最大价值 走到 $[row][col]$ 位置有 $2$ 种可能 从 $[row][col-1]$ 位置往右走 从 $[row - 1][col]$位置往下走 所以 $dp[row][col] = max(dp[row][col-1],dp[row-1][col]) + grid[row][col]$ 1234567891011121314151617181920212223class Solution &#123; public int maxValue(int[][] grid) &#123; int rows = grid.length; int cols = grid[0].length; int[][] dp = new int[rows][cols]; dp[0][0] = grid[0][0]; // 第0行 for (int col = 1; col &lt; cols; col++) &#123; dp[0][col] = dp[0][col - 1] + grid[0][col]; &#125; // 第0列 for (int row = 1; row &lt; rows; row++) &#123; dp[row][0] = dp[row - 1][0] + grid[row][0]; &#125; for (int row = 1; row &lt; rows; row++) &#123; for (int col = 1; col &lt; cols; col++) &#123; dp[row][col] = Math.max(dp[row - 1][col], dp[row][col - 1]) + grid[row][col]; &#125; &#125; return dp[rows - 1][cols - 1]; &#125;&#125; 将二维数组优化成一维数组 举例：当计算 $grid[1][1]$ 时，一维数组中保存的组就是红圈中的值 12345678910111213141516171819202122232425class Solution &#123; public int maxValue(int[][] grid) &#123; int rows = grid.length; int cols = grid[0].length; int[] dp = new int[cols]; dp[0] = grid[0][0]; for (int row = 0; row &lt; rows; row++) &#123; for (int col = 0; col &lt; cols; col++) &#123; // 0行的处理 grid[0][0]跳过 if (row == 0 &amp;&amp; col &gt; 0)&#123; dp[col] = dp[col-1] + grid[row][col]; &#125;else if (col == 0 &amp;&amp; row &gt; 0)&#123; // 0列的处理 grid[0][0]跳过 dp[col] = dp[col] + grid[row][col]; &#125;else if (row &gt; 0 &amp;&amp; col &gt; 0)&#123; // 先将原先的 dp[col] 与dp[col-1] 比较，再重新将 dp[col] 赋值 dp[col] = Math.max(dp[col-1], dp[col]) + grid[row][col]; &#125; &#125; &#125; return dp[cols - 1]; &#125;&#125; LeetCode_买卖股票的最佳时机 第 $i$ 天买，第 $j$ 天卖的利润是 第 $i - j$ 天内，所有相邻两天股价差的和 举例：第 $1$ 天买，第 $4$ 天卖的利润是 $(6-3) + (3-5) + (5-1) == 6-1 == 5$ 于是，转化为了求【最大子数组和】的问题 也就是求【最大连续子序列和】的问题 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; // 前面扫描过的最小价格 int minPrice = prices[0]; // 前面扫描过的最大利润 int maxProfit = 0; // 扫描所有的价格 for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minPrice) &#123; minPrice = prices[i]; &#125; else &#123; // 把第i天的股票卖出 maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; &#125; return maxProfit; &#125;&#125; LeetCode_编辑距离 假设 $dp[i][j]$ 字符串 $（”mice”）$为 $s1$ ，它的长度为 $n1$ ；字符串 $（”arise”）$为 $s2$ ，它的长度为 $n2$ $dp$ 是大小为 $(n1+1) * (n2 + 1)$ 的二维数组 $dp[i][j]$ 是 $s1[0,i)$ 转换成 $s2[0,j)$ 的最少操作数 $s1[0,i)$ 是由 $s1$ 的前 $i$ 个字符组成的子串（区间，如：$s1[0,2)mic$ 转换成 $s2[0,3)aris$） $s2[0,j)$ 是由 $s2$ 的前 $j$ 个字符组成的子串 很显然， $dp[n1][n2]$ 就是 $s1[0,n1)$ 转换成 $s2[0,n2)$ 的最少操作数 也就是 $s1$ 转换成 $s2$ 的最少操作数 求出 $dp[i][j]$ 边界 最左上角的 $dp[0][0]$ ：代表 $s1$ 的空子串转换为 $s2$ 的空子串的最少操作数 其实就是什么也不用做，所以：$dp[0][0] = 0$ 第 $0$ 列的 $dp[i][0]$ ：代表 $s1[0,i)$ 转换为 $s2$ 的空子串的最少操作数 其实就是删除 $s1[0,i)$ 的所有字符，所以： $dp[i][0] = i$ 第 $0$ 行的 $dp[0][j]$：代表 $s1$ 的空子串转换为 $s2[0,j)$ 的最少操作数 其实就是插入 $s2[0,j)$ 的所有字符，所以：$dp[0][j] = j$ 求出其他位置的 $dp[i][j]$ $dp[i][j]$ 是 $s1[0,i)$ 转换成 $s2[0,j)$ 的最少操作数 可以分$4$ 种情况讨论 ① 先删除 $s1[0,i)$ 的最后一个字符得到 $s1[0, i - 1)$ ​ 然后由 $s1[0,i - 1)$ 转换为 $s2[0,j)$ ​ 这种情况下，$dp[i][j] = 1 + dp[i - 1][j]$ ​ 举例：$s1[0,3) mic$ 转换成 $s2[0,3)ari$ $s1[0,3)mic$ 删除最后一个字符 $s1[0,2)mi$（操作 $1$ ） $s1[0,2)mi$ 再转换成 $s2[0,3)ari$（操作 $dp[i-1][j]$） ② 先由 $s1[0,i)$ 转换为 $s2[0,j - 1)$ ，然后在最后插入字符 $s2[j-1]$ ，得到 $s2[0,j)$ ​ 这种情况下，$dp[i][j] = dp[i][j - 1] + 1$ ​ 举例：$s1[0,3) mic$ 转换成 $s2[0,3)ari$ $s1[0,3)mic$ 转换成 $s2[0,2)ar$（操作 $dp[i][j-1]$） $s2[0,2)ar$ 插入一个字符，得到 $s2[0,3)ari$（操作 $1$ ） 情况③ 和④ 是比较最后一个字符是否相等，相等不用操作，不相等只需一个替换操作 ③ 如果 $s1[i - 1] != s2[j - 1]$，先由 $s1[0,i - 1)$ 转换为 $s2[0,j - 1)$ ​ 然后将 $s1[i-1]$ 替换为 $s2[j - 1]$，这种情况下，$dp[i][j] = dp[i-1][j-1] + 1$ ​ 举例：$s1[0,3) mic$ 转换成 $s2[0,3)ari$ $s1[1]i$ $!= s2[1]r$ ，$s1[0,2)mi$ 转换为 $s2[0,2)ar$ (操作 $dp[i-1][j-1]$ ) $s1[2]c$ 转换为 $s2[2]i$ (操作 $1$ ) ④ 如果 $s1[i - 1] == s2[j - 1]$，由 $s1[0,i - 1)$ 转换为 $s2[0,j-1)$ 后就不用再做任何操作 ​ 这种情况下，$dp[i][j] = dp[i - 1][j - 1]$ ​ 举例：$s1[0,2) mi$ 转换成 $s2[0,3)ari$ $s1[1]i$ $== s2[2]i$ ，$s1[0,1)m$ 转换为 $s2[0,2)ar$ (操作 $dp[i-1][j-1]$ ) 代码实现123456789101112131415161718192021222324252627282930class Solution &#123; public int minDistance(String word1, String word2) &#123; if (word1 == null || word2 == null) return 0; char[] cs1 = word1.toCharArray(); char[] cs2 = word2.toCharArray(); int[][] dp = new int[cs1.length + 1][cs2.length + 1]; dp[0][0] = 0; // 第0列 for (int i = 1; i &lt;= cs1.length; i++) &#123; dp[i][0] = i; &#125; // 第0行 for (int j = 1; j &lt;= cs2.length; j++) &#123; dp[0][j] = j; &#125; // 其他行其他列 for (int i = 1; i &lt;= cs1.length; i++) &#123; for (int j = 1; j &lt;= cs2.length; j++) &#123; int top = dp[i - 1][j] + 1; int left = dp[i][j - 1] + 1; int leftTop = dp[i - 1][j - 1]; if (cs1[i - 1] != cs2[j - 1]) &#123; leftTop++; &#125; dp[i][j] = Math.min(Math.min(top, left), leftTop); &#125; &#125; return dp[cs1.length][cs2.length]; &#125;&#125; LeetCode_最长回文子串 暴力法 $O(n^3)$ 列举出所有的子串，时间复杂度：$0(n^2)$ 检查每一个子串是否为回文串，每一个子串所需时间复杂度：$O(n)$ 总共时间复杂度：$O(n^3)$，空间复杂度：$O(1)$ 动态规划解法 $O(n^2)$其实是基于暴力法的优化，优化的部分：判断每个串是否为回文串 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$ 空间复杂度可以优化至 $O(n)$ 假设字符串（”$babad$”）为 ，它的长度为 $n$ $dp$ 是大小为 $n * n$ 的二维数组，$dp[i][j]$ 表示 $s[i,j]$ 是否为回文串，存储 $true$ 、$false$ 分 $2$ 种情况求出 $dp[i][j]$ 的值 如果 $s[i,j]$ 的长度（ $j-i+1$ ）≤ $2$ 时 如果 $s[i]$ 等于 $s[j]$，那么 $s[i,j]$ 是回文串 所以 $dp[i,j] = (s[i] == s[j])$ 如果 $s[i,j]$ 的长度（ $j-i+1$ ）＞ $2$ 时 如果 $s[i+1,j-1]$ 是回文串，并且 $s[i]$ 等于 $s[j]$ ，那么 $s[i,j]$ 是回文串 所以 $dp[i][j] = dp[i+1,j-1]$ $\&amp;\&amp;$ $(s[i] == s[j])$ 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null) return null; char[] cs = s.toCharArray(); if (cs.length &lt;= 1) return s; // 最长回文子串的长度（至少是1） int maxLen = 1; // 最长回文子串的开始索引 int begin = 0; boolean[][] dp = new boolean[cs.length][cs.length]; // 从下到上（i由大到小） for (int i = cs.length - 1; i &gt;= 0; i--) &#123; // 从左到右（j由小到大） for (int j = i; j &lt; cs.length; j++) &#123; // cs[i, j]的长度 int len = j - i + 1; dp[i][j] = (cs[i] == cs[j]) &amp;&amp; (len &lt;= 2 || dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; len &gt; maxLen) &#123; // 说明cs[i, j]是回文子串 maxLen = len; begin = i; &#125; &#125; &#125; return new String(cs, begin, maxLen); &#125;&#125; 扩展中心法 $O(n)$ ~ $O(n^2)$ 假设字符串（”$abbaba$”)的长度为 $n$ ，那么一共有 $n + (n-1) == 2n - 1$ 个扩展中心 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null) return null; char[] cs = s.toCharArray(); if (cs.length &lt;= 1) return s; // 最长回文子串的长度（至少是1） int maxLen = 1; // 最长回文子串的开始索引 int begin = 0; for (int i = cs.length - 2; i &gt;= 1; i--) &#123; // 以字符为中心向左右扩展 int len1 = palindromeLength(cs, i - 1, i + 1); // 以字符右边的间隙为中心向左右扩展 int len2 = palindromeLength(cs, i, i + 1); len1 = Math.max(len1, len2); if (len1 &gt; maxLen) &#123; maxLen = len1; // 根据长度和中心位置算出开始索引 begin = i - ((maxLen - 1) &gt;&gt; 1); &#125; &#125; // 以0号字符右边的间隙为中心的最长回文子串长度是2 if (cs[0] == cs[1] &amp;&amp; maxLen &lt; 2) &#123; // cs[0, 1]就是最长的回文子串 begin = 0; maxLen = 2; &#125; return new String(cs, begin, maxLen); &#125; /** * @return 从l开始向左、从r开始向右扫描，获得的最长回文子串的长度 */ private int palindromeLength(char[] cs, int l, int r) &#123; while (l &gt;= 0 &amp;&amp; r &lt; cs.length &amp;&amp; cs[l] == cs[r]) &#123; l--; r++; &#125; return r - l - 1; &#125;&#125; 基于扩展中心法的优化 $O(n)$ ~ $O(n^2)$ 算法的核心思想：由连续的相同字符组成的子串作为扩展中心 所以，字符串 “$babbbabaa$” 的扩展中心有 “$b$”、”$a$”、”$bbb$”、”$a$”、”$b$”、”$aa$” 核心逻辑 找到右边第一个不等于 $s[i]$ 的字符，记为位置 $r$ , $i$ 左边位置记为 $l$ $r$ 作为下一次的 $i$ 由 $l$ 开始向左、$r$ 开始向右扩展，找到最长的回文子串 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null) return null; char[] cs = s.toCharArray(); if (cs.length &lt;= 1) return s; // 最长回文子串的长度（至少是1） int maxLen = 1; // 最长回文子串的开始索引 int begin = 0; int i = 0; while (i &lt; cs.length) &#123; int l = i - 1; // 找到右边第一个不等于cs[i]的位置 int r = i; while (++r &lt; cs.length &amp;&amp; cs[r] == cs[i]); // r会成为新的i i = r; // 从l向左，从r向右扩展 while (l &gt;= 0 &amp;&amp; r &lt; cs.length &amp;&amp; cs[l] == cs[r]) &#123; l--; r++; &#125; // 扩展结束后，cs[l + 1, r)就是刚才找到的最大回文子串 // ++l后，l就是刚才找到的最大回文子串的开始索引 int len = r - ++l; if (len &gt; maxLen) &#123; maxLen = len; begin = l; &#125; &#125; return new String(cs, begin, maxLen); &#125;&#125; Manacher (马拉车）$O(n)$前提说明 中间的 # 字符可以是任意字符，头部的 ^ 字符、尾部的 $ 字符，必须是原字符串中不包含的字符 $m[i]$ 的含义： 是以 $cs[i]$ 为扩展中心的最大回文子串的长度（不包含 #​ 字符） 最大回文子串在原字符串中的开始索引：$(i - m[i]) &gt;&gt; 1$ 是以 $cs[i]$ 为扩展中心的最大回文子串的右半部分或左半部分的长度（包含 # 字符） 所以，$Manacher$ 算法的关键在于求出 $m$ 数组 以下图 $m[8]$ (红色区域)举例： 绿色区域就是以 $cs[8]a$ 为扩展中心的最大回文子串的长度 $m[8]3$（不包含 # 字符） 蓝色区域就是以 $cs[8]a$ 为扩展中心的最大回文子串的右半部分或左半部分的长度 $m[8]3$（包含 # 字符） 怎么求出数组 $m$ - 情况1 假设已知 索引 $l、li 、c 、i 、r$ 的值分别为 $1、 4、 6、 8、11$ $cs[l,r]$ 是以 $c$ 为中心的最大回文串（绿色区域） $i$、$li$ 以 $c$ 为中心对称，（蓝色区域）$m[i]$ 是待求项，已知$m[li] == 1$ $i + m[li] &lt; r$ 由于回文的对称性，得出结论 当 $i + m[li] &lt; r$ 时 $m[i] = m[li] == 1$ 怎么求出数组 $m$ - 情况2 假设已知 $m[li] == 3$ $i + m[li] == r$ (蓝色区域) 结论 当 $i + m[li] == r$ (蓝色区域) $m[i]$ 至少是 $m[li]$，也就是说，至少是 $3$ 接下来利用扩展中心法以 $i$ (黄色区域) 为中心计算出 $m[i]$，也可以直接跳到 (橙色区域) 进行比较 直到当 $i + m[i] &gt; r$ 时，更新 $c、r$ (超出 $c$ 管辖的范围 绿色区域) $c = i$ $r = i + m[i]$ 怎么求出数组 $m$ - 情况3 假设已知 $m[li] == 5$ $i + m[li] &gt; r$ (蓝色区域) 结论 当 $i + m[li] &gt; r$ (蓝色区域) $m[i]$ 至少是 $r - i$，也就是说，至少是 $3$ 接下来利用扩展中心法以 $i$ 为中心计算出 $m[i]$ 直到当 $i + m[i] &gt; r$ 时，更新 $c、r$ (超出 $c$ 管辖的范围 绿色区域) $c = i$ $r = i + m[i]$ 怎么求出数组 $m$ - 情况4 当 $i == r$ 时 直接利用扩展中心法以 $i$ 为中心计算出 $m[i]$ 直到当 $i + m[i] &gt; r$ 时，更新 $c、r$ (超出 $c$ 管辖的范围 绿色区域) $c = i$ $r = i + m[i]$ 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; private char[] preprocess(char[] oldCs) &#123; char[] cs = new char[(oldCs.length &lt;&lt; 1) + 3]; cs[0] = '^'; cs[1] = '#'; cs[cs.length - 1] = '$'; for (int i = 0; i &lt; oldCs.length; i++) &#123; int idx = (i + 1) &lt;&lt; 1; cs[idx] = oldCs[i]; cs[idx + 1] = '#'; &#125; return cs; &#125; public String longestPalindrome(String s) &#123; if (s == null) return null; char[] oldCs = s.toCharArray(); if (oldCs.length &lt;= 1) return s; // 预处理 char[] cs = preprocess(oldCs); // 构建m数组 int[] m = new int[cs.length]; int c = 1, r = 1, lastIdx = m.length - 2; int maxLen = 0, idx = 0; for (int i = 2; i &lt; lastIdx; i++) &#123; // 前三种情况 if (r &gt; i) &#123; int li = (c &lt;&lt; 1) - i; // 满足是情况1，不满足是情况2、3 m[i] = (i + m[li] &lt;= r) ? m[li] : (r - i); &#125; // 以i为中心，向左右扩展（情况2、3、4都可能会执行） while (cs[i + m[i] + 1] == cs[i - m[i] - 1]) &#123; m[i]++; &#125; // 更新c、r if (i + m[i] &gt; r) &#123; c = i; r = i + m[i]; &#125; // 找出更大的回文子串 if (m[i] &gt; maxLen) &#123; maxLen = m[i]; idx = i; &#125; &#125; int begin = (idx - maxLen) &gt;&gt; 1; return new String(oldCs, begin, maxLen); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-字符串]]></title>
    <url>%2F2020%2F07%2F26%2FLeetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[LeetCode_字符串轮转 12345class Solution &#123; public boolean isFlipedString(String s1, String s2) &#123; return s1.equals(s2)||(s1.length()==s2.length()&amp;&amp;(s1+s1).contains(s2)); &#125;&#125; LeetCode_另一个树的子树 序列化实现 非空节点：$值 !$，空节点：# $!$ 空节点也必须要序列化，才能完整地表达唯一的一棵树 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null || t == null) return false; return postSerialize(s).contains(postSerialize(t)); &#125; /** * 利用后序遍历的方式进行序列化 * @param root 树的根节点 * @return */ private String postSerialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder("!"); postSerialize(root, sb); return sb.toString(); &#125; private void postSerialize(TreeNode node, StringBuilder sb) &#123; sb.append(node.val).append("!"); if (node.left == null) &#123; sb.append("#!"); &#125; else &#123; postSerialize(node.left, sb); &#125; if (node.right == null) &#123; sb.append("#!"); &#125; else &#123; postSerialize(node.right, sb); &#125; &#125;&#125; KMP优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null || t == null) return false; return contains(postSerialize(s), postSerialize(t)); &#125; private boolean contains(String text, String pattern) &#123; int plen = pattern.length(); int tlen = text.length(); if (tlen == 0 || plen == 0 || tlen &lt; plen) return false; int[] next = next(pattern); int pi = 0, ti = 0; int tmax = tlen - plen; while (pi &lt; plen &amp;&amp; ti - pi &lt;= tmax) &#123; if (pi &lt; 0 || text.charAt(ti) == pattern.charAt(pi)) &#123; ti++; pi++; &#125; else &#123; pi = next[pi]; &#125; &#125; return pi == plen; &#125; private int[] next(String pattern) &#123; int len = pattern.length(); int[] next = new int[len]; int i = 0; int n = next[i] = -1; int imax = len - 1; while (i &lt; imax) &#123; if (n &lt; 0 || pattern.charAt(i) == pattern.charAt(n)) &#123; i++; n++; if (pattern.charAt(i) == pattern.charAt(n)) &#123; next[i] = next[n]; &#125; else &#123; next[i] = n; &#125; &#125; else &#123; n = next[n]; &#125; &#125; return next; &#125; /** * 利用后序遍历的方式进行序列化 * @param root 树的根节点 * @return */ private String postSerialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder("!"); postSerialize(root, sb); return sb.toString(); &#125; private void postSerialize(TreeNode node, StringBuilder sb) &#123; sb.append(node.val).append("!"); if (node.left == null) &#123; sb.append("#!"); &#125; else &#123; postSerialize(node.left, sb); &#125; if (node.right == null) &#123; sb.append("#!"); &#125; else &#123; postSerialize(node.right, sb); &#125; &#125;&#125; LeetCode_有效的字母异位词 本题字符串只包含小写字母 定义一个长度为 $26$ 的数组，遍历 $s$ 时，字符出现的次数 $++$， 遍历 $t$ 时，字符出现的次数 $—$，当出现不存在的字符就可返回 $false$ 123456789101112131415161718class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s == null || t == null) return false; char[] schars = s.toCharArray(); char[] tchars = t.toCharArray(); if (schars.length != tchars.length) return false; int len = schars.length; int[] counts = new int[26]; for (char schar : schars) &#123; counts[schar - 'a']++; &#125; for (int i = 0; i &lt; len; i++) &#123; if (--counts[tchars[i] - 'a'] &lt; 0) return false; &#125; return true; &#125;&#125; LeetCode_翻转字符串里的单词 消除字符串中的多余空格(双指针) 指针 $i$ 遍历完数组 指针 $cur$ 数组中可以覆盖的位置 $space$ 前一个字符是否为空格字符 指定范围的字符串逆序将整个有效字符串逆序，再将每个单词逆序 双指针：交换位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public String reverseWords(String s) &#123; if (s == null) return ""; char[] chars = s.toCharArray(); // 消除多余的空格 // 字符串最终的有效长度 int len = 0; // 当前用来存放字符的位置 int cur = 0; // 前一个字符是否为空格字符 boolean space = true; for (int i = 0; i &lt; chars.length; i++) &#123; if (chars[i] != ' ') &#123; // chars[i]是非空格字符 chars[cur++] = chars[i]; space = false; &#125; else if (space == false) &#123; // chars[i]是空格字符，chars[i - 1]是非空格字符 chars[cur++] = ' '; space = true; &#125; &#125; len = space ? (cur - 1) :cur; if (len &lt;= 0) return ""; // 对整一个有效字符串进行逆序 reverse(chars, 0, len); // 对每一个单词进行逆序 // 前一个空格字符的位置（有-1位置有个假想的哨兵，就是一个假想的空格字符） int prevSapceIdx = -1; for (int i = 0; i &lt; len; i++) &#123; if (chars[i] != ' ') continue; // i是空格字符的位置 reverse(chars, prevSapceIdx + 1, i); prevSapceIdx = i; &#125; // 翻转最后一个单词 reverse(chars, prevSapceIdx + 1, len); return new String(chars, 0, len); &#125; /** * 将[li, ri)范围内的字符串进行逆序 */ private void reverse(char[] chars, int li, int ri) &#123; ri--; while (li &lt; ri) &#123; char tmp = chars[li]; chars[li] = chars[ri]; chars[ri] = tmp; li++; ri--; &#125; &#125;&#125; LeetCode_无重复字符的最长子串 $pi$ 是 $s[i]$ 字符上一次出现的位置 $li$ 是以 $s[i-1]$字符结尾的最长不重复子串的开始索引（最左索引） 1234567891011121314151617181920212223242526class Solution &#123; public int lengthOfLongestSubstring2(String s) &#123; if (s == null) return 0; char[] chars = s.toCharArray(); if (chars.length == 0) return 0; // 用来保存每一个字符上一次出现的位置 Map&lt;Character, Integer&gt; prevIdxes = new HashMap&lt;&gt;(); prevIdxes.put(chars[0], 0); // 以i - 1位置字符结尾的最长不重复字符串的开始索引（最左索引） int li = 0; int max = 1; for (int i = 1; i &lt; chars.length; i++) &#123; // i位置字符上一次出现的位置 Integer pi = prevIdxes.get(chars[i]); if (pi != null &amp;&amp; li &lt;= pi) &#123; li = pi + 1; &#125; // 存储这个字符出现的位置 prevIdxes.put(chars[i], i); // 求出最长不重复子串的长度 max = Math.max(max, i - li + 1); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_栈_队列]]></title>
    <url>%2F2020%2F07%2F25%2FLeetcode-%E6%A0%88-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[LeetCode_最小栈 多维护一个栈，来保存最小数据 12345678910111213141516171819202122232425262728293031323334class MinStack &#123; /* 用来存放正常数据 */ private Stack&lt;Integer&gt; stack; /* 用来存放最小数据 */ private Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (minStack.isEmpty()) &#123; minStack.push(x); &#125; else &#123; minStack.push(Math.min(x, minStack.peek())); &#125; &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; 链表实现，同时保存value和最小值12345678910111213141516171819202122232425262728293031323334class MinStack &#123; private Node head; public MinStack() &#123; head = new Node(0, Integer.MAX_VALUE, null); &#125; public void push(int x) &#123; head = new Node(x, Math.min(x, head.min), head); &#125; public void pop() &#123; head = head.next; &#125; public int top() &#123; return head.val; &#125; public int getMin() &#123; return head.min; &#125; private static class Node &#123; public int val; public int min; public Node next; public Node(int val, int min, Node next) &#123; this.val = val; this.min = min; this.next = next; &#125; &#125;&#125; LeetCode_滑动窗口最大值 双端队列实现① 如果 $nums[ri] ≥ nums[$ 队尾 $]$，不断删除队尾，直到 $nums[$ 队尾 $]≥ nums[ri]$ ② 将索引 $ri$ 加入队尾 ③ 如 果 $li ≥ 0$ （$li$ 滑动窗口的最左边） 删除失效的队头（队头索引 $&lt; li$ 就代表失效） 更新 $li$ 位置的窗口最大值为 $nums[$ 队头 $]$ 注意 队列中存放的是索引 从对头到对尾，$nums[$ 队列元素 $]$，是逐渐减小的（队头保留滑动窗口的最大值） 举例：当滑动窗口到索引 $1$ 时，窗口最大值为 $7$，如下图所示 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &lt; 1) return new int[0]; if (k == 1) return nums; int[] maxes = new int[nums.length - k + 1]; // peek: 取值（偷偷瞥一眼） // poll: 删除（削） // offer: 添加（入队） Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int ri = 0; ri &lt; nums.length; ri++) &#123; // 只要nums[队尾] &lt;= nums[i]，就删除队尾 while (!deque.isEmpty() &amp;&amp; nums[ri] &gt;= nums[deque.peekLast()]) &#123; // deque.pollLast(); deque.removeLast(); &#125; // 将i加到队尾 // deque.offerLast(ri); deque.addLast(ri); // 检查窗口的索引是否合法 // li 滑动窗口的最左边 int li = ri - k + 1; if (li &lt; 0) continue; // 检查队头的合法性 if (deque.peekFirst() &lt; li) &#123; // 队头不合法（失效，不在滑动窗口索引范围内） // deque.pollFirst(); deque.removeFirst(); &#125; // 设置窗口的最大值 maxes[li] = nums[deque.peekFirst()]; &#125; return maxes; &#125;&#125; LeetCode_最大二叉树 123456789101112131415161718192021222324class Solution &#123; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; if (nums == null) return null; return findRoot(nums, 0, nums.length); &#125; /** * 找出[l, r)范围的根节点 */ private TreeNode findRoot(int[] nums, int l, int r) &#123; if (l == r) return null; // 找出[l, r)范围内最大值的索引 int maxIdx = l; for (int i = l + 1; i &lt; r; i++) &#123; if (nums[i] &gt; nums[maxIdx]) maxIdx = i; &#125; TreeNode root = new TreeNode(nums[maxIdx]); root.left = findRoot(nums, l, maxIdx); root.right = findRoot(nums, maxIdx + 1, r); return root; &#125;&#125; 题目变种：返回一个数组，数组里面存着每个节点的父节点的索引（如果没有父节点，就存 $-1$ ） 利用栈求左、右边第一个比它大的数（单调栈）注意：栈中只存放索引，图为方便举例，包括值 举例： ① 索引 $1$ 入栈时，$nums[0] &gt; nums[1] $，索引 $1$ 入栈 所以索引 $1$ 左边第一个比它大的数就是索引 $0$ ② 索引 $2$ 入栈时，$nums[1] &gt; nums[2] $，索引 $2$ 入栈 所以索引 $2$ 左边第一个比它大的数就是索引 $1$ ③ 索引 $3$ 入栈时，$nums[3] &gt; nums[2]$，索引 $2$ 出栈，所以索引 $2$ 右边第一个比它大的数就是索引 $3$ 又$nums[3] &gt; nums[1]$，索引 $1$ 出栈，所以索引 $1$ 右边第一个比它大的数就是索引 $3$ 又$nums[3] &gt; nums[0]$，索引 $0$ 出栈，所以索引 $0$ 右边第一个比它大的数就是索引 $3$ 栈顶为空，索引 $3$ 入栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int[] parentIndexes(int[] nums) &#123; if (nums == null || nums.length == 0) return null; /* * 1.扫描一遍所有的元素 * 2.保持栈从栈底到栈顶是单调递减的 */ int[] lis = new int[nums.length]; int[] ris = new int[nums.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 初始化 for (int i = 0; i &lt; nums.length; i++) &#123; ris[i] = -1; lis[i] = -1; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // 新遍历的索引的值大 while (!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peek()]) &#123; // 栈顶索引 右边第一个比它大的数就是 i ris[stack.pop()] = i; &#125; if (!stack.isEmpty()) &#123; // 准备入栈的索引的 栈顶索引就是左边第一个比它大的数 lis[i] = stack.peek(); &#125; stack.push(i); &#125; // 数组lis、ris中比较大的值就是每个节点的父节点的索引 int[] pis = new int[nums.length]; for (int i = 0; i &lt; pis.length; i++) &#123; if (lis[i] == -1 &amp;&amp; ris[i] == -1) &#123; // i位置的是根节点 pis[i] = -1; continue; &#125; if (lis[i] == -1) &#123; pis[i] = ris[i]; &#125; else if (ris[i] == -1) &#123; pis[i] = lis[i]; &#125; else if (nums[lis[i]] &lt; nums[ris[i]]) &#123; pis[i] = lis[i]; &#125; else &#123; pis[i] = ris[i]; &#125; &#125; return pis;&#125; LeetCode_每日温度 利用栈求右边第一个比它大的数(原理同上单调栈)1234567891011121314public int[] dailyTemperatures(int[] T) &#123; if (T == null || T.length == 0) return null; int[] result = new int[T.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; T.length; i++) &#123; // 这里应该要写大于，不要写大于等于 while (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123; result[stack.peek()] = i - stack.peek(); stack.pop(); &#125; stack.push(i); &#125; return result;&#125; 倒推法$i$ 用来扫描所有的元素，从右往左扫描（ $i$ 逐渐递减），一开始 $i$ 指向倒数第 $2$ 个元素 对于每一个 $i$，一开始令 $j = i + 1$ ① 如果 $T[i] &lt; T[j]$， 那么 $values[i] = j - i$，然后 $i—$ ② 如果 $T[i] == T[j]$ 如果 $values[j] == 0$，$values[i] = 0$，然后 $i—$ 如果 $values[j] != 0$，$values[i] = values[j] + j - i$，然后 $i—$ ③ 如果 $T[i] &gt; T[j]$ 如果 $values[j] == 0$，$values[i] = 0$，然后 $i—$ 如果 $values[j] != 0$，$j = j + values[j]$，重新进入①的判断 举例： ① 当 $i == 3$ 时，$j == 4$ $T[3] &gt; T[4]，values[4] != 0，j = 4 + 1 = 5$ $T[3] &gt; T[5]，values[5] != 0，j = 5 + 1 = 6$ $T[3] &lt; T[6]，values[3] = 6 - 3 $ ② 当 $i == 2$ 时，$j == 3$ $T[2] == T[3]$，$values[3] != 0$，$values[2] = values[3] + 3 - 2 = 4$ 1234567891011121314151617181920212223public int[] dailyTemperatures(int[] T) &#123; if (T == null || T.length == 0) return null; int[] values = new int[T.length]; for (int i = T.length - 2; i &gt;= 0; i--) &#123; int j = i + 1; while (true) &#123; if (T[i] &lt; T[j]) &#123; values[i] = j - i; break; &#125; else if (values[j] == 0) &#123; values[i] = 0; break; &#125; else if (T[i] == T[j]) &#123; // 此条件可以省略 values[i] = values[j] + j - i; break; &#125; /*else &#123; j = j + values[j]; &#125;*/ j = j + values[j]; &#125; &#125; return values;&#125; 倒推法 - 精简条件$i$ 用来扫描所有的元素，从右往左扫描（ $i$ 逐渐递减），一开始 $i$ 指向倒数第 $2$ 个元素 对于每一个 $i$，一开始令 $j = i + 1$ ① 如果 $T[i] &lt; T[j]$ 那么 $values[i] = j - i$ ，然后 $i- -$ ② 如果 $values[j] == 0$，那么 $values[i] == 0$，然后 $i- -$ ③ 否则，设置 $j = j + values[j]$ 回到步骤① 12345678910111213141516171819public int[] dailyTemperatures(int[] T) &#123; if (T == null || T.length == 0) return null; int[] values = new int[T.length]; for (int i = T.length - 2; i &gt;= 0; i--) &#123; int j = i + 1; while (true) &#123; if (T[i] &lt; T[j]) &#123; values[i] = j - i; break; &#125; else if (values[j] == 0) &#123; values[i] = 0; break; &#125; // 当T[i] == T[j]的时候 j = j + values[j]; &#125; &#125; return values;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_链表]]></title>
    <url>%2F2020%2F07%2F25%2FLeetcode_%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode_移除链表元素 时间复杂度：$O(n)$、空间复杂度：$O(1)$ 123456789101112131415161718class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null) return null; // 新链表的虚拟头结点 ListNode newHead = new ListNode(0); // 新链表的尾结点 ListNode newTail = newHead; while (head != null) &#123; if (head.val != val) &#123; newTail.next = head; newTail = head; &#125; head = head.next; &#125; newTail.next = null; return newHead.next; &#125;&#125; LeetCode_两数相加 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode dummyHead = new ListNode(0); ListNode last = dummyHead; // 进位值 int carry = 0; while (l1 != null || l2 != null) &#123; int v1 = 0; if (l1 != null) &#123; v1 = l1.val; l1 = l1.next; &#125; int v2 = 0; if (l2 != null) &#123; v2 = l2.val; l2 = l2.next; &#125; int sum = v1 + v2 + carry; // 设置进位值 carry = sum / 10; // sum的个位数作为新节点的值 last.next = new ListNode(sum % 10); last = last.next; &#125; // 检查最后的进位 if (carry &gt; 0) &#123; // carry == 1 last.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; LeetCode_相交链表 1234567891011public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode curA = headA, curB = headB; while (curA != curB) &#123; curA = (curA == null) ? headB : curA.next; curB = (curB == null) ? headA : curB.next; &#125; return curA; &#125;&#125; LeetCode_分隔链表 双指针法：一个指针存放小于 $x$ 的值，另一个指针存放大于等于 $x$ 的值 1234567891011121314151617181920212223242526272829class Solution &#123; public ListNode partition(ListNode head, int x) &#123; if (head == null) return null; ListNode lHead = new ListNode(0); ListNode lTail = lHead; ListNode rHead = new ListNode(0); ListNode rTail = rHead; while (head != null) &#123; if (head.val &lt; x) &#123; // 放在lTail后面 lTail.next = head; lTail = head; &#125; else &#123; // 放在rTail后面 rTail.next = head; rTail = head; &#125; head = head.next; &#125; // 这句代码不能少 /* * 因为可能出现这样的情况: * 原链表倒数第N个节点A的值是&gt;=x的，A后面所有节点的值都是&lt;x的 * 然后rTail.next最终其实就是A.next */ rTail.next = null; // 将rHead.next拼接在lTail后面 lTail.next = rHead.next; return lHead.next; &#125;&#125; LeetCode_回文链表 利用快慢指针得到中间节点 翻转中间节点后面的链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) return true; if (head.next.next == null) return head.val == head.next.val; // 找到中间节点 ListNode mid = middleNode(head); // 翻转右半部分（中间节点的右边部分） ListNode rHead = reverseList(mid.next); ListNode lHead = head; ListNode rOldHead = rHead; // 从lHead、rHead出发，判断是否为回文链表 boolean result = true; while (rHead != null) &#123; if (lHead.val != rHead.val) &#123; result = false; break; &#125; rHead = rHead.next; lHead = lHead.next; &#125; // 恢复右半部分（对右半部分再次翻转） reverseList(rOldHead); return result; &#125; /** * 找到中间节点（右半部分链表头结点的前一个节点） * 比如 1&gt;2&gt;3&gt;2&gt;1中的3是中间节点 * 比如 1&gt;2&gt;2&gt;1中左边第一个2是中间节点 */ private ListNode middleNode(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125; /** * 翻转链表 * @param head 原链表的头结点 * 比如原链表：1&gt;2&gt;3&gt;4&gt;null，翻转之后是：4&gt;3&gt;2&gt;1&gt;null * @return 翻转之后链表的头结点（返回4） */ private ListNode reverseList(ListNode head) &#123; ListNode newHead = null; while (head != null) &#123; ListNode tmp = head.next; head.next = newHead; newHead = head; head = tmp; &#125; return newHead; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_数组_排序]]></title>
    <url>%2F2020%2F07%2F25%2FLeetcode_%E6%95%B0%E7%BB%84_%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[LeetCode 合并两个有序数组 双指针 / 从后往前1234567891011121314151617class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; // 传入的两个数组是有序的 int i1 = m - 1; int i2 = n - 1; // 将数组nums1 从后往前重新赋值 int cur = nums1.length - 1; while (i2 &gt;= 0) &#123; if (i1 &gt;= 0 &amp;&amp; nums2[i2] &lt; nums1[i1]) &#123; nums1[cur--] = nums1[i1--]; &#125; else &#123; // i1 &lt; 0 || nums2[i2] &gt;= nums1[i1] nums1[cur--] = nums2[i2--]; &#125; &#125; &#125;&#125; LeetCode 颜色分类 三指针 红色指针：（i） 遍历完全部元素 绿色指针：（l）追踪 0 的最右边界 紫色指针：（r）2 的最左边界和当前考虑的元素 遇到1：跳过，红色指针++ 遇到0：跟绿色指针交换值，绿色指针++、红色指针++ 遇到2：跟紫色指针交换值，紫色指针—，再次对红色指针的值进行判断 表格中颜色是执行操作后指针最后所处的位置 初始值 1 0 2 1 1 0 2 遇到1 1 0 2 1 1 0 2 遇到0 0 1 2 1 1 0 2 遇到2，执行第1次 0 1 2 1 1 0 2 遇到2，执行第2次 0 1 0 1 1 2 2 遇到0 0 0 1 1 1 2 2 … 1234567891011121314151617181920212223242526class Solution &#123; /* * 一个只包含0、1、2的整型数组，要求对它进行【原地】排序 * 空间复杂度O(1)，时间复杂度O(n) */ public void sortColors(int[] nums) &#123; int i = 0; int l = 0; int r = nums.length - 1; while (i &lt;= r) &#123; if (nums[i] == 0) &#123; swap(nums, i++, l++); &#125; else if (nums[i] == 1) &#123; i++; &#125; else &#123; swap(nums, i, r--); &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125; LeetCode 部分排序 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[] subSort(int[] array) &#123; if (array.length == 0) return new int[] &#123; -1, -1 &#125;; // 从左扫描到右寻找逆序对（正序：逐渐变大） int max = array[0]; // 用来记录最右的那个逆序对位置 int r = -1; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt;= max) &#123; max = array[i]; &#125; else &#123; r = i; &#125; &#125; // 提前结束 if (r == -1) return new int[] &#123; -1, -1 &#125;; // 从右扫描到左寻找逆序对（正序：逐渐变小） int min = array[array.length - 1]; // 用来记录最左的那个逆序对位置 int l = -1; for (int i = array.length - 2; i &gt;= 0; i--) &#123; if (array[i] &lt;= min) &#123; min = array[i]; &#125; else &#123; l = i; &#125; &#125; return new int[] &#123; l, r &#125;; &#125;&#125; LeetCode 有序数组的平方 反向遍历数组中的负数部分，从前向后遍历数组中的非负数部分， 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int[] sortedSquares(int[] A) &#123; int len = A.length; // 找到最后一个负数 int j = 0; while (j &lt; len &amp;&amp; A[j] &lt; 0)&#123; j++; &#125; // 第一个正数 int i = j - 1; int [] nA= new int[len]; int t = 0; // 指针 i 反向读取负数部分，指针 j 正向读取非负数部分 while (i &gt;= 0 &amp;&amp; j &lt; len)&#123; if (A[i] * A[i] &lt; A[j] * A[j])&#123; nA[t++] = A[i] * A[i]; i--; &#125;else&#123; nA[t++] = A[j] * A[j]; j++; &#125; &#125; // 负数还有剩余 while (i &gt;= 0)&#123; nA[t++] = A[i] * A[i]; i--; &#125; // 非负数还有剩余 while (j &lt; len)&#123; nA[t++] = A[j] * A[j]; j++; &#125; return nA; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B+树]]></title>
    <url>%2F2020%2F07%2F23%2FB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B+树$B+$树是 $B$ 树的变体，常用于数据库和操作系统的文件系统中 $MySQL$ 数据库的索引就是基于 $B+$ 树实现的 B+树的特点 分为内部节点（非叶子）、叶子节点 $2$ 种节点 内部节点只存储 $key$，不存储具体数据 叶子节点存储 $key$ 和具体数据 $value$ 所有的叶子节点形成一条有序链表 $m$ 阶 $B+$ 树非根节点的元素数量 $x$ $┌ m/2 ┐ ≤ x ≤ m$ MySQL的索引底层为何使用B+树？ 为了减小 $IO$ 操作数量，一般把一个节点的大小设计成最小读写单位的大小 $MySQL$ 的存储引擎 $InnoDB$ 的最小读写单位是 $16K$ 对比 $B$ 树，$B+$ 树的优势是 每个节点存储的 $key$ 数量更多，树的高度更低 所有的具体数据都存在叶子节点上，所以每次查询都要查到叶子节点，查询速度比较稳定 所有的叶子节点构成了一个有序链表，做区间查询时更方便 B*树$B*$ 树是 $B+$ 树的变体：给内部节点增加了指向兄弟节点的指针 $m$ 阶 $B*$ 树非根节点的元素数量 $x$ $┌ 2m/3 ┐ ≤ x ≤ m$]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串]]></title>
    <url>%2F2020%2F07%2F22%2F%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[串（Sequence）字符串 $thank$ 的前缀（ $prefix$ ）、真前缀（ $proper prefix$ ）、后缀（ $suffix$ ）、真后缀（ $proper suffix$） 前缀 t, th, tha, than, thank 真前缀 t, th, tha, than 后缀 thank, hank, ank, nk, k 真后缀 hank, ank, nk, k 串匹配算法查找一个模式串（ $pattern$ ）在文本串（ $text$ ）中的位置 几个经典的串匹配算法 蛮力（ $Brute Force$ ） $KMP$ $Boyer-Moore$ $Karp-Rabin$ $Sunday$ 用 $tlen$ 代表文本串 $text$ 的长度，$plen$ 代表模式串 $pattern$ 的长度 蛮力（Brute Force）以字符为单位，从左到右移动模式串，直到匹配成功 蛮力算法有 $2$ 种常见实现思路 蛮力1 – 执行过程$pi$ 的取值范围 $[0, plen)$ $ti$ 的取值范围 $[0, tlen)$ 当匹配的两个字符不相等时： $textChars[ti] != patternChars[pi]$ $pi = 0$ $ti –= pi – 1$ 当匹配的两个字符相等时： $textChars[ti] == patternChars[pi]$ $pi ++$ $ti ++$ 继续向后匹配 当 $pi == plen$：代表匹配成功 蛮力1 – 实现1234567891011121314151617181920212223public static int indexOf01(String text, String pattern)&#123; // 判断合法性 if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; int pi = 0, ti = 0; while (pi &lt; plen &amp;&amp; ti &lt; tlen)&#123; if (textChars[ti] == patternChars[pi])&#123; ti++; pi++; &#125;else&#123; ti -= pi - 1; pi = 0; &#125; &#125; return (pi == plen) ? (ti - pi) : -1;&#125; 蛮力1 – 优化 此前实现的蛮力算法，在恰当的时候可以提前退出，减少比较次数 因此，$ti$ 的退出条件可以从 $ti &lt; tlen$ 改为 $ti – pi &lt;= tlen – plen$ $ti – pi$ 是指每一轮比较中 $text$ 首个比较字符的位置 蛮力1 – 优化实现12345678910111213141516171819202122232425public static int indexOf02(String text, String pattern)&#123; if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; int pi = 0, ti = 0; // ti - pi 文本串正在匹配的子串的开始索引 // tlen - plen 开始索引的临界值 int lenDelta = tlen - plen; while (pi &lt; plen &amp;&amp; ti - pi &lt;= lenDelta)&#123; if (textChars[ti] == patternChars[pi])&#123; ti++; pi++; &#125;else&#123; ti -= pi - 1; pi = 0; &#125; &#125; return (pi == plen) ? (ti - pi) : -1;&#125; 蛮力2 – 执行过程$pi$ 的取值范围 $[0, plen)$ $ti$ 的取值范围 $[0, tlen – plen]$ 当匹配的两个字符相等时： $textChars[ti]==patternChars[pi]$ $pi ++$ $ti += pi$ 当匹配的两个字符不相等时： $textChars[ti]==patternChars[pi]$ $pi = 0$ $ti++$ 当 $pi == plen$：代表匹配成功 蛮力2 – 实现1234567891011121314151617181920public static int indexOf(String text, String pattern)&#123; if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; int tiMax = tlen - plen; for (int ti = 0; ti &lt;= tiMax; ti++) &#123; int pi = 0; for (; pi &lt; plen; pi++) &#123; if (textChars[ti + pi] != patternChars[pi]) break;; &#125; if (pi == plen) return ti; &#125; return -1;&#125; 蛮力 – 性能分析$n$ 是文本串长度，$m$ 是模式串长度 最好情况 只需一轮比较就完全匹配成功，比较 $m$ 次（ $m$ 是模式串的长度） 时间复杂度为 $O(m)$ 最坏情况（字符集越大，出现概率越低） 执行了 $n – m + 1$ 轮比较（ $n$ 是文本串的长度） 每轮都比较至模式串的末字符后失败（ $m – 1$ 次成功，$1$ 次失败） 时间复杂度为 $O(m ∗ (n − m + 1))$，由于一般 $m$ 远小于 $n$，所以为 $O(mn)$ KMP$KMP$ 是 $Knuth–Morris–Pratt$ 的简称（取名自 $3$ 位发明人的名字），于 $1977$ 年发布 KMP – next表的使用$KMP$ 会预先根据模式串的内容生成一张 $next$ 表（一般是个数组） 后面再讲怎么生成 $next$ 表（先学会使用） 举例： 当在 $E(ti = 8，pi = 7)$ 发生失配时，$ti$ 不变，$pi$ 变成 $next$ 表中的值 当在 $D(ti = 5，pi = 3)$ 发生失配时，$ti$ 不变，$pi$ 变成 $next$ 表中的值 KMP – 核心原理$A、B$ 是个子串（有多个字符） $c、d、e$ 是单个字符 当 $d、e$ 失配时，如果希望 $pattern$ 能够一次性向右移动一大段距离，然后直接比较 $d、c$ 字符 前提条件是子串 $A$ 必须等于子串 $B$ 所以 $KMP$ 必须在失配字符 $e$ 左边的子串中找出符合条件的子串 $A 、B$，从而得知向右移动的距离 向右移动的距离：$e$ 左边子串的长度 $– A$ 的长度（也等于 $-B$ 的长度），等价于：$e$ 的索引 $– c$ 的索引 且 $c$ 的索引 == $next[$ $e$ 的索引 $]$，所以向右移动的距离：$e$ 的索引 $– next$ [ $e$ 的索引 ] 举例： $text: \underbrace{abc}_{\rm A}$ $c$ $\underbrace{abc}_{\rm B}$ $d$ $pattern：abce$ 当 $A = \underbrace{abc}_{\rm A} 、B = \underbrace{abc}_{\rm B}$ $pi$ 一次性向右移动的距离：$7 - 3 = 4$ 总结 如果在 $pi$ 位置失配，向右移动的距离是 $pi – next[pi]$，所以 $next[pi]$ 越小，移动距离越大 $next[pi]$ 是 $pi$ 左边子串的真前缀后缀的最大公共子串长度 KMP – 真前缀后缀的最大公共子串长度 KMP – 得到next表 将最大公共子串长度都向后移动 $1$ 位，首字符设置为 负 $1$，就得到了 $next$ 表 KMP – 负1的精妙之处如果：$pi = next[pi] → (-1)$ $(pi++) → (-1) → 0$ $(ti++) → 2 → 3$ 相当于在负 $1$ 位置有个假想的通配字符（哨兵） 匹配成功后 $ti++、pi++$ KMP – 主算法实现123456789101112131415161718192021222324252627public static int indexOf(String text, String pattern)&#123; // 判断合法性 if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; // next表 int[] next = next(pattern); int pi = 0, ti = 0; int lenDelta = tlen - plen; while (pi &lt; plen &amp;&amp; ti - pi &lt;= lenDelta)&#123; if (pi &lt; 0 || textChars[ti] == patternChars[pi])&#123; ti++; pi++; &#125;else&#123; // pi 一次性向右移动的距离 pi = next[pi]; &#125; &#125; return (pi == plen) ? (ti - pi) : -1;&#125; KMP – 为什么是“最大“公共子串长度？假设文本串是 $AAAAABCDEF$，模式串是 $AAAAB$ 应该将 $1、2、3$ 中的哪个值赋值给 $pi$ 是正确的？ 将 $3$ 赋值给 $pi$ 向右移动了 $1$ 个字符单位，最后成功匹配 将 $1$ 赋值给 $pi$ 向右移动了 $3$ 个字符单位，错过了成功匹配的机会 公共子串长度越小，向右移动的距离越大，越不安全 公共子串长度越大，向右移动的距离越小，越安全 KMP – next表的构造思路假设(已知) $next[i] == n$ （数组下标为 $i$ 左边子串的真前缀后缀的最大公共子串长度有 $n$ 个） 让下标为 $i$ 与下标为 $n$ 位置的值做比较 ① 如 果 $pattern.charAt(i) == pattern.charAt(n)$ ​ 那么 $next[i + 1] == n + 1$ ② 如 果 $pattern.charAt(i) != pattern.charAt(n)$ ​ 已知 $next[n] == k$，$k$ （左边子串的真前缀后缀的最大公共子串长度） ​ 也就是再去 $n$ 的左边寻找真前缀后缀的最大公共子串长度 如果 $pattern.charAt(i) == pattern.charAt(k)$ 那么 $next[i + 1] == k + 1$ 如果 $pattern.charAt(i) != pattern.charAt(k)$ 将 $k$ 代入 $n$， $（n = next[n]）$，重复执行 ② KMP – next表的代码实现123456789101112131415161718private static int[] next(String pattern)&#123; char[] chars = pattern.toCharArray(); int[] next = new int[chars.length]; // next[i] 第 i 项左边子串的真前缀后缀的最大公共子串长度 // 已知 n == next[i] int i = 0; int n = next[i] = -1; int iMax = chars.length -1; while (i &lt; iMax)&#123; if (n &lt; 0 || chars[i] == chars[n])&#123; next[++i] = ++n; &#125;else&#123; n = next[n]; // 图示为 n = k &#125; &#125; return next;&#125; KMP – next表的不足之处假设文本串是 $AAABAAAAB$ ，模式串是 $AAAAB$ 在这种情况下，$KMP$ 显得比较笨拙 KMP – next表的优化思路已知：$next[i] == n，next[n] == k$ 如果 $pattern[i] != d$，就让模式串滑动到 $next[i]$（也就是 $n$ ）位置跟 $d$ 进行比较 如果 $pattern[n] != d$，就让模式串滑动到 $next[n]$（也就是 $k$ ）位置跟 $d$ 进行比较 如果 $pattern[i] == pattern[n]$，那么当 $i$ 位置失配时，模式串最终必然会滑到 $k$ 位置跟 $d$ 进行比较 所以 $next[i]$ 直接存储 $next[n]$（也就是 $k$ ）即可 KMP – next表的优化实现12345678910111213141516171819202122232425private static int[] next(String pattern)&#123; char[] chars = pattern.toCharArray(); int[] next = new int[chars.length]; // next[i] 第 i 项左边子串的真前缀后缀的最大公共子串长度 // 已知 n == next[i] int i = 0; int n = next[i] = -1; int iMax = chars.length -1; while (i &lt; iMax)&#123; if (n &lt; 0 || chars[i] == chars[n])&#123; ++i; ++n; // ++后，先比较，相等，直接跳到下一个，上图中可认为是k if (chars[i] == chars[n])&#123; next[i] = next[n]; &#125;else&#123; next[i] = n; &#125; &#125;else&#123; n = next[n]; &#125; &#125; return next;&#125; KMP – next表的优化效果 KMP – 性能分析 $KMP$ 主逻辑 最好时间复杂度：$O(m)$ 最坏时间复杂度：$O(n)$，不超过 $O(2n)$ $next$ 表的构造过程跟 $KMP$ 主体逻辑类似 时间复杂度：$O(m)$ $KMP$ 整体 最好时间复杂度：$O(m)$ 最坏时间复杂度：$O(n + m)$ 空间复杂度： $O(m)$ 蛮力 vs KMP蛮力算法为何低效？ 当字符失配时 蛮力算法 $ti$ 回溯到左边位置 $pi$ 回溯到 $0$ KMP 算法 $ti$ 不必回溯 $pi$ 不一定要回溯到 $0$ 对比蛮力算法，$KMP$ 的精妙之处：充分利用了此前比较过的内容，可以很聪明地跳过一些不必要的比较位置]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳表]]></title>
    <url>%2F2020%2F07%2F21%2F%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[跳表（SkipList）思考一个有序链表搜索、添加、删除的平均时间复杂度是多少？ $O(n)$ 能否利用二分搜索优化有序链表，将搜索、添加、删除的平均时间复杂度降低至 $O(logn)$？ 链表没有像数组那样的高效随机访问（$O(1)$ 时间复杂度），所以不能像有序数组那样直接进行二分搜索优化 那有没有其他办法让有序链表搜索、添加、删除的平均时间复杂度降低至 $O(logn)$？ 使用跳表（$SkipList$） 跳表是什么 跳表，又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能 由 $William Pugh$于 $1990$ 年发布，设计的初衷是为了取代平衡树（比如红黑树） $Redis$ 中 的 $SortedSet、LevelDB$ 中的 $MemTable$ 都用到了跳表 $Redis、LevelDB$ 都是著名的 $Key-Value$ 数据库 对比平衡树 跳表的实现和维护会更加简单 跳表的搜索、删除、添加的平均时间复杂度是 $O(logn)$ 使用跳表优化链表 跳表的基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 最高层数private static final int MAX_LEVEL = 32;// 新增层数的概率private static final double P = 0.25;private int size;private Comparator&lt;K&gt; comparator;// 有效层数private int level;// 首节点，不存放任何K-Vprivate Node&lt;K, V&gt; first;public SkipList(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; first = new Node&lt;&gt;(null, null, MAX_LEVEL);&#125;public SkipList() &#123; this(null);&#125;public int size() &#123; return size;&#125;public boolean isEmpty() &#123; return size == 0;&#125;// 随机返回新增节点的层数private int randomLevel() &#123; int level = 1; while (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123; level++; &#125; return level;&#125;private void keyCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null."); &#125;&#125;private int compare(K k1, K k2) &#123; return comparator != null ? comparator.compare(k1, k2) : ((Comparable&lt;K&gt;)k1).compareTo(k2);&#125;@Overridepublic String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("一共" + level + "层").append("\n"); for (int i = level - 1; i &gt;= 0; i--) &#123; Node&lt;K, V&gt; node = first; while (node.nexts[i] != null) &#123; sb.append(node.nexts[i]); sb.append(" "); node = node.nexts[i]; &#125; sb.append("\n"); &#125; return sb.toString();&#125; 跳表节点的定义123456789101112131415private static class Node&lt;K, V&gt; &#123; K key; V value; // 节点指向的下一个节点（多个） Node&lt;K, V&gt;[] nexts; public Node(K key, V value, int level) &#123; this.key = key; this.value = value; nexts = new Node[level]; &#125; @Override public String toString() &#123; return key + ":" + value + "_" + nexts.length; &#125;&#125; 跳表的搜索① 从顶层链表的首元素开始，从左往右搜索，直至找到一个大于或等于目标的元素，或者到达当前层链表的尾部 ② 如果该元素等于目标元素，则表明该元素已被找到 ③ 如果该元素大于目标元素或已到达链表的尾部，则退回到当前层的前一个元素，然后转入下一层进行搜索 举例： 查找存在的 $17$ 从首节点 $first$ 的顶层链表开始，找到 $21$，$21&gt;17$，退回到上一个节点 $first$ ，层数 $-1$， 从 $first$ 出发,找到 $9$，$9 &lt; 17$，继续往后找，找到 $21$，$21 &gt; 17$，退回到上一个节点 $9$ ，层数 $-1$, 从 $9$ 出发，找到 $17$，$17==17$，找到了该元素 查找不存在的 $18$ 从首节点 $first$ 的顶层链表开始，找到 $21$，$21&gt;18$，退回到上一个节点 $first$ ，层数 $-1$， 从 $first$ 出发,找到 $9$，$9 &lt; 18$，继续往后找，找到 $21$，$21 &gt; 18$，退回到上一个节点 $9$ ，层数 $-1$, 从 $9$ 出发，找到 $17$，$17 &lt; 18$，继续往后找，找到 $21$，$21&gt;18$，退回到上一个节点 $17$，层数 $-1$, 从 $17$ 出发，找到 $19$，$19 &gt; 18$，退回到上一个节点 $17$，层数 $-1$, 发现是在最后一层，返回 $false$，没有找到 12345678910111213141516171819202122232425public V get(K key) &#123; keyCheck(key); // 举例： // first.nexts[3] == 21节点 // first.nexts[2] == 9节点 // first.nexts[1] == 6节点 // first.nexts[0] == 3节点 // level = 4 Node&lt;K, V&gt; node = first; for (int i = level - 1; i &gt;= 0; i--) &#123; int cmp = -1; // 一个技巧： // 直接让node的下一个节点跟传入的值做比较 // 传入的值较小时，就不用退回到上一个节点 while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; // 找到key值了，可以不用先退出，层数会不断-1 // 例如 17，在level == 1 时 就找到了 if (cmp == 0) return node.nexts[i].value; &#125; return null;&#125; 跳表的添加 添加的细节 随机决定新添加元素的层数 寻找节点是否存在时，一定要遍历完所有层数，找到新添加节点的所有前驱节点 前驱节点可以认为是层数 $-1$ 时，当时的节点就是前驱节点 举例： 添加不存在的节点 $17$ 从首节点 $first[3]$ 的顶层链表开始，找到 $6$，$6 &lt; 17$，继续往后找，找到 $NULL$，退回到上一个节点 $6$ ，层数 $-1$，保存前驱节点 $6[3]$ 从 $6[2]$ 出发,找到 $25$，$25 &gt; 17$，退回到上一个节点 $6 [2]$ ，层数 $-1$，保存前驱节点 $6[2]$ 从 $6[1]$ 出发，找到 $9$，$9 &lt; 17$，继续往后找，找到$25$，$25 &gt; 17$，退回到上一个节点 $9$，层数 $-1$，保存前驱节点 $9[1]$ 从 $9[0]$ 出发，找到 $12$，$12 &lt; 17$，继续往后找，找到 $19$，$19 &gt; 17$，退回到上一个节点 $12$，层数 $-1$，保存前驱节点 $12[0]$ 发现层数为 $0$ 了，找到 $17$ 添加的位置了，前驱节点分别为 $6[3],6[2],9[1],12[0]$ 下面只需更改前驱节点和新节点的指向就行 添加存在的节点 $9$ 方法与上面类似，找到该节点的位置，更改该节点的 $value$，返回 $oldvalue$ 就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344public V put(K key, V value) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; // 前驱节点的个数就是层数 $level Node&lt;K, V&gt;[] prevs = new Node[level]; for (int i = level - 1; i &gt;= 0; i--) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; if (cmp == 0) &#123; // 节点是存在的 V oldV = node.nexts[i].value; node.nexts[i].value = value; return oldV; &#125; // 保存前驱节点 prevs[i] = node; &#125; // 随机产生新节点的层数 int newLevel = randomLevel(); // 添加新节点 Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, newLevel); // 设置前驱和后继 for (int i = 0; i &lt; newLevel; i++) &#123; // 新节点的层数可能比原来的大 if (i &gt;= level) &#123; first.nexts[i] = newNode; &#125; else &#123; newNode.nexts[i] = prevs[i].nexts[i]; prevs[i].nexts[i] = newNode; &#125; &#125; // 节点数量增加 size++; // 计算跳表的最终层数 level = Math.max(level, newLevel); return null;&#125; 跳表的删除删除的细节 删除一个元素后，整个跳表的层数可能会降低 找到元素后，不能提前退出，要找到要删除节点的全部前驱节点 123456789101112131415161718192021222324252627282930313233343536public V remove(K key) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; Node&lt;K, V&gt;[] prevs = new Node[level]; boolean exist = false; for (int i = level - 1; i &gt;= 0; i--) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; prevs[i] = node; if (cmp == 0) exist = true; &#125; if (!exist) return null; // 需要被删除的节点 Node&lt;K, V&gt; removedNode = node.nexts[0]; // 数量减少 size--; // 设置后继 for (int i = 0; i &lt; removedNode.nexts.length; i++) &#123; prevs[i].nexts[i] = removedNode.nexts[i]; &#125; // 更新跳表的层数 int newLevel = level; while (--newLevel &gt;= 0 &amp;&amp; first.nexts[newLevel] == null) &#123; level = newLevel; &#125; return removedNode.value;&#125; 跳表的层数跳表是按层构造的，底层是一个普通的有序链表，高层相当于是低层的 “快速通道” 在第 $i$ 层中的元素按某个固定的概率 $p$（通常为 $\frac{1}{2}$ 或 $\frac{1}{4}$ 出现在第 $i + 1$层中，产生越高的层数，概率越低 元素层数恰好等于 $1$ 的概率为 $1 – p$ 元素层数大于等于 $2$ 的概率为 $p$，而元素层数恰好等于 $2$ 的概率为 $p * (1 – p)$ 元素层数大于等于 $3$ 的概率为 $p^2$，而元素层数恰好等于 $3$ 的概率为 $p^2 * (1 – p)$ 元素层数大于等于 $4$ 的概率为 $p^3$，而元素层数恰好等于 $4$ 的概率为 $p^3 * (1 – p)$ $\ldots\ldots$ 一个元素的平均层数是 $\frac{1}{(1 – p)}$ 1\times(1-p)+2p(1-p)+3p^2(1-p)+4p^3(1-p)+\ldots=(1-p) \sum_{k=1}^{+\infty}kp^{k-1}=(1-p)\cdot \frac{1}{(1-p)^2}= \frac{1}{1-p}当 $p = \frac12$ 时，每个元素所包含的平均指针数量是 $2$ 当 $p = \frac14$ 时，每个元素所包含的平均指针数量是 $1.33$ 跳表的复杂度分析每一层的元素数量 第 $1$ 层链表固定有 $n$ 个元素 第 $2$ 层链表平均有 $n * p$ 个元素 第 $3$ 层链表平均有 $n * p^2$ 个元素 第 $k$ 层链表平均有 $n * p^k$ 个元素 $\ldots\ldots$ 另外 最高层的层数是 $log_\frac1p n$，平均有个 $\frac1p$ 元素 在搜索时，每一层链表的预期查找步数最多是 $\frac1p$，所以总的查找步数是 $–(log_p\frac np)$，时间复杂度是 $O(logn)$]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>跳表</tag>
        <tag>SkipList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2020%2F07%2F21%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[布隆过滤器（Bloom Filter）思考 如果要经常判断 1 个元素是否存在，你会怎么做？ 很容易想到使用哈希表（$HashSet、HashMap$），将元素作为 $key$ 去查找 时间复杂度：$O(1)$，但是空间利用率不高，需要占用比较多的内存资源 如果需要编写一个网络爬虫去爬 $10亿$ 个网站数据，为了避免爬到重复的网站，如何判断某个网站是否爬过？ 很显然，$HashSet、HashMap$ 并不是非常好的选择 是否存在时间复杂度低、占用内存较少的方案？ 布隆过滤器$（Bloom Filter）$ 布隆过滤器 - 是什么 1970年由布隆提出 它是一个空间效率高的概率型数据结构，可以用来告诉你：一个元素一定不存在或者可能存在 优缺点 优点：空间效率和查询时间都远远超过一般的算法 缺点：有一定的误判率、删除困难 它实质上是一个很长的二进制向量和一系列随机映射函数（Hash函数） 常见应用 网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统、解决缓存穿透问题 布隆过滤器 - 原理假设布隆过滤器由 $20$ 位二进制、 $3$ 个哈希函数组成，每个元素经过哈希函数处理都能生成一个索引位置 添加元素：将每一个哈希函数生成的索引位置都设为 $1$ 查询元素是否存在 如果有一个哈希函数生成的索引位置不为 $1$，就代表不存在（$100\%$ 准确） 如果每一个哈希函数生成的索引位置都为 $1$，就代表存在（存在一定的误判率） 添加、查询的时间复杂度都是：$O(k)$ ，$k$ 是哈希函数的个数。空间复杂度是：$O(m)$ ，$m$ 是二进制位的个数 布隆过滤器 - 误判率误判率 $p$ 受 $3$ 个因素影响：二进制位的个数 $m$、哈希函数的个数 $k$、数据规模 $n$ p = (1 - e^{-\frac{k(n+0.5)}{m-1}})^k ≈ (1 - e^{-\frac{kn}{m}})^k已知误判率 $p$、数据规模 $n$，求二进制位的个数 $m$、哈希函数的个数 $k$ m = - \frac{nlnp}{(ln2)^2} \\ k = \frac{m}{n} ln2布隆过滤器 - 实现布隆过滤器 - 基本定义数据的存放格式是数组，每个数组存放着Long个字节 123456789101112131415161718192021222324252627282930313233343536373839public class BloomFilter&lt;T&gt; &#123; /** * 二进制向量的长度(一共有多少个二进制位) */ private int bitSize; /** * 二进制向量 */ private long[] bits; /** * 哈希函数的个数 */ private int hashSize; /** * @param n 数据规模 * @param p 误判率, 取值范围(0, 1) */ public BloomFilter(int n, double p) &#123; if (n &lt;= 0 || p &lt;= 0 || p &gt;= 1) &#123; throw new IllegalArgumentException("wrong n or p"); &#125; // 下面三个参数是根据公式计算的 double ln2 = Math.log(2); // 求出二进制向量的长度 bitSize = (int) (- (n * Math.log(p)) / (ln2 * ln2)); // 求出哈希函数的个数 hashSize = (int) (bitSize * ln2 / n); // bits数组的长度 bits = new long[(bitSize + Long.SIZE - 1) / Long.SIZE]; &#125; private void nullCheck(T value) &#123; if (value == null) &#123; throw new IllegalArgumentException("Value must not be null."); &#125; &#125;&#125; 布隆过滤器 - 设置index位置的二进位为1(按位或 | ) $101010101010010101$ $\mid 000000000000000100$ $(1 &lt;&lt; index)$ $101010111010010101$ 123456789private boolean set(int index) &#123; // （index / Long.SIZE） index在数组中的下标 // value改下标的值 long value = bits[index / Long.SIZE]; int bitValue = 1 &lt;&lt; (index % Long.SIZE); bits[index / Long.SIZE] = value | bitValue; return (value &amp; bitValue) == 0;&#125; 布隆过滤器 - 查看index位置的二进位的值 $101010101010010101$ &amp;$000000000000000100$ $(1 &lt;&lt; index)$ $000000000000000100$ 123456// @return true代表1, false代表0private boolean get(int index) &#123; long value = bits[index / Long.SIZE]; int bitValue = 1 &lt;&lt; (index % Long.SIZE); return (value &amp; bitValue) != 0;&#125; 布隆过滤器 - 添加元素1234567891011121314151617181920public boolean put(T value) &#123; nullCheck(value); // 利用value生成2个整数 int hash1 = value.hashCode(); int hash2 = hash1 &gt;&gt;&gt; 16; boolean result = false; for (int i = 1; i &lt;= hashSize; i++) &#123; int combinedHash = hash1 + (i * hash2); if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; // 生成一个二进位的索引 int index = combinedHash % bitSize; // 设置index位置的二进位为1 if (set(index)) result = true; &#125; return result;&#125; 布隆过滤器 - 判断一个元素是否存在123456789101112131415161718public boolean contains(T value) &#123; nullCheck(value); // 利用value生成2个整数 int hash1 = value.hashCode(); int hash2 = hash1 &gt;&gt;&gt; 16; for (int i = 1; i &lt;= hashSize; i++) &#123; int combinedHash = hash1 + (i * hash2); if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; // 生成一个二进位的索引 int index = combinedHash % bitSize; // 查询index位置的二进位是否为0 if (!get(index)) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>布隆过滤器</tag>
        <tag>BloomFilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2020%2F07%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划（Dynamic Programming）动态规划 - 是什么动态规划，简称 $DP$ 是求解最优化问题的一种常用策略 通常的使用套路（一步一步优化） ① 暴力递归（自顶向下，出现了重叠子问题） ② 记忆化搜索（自顶向下） ③ 递推（自底向上） 动态规划 - 常规步骤动态规划中的“动态”可以理解为是“会变化的状态” ① 定义状态（状态是原问题、子问题的解） ​ 比如定义 $dp(i)$ 的含义 ② 设置初始状态（边界） ​ 比如设置 $dp(0)$ 的值 ③ 确定状态转移方程 ​ 比如确定 $dp(i)$ 和 $dp(i – 1)$ 的关系 动态规划 - 一些相关概念来自维基百科的解释 Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions. ① 将复杂的原问题拆解成若干个简单的子问题 ② 每个子问题仅仅解决1次，并保存它们的解 ③ 最后推导出原问题的解 可以用动态规划来解决的问题，通常具备 $2$ 个特点 最优子结构（最优化原理）：通过求解子问题的最优解，可以获得原问题的最优解 无后效性 某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响（未来与过去无关） 在推导后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的 练习1 – 找零钱LeetCode地址 假设有 $25$ 分、$20$ 分、$5$ 分、$1$ 分的硬币，现要找给客户 $41$ 分的零钱，如何办到硬币个数最少？ 此前用贪心策略得到的并非是最优解（贪心得到的解是 $5$ 枚硬币） 假设 $dp(n)$ 是凑到 $n$ 分需要的最少硬币个数 如果第 $1$ 次选择了 $25$ 分的硬币，那么 $dp(n) = dp(n – 25) + 1$ 如果第 $1$ 次选择了 $20$ 分的硬币，那么 $dp(n) = dp(n – 20) + 1$ 如果第 $1$ 次选择了 $5$ 分的硬币，那么 $dp(n) = dp(n – 5) + 1$ 如果第 $1$ 次选择了 $1$ 分的硬币，那么 $dp(n) = dp(n – 1) + 1$ 所以 $dp(n) = min \{ dp(n – 25), dp(n – 20), dp(n – 5), dp(n – 1) \} + 1$ 找零钱 – 暴力递归12345678// 暴力递归（自顶向下的调用，出现了重叠子问题）static int coins(int n) &#123; if (n &lt; 1) return Integer.MAX_VALUE; if (n == 25 || n == 20 || n == 5 || n == 1) return 1; int min1 = Math.min(coins(n - 25), coins(n - 20)); int min2 = Math.min(coins(n - 5), coins(n - 1)); return Math.min(min1, min2) + 1;&#125; 类似于斐波那契数列的递归版，会有大量的重复计算，时间复杂度较高 找零钱 – 记忆化搜索1234567891011121314151617181920212223// 记忆化搜索（自顶向下的调用）static int coins(int n) &#123; if (n &lt; 1) return -1; int[] dp = new int[n + 1]; // 判断传入的 n 是否大于面值 int[] faces = &#123;1, 5, 20, 25&#125;; for (int face : faces) &#123; if (n &lt; face) break; dp[face] = 1; &#125; return coins(n, dp);&#125;static int coins(int n, int[] dp) &#123; if (n &lt; 1) return Integer.MAX_VALUE; if (dp[n] == 0) &#123; int min1 = Math.min(coins(n - 25, dp), coins(n - 20, dp)); int min2 = Math.min(coins(n - 5, dp), coins(n - 1, dp)); dp[n] = Math.min(min1, min2) + 1; &#125; return dp[n];&#125; 找零钱 – 递推12345678910111213// 递推（自底向上）static int coins3(int n) &#123; if (n &lt; 1) return -1; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; int min = dp[i - 1]; if (i &gt;= 5) min = Math.min(dp[i - 5], min); if (i &gt;= 20) min = Math.min(dp[i - 20], min); if (i &gt;= 25) min = Math.min(dp[i - 25], min); dp[i] = min + 1; &#125; return dp[n];&#125; 时间复杂度、空间复杂度：$O(n)$ 输出找零钱的具体方案123456789101112131415161718192021222324252627282930313233343536static int coins4(int n) &#123; if (n &lt; 1) return -1; int[] dp = new int[n + 1]; // faces[i]是凑够i分时最后那枚硬币的面值 int[] faces = new int[dp.length]; for (int i = 1; i &lt;= n; i++) &#123; int min = dp[i - 1]; faces[i] = 1; if (i &gt;= 5 &amp;&amp; dp[i - 5] &lt; min) &#123; min = dp[i - 5]; faces[i] = 5; &#125; if (i &gt;= 20 &amp;&amp; dp[i - 20] &lt; min) &#123; min = dp[i - 20]; faces[i] = 20; &#125; if (i &gt;= 25 &amp;&amp; dp[i - 25] &lt; min) &#123; min = dp[i - 25]; faces[i] = 25; &#125; dp[i] = min + 1; print(faces, i); &#125; // print(faces, n); return dp[n];&#125;static void print(int[] faces, int n) &#123; System.out.print("[" + n + "] = "); while (n &gt; 0) &#123; System.out.print(faces[n] + " "); n -= faces[n]; &#125; System.out.println();&#125; 找零钱 – 通用实现12345678910111213141516171819static int coins5(int n, int[] faces) &#123; if (n &lt; 1 || faces == null || faces.length == 0) return -1; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; int min = Integer.MAX_VALUE; for (int face : faces) &#123; if (i &lt; face) continue; int v = dp[i - face]; if (v &lt; 0 || v &gt;= min) continue; min = v; &#125; if (min == Integer.MAX_VALUE) &#123; dp[i] = -1; &#125; else &#123; dp[i] = min + 1; &#125; &#125; return dp[n];&#125; 练习2 – 最大连续子序列和给定一个长度为 $n$ 的整数序列，求它的最大连续子序列和 比如 $–2、1、–3、4、–1、2、1、–5、4$ 的最大连续子序列和是 $4 + (–1) + 2 + 1 = 6$ 状态定义 假设 $dp(i)$ 是以 $nums[i]$ 结尾的最大连续子序列和（$nums$ 是整个序列） 以 $nums[0] – 2$ 结尾的最大连续子序列是 $–2$，所以 $dp(0) = –2$ 以 $nums[1] 1$ 结尾的最大连续子序列是 $1$，所以 $dp(1) = 1$ 以 $nums[2] –3$ 结尾的最大连续子序列是 $1、–3$，所以 $dp(2) = dp(1) + (–3) = –2$ 以 $nums[3] 4$ 结尾的最大连续子序列是 $4$，所以 $dp(3) = 4$ 以 $nums[4] –1$ 结尾的最大连续子序列是 $4、–1$，所以 $dp(4) = dp(3) + (–1) = 3$ 以 $nums[5] 2$ 结尾的最大连续子序列是 $4、–1、2$，所以 $dp(5) = dp(4) + 2 = 5$ 以 $nums[6] 1$ 结尾的最大连续子序列是 $4、–1、2、1$，所以 $dp(6) = dp(5) + 1 = 6$ 以 $nums[7] –5$ 结尾的最大连续子序列是 $4、–1、2、1、–5$，所以 $dp(7) = dp(6) + (–5) = 1$ 以 $nums[8] 4$ 结尾的最大连续子序列是 $4、–1、2、1、–5、4$，所以 $dp(8) = dp(7) + 4 = 5$ 最大连续子序列和 – 状态转移方程和初始状态状态转移方程 如果 $dp(i – 1) ≤ 0$，那么 $dp(i) = nums[i]$ 如果 $dp(i – 1) &gt; 0$，那么 $dp(i) = dp(i – 1) + nums[i]$ 初始状态 $dp(0)$ 的值是 $nums[0]$ 最终的解 最大连续子序列和是所有 $dp(i)$ 中的最大值 $max \{ dp(i) \}，i ∈ [0, nums.length)$ 最大连续子序列和 – 动态规划 – 一维数组实现1234567891011121314151617public int maxSubArray1(int[] nums) &#123; // nums = &#123;–2、1、–3、4、–1、2、1、–5、4&#125; if (nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; dp.length; i++) &#123; int prev = dp[i - 1]; if (prev &lt;= 0) &#123; dp[i] = nums[i]; &#125; else &#123; dp[i] = prev + nums[i]; &#125; max = Math.max(dp[i], max); &#125; return max;&#125; 空间复杂度：$O(n)$，时间复杂度：$O(n)$ 最大连续子序列和 – 动态规划 – 优化实现(去掉一维数组)123456789101112131415public int maxSubArray2(int[] nums) &#123; // nums = &#123;–2、1、–3、4、–1、2、1、–5、4&#125; if (nums == null || nums.length == 0) return 0; int dp = nums[0]; int max = dp; for (int i = 1; i &lt; nums.length; i++) &#123; if (dp &lt;= 0) &#123; dp = nums[i]; &#125; else &#123; dp = dp + nums[i]; &#125; max = Math.max(dp, max); &#125; return max;&#125; 空间复杂度：$O(1)$，时间复杂度：$O(n)$ 练习3 – 最长上升子序列（LIS）最长上升子序列（最长递增子序列，$Longest Increasing Subsequence，LIS$） leetcode地址 最长上升子序列 – 动态规划 – 状态定义假设数组是 $nums， [10, 2, 2, 5, 1, 7, 101, 18]$ $dp(i)$ 是以 $nums[i]$ 结尾的最长上升子序列的长度，$i ∈ [0, nums.length)$ 以 $nums[0] 10$ 结尾的最长上升子序列是 $10$，所以 $dp(0) = 1$ 以 $nums[1] 2$ 结尾的最长上升子序列是 $2$，所以 $dp(1) = 1$ 以 $nums[2] 2$ 结尾的最长上升子序列是 $2$，所以 $dp(2) = 1$ 以 $nums[3] 5$ 结尾的最长上升子序列是 $2、5$，所以 $dp(3) = dp(1) + 1 = dp(2) + 1 = 2$ 以 $nums[4] 1$ 结尾的最长上升子序列是 $1$，所以 $dp(4) = 1$ 以 $nums[5] 7$ 结尾的最长上升子序列是 $2、5、7$，所以 $dp(5) = dp(3) + 1 = 3$ 以 $nums[6] 101$ 结尾的最长上升子序列是 $2、5、7、101$，所以 $dp(6) = dp(5) + 1 = 4$ 以 $nums[7] 18$ 结尾的最长上升子序列是 $2、5、7、18$，所以 $dp(7) = dp(5) + 1 = 4$ 最长上升子序列的长度是所有 $dp(i)$ 中的最大值 $max \{ dp(i) \}，i ∈ [0, nums.length)$ 最长上升子序列 – 动态规划 – 状态转移方程遍历 $j ∈ [0, i)$ 当 $nums[i] &gt; nums[ j]$ $nums[i]$ 可以接在 $nums[j]$ 后面，形成一个比 $dp(j)$ 更长的上升子序列，长度为 $dp(j) + 1$ $dp(i) = max \{ dp(i), dp( j) + 1 \}$ 当 $nums[i] ≤ nums[j]$ $nums[i]$ 不能接在 $nums[j]$ 后面，跳过此次遍历$（continue）$ 状态的初始值 $dp(0) = 1$ 所有的 $dp(i)$ 默认都初始化为 $1$ 最长上升子序列 – 动态规划 – 实现1234567891011121314static int lengthOfLIS1(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length]; int max = dp[0] = 1; for (int i = 1; i &lt; dp.length; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &lt;= nums[j]) continue; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; max = Math.max(dp[i], max); &#125; return max;&#125; 空间复杂度：$O(n)$，时间复杂度：$O(n^2)$ 最长上升子序列 – 二分搜索 – 思路把每个数字看做是一张扑克牌，从左到右按顺序处理每一个扑克牌 将它压在（从左边数过来）第一个牌顶 ≥ 它的牌堆上面 如果找不到牌顶 ≥ 它的牌堆，就在最右边新建一个牌堆，将它放入这个新牌堆中 当处理完所有牌，最终牌堆的数量就是最长上升子序列的长度 思路（假设数组是 $nums$，也就是最初的牌数组） $top[i]$ 是第 $i$ 个牌堆的牌顶，$len$ 是牌堆的数量，初始值为 $0$ 遍历每一张牌 $num$ 利用二分搜索找出 $num$ 最终要放入的牌堆位置 $index$ $num$ 作为第 $index$ 个牌堆的牌顶，$top[index] = num$ 如果 $index$ 等于 $len$，相当于新建一个牌堆，牌堆数量 $+1$，也就是 $len++$ 最长上升子序列 – 二分搜索 – 实现1234567891011121314151617181920212223242526static int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; // 牌堆的数量 int len = 0; // 牌顶数组 int[] top = new int[nums.length]; // 遍历所有的牌 for (int num : nums) &#123; int begin = 0; int end = len; // 二分搜索 while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (num &lt;= top[mid]) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; // 覆盖牌顶 top[begin] = num; // 检查是否要新建一个牌堆 if (begin == len) len++; &#125; return len;&#125; 空间复杂度：$O(n)$；时间复杂度：$O(nlogn)$ 练习4 – 最长公共子序列（LCS）最长公共子序列（$Longest Common Subsequence，LCS$） leetcode地址 最长公共子序列 – 思路假设 $2$ 个序列分别是 $nums1、nums2$ $i ∈ [1, nums1.length]$ $j ∈ [1, nums2.length]$ 假设 $dp(i, j)$ 是【$nums1$ 前 $i$ 个元素】与【$nums2$ 前 $j$ 个元素】的最长公共子序列长度 $dp(i, 0)、dp(0, j)$ 初始值均为 $0$ 如果 $nums1[i – 1] = nums2[ j – 1]$，那么 $dp(i, j) = dp(i – 1, j – 1) + 1$ 如果 $nums1[i – 1] ≠ nums2[ j – 1]$，那么 $dp(i, j) = max \{ dp(i – 1, j), dp(i, j – 1) \}$ 最长公共子序列 – 递归实现12345678910111213141516int lcs1(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; return lcs1(nums1, nums1.length, nums2, nums2.length);&#125;/** * 求nums1前i个元素和nums2前j个元素的最长公共子序列长度 */int lcs1(int[] nums1, int i, int[] nums2, int j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; return lcs1(nums1, i - 1, nums2, j - 1) + 1; &#125; return Math.max(lcs1(nums1, i - 1, nums2, j), lcs1(nums1, i, nums2, j - 1));&#125; 空间复杂度：$O(k)$ , $k = min\{n, m\}，n、m$ 是 $2$ 个序列的长度 时间复杂度：$O(2^n)$，当 $n = m$ 时 最长公共子序列 – 递归实现分析 出现了重复的递归调用 最长公共子序列 – 非递归实现 - 二维数组实现123456789101112131415int lcs2(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[][] dp = new int[nums1.length + 1][nums2.length + 1]; for (int i = 1; i &lt;= nums1.length; i++) &#123; for (int j = 1; j &lt;= nums2.length; j++) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[nums1.length][nums2.length];&#125; 空间复杂度：$O(n ∗ m)$，时间复杂度：$O(n ∗ m)$ $dp$ 数组的计算结果分析 举例：计算 $dp[1][2]$ 时，需要的前提计算结果为 $dp[1,1]、dp[0,2]$ 和 $dp[0,1]$ 的值 最长公共子序列 – 非递归实现 – 滚动数组可以使用滚动数组优化空间复杂度 1234567891011121314151617static int lcs3(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[][] dp = new int[2][nums2.length + 1]; for (int i = 1; i &lt;= nums1.length; i++) &#123; int row = i &amp; 1; int prevRow = (i - 1) &amp; 1; for (int j = 1; j &lt;= nums2.length; j++) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[row][j] = dp[prevRow][j - 1] + 1; &#125; else &#123; dp[row][j] = Math.max(dp[prevRow][j], dp[row][j - 1]); &#125; &#125; &#125; return dp[nums1.length &amp; 1][nums2.length];&#125; 最长公共子序列 – 非递归实现 – 一维数组可以将 二维数组 优化成 一维数组，进一步降低空间复杂度 举例：当计算 $dp[6]$ 时，$dp[]$ 数组中的值存放的就是下图中圆圈的值，再将 $dp[6]$ 左上角的值存放在 $leftTop$ 中即可。 另一种思路：每行的列从后往前计算，$leftTop$ 也可省略，只需一个一维数组。 123456789101112131415161718static int lcs4(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[] dp = new int[nums2.length + 1]; for (int i = 1; i &lt;= nums1.length; i++) &#123; int cur = 0; for (int j = 1; j &lt;= nums2.length; j++) &#123; int leftTop = cur; cur = dp[j]; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = leftTop + 1; &#125; else &#123; dp[j] = Math.max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[nums2.length];&#125; 最长公共子序列 – 非递归实现 – 一维数组再次优化可以将空间复杂度优化至$O(k) , k = min\{n, m\}$ 数组元素数量少的做列 $row$ 1234567891011121314151617181920212223static int lcs(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[] rowsNums = nums1, colsNums = nums2; if (nums1.length &lt; nums2.length) &#123; colsNums = nums1; rowsNums = nums2; &#125; int[] dp = new int[colsNums.length + 1]; for (int i = 1; i &lt;= rowsNums.length; i++) &#123; int cur = 0; for (int j = 1; j &lt;= colsNums.length; j++) &#123; int leftTop = cur; cur = dp[j]; if (rowsNums[i - 1] == colsNums[j - 1]) &#123; dp[j] = leftTop + 1; &#125; else &#123; dp[j] = Math.max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[colsNums.length];&#125; 最长公共子序列 - 字符串实现1234567891011121314151617181920212223242526public int longestCommonSubsequence(String text1, String text2) &#123; if (text1 == null || text2 == null) return 0; char[] chars1 = text1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = text2.toCharArray(); if (chars2.length == 0) return 0; char[] rowsChars = chars1, colsChars = chars2; if (chars1.length &lt; chars2.length) &#123; colsChars = chars1; rowsChars = chars2; &#125; int[] dp = new int[colsChars.length + 1]; for (int i = 1; i &lt;= rowsChars.length; i++) &#123; int cur = 0; for (int j = 1; j &lt;= colsChars.length; j++) &#123; int leftTop = cur; cur = dp[j]; if (rowsChars[i - 1] == colsChars[j - 1]) &#123; dp[j] = leftTop + 1; &#125; else &#123; dp[j] = Math.max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[colsChars.length];&#125; 练习5 – 最长公共子串最长公共子串$（Longest Common Substring）$ 子串是连续的子序列 求两个字符串的最长公共子串长度 $ABCBA$ 和 $BABCA$ 的最长公共子串是 $ABC$，长度为 $3$ 最长公共子串 – 思路 假设 $2$ 个字符串分别是 $str1、str2$ $i ∈ [1, str1.length]$ $j ∈ [1, str2.length]$ 假设 $dp(i, j)$ 是以 $str1[i – 1]、str2[ j – 1]$ 结尾的最长公共子串长度 $dp(i, 0)、dp(0, j)$ 初始值均为 $0$ 如果 $str1[i – 1] = str2[ j – 1]$，那么 $dp(i, j) = dp(i – 1, j – 1) + 1$ 如果 $str1[i – 1] ≠ str2[ j – 1]$，那么 $dp(i, j) = 0$ 最长公共子串的长度是所有 $dp(i, j)$ 中的最大值 $max \{ dp(i, j) \}$ 最长公共子串 – 实现 - 二维数组12345678910111213141516171819int lcs1(String str1, String str2) &#123; if (str1 == null || str2 == null) return 0; char[] chars1 = str1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = str2.toCharArray(); if (chars2.length == 0) return 0; int[][] dp = new int[chars1.length + 1][chars2.length + 1]; int max = 0; for (int i = 1; i &lt;= chars1.length; i++) &#123; for (int j = 1; j &lt;= chars2.length; j++) &#123; if (chars1[i - 1] != chars2[j - 1]) continue; dp[i][j] = dp[i - 1][j - 1] + 1; max = Math.max(dp[i][j], max); &#125; &#125; return max;&#125; 空间复杂度：$O(n ∗ m)$ 时间复杂度：$O(n ∗ m)$ 最长公共子串 – 一维数组实现(优化原理跟练习4类似)12345678910111213141516171819202122232425262728293031int lcs2(String str1, String str2) &#123; if (str1 == null || str2 == null) return 0; char[] chars1 = str1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = str2.toCharArray(); if (chars2.length == 0) return 0; char[] rowsChars = chars1, colsChars = chars2; if (chars1.length &lt; chars2.length) &#123; colsChars = chars1; rowsChars = chars2; &#125; // 上方整行的值 int[] dp = new int[colsChars.length + 1]; int max = 0; for (int row = 1; row &lt;= rowsChars.length; row++) &#123; // 左上角的值 int cur = 0; for (int col = 1; col &lt;= colsChars.length; col++) &#123; int leftTop = cur; cur = dp[col]; if (chars1[row - 1] != chars2[col - 1]) &#123; dp[col] = 0; &#125; else &#123; dp[col] = leftTop + 1; max = Math.max(dp[col], max); &#125; &#125; &#125; return max;&#125; 空间复杂度：$O(k),k = min\{n, m\}$ 时间复杂度：$O(n ∗ m)$ 最长公共子串 – 一维数组优化 - 每行的列从后往前开始计算1234567891011121314151617181920212223242526static int lcs(String str1, String str2) &#123; if (str1 == null || str2 == null) return 0; char[] chars1 = str1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = str2.toCharArray(); if (chars2.length == 0) return 0; char[] rowsChars = chars1, colsChars = chars2; if (chars1.length &lt; chars2.length) &#123; colsChars = chars1; rowsChars = chars2; &#125; int[] dp = new int[colsChars.length + 1]; int max = 0; for (int row = 1; row &lt;= rowsChars.length; row++) &#123; for (int col = colsChars.length; col &gt;= 1; col--) &#123; if (chars1[row - 1] != chars2[col - 1]) &#123; dp[col] = 0; &#125; else &#123; dp[col] = dp[col - 1] + 1; max = Math.max(dp[col], max); &#125; &#125; &#125; return max;&#125; 练习6 – 0-1背包 有 $n$ 件物品和一个最大承重为 $W$ 的背包，每件物品的重量是 $𝑤i$、价值是 $𝑣i$ 在保证总重量不超过 $W$ 的前提下，选择某些物品装入背包，背包的最大总价值是多少？ 注意：每个物品只有 $1$ 件，也就是每个物品只能选择 $0$ 件或者 $1$ 件 假设 $values$ 是价值数组，$weights$ 是重量数组 编号为 $k$ 的物品，价值是 $values[k]$，重量是 $weights[k]，k ∈ [0, n)$ 假设 $dp(i, j)$ 是最大承重为 $j$、有前 $i$ 件物品可选时的最大总价值，$i ∈ [1, n]，j ∈ [1, W]$ $dp(i, 0)、dp(0, j)$ 初始值均为 $0$ 如果 $j &lt; weights[i – 1]$，那么 $dp(i, j) = dp(i – 1, j)$ ，不够再容纳东西了 如果 $j ≥ weights[i – 1]$，那么 $dp(i, j) = max \{ dp(i – 1, j), dp(i – 1, j – weights[i – 1]) + values[i – 1] \}$，可以再容纳东西，有两种选择，装进背包与不装进背包 0-1背包 – 非递归实现123456789101112131415161718int maxValue1(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[][] dp = new int[values.length + 1][capacity + 1]; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = 1; j &lt;= capacity; j++) &#123; if (j &lt; weights[i - 1]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = Math.max( dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]]); &#125; &#125; &#125; return dp[values.length][capacity];&#125; dp 数组的计算结果分析 0-1背包 – 非递归实现 – 一维数组$dp(i, j)$ 都是由 $dp(i – 1, k)$ 推导出来的，也就是说，第 $i$ 行的数据是由它的上一行第 $i – 1$ 行推导出来的 因此，可以使用一维数组来优化 另外，由于 $k ≤ j$ ，所以 $j$ 的遍历应该由大到小，否则导致数据错乱（每行的列由后往前遍历） 1234567891011121314int maxValue2(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[] dp = new int[capacity + 1]; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = capacity; j &gt;= 1; j--) &#123; // j &lt; weights[i - 1] 可以合并到 for 循环里判断 if (j &lt; weights[i - 1]) continue; dp[j] = Math.max(dp[j], values[i - 1] + dp[j - weights[i - 1]]); &#125; &#125; return dp[capacity];&#125; 0-1背包 – 非递归实现 – 一维数组优化观察二维数组表，得出结论：$j$ 的下界可以从 $1$ 改为 $weights[i – 1]$ 123456789101112int maxValue(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[] dp = new int[capacity + 1]; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = capacity; j &gt;= weights[i - 1]; j--) &#123; dp[j] = Math.max(dp[j], values[i - 1] + dp[j - weights[i - 1]]); &#125; &#125; return dp[capacity];&#125; 0-1背包 – 恰好装满有 $n$ 件物品和一个最大承重为 $W$ 的背包，每件物品的重量是 $𝑤i$、价值是 $𝑣i$ 在保证总重量恰好等于 $W$ 的前提下，选择某些物品装入背包，背包的最大总价值是多少？ 注意：每个物品只有 $1$ 件，也就是每个物品只能选择 $0$ 件或者 $1$ 件 $dp(i, j)$ 初始状态调整 $dp(i, 0) = 0$，总重量恰好为 $0$，最大总价值必然也为 $0$ $dp(0, j) = –∞$（负无穷），$j ≥ 1$，负数在这里代表无法恰好装满 0-1背包 – 恰好装满 – 实现12345678910111213141516// 如果返回-1，代表没法刚好凑到capacity这个容量static int maxValueExactly(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[] dp = new int[capacity + 1]; for (int j = 1; j &lt;= capacity; j++) &#123; dp[j] = Integer.MIN_VALUE; &#125; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = capacity; j &gt;= weights[i - 1]; j--) &#123; dp[j] = Math.max(dp[j], values[i - 1] + dp[j - weights[i - 1]]); &#125; &#125; return dp[capacity] &lt; 0 ? -1 : dp[capacity];&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治]]></title>
    <url>%2F2020%2F07%2F19%2F%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[分治（Divide And Conquer）什么是分治分治，也就是分而治之。它的一般步骤是 ① 将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样） ② 子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解） ③ 利用子问题的解推导出原问题的解 因此，分治策略非常适合用递归 需要注意的是：子问题之间是相互独立的 分治的应用快速排序 归并排序 $Karatsuba$ 算法（大数乘法） 主定理（Master Theorem）分治策略通常遵守一种通用模式 解决规模为 $n$ 的问题，分解成 $a$ 个规模为 $\frac{n}{b}$ 的子问题，然后在 $O(n^d)$时间内将子问题的解合并起来 算法运行时间为：$T(n)= aT(\frac{n}{b}) + O(n^d), a &gt; 0,b &gt; 1,d ≥ 0$ $d &gt; log_ba, T(n) = O(n^d)$ $d = log_ba, T(n) = O(n^dlogn)$ $d &lt; log_ba, T(n) = O(n^{log_ba})$ 比如归并排序的运行时间是：$T(n) = 2T(\frac{n}{2}) + O(n), a = 2,b = 2,d = 1,$ 所以$T(n) = O(nlogn)$ 练习1 – 最大连续子序列和动态规划实现子序列 LeetCode地址 这道题也属于最大切片问题（最大区段，$Greatest Slice$） 概念区分：子串、子数组、子区间必须是连续的，子序列是可以不连续的 解法1 – 暴力出奇迹穷举出所有可能的连续子序列，并计算出它们的和，最后取它们中的最大值 123456789101112131415public int maxSubarray1(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int max = Integer.MIN_VALUE; for (int begin = 0; begin &lt; nums.length; begin++) &#123; for (int end = begin; end &lt; nums.length; end++) &#123; // sum是[begin, end]的和 int sum = 0; for (int i = begin; i &lt;= end; i++) &#123; sum += nums[i]; &#125; max = Math.max(max, sum); &#125; &#125; return max;&#125; 空间复杂度：$O(1)$ ，时间复杂度：$O(n^3)$ 解法1 – 暴力出奇迹 – 优化重复利用前面计算过的结果 12345678910111213public int maxSubarray2(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int max = Integer.MIN_VALUE; for (int begin = 0; begin &lt; nums.length; begin++) &#123; int sum = 0; for (int end = begin; end &lt; nums.length; end++) &#123; // sum是[begin, end]的和 sum += nums[end]; max = Math.max(max, sum); &#125; &#125; return max;&#125; 空间复杂度：$O(1)$ ，时间复杂度：$O(n^2)$ 解法2 – 分治123456789101112131415161718192021222324252627282930313233343536static int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; return maxSubArray(nums, 0, nums.length);&#125;/** * 求解[begin, end)中最大连续子序列的和 * T(n) = T(n/2) + T(n/2) + O(n) * T(n) = 2T(n/2) + O(n) * logba = 1 d = 1 */static int maxSubArray(int[] nums, int begin, int end) &#123; if (end - begin &lt; 2) return nums[begin]; int mid = (begin + end) &gt;&gt; 1; int leftMax = nums[mid - 1]; int leftSum = leftMax; for (int i = mid - 2; i &gt;= begin; i--) &#123; leftSum += nums[i]; leftMax = Math.max(leftMax, leftSum); &#125; int rightMax = nums[mid]; int rightSum = rightMax; for (int i = mid + 1; i &lt; end; i++) &#123; rightSum += nums[i]; rightMax = Math.max(rightMax, rightSum); &#125; return Math.max(leftMax + rightMax, Math.max( maxSubArray(nums, begin, mid), maxSubArray(nums, mid, end)) );&#125; 空间复杂度：$O(logn)$ 时间复杂度：$O(nlogn)$ 跟归并排序、快速排序一样 $T(n) = 2(T)(\frac{n}{2}) + O(n)$ 练习2 – 大数乘法$2$ 个超大的数（比如 $2$ 个 $100$ 位的数），如何进行乘法？ 按照小学时学习的乘法运算，在进行 $n$ 位数之间的相乘时，需要大约进行 $n^2$ 次个位数的相乘 比如计算 $36 * 54$ $T(n) = 4T(\frac{n}{2}) + O(n) = O(n^2)$ $1960$ 年 $Anatolii Alexeevitch Karatsuba$ 提出了 $Karatsuba$ 算法，提高了大数乘法的效率 $BC + AD = AC + BD − (A − B)(C − D)$ $T(n) = 3T(\frac{n}{2}) + O(n) = O(n^{log_23}) = O(n^{1.585})$]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2020%2F07%2F19%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[贪心（Greedy）什么是贪心算法贪心策略，也称为贪婪策略 每一步都采取当前状态下最优的选择（局部最优解），从而希望推导出全局最优解 贪心的应用 哈夫曼树 最小生成树算法：$Prim、Kruskal$ 最短路径算法：$Dijkstra$ 练习1 – 最优装载问题（加勒比海盗）在北美洲东南部，有一片神秘的海域，是海盗最活跃的加勒比海 有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值 海盗船的载重量为 $W$，每件古董的重量为 $𝑤_i$，海盗们该如何把尽可能多数量的古董装上海盗船？ 比如 $W$ 为 $30$，$𝑤_i$ 分别为 $3、 5、 4、 10、 7、 14、 2、 11$ 贪心策略：每一次都优先选择重量最小的古董 ① 选择重量为 $2$ 的古董，剩重量 $28$ ② 选择重量为 $3$ 的古董，剩重量 $25$ ③ 选择重量为 $4$ 的古董，剩重量 $21$ ④ 选择重量为 $5$ 的古董，剩重量 $16$ ⑤ 选择重量为 $7$ 的古董，剩重量 $9$ 最多能装载 $5$ 个古董 123456789101112131415161718public class Pirate &#123; public static void main(String[] args) &#123; int[] weights = &#123;3, 5, 4, 10, 7, 14, 2, 11&#125;; Arrays.sort(weights); int capacity = 30, weight = 0, count = 0; for (int i = 0; i &lt; weights.length &amp;&amp; weight &lt; capacity; i++) &#123; int newWeight = weight + weights[i]; if (newWeight &lt;= capacity) &#123; weight = newWeight; count++; System.out.println(weights[i]); &#125; &#125; System.out.println("一共选了" + count + "件古董"); &#125;&#125; 练习2 – 零钱兑换动态规划实现零钱兑换 假设有 $25$ 分、$10$ 分、$5$ 分、$1$ 分的硬币，现要找给客户 $41$ 分的零钱，如何办到硬币个数最少？ 贪心策略：每一次都优先选择面值最大的硬币 ① 选择 $25$ 分的硬币，剩 $16$ 分 ② 选择 $10$ 分的硬币，剩 $6$ 分 ③ 选择 $5$ 分的硬币，剩 $1$ 分 ④ 选择 $1$ 分的硬币 最终的解是共 $4$ 枚硬币 $25$ 分、$10$ 分、$5$ 分、$1$ 分硬币各一枚 12345678910111213Integer[] faces = &#123;25, 10, 5, 1&#125;Arrays.sort(faces);int coins = 0, money = 41;idx = faces.length - 1;while (idx &gt;= 0) &#123; while (money &gt;= faces[idx]) &#123; System.out.println(faces[idx]); money -= faces[idx]; coins++; &#125; idx--;&#125;System.out.println(coins); 零钱兑换的另一个例子假设有 $25$ 分、$20$ 分、$5$ 分、$1$ 分的硬币，现要找给客户 $41$ 分的零钱，如何办到硬币个数最少？ 贪心策略：每一步都优先选择面值最大的硬币 ① 选择 $25$ 分的硬币，剩 $16$ 分 ② 选择 $5$ 分的硬币，剩 $11$ 分 ③ 选择 $5$ 分的硬币，剩 $6$ 分 ④ 选择 $5$ 分的硬币，剩 $1$ 分 ⑤ 选择 $1$ 分的硬币 最终的解是 $1$ 枚 $25$ 分、$3$ 枚 $5$ 分、$1$ 枚 $1$ 分的硬币，共 $5$ 枚硬币 实际上本题的最优解是：$2$ 枚 $20$ 分、$1$ 枚 $1$ 分的硬币，共 $3$ 枚硬币 注意贪心策略并不一定能得到全局最优解 因为一般没有测试所有可能的解，容易过早做决定，所以没法达到最佳解 贪图眼前局部的利益最大化，看不到长远未来，走一步看一步 优点：简单、高效、不需要穷举所有可能，通常作为其他算法的辅助算法来使用 缺点：鼠目寸光，不从整体上考虑其他可能，每次采取局部最优解，不会再回溯，因此很少情况会得到最优解 练习3 – 0-1背包动态规划实现0-1背包 有 $n$ 件物品和一个最大承重为 $W$ 的背包，每件物品的重量是 $𝑤_i$、价值是 $𝑣_i$ 在保证总重量不超过 $W$ 的前提下，将哪几件物品装入背包，可以使得背包的总价值最大？ 注意：每个物品只有 $1$ 件，也就是每个物品只能选择 $0$ 件或者 $1$ 件，因此称为 $0-1$背包问题 如果采取贪心策略，有 $3$ 个方案 ① 价值主导：优先选择价值最高的物品放进背包 ② 重量主导：优先选择重量最轻的物品放进背包 ③ 价值密度主导：优先选择价值密度最高的物品放进背包（价值密度 = 价值 ÷ 重量） 0-1背包 – 实例假设背包最大承重 $150$，$7$ 个物品如表格所示 编号 1 2 3 4 5 6 7 重量 35 30 60 50 40 10 25 价值 10 40 30 50 35 40 30 价值密度 0.29 1.33 0.5 1.0 0.88 4.0 1.2 ① 价值主导：放入背包的物品编号是 $4、2、6、5$，总重量 $130$，总价值 $165$ ② 重量主导：放入背包的物品编号是 $6、7、2、1、5$，总重量 $140$，总价值 $155$ ③ 价值密度主导：放入背包的物品编号是 $6、2、7、4、1$，总重量 $150$，总价值 $170$ 0-1背包 – 实现123456789101112131415161718192021222324252627static void select(String title, Comparator&lt;Article&gt; cmp) &#123; Article[] articles = new Article[] &#123; new Article(35, 10), new Article(30, 40), new Article(60, 30), new Article(50, 50), new Article(40, 35), new Article(10, 40), new Article(25, 30) &#125;; Arrays.sort(articles, cmp); int capacity = 150, weight = 0, value = 0; List&lt;Article&gt; selectedArticles = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; articles.length &amp;&amp; weight &lt; capacity; i++) &#123; int newWeight = weight + articles[i].weight; if (newWeight &lt;= capacity) &#123; weight = newWeight; value += articles[i].value; selectedArticles.add(articles[i]); &#125; &#125; System.out.println("【" + title + "】"); System.out.println("总价值：" + value); for (int i = 0; i &lt; selectedArticles.size(); i++) &#123; System.out.println(selectedArticles.get(i)); &#125; System.out.println("-----------------------------");&#125; 1234567891011public static void main(String[] args) &#123; select("价值主导", (Article a1, Article a2) -&gt; &#123; return a2.value - a1.value; &#125;); select("重量主导", (Article a1, Article a2) -&gt; &#123; return a1.weight - a2.weight; &#125;); select("价值密度主导", (Article a1, Article a2) -&gt; &#123; return Double.compare(a2.valueDensity, a1.valueDensity); &#125;);&#125; 1234567891011121314public class Article &#123; public int weight; public int value; public double valueDensity; public Article(int weight, int value) &#123; this.weight = weight; this.value = value; valueDensity = value * 1.0 / weight; &#125; @Override public String toString() &#123; return "Article [weight=" + weight + ", value=" + value + ", valueDensity=" + valueDensity + "]"; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯]]></title>
    <url>%2F2020%2F07%2F18%2F%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[回溯（Back Tracking）什么是回溯回溯可以理解为：通过选择不同的岔路口来通往目的地（找到想要的结果） 每一步都选择一条路出发，能进则进，不能进则退回上一步（回溯），换一条路再试 树、图的深度优先搜索 ($DFS$)、八皇后、走迷宫都是典型的回溯应用 八皇后问题（Eight Queens）八皇后问题是一个古老而著名的问题 在 $8*8$ 格的国际象棋上摆放八个皇后，使其不能互相攻击：任意两个皇后都不能处于同一行、同一列、同一斜线上 请问有多少种摆法？ 八皇后问题的解决思路思路一：暴力出奇迹 从 $64$ 个格子中选出任意 $8$ 个格子摆放皇后，检查每一种摆法的可行性 一共 $C^8_{64}$ 种摆法（大概是 $4.4 ∗ 10^9$ 种摆法） 思路二：根据题意减小暴力程度 很显然，每一行只能放一个皇后，所以共有 $88$ 种摆法（ $16777216$ 种），检查每一种摆法的可行性 A^m_n = n(n-1) \cdots (n-m+1) = \frac{n!}{(n-m)!} \\ C^m_n = \frac{A^m_n}{m!} = \frac{n!}{m!(n-m)!} = C^{n-m}_n思路三：回溯法 回溯 + 剪枝 四皇后 – 回溯法在解决八皇后问题之前，可以先缩小数据规模，看看如何解决四皇后问题 四皇后 – 剪枝（Pruning） 八皇后 – 回溯法 八皇后实现 – 合法性检查123456789101112131415161718192021// 数组索引是行号，数组元素是列号int[] cols;// 一共有多少种摆法int ways;// 判断第row行第col列是否可以摆放皇后boolean isValid(int row, int col) &#123; for (int i = 0; i &lt; row; i++) &#123; // 第col列已经有皇后 if (cols[i] == col) &#123; return false; &#125; // 第i行的皇后跟第row行第col列格子处在同一斜线上 // 斜率等于 -1 或 1 if (row - i == Math.abs(col - cols[i])) &#123; return false; &#125; &#125; return true;&#125; 八皇后实现 – 打印12345678910111213void show() &#123; for (int row = 0; row &lt; cols.length; row++) &#123; for (int col = 0; col &lt; cols.length; col++) &#123; if (cols[row] == col) &#123; System.out.print("1 "); &#125; else &#123; System.out.print("0 "); &#125; &#125; System.out.println(); &#125; System.out.println("------------------------------");&#125; 八皇后实现 – 从某一行开始摆放皇后123456789101112131415161718192021// 从第row行开始摆放皇后void place(int row) &#123; // cols的大小为n，row == n，n个都摆完，证明这次的n个摆放是正确的 // 摆法++，展示摆法方式 if (row == cols.length) &#123; ways++; show(); // 继续寻找其他可能的摆法方式 return; &#125; // 不满足时回溯，行row--，列col++ for (int col = 0; col &lt; cols.length; col++) &#123; if (isValid(row, col)) &#123; // 在第row行第col列摆放皇后 cols[row] = col; // 满足时行row++，继续尝试在下一行摆放（递归） place(row + 1); &#125; &#125;&#125; 八皇后实现 – 摆放所有皇后123456void placeQueens(int n) &#123; if (n &lt; 1) return; cols = new int[n]; place(0); System.out.println(n + "皇后一共有" + ways + "种摆法");&#125; 八皇后优化 – 成员变量12345678910111213141516// 数组索引是行号，数组元素是列号// 仅在打印中使用int[] queens;// 标记着某一列是否有皇后，行号不用考虑boolean[] cols;// 标记着某一斜线上是否有皇后（左上角 -&gt; 右下角）↘// 举例：当n为4时，从左上角到右下角有7条斜线 n^2 - 1boolean[] leftTop;// 标记着某一斜线上是否有皇后（右上角 -&gt; 左下角）↙boolean[] rightTop;// 一共有多少种摆法int ways; 八皇后优化 – 从某一行开始摆放皇后1234567891011121314151617181920212223242526272829303132void place(int row) &#123; if (row == cols.length) &#123; ways++; show(); return; &#125; for (int col = 0; col &lt; cols.length; col++) &#123; // 如果成立，意味着col列已经有皇后 if (cols[col]) continue; // 两条斜线是否有皇后 int ltIndex = row - col + cols.length - 1; if (leftTop[ltIndex]) continue; int rtIndex = row +col; if (rightTop[rtIndex]) continue; // col列、两条斜线没皇后 // queens 回溯时不用修改，会被后来覆盖 // queens 只在打印时使用 queens[row] = col; cols[col] = true; leftTop[ltIndex] = true; rightTop[rtIndex] = true; place(row + 1); // 回溯（恢复现场） cols[col] = false; leftTop[ltIndex] = false; rightTop[rtIndex] = false; &#125;&#125; 八皇后优化 – 摆放所有皇后123456789void placeQueens(int n) &#123; if (n &lt; 1) return; queens = new int[n]; cols = new boolean[n]; leftTop = new boolean[(n &lt;&lt; 1) - 1]; rightTop = new boolean[leftTop.length]; place(0); System.out.println(n + "皇后一共有" + ways + "种摆法");&#125; 八皇后优化 – 对角线左上角 -&gt; 右下角的对角线索引：$row – col + 7$ 右上角 -&gt; 左下角的对角线索引：$row + col$]]></content>
      <categories>
        <category>算法</category>
        <category>算法对策</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径]]></title>
    <url>%2F2020%2F07%2F15%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径（Shortest Path）什么是最短路径最短路径是指两顶点之间权值之和最小的路径（有向图、无向图均适用，不能有负权环） 无权图相当于是全部边权值为 $1$ 的有权图 最短路径 – 负权边有负权边，但没有负权环时，存在最短路径 $A$ 到 $E$ 的最短路径是：$A → B → E$ 最短路径 – 负权环有负权环时，不存在最短路径 通过负权环， $A$ 到 $E$ 的路径可以无限短 $A → E → D → F → E → D → F → E → D → F → E → D → F → E → ……$ 求解最短路径的3个经典算法最短路径的典型应用之一：路径规划问题 单源最短路径算法 $Dijkstra$（迪杰斯特拉算法） $Bellman-Ford$（贝尔曼-福特算法） 多源最短路径算法 $Floyd$（弗洛伊德算法） Dijkstra$Dijkstra$ 属于单源最短路径算法，用于计算一个顶点到其他所有顶点的最短路径 使用前提：不能有负权边 时间复杂度：可优化至 $O(ElogV)$ ，$E$ 是边数量，$V$ 是节点数量 由荷兰的科学家 $Edsger Wybe Dijkstra$ 发明，曾在 $1972$ 年获得图灵奖 Dijkstra – 等价思考$Dijkstra$ 的原理其实跟生活中的一些自然现象完全一样 把每 $1$ 个顶点想象成是 $1$ 块小石头 每 $1$ 条边想象成是 $1$ 条绳子，每一条绳子都连接着 $2$ 块小石头，边的权值就是绳子的长度 将小石头和绳子平放在一张桌子上（下图是一张俯视图，图中黄颜色的是桌子） 接下来想象一下，手拽着小石头 $A$，慢慢地向上提起来，远离桌面 $B、D、C、E$会依次离开桌面 最后绷直的绳子就是 $A$ 到其他小石头的最短路径 有一个很关键的信息 后离开桌面的小石头，都是被先离开桌面的小石头拉起来的 Dijkstra – 执行过程 绿色：已经“离开桌面”，已经确定了最终的最短路径 红色：更新了最短路径信息 松弛操作$（Relaxation）$：更新 $2$ 个顶点之间的最短路径 这里一般是指：更新源点到另一个点的最短路径 松弛操作的意义：尝试找出更短的最短路径 确定 $A$ 到 $D$ 的最短路径后，对 $DC、DE$ 边进行松弛操作，更新了 $A$ 到 $C$、$A$ 到 $E$ 的最短路径 Dijkstra – 代码实现边和顶点的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static class Vertex&lt;V, E&gt; &#123; V value; Set&lt;Edge&lt;V, E&gt;&gt; inEdges = new HashSet&lt;&gt;(); Set&lt;Edge&lt;V, E&gt;&gt; outEdges = new HashSet&lt;&gt;(); Vertex(V value) &#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; return Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value); &#125; @Override public int hashCode() &#123; return value == null ? 0 : value.hashCode(); &#125; @Override public String toString() &#123; return value == null ? "null" : value.toString(); &#125;&#125;private static class Edge&lt;V, E&gt; &#123; Vertex&lt;V, E&gt; from; Vertex&lt;V, E&gt; to; E weight; Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123; this.from = from; this.to = to; &#125; EdgeInfo&lt;V, E&gt; info() &#123; return new EdgeInfo&lt;&gt;(from.value, to.value, weight); &#125; @Override public boolean equals(Object obj) &#123; Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj; return Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to); &#125; @Override public int hashCode() &#123; return from.hashCode() * 31 + to.hashCode(); &#125; @Override public String toString() &#123; return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125;private Map&lt;V, Vertex&lt;V, E&gt;&gt; vertices = new HashMap&lt;&gt;();private Set&lt;Edge&lt;V, E&gt;&gt; edges = new HashSet&lt;&gt;();private Comparator&lt;Edge&lt;V, E&gt;&gt; edgeComparator = (Edge&lt;V, E&gt; e1, Edge&lt;V, E&gt; e2) -&gt; &#123; return weightManager.compare(e1.weight, e2.weight);&#125;; 边信息的定义1234567891011121314151617181920212223242526272829303132public static class EdgeInfo&lt;V, E&gt; &#123; private V from; private V to; private E weight; public EdgeInfo(V from, V to, E weight) &#123; this.from = from; this.to = to; this.weight = weight; &#125; public V getFrom() &#123; return from; &#125; public void setFrom(V from) &#123; this.from = from; &#125; public V getTo() &#123; return to; &#125; public void setTo(V to) &#123; this.to = to; &#125; public E getWeight() &#123; return weight; &#125; public void setWeight(E weight) &#123; this.weight = weight; &#125; @Override public String toString() &#123; return "EdgeInfo [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; 路径信息的定义123456789101112131415161718192021222324public static class PathInfo&lt;V, E&gt; &#123; protected E weight; protected List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new LinkedList&lt;&gt;(); public PathInfo() &#123;&#125; public PathInfo(E weight) &#123; this.weight = weight; &#125; public E getWeight() &#123; return weight; &#125; public void setWeight(E weight) &#123; this.weight = weight; &#125; public List&lt;EdgeInfo&lt;V, E&gt;&gt; getEdgeInfos() &#123; return edgeInfos; &#125; public void setEdgeInfos(List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos) &#123; this.edgeInfos = edgeInfos; &#125; @Override public String toString() &#123; return "PathInfo [weight=" + weight + ", edgeInfos=" + edgeInfos + "]"; &#125;&#125; 权值的定义和比较1234567891011121314static WeightManager&lt;Double&gt; weightManager = new WeightManager&lt;Double&gt;() &#123; public int compare(Double w1, Double w2) &#123; return w1.compareTo(w2); &#125; public Double add(Double w1, Double w2) &#123; return w1 + w2; &#125; @Override public Double zero() &#123; return 0.0; &#125;&#125;; 从路径中挑一个最小的路径出来1234567891011private Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; getMinPath(Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123; Iterator&lt;Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt;&gt; it = paths.entrySet().iterator(); Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = it.next(); while (it.hasNext()) &#123; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; entry = it.next(); if (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) &lt; 0) &#123; minEntry = entry; &#125; &#125; return minEntry;&#125; dijkstra算法123456789101112131415161718192021222324252627282930private Map&lt;V, PathInfo&lt;V, E&gt;&gt; dijkstra(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) return null; // 已经是最短路径 存储起点到某个点，（包括路径信息） Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = new HashMap&lt;&gt;(); // 还未确定是最短路径 Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths = new HashMap&lt;&gt;(); // 初始化从起点出发，直接到的点，存放到paths paths.put(beginVertex, new PathInfo&lt;&gt;(weightManager.zero())); while (!paths.isEmpty()) &#123; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = getMinPath(paths); // minVertex离开桌面 Vertex&lt;V, E&gt; minVertex = minEntry.getKey(); PathInfo&lt;V, E&gt; minPath = minEntry.getValue(); selectedPaths.put(minVertex.value, minPath); paths.remove(minVertex); // 对它的minVertex的outEdges进行松弛操作 for (Edge&lt;V, E&gt; edge : minVertex.outEdges) &#123; // 如果edge.to已经离开桌面，就没必要进行松弛操作 if (selectedPaths.containsKey(edge.to.value)) continue; relaxForDijkstra(edge, minPath, paths); &#125; &#125; selectedPaths.remove(begin); return selectedPaths;&#125; 松弛操作123456789101112131415161718192021222324/** * 松弛 * @param edge 需要进行松弛的边 * @param fromPath edge的from的最短路径信息 * @param paths 存放着其他点（对于dijkstra来说，就是还没有离开桌面的点）的最短路径信息 */private void relaxForDijkstra(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123; // 新的可选择的最短路径：beginVertex到edge.from的最短路径 + edge.weight E newWeight = weightManager.add(fromPath.weight, edge.weight); // 以前的最短路径：beginVertex到edge.to的最短路径 PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to); if (oldPath != null &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= 0) return; if (oldPath == null) &#123; oldPath = new PathInfo&lt;&gt;(); paths.put(edge.to, oldPath); &#125; else &#123; oldPath.edgeInfos.clear(); &#125; oldPath.weight = newWeight; oldPath.edgeInfos.addAll(fromPath.edgeInfos); oldPath.edgeInfos.add(edge.info());&#125; Dijkstra - 算法测试构建有向图1234567891011121314private static Graph&lt;Object, Double&gt; directedGraph(Object[][] data) &#123; Graph&lt;Object, Double&gt; graph = new ListGraph&lt;&gt;(weightManager); for (Object[] edge : data) &#123; if (edge.length == 1) &#123; graph.addVertex(edge[0]); &#125; else if (edge.length == 2) &#123; graph.addEdge(edge[0], edge[1]); &#125; else if (edge.length == 3) &#123; double weight = Double.parseDouble(edge[2].toString()); graph.addEdge(edge[0], edge[1], weight); &#125; &#125; return graph;&#125; 无负权值测试 1234567891011121314public static void main(String[] args) &#123; public static final Object[][] SP = &#123; &#123;"A", "B", 10&#125;, &#123;"A", "D", 30&#125;, &#123;"A", "E", 100&#125;, &#123;"B", "C", 50&#125;, &#123;"C", "E", 10&#125;, &#123;"D", "C", 20&#125;, &#123;"D", "E", 60&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.SP); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra("A"); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; 有负权值测试（dijkstra不能有负权边） 1234567891011121314public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT1 = &#123; &#123;"A", "B", -1&#125;, &#123;"A", "C", 4&#125;, &#123;"B", "C", 3&#125;, &#123;"B", "D", 2&#125;, &#123;"B", "E", 2&#125;, &#123;"D", "B", 1&#125;, &#123;"D", "C", 5&#125;, &#123;"E", "D", -3&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra("A"); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; $dijkstra$ 算法不能有负权边，不然会算错 Bellman−FordBellman−Ford - 是什么$Bellman-Ford$ 也属于单源最短路径算法，支持负权边，还能检测出是否有负权环 算法原理：对所有的边进行 $V – 1$ 次松弛操作（ $V$ 是节点数量），得到所有可能的最短路径 时间复杂度：$O(EV)$ ，$E$ 是边数量，$V$ 是节点数量 下图的最好情况是恰好从左到右的顺序对边进行松弛操作 对所有边仅需进行 $1$ 次松弛操作就能计算出 $A$ 到达其他所有顶点的最短路径 最坏情况是恰好每次都从右到左的顺序对边进行松弛操作 对所有边需进行 $V – 1$ 次松弛操作才能计算出 $A$ 到达其他所有顶点的最短路径 Bellman-Ford – 实例一共 $8$ 条边 假设每次松弛操作的顺序是：$DC、DF、BC、ED、EF、BE、AE、AB$ 不难分析出，经过 $4$ 次松弛操作之后，已经计算出了 $A$ 到其他所有顶点的最短路径 Bellman-Ford – 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private Map&lt;V, PathInfo&lt;V, E&gt;&gt; bellmanFord(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) return null; Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = new HashMap&lt;&gt;(); // 初始化起点权值为0，（A -&gt; A = 0）后续松弛操作才能计算，权值相加和比较不能为null selectedPaths.put(begin, new PathInfo&lt;&gt;(weightManager.zero())); int count = vertices.size() - 1; for (int i = 0; i &lt; count; i++) &#123; // v - 1 次 for (Edge&lt;V, E&gt; edge : edges) &#123; PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value); if (fromPath == null) continue; relax(edge, fromPath, selectedPaths); &#125; &#125; // 判断是否有环 for (Edge&lt;V, E&gt; edge : edges) &#123; PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value); if (fromPath == null) continue; if (relax(edge, fromPath, selectedPaths)) &#123; System.out.println("有负权环"); return null; &#125; &#125; selectedPaths.remove(begin); return selectedPaths;&#125;/** * 松弛 * @param edge 需要进行松弛的边 * @param fromPath edge的from的最短路径信息 * @param paths 存放着其他点（对于dijkstra来说，就是还没有离开桌面的点）的最短路径信息 */private boolean relax(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;V, PathInfo&lt;V, E&gt;&gt; paths) &#123; // 新的可选择的最短路径：beginVertex到edge.from的最短路径 + edge.weight E newWeight = weightManager.add(fromPath.weight, edge.weight); // 以前的最短路径：beginVertex到edge.to的最短路径 PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to.value); if (oldPath != null &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= 0) return false; if (oldPath == null) &#123; oldPath = new PathInfo&lt;&gt;(); paths.put(edge.to.value, oldPath); &#125; else &#123; oldPath.edgeInfos.clear(); &#125; oldPath.weight = newWeight; oldPath.edgeInfos.addAll(fromPath.edgeInfos); oldPath.edgeInfos.add(edge.info()); return true;&#125; Bellman-Ford – 算法测试有负权值测试 1234567891011121314public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT1 = &#123; &#123;"A", "B", -1&#125;, &#123;"A", "C", 4&#125;, &#123;"B", "C", 3&#125;, &#123;"B", "D", 2&#125;, &#123;"B", "E", 2&#125;, &#123;"D", "B", 1&#125;, &#123;"D", "C", 5&#125;, &#123;"E", "D", -3&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord("A"); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; 有负权环测试 12345678910111213public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT2 = &#123; &#123;0, 1, 1&#125;, &#123;1, 2, 7&#125;, &#123;1, 0, -2&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT2); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord(0); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; FloydFloyd - 是什么$Floyd$ 属于多源最短路径算法，能够求出任意 $2$ 个顶点之间的最短路径，支持负权边 时间复杂度：$O(V^3)$，效率比执行 $V$ 次 $Dijkstra$ 算法要好（ $V$ 是顶点数量） 算法原理 从任意顶点 $i$ 到任意顶点 $j$ 的最短路径不外乎两种可能 ① 直接从 $i$ 到 $j$ ② 从 $i$ 经过若干个顶点到 $j$ 假设 $dist(i，j)$ 为顶点 $i$ 到顶点 $j$ 的最短路径的距离 对于每一个顶点 $k$，检查 $dist(i，k) + dist(k，j)＜dist(i，j)$ 是否成立 如果成立，证明从 $i$ 到 $k$ 再到 $j$ 的路径比 $i$ 直接到 $j$ 的路径短，设置 $dist(i，j) = dist(i，k) + dist(k，j)$ 当我们遍历完所有结点 $k$，$dist(i，j)$ 中记录的便是 $i$ 到 $j$ 的最短路径的距离 12345678910// 伪代码for (int k = 0; k &lt; V; k++) &#123; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (dist(i,k)) + dist(k,j) &lt; dist(i,j))&#123; dist(i,j) = dist(i,k) + dist(k,j); &#125; &#125; &#125;&#125; Floyd - 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; floyd() &#123; Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths = new HashMap&lt;&gt;(); // 初始化 for (Edge&lt;V, E&gt; edge : edges) &#123; // 把能直接走的路径存放在map Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(edge.from.value); if (map == null) &#123; map = new HashMap&lt;&gt;(); paths.put(edge.from.value, map); &#125; PathInfo&lt;V, E&gt; pathInfo = new PathInfo&lt;&gt;(edge.weight); pathInfo.edgeInfos.add(edge.info()); map.put(edge.to.value, pathInfo); &#125; vertices.forEach((V v2, Vertex&lt;V, E&gt; vertex2) -&gt; &#123; vertices.forEach((V v1, Vertex&lt;V, E&gt; vertex1) -&gt; &#123; vertices.forEach((V v3, Vertex&lt;V, E&gt; vertex3) -&gt; &#123; if (v1.equals(v2) || v2.equals(v3) || v1.equals(v3)) return; // v1 -&gt; v2 PathInfo&lt;V, E&gt; path12 = getPathInfo(v1, v2, paths); if (path12 == null) return; // v2 -&gt; v3 PathInfo&lt;V, E&gt; path23 = getPathInfo(v2, v3, paths); if (path23 == null) return; // v1 -&gt; v3 PathInfo&lt;V, E&gt; path13 = getPathInfo(v1, v3, paths); E newWeight = weightManager.add(path12.weight, path23.weight); if (path13 != null &amp;&amp; weightManager.compare(newWeight, path13.weight) &gt;= 0) return; if (path13 == null) &#123; path13 = new PathInfo&lt;V, E&gt;(); paths.get(v1).put(v3, path13); &#125; else &#123; path13.edgeInfos.clear(); &#125; path13.weight = newWeight; path13.edgeInfos.addAll(path12.edgeInfos); path13.edgeInfos.addAll(path23.edgeInfos); &#125;); &#125;); &#125;); return paths;&#125;// 获取路径信息private PathInfo&lt;V, E&gt; getPathInfo(V from, V to, Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths) &#123; Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(from); return map == null ? null : map.get(to);&#125; Floyd - 算法测试 12345678910111213141516public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT1 = &#123; &#123;"A", "B", -1&#125;, &#123;"A", "C", 4&#125;, &#123;"B", "C", 3&#125;, &#123;"B", "D", 2&#125;, &#123;"B", "E", 2&#125;, &#123;"D", "B", 1&#125;, &#123;"D", "C", 5&#125;, &#123;"E", "D", -3&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1); Map&lt;Object, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt;&gt; sp = graph.shortestPath(); sp.forEach((Object from, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; paths) -&gt; &#123; System.out.println(from + "---------------------"); paths.forEach((Object to, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(to + " - " + path); &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>Dijkstra</tag>
        <tag>迪杰斯特拉算法</tag>
        <tag>Bellman-Ford</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成树]]></title>
    <url>%2F2020%2F07%2F15%2F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[生成树（Spanning Tree）什么是生成树生成树 $（ Spanning Tree ）$，也称为支撑树 连通图的极小连通子图，它含有图中全部的 $n$ 个顶点，恰好只有 $n – 1$ 条边 最小生成树（Minimum Spanning Tree）最小生成树$（Minimum Spanning Tree$，简称$MST）$ 也称为最小权重生成树$（Minimum Weight Spanning Tree）$、最小支撑树 是所有生成树中，总权值最小的那棵 适用于有权的连通图（无向） 最小生成树的应用最小生成树在许多领域都有重要的作用，例如 要在 $n$ 个城市之间铺设光缆，使它们都可以通信 铺设光缆的费用很高，且各个城市之间因为距离不同等因素，铺设光缆的费用也不同 如何使铺设光缆的总费用最低？ 最小生成树的实现算法如果图的每一条边的权值都互不相同，那么最小生成树将只有一个，否则可能会有多个最小生成树 求最小生成树的 $2$ 个经典算法 $Prim$（普里姆算法） $Kruskal$（克鲁斯克尔算法） 切分定理切分$（Cut）$：把图中的节点分为两部分，称为一个切分 下图有个切分 $C = (S, T)，S = \{A, B, D\}，T = \{C, E\}$ 横切边$（Crossing Edge）$：如果一个边的两个顶点，分别属于切分的两部分，这个边称为横切边 比如上图的边 $BC、BE、DE$就是横切边 切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树 边和顶点的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static class Vertex&lt;V, E&gt; &#123; V value; Set&lt;Edge&lt;V, E&gt;&gt; inEdges = new HashSet&lt;&gt;(); Set&lt;Edge&lt;V, E&gt;&gt; outEdges = new HashSet&lt;&gt;(); Vertex(V value) &#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; return Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value); &#125; @Override public int hashCode() &#123; return value == null ? 0 : value.hashCode(); &#125; @Override public String toString() &#123; return value == null ? "null" : value.toString(); &#125;&#125;private static class Edge&lt;V, E&gt; &#123; Vertex&lt;V, E&gt; from; Vertex&lt;V, E&gt; to; E weight; Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123; this.from = from; this.to = to; &#125; EdgeInfo&lt;V, E&gt; info() &#123; return new EdgeInfo&lt;&gt;(from.value, to.value, weight); &#125; @Override public boolean equals(Object obj) &#123; Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj; return Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to); &#125; @Override public int hashCode() &#123; return from.hashCode() * 31 + to.hashCode(); &#125; @Override public String toString() &#123; return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; 边信息的定义1234567891011121314151617181920212223242526272829303132public static class EdgeInfo&lt;V, E&gt; &#123; private V from; private V to; private E weight; public EdgeInfo(V from, V to, E weight) &#123; this.from = from; this.to = to; this.weight = weight; &#125; public V getFrom() &#123; return from; &#125; public void setFrom(V from) &#123; this.from = from; &#125; public V getTo() &#123; return to; &#125; public void setTo(V to) &#123; this.to = to; &#125; public E getWeight() &#123; return weight; &#125; public void setWeight(E weight) &#123; this.weight = weight; &#125; @Override public String toString() &#123; return "EdgeInfo [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; Prim算法 – 执行过程假设 $G = (V，E)$ 是有权的连通图（无向），$A$ 是 $G$ 中最小生成树的边集 算法从 $S = \{ u0 \}（u0 ∈ V），A = \{ \} $ 开始，重复执行下述操作，直到 $S = V $为止 找到切分 $C = (S，V – S)$ 的最小横切边 $(u0，v0) $并入集合 $A$，同时将 $v0$ 并入集合 $S$ Prim算法 – 实现MinHeap的实现原理 12345678910111213141516171819private Set&lt;EdgeInfo&lt;V, E&gt;&gt; prim() &#123; Iterator&lt;Vertex&lt;V, E&gt;&gt; it = vertices.values().iterator(); if (!it.hasNext()) return null; Vertex&lt;V, E&gt; vertex = it.next(); Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new HashSet&lt;&gt;(); Set&lt;Vertex&lt;V, E&gt;&gt; addedVertices = new HashSet&lt;&gt;(); addedVertices.add(vertex); MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = new MinHeap&lt;&gt;(vertex.outEdges, edgeComparator); int verticesSize = vertices.size(); while (!heap.isEmpty() &amp;&amp; addedVertices.size() &lt; verticesSize) &#123; Edge&lt;V, E&gt; edge = heap.remove(); if (addedVertices.contains(edge.to)) continue; edgeInfos.add(edge.info()); addedVertices.add(edge.to); heap.addAll(edge.to.outEdges); &#125; return edgeInfos;&#125; Kruskal算法 – 执行过程按照边的权重顺序（从小到大）将边加入生成树中，直到生成树中含有 $V – 1$ 条边为止（ $V$ 是顶点数量） 若加入该边会与生成树形成环，则不加入该边 从第 $3$ 条边开始，可能会与生成树形成环 Kruskal算法 – 实现1234567891011121314151617private Set&lt;EdgeInfo&lt;V, E&gt;&gt; kruskal() &#123; int edgeSize = vertices.size() - 1; if (edgeSize == -1) return null; Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new HashSet&lt;&gt;(); MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = new MinHeap&lt;&gt;(edges, edgeComparator); UnionFind&lt;Vertex&lt;V, E&gt;&gt; uf = new UnionFind&lt;&gt;(); vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123; uf.makeSet(vertex); &#125;); while (!heap.isEmpty() &amp;&amp; edgeInfos.size() &lt; edgeSize) &#123; Edge&lt;V, E&gt; edge = heap.remove(); if (uf.isSame(edge.from, edge.to)) continue; edgeInfos.add(edge.info()); uf.union(edge.from, edge.to); &#125; return edgeInfos;&#125; 时间复杂度：$O(ElogE)$ 算法测试构建无向图12345678910111213141516private static Graph&lt;Object, Double&gt; undirectedGraph(Object[][] data) &#123; Graph&lt;Object, Double&gt; graph = new ListGraph&lt;&gt;(weightManager); for (Object[] edge : data) &#123; if (edge.length == 1) &#123; graph.addVertex(edge[0]); &#125; else if (edge.length == 2) &#123; graph.addEdge(edge[0], edge[1]); graph.addEdge(edge[1], edge[0]); &#125; else if (edge.length == 3) &#123; double weight = Double.parseDouble(edge[2].toString()); graph.addEdge(edge[0], edge[1], weight); graph.addEdge(edge[1], edge[0], weight); &#125; &#125; return graph;&#125; 构建有向图1234567891011121314private static Graph&lt;Object, Double&gt; directedGraph(Object[][] data) &#123; Graph&lt;Object, Double&gt; graph = new ListGraph&lt;&gt;(weightManager); for (Object[] edge : data) &#123; if (edge.length == 1) &#123; graph.addVertex(edge[0]); &#125; else if (edge.length == 2) &#123; graph.addEdge(edge[0], edge[1]); &#125; else if (edge.length == 3) &#123; double weight = Double.parseDouble(edge[2].toString()); graph.addEdge(edge[0], edge[1], weight); &#125; &#125; return graph;&#125; 测试无向图 12345678910111213141516public static void main(String[] args) &#123; public static final Object[][] MST_01 = &#123; &#123;0, 2, 2&#125;, &#123;0, 4, 7&#125;, &#123;1, 2, 3&#125;, &#123;1, 5, 1&#125;, &#123;1, 6, 7&#125;, &#123;2, 4, 4&#125;, &#123;2, 5, 3&#125;, &#123;2, 6, 6&#125;, &#123;3, 7, 9&#125;, &#123;4, 6, 8&#125;, &#123;5, 6, 4&#125;, &#123;5, 7, 5&#125; &#125;; Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_01); // Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim(); Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal(); for (EdgeInfo&lt;Object, Double&gt; info : infos) &#123; System.out.println(info); &#125;&#125; 测试有向图 123456789101112131415public static void main(String[] args) &#123; public static final Object[][] MST_02 = &#123; &#123;"A", "B", 17&#125;, &#123;"A", "F", 1&#125;, &#123;"A", "E", 16&#125;, &#123;"B", "C", 6&#125;, &#123;"B", "D", 5&#125;, &#123;"B", "F", 11&#125;, &#123;"C", "D", 10&#125;, &#123;"D", "E", 4&#125;, &#123;"D", "F", 14&#125;, &#123;"E", "F", 33&#125; &#125;; Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_02); Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim(); // Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal(); for (EdgeInfo&lt;Object, Double&gt; info : infos) &#123; System.out.println(info); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>Prim</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOV网]]></title>
    <url>%2F2020%2F07%2F15%2FAOV%E7%BD%91%2F</url>
    <content type="text"><![CDATA[AOV网（Activity On Vertex Network）一项大的工程常被分为多个小的子工程 子工程之间可能存在一定的先后顺序，即某些子工程必须在其他的一些子工程完成后才能开始 在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，子工程被称为活动$（Activity）$ 以顶点表示活动、有向边表示活动之间的先后关系，这样的图简称为 $AOV$ 网 标准的 $AOV$网必须是一个有向无环图$（Directed Acyclic Graph$，简称 $DAG$） B依赖于A；C依赖于B；D依赖于B；E依赖于B、C、D；F依赖于E 拓扑排序（Topological Sort）前驱活动：有向边起点的活动称为终点的前驱活动 只有当一个活动的前驱全部都完成后，这个活动才能进行 后继活动：有向边终点的活动称为起点的后继活动 将 AOV 网中所有活动排成一个序列，使得每个活动的前驱活动都排在该活动的前面 比如上图的拓扑排序结果是：A、B、C、D、E、F 或者 A、B、D、C、E、F （结果并不一定是唯一的） 拓扑排序 – 思路可以使用卡恩算法（Kahn于1962年提出）完成拓扑排序 假设 L 是存放拓扑排序结果的列表 ① 把所有入度为 0 的顶点放入 L 中，然后把这些顶点从图中去掉 ② 重复操作 ①，直到找不到入度为 0 的顶点 如果此时 L 中的元素个数和顶点总数相同，说明拓扑排序完成 如果此时 L 中的元素个数少于顶点总数，说明原图中存在环，无法进行拓扑排序 拓扑排序 – 实现12345678910111213141516171819202122232425262728293031public List&lt;V&gt; topologicalSort() &#123; List&lt;V&gt; list = new ArrayList&lt;&gt;(); Queue&lt;Vertex&lt;V, E&gt;&gt; queue = new LinkedList&lt;&gt;(); Map&lt;Vertex&lt;V, E&gt;, Integer&gt; ins = new HashMap&lt;&gt;(); // 初始化（将度为0的节点都放入队列） vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123; int in = vertex.inEdges.size(); if (in == 0) &#123; queue.offer(vertex); &#125; else &#123; ins.put(vertex, in); &#125; &#125;); while (!queue.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = queue.poll(); // 放入返回结果中 list.add(vertex.value); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; int toIn = ins.get(edge.to) - 1; if (toIn == 0) &#123; queue.offer(edge.to); &#125; else &#123; ins.put(edge.to, toIn); &#125; &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图（Graph）什么是图图由顶点$（vertex）$和边$（edge）$组成，通常表示为 $G = (V, E)$ $G$ 表示一个图，$V$ 是顶点集，$E$ 是边集 顶点集 $V$ 有穷且非空 任意两个顶点之间都可以用边来表示它们之间的关系，边集 $E$ 可以是空的 有向图（Directed Graph）有向图的边是有明确方向的 有向无环图（Directed Acyclic Graph，简称 DAG） 如果一个有向图，从任意顶点出发无法经过若干条边回到该顶点，那么它就是一个有向无环图 出度、入度出度、入度适用于有向图 出度$（Out-degree）$ 一个顶点的出度为 $x$，是指有 $x$ 条边以该顶点为起点 顶点 $11$ 的出度是 $3$ 入度$（In-degree）$ 一个顶点的入度为 $x$，是指有 $x$ 条边以该顶点为终点 顶点 $11$ 的入度是 $2$ 无向图（Undirected Graph）无向图的边是无方向的，效果类似于下面的有向图 混合图（Mixed Graph）混合图的边可能是无向的，也可能是有向的 简单图、多重图平行边 在无向图中，关联一对顶点的无向边如果多于 $1$ 条，则称这些边为平行边 在有向图中，关联一对顶点的有向边如果多于 $1$ 条，并且它们的的方向相同，则称这些边为平行边 多重图（Multigraph） 有平行边或者有自环的图 简单图（Simple Graph） 既没有平行边也不没有自环的图 无向完全图（Undirected Complete Graph）无向完全图的任意两个顶点之间都存在边 $n$ 个顶点的无向完全图有 $n(n − 1)/2$ 条边 $n − 1 + n − 2 + n − 3 + ⋯ + 3 + 2 + 1$ 有向完全图（Directed Complete Graph）有向完全图的任意两个顶点之间都存在方向相反的两条边 $n$ 个顶点的有向完全图有 $n(n − 1)$ 条边 稠密图（Dense Graph）：边数接近于或等于完全图 稀疏图（Sparse Graph）：边数远远少于完全图 有权图（Weighted Graph）有权图的边可以拥有权值$（Weight）$ 连通图（Connected Graph）如果顶点 $x$ 和 $y$ 之间存在可相互抵达的路径（直接或间接的路径），则称 $x$ 和 $y$ 是连通的 如果无向图 $G$ 中任意 $2$ 个顶点都是连通的，则称 $G$ 为连通图 连通分量（Connected Component）连通分量：无向图的极大连通子图 连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量 下面的无向图有 $3$ 个连通分量 强连通图（Strongly Connected Graph）如果有向图 $G$ 中任意 $2$ 个顶点都是连通的，则称 $G$ 为强连通图 强连通分量（Strongly Connected Component）强连通分量：有向图的极大强连通子图 强连通图只有一个强连通分量，即其自身；非强连通的有向图有多个强连通分量 图的实现方案图有2种常见的实现方案 邻接矩阵（Adjacency Matrix） 邻接表（Adjacency List） 邻接矩阵（Adjacency Matrix） 邻接矩阵的存储方式 一维数组存放顶点信息 二维数组存放边信息 邻接矩阵比较适合稠密图 不然会比较浪费内存 邻接矩阵 – 有权图 邻接表（Adjacency List） 邻接表 – 有权图 图的基础接口12345678910111213// 边的数量public abstract int edgesSize();// 顶点的数量public abstract int verticesSize();// 添加、删除顶点public abstract void addVertex(V v);public abstract void removeVertex(V v);public abstract void addEdge(V from, V to);// 添加有权边public abstract void addEdge(V from, V to, E weight);public abstract void removeEdge(V from, V to); 顶点的定义1234567891011121314151617181920private static class Vertex&lt;V, E&gt; &#123; V value; Set&lt;Edge&lt;V, E&gt;&gt; inEdges = new HashSet&lt;&gt;(); Set&lt;Edge&lt;V, E&gt;&gt; outEdges = new HashSet&lt;&gt;(); Vertex(V value) &#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; return Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value); &#125; @Override public int hashCode() &#123; return value == null ? 0 : value.hashCode(); &#125; @Override public String toString() &#123; return value == null ? "null" : value.toString(); &#125;&#125; 边的定义12345678910111213141516171819202122232425private static class Edge&lt;V, E&gt; &#123; Vertex&lt;V, E&gt; from; Vertex&lt;V, E&gt; to; E weight; Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123; this.from = from; this.to = to; &#125; @Override public boolean equals(Object obj) &#123; Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj; return Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to); &#125; @Override public int hashCode() &#123; return from.hashCode() * 31 + to.hashCode(); &#125; @Override public String toString() &#123; return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; 图的遍历从图中某一顶点出发访问图中其余顶点，且每一个顶点仅被访问一次 图有 $2$ 种常见的遍历方式（有向图、无向图都适用） 广度优先搜索$（Breadth First Search，BFS）$，又称为宽度优先搜索、横向优先搜索 深度优先搜索$（Depth First Search，DFS）$ 发明“深度优先搜索”算法的 $2$ 位科学家在 $1986$年共同获得计算机领域的最高奖：图灵奖 广度优先搜索（Breadth First Search）二叉树层序遍历也是一种广度优先搜索 广度优先搜索 – 思路 广度优先搜索 – 实现1234567891011121314151617public void bfs(&lt;Vertex&lt;V, E&gt;&gt; beginVertex) &#123; Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = new HashSet&lt;&gt;(); Queue&lt;Vertex&lt;V, E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginVertex); visitedVertices.add(beginVertex); while (!queue.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = queue.poll(); System.out.println(vertex.value); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; if (visitedVertices.contains(edge.to)) continue; queue.offer(edge.to); visitedVertices.add(edge.to); &#125; &#125;&#125; 深度优先搜索（Depth First Search）二叉树前序遍历也是一种深度优先搜索 深度优先搜索 – 递归实现123456789101112131415public void dfs(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) return; dfs(beginVertex, new HashSet&lt;&gt;());&#125;private void dfs(Vertex&lt;V, E&gt; vertex, Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices) &#123; System.out.println(vertex.value); visitedVertices.add(vertex); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; if (visitedVertices.contains(edge.to)) continue; dfs(edge.to, visitedVertices); &#125;&#125; 深度优先搜索 – 非递归实现 1234567891011121314151617181920212223public void dfs(Vertex&lt;V, E&gt; beginVertex) &#123; Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = new HashSet&lt;&gt;(); Stack&lt;Vertex&lt;V, E&gt;&gt; stack = new Stack&lt;&gt;(); // 先访问起点 stack.push(beginVertex); visitedVertices.add(beginVertex); System.out.println(beginVertex.value); while (!stack.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = stack.pop(); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; if (visitedVertices.contains(edge.to)) continue; stack.push(edge.from); stack.push(edge.to); visitedVertices.add(edge.to); System.out.println(edge.to.value); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集（Union Find）需求分析假设有n个村庄，有些村庄之间有连接的路，有些村庄之间并没有连接的路 设计一个数据结构，能够快速执行2个操作 查询2个村庄之间是否有连接的路 连接2个村庄 数组、链表、平衡二叉树、集合（Set）？ 查询、连接的时间复杂度都是：$O(n)$ 并查集能够办到查询、连接的均摊时间复杂度都是 $O(α(n)),α(n) &lt; 5$ 并查集非常适合解决这类“连接”相关的问题 什么是并查集并查集也叫作不相交集合（Disjoint Set） 并查集有2个核心操作 查找$（Find）$：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是指广义的数据集合） 合并$（Union）$：将两个元素所在的集合合并为一个集合 有2种常见的实现思路 $Quick Find$ 查找$（Find）$的时间复杂度：$O(1)$ 合并$（Union）$的时间复杂度：$O(n)$ $Quick Union$ 查找$（Find）$的时间复杂度：$O(logn)$，可以优化至 $O(α(n)),α(n) &lt; 5$ 合并$（Union）$的时间复杂度：$O(logn)$，可以优化至 $O(α(n)),α(n) &lt; 5$ 如何存储数据？假设并查集处理的数据都是整型，那么可以用整型数组来存储数据 不难看出 $0、1、3$ 属于同一集合 $2$ 单独属于一个集合 $4、5、6、7$ 属于同一集合 因此，并查集是可以用数组实现的树形结构（二叉堆、优先级队列也是可以用数组实现的树形结构） 接口定义12345678// 查找v所属的集合（根节点）public abstract int find(int v);// 合并v1、v2所在的集合public abstract void union(int v1, int v2);// 检查v1、v2是否属于同一个集合public boolean isSame(int v1, int v2); 123public boolean isSame(int v1, int v2) &#123; return find(v1) == find(v2);&#125; 初始化初始化时，每个元素各自属于一个单元素集合 1234567891011protected int[] parents;public UnionFind(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity must be &gt;= 1"); &#125; parents = new int[capacity]; for (int i = 0; i &lt; parents.length; i++) &#123; parents[i] = i; &#125;&#125; Quick FindQuick Find – Union$Quick Find$ 的 $union(v1, v2)$：让 $v1$ 所在集合的所有元素都指向 $v2$ 的根节点 123456789101112// 将v1所在集合的所有元素，都嫁接到v2的父节点上public void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; for (int i = 0; i &lt; parents.length; i++) &#123; if (parents[i] == p1) &#123; parents[i] = p2; &#125; &#125;&#125; 时间复杂度：$O(n)$ Quick Find – Find 12345// 父节点就是根节点public int find(int v) &#123; rangeCheck(v); return parents[v];&#125; $find(0) == 2$ | $find(1) == 2$ | $find(3) == 4$ | $find(2) == 2$ 时间复杂度：$O(1)$ Quick UnionQuick Union – Union$Quick Union$ 的 $union(v1, v2)$：让 $v1$ 的根节点指向 $v2$ 的根节点 1234567// 将v1的根节点嫁接到v2的根节点上public void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; parents[p1] = p2;&#125; 时间复杂度：$O(logn)$ Quick Union – Find 12345678// 通过parent链条不断地向上找，直到找到根节点public int find(int v) &#123; rangeCheck(v); while (v != parents[v]) &#123; v = parents[v]; &#125; return v;&#125; $find(0) == 2$ | $find(1) == 2$ | $find(3) == 2$ | $find(2) == 2$ 时间复杂度：$O(logn)$ Quick Union – 优化在 $Union$ 的过程中，可能会出现树不平衡的情况，甚至退化成链表 有2种常见的优化方案 基于 $size$ 的优化：元素少的树嫁接到元素多的树 基于 $rank$ 的优化：矮的树嫁接到高的树 Quick Union – 基于size的优化 1234sizes = new int[capacity];for (int i = 0; i &lt; sizes.length; i++) &#123; sizes[i] = 1;&#125; 1234567891011121314private int[] sizes;public void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; if (sizes[p1] &lt; sizes[p2]) &#123; parents[p1] = p2; sizes[p2] += sizes[p1]; &#125; else &#123; parents[p2] = p1; sizes[p1] += sizes[p2]; &#125;&#125; 基于 $size$ 的优化，也可能会存在树不平衡的问题 Quick Union – 基于rank的优化 12ranks = new int[capacity];Arrays.fill(ranks, 1); 123456789101112131415private int[] ranks;public void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; if (ranks[p1] &lt; ranks[p2]) &#123; parents[p1] = p2; &#125; else if (ranks[p1] &gt; ranks[p2]) &#123; parents[p2] = p1; &#125; else &#123; parents[p1] = p2; ranks[p2]++; &#125;&#125; 路径压缩（Path Compression）虽然有了基于 $rank$ 的优化，树会相对平衡一点 但是随着 $Union$次数的增多，树的高度依然会越来越高 导致 $find$ 操作变慢，尤其是底层节点（因为 $find$ 是不断向上找到根节点) 什么是路径压缩？ 在 $find$ 时使路径上的所有节点都指向根节点，从而降低树的高度 1234567public int find(int v) &#123; // v == 1, parents[v] == 2 rangeCheck(v); if (parents[v] != v) &#123; parents[v] = find(parents[v]); &#125; return parents[v];&#125; 路径压缩使路径上的所有节点都指向根节点，所以实现成本稍高 还有 $2$ 种更优的做法，不但能降低树高，实现成本也比路径压缩低 路径分裂$（Path Spliting）$ 路径减半$（Path Halving）$ 路径分裂、路径减半的效率差不多，但都比路径压缩要好 路径分裂（Path Spliting）路径分裂：使路径上的每个节点都指向其祖父节点$（parent$ 的 $parent）$ 123456789public int find(int v) &#123; rangeCheck(v); while (v != parents[v]) &#123; int p = parents[v]; parents[v] = parents[parents[v]]; v = p; &#125; return v;&#125; 路径减半（Path Halving）路径减半：使路径上每隔一个节点就指向其祖父节点$（parent$ 的 $parent）$ 12345678public int find(int v) &#123; rangeCheck(v); while (v != parents[v]) &#123; parents[v] = parents[parents[v]]; v = parents[v]; &#125; return v;&#125; 总结摘自《维基百科》 大概意思是 使用路径压缩、分裂或减半 + 基于 $rank$ 或者 $size$ 的优化 可以确保每个操作的均摊时间复杂度为 $O(𝛼(𝑛)),α(𝑛) &lt; 5$]]></content>
      <categories>
        <category>算法</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[休眠排序]]></title>
    <url>%2F2020%2F07%2F15%2F%E4%BC%91%E7%9C%A0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[史上“最强”排序 – 休眠排序1234567891011121314151617181920public class SleepSort extends Thread&#123; private int value; public SleepSort(int value)&#123; this.value = value; &#125; public void run()&#123; try &#123; Thread.sleep(value); System.out.println(value); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; int[] array = &#123;10,100,50,30,60,2&#125;; for (int item : array) &#123; new SleepSort(item).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序]]></title>
    <url>%2F2020%2F07%2F15%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[桶排序（Bucket Sort）什么是桶排序执行流程 ① 创建一定数量的桶（比如用数组、链表作为桶） ② 按照一定的规则（不同类型的数据，规则不同），将序列中的元素均匀分配到对应的桶 ③ 分别对每个桶进行单独排序 ④ 将所有非空桶的元素合并成有序序列 元素在桶中的索引 元素值 * 元素数量 桶排序 – 实现12345678910111213141516171819202122double[] array = &#123;0.34,0.47,0.29,0.84,0.45,0.38,0.35,0.76&#125;;// 桶排序List&lt;Double&gt;[] buckets = new List[array.length];for (double v : array) &#123; int bucketIndex = (int) (v * array.length); List&lt;Double&gt; bucket = buckets[bucketIndex]; if (bucket == null) &#123; bucket = new LinkedList&lt;&gt;(); buckets[bucketIndex] = bucket; &#125; bucket.add(v);&#125;// 对每个桶进行排序int index = 0;for (List&lt;Double&gt; bucket : buckets) &#123; if (bucket == null) continue; bucket.sort(null); for (Double d : bucket) &#123; array[index++] = d; &#125;&#125; 空间复杂度：$O(n + m)$，$m$ 是桶的数量 时间复杂度：$O(n) + m ∗ O( \frac{n} {m} ∗ log\frac{n}{m}) = O(n + n ∗ log\frac{n}{m}) = O(n + n ∗ logn − n ∗ logm)$ 因 此 为 $O(n + k)$ ，$k$ 为 $n ∗ logn − n ∗ logm$ 属于稳定排序]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序（Radix Sort）什么是基数排序基数排序非常适合用于整数排序（尤其是非负整数），因此本课程只演示对非负整数进行基数排序 执行流程：依次对个位数、十位数、百位数、千位数、万位数…进行排序（从低位到高位） 个位数、十位数、百位数的取值范围都是固定的 $0$ ~ $9$，可以使用计数排序对它们进行排序 如果先对高位排序，再对低位排序，是不可行的 基数排序 – 实现123456789101112131415161718protected void sort() &#123; // 找出最大值 int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // 个位数: array[i] / 1 % 10 = 3 // 十位数：array[i] / 10 % 10 = 9 // 百位数：array[i] / 100 % 10 = 5 // 千位数：array[i] / 1000 % 10 = ... for (int divider = 1; divider &lt;= max; divider *= 10) &#123; countingSort(divider); &#125;&#125; 1234567891011121314151617181920212223protected void countingSort(int divider) &#123; // 开辟内存空间，存储次数 int[] counts = new int[10]; // 统计每个整数出现的次数 for (Integer integer : array) &#123; counts[integer / divider % 10]++; &#125; // 累加次数 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // 从后往前遍历元素，将它放到有序数组中的合适位置 int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] / divider % 10]] = array[i]; &#125; // 将有序数组赋值到array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125;&#125; 最好、最坏、平均时间复杂度：$O(d ∗ (n + k))$ ，$d$ 是最大值的位数，$k$ 是进制。属于稳定排序 空间复杂度：$O(n + k)$，$k$ 是进制]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序]]></title>
    <url>%2F2020%2F07%2F15%2F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序（Counting Sort）冒泡、选择、插入、归并、快速、希尔、堆排序，都是基于比较的排序 平均时间复杂度目前最低是 $O(nlogn)$ 计数排序、桶排序、基数排序，都不是基于比较的排序 它们是典型的用空间换时间，在某些时候，平均时间复杂度可以比 $O(nlogn)$ 更低 什么是计数排序计数排序于1954年由Harold H. Seward提出，适合对一定范围内的整数进行排序 计数排序的核心思想： 统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引 计数排序 – 最简单的实现 123456789101112131415161718192021222324protected void sort() &#123; // 找出最大值 int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // O(n) // 开辟内存空间，存储每个整数出现的次数 int[] counts = new int[1 + max]; // 统计每个整数出现的次数 for (Integer integer : array) &#123; counts[integer]++; &#125; // O(n) // 根据整数的出现次数，对整数进行排序 int index = 0; for (int i = 0; i &lt; counts.length; i++) &#123; while (counts[i]-- &gt; 0) &#123; array[index++] = i; &#125; &#125; // O(n)&#125; 这个版本的实现存在以下问题 无法对负整数进行排序 极其浪费内存空间 是个不稳定的排序 计数排序 – 改进思路假设 $array$ 中的最小值是 $min$ $array$ 中的元素 $k$ 对应的 $counts$ 索引是 $k – min$ $array$ 中的元素 $k$ 在有序序列中的索引 $counts[k – min] – p$ $p$ 代表着是倒数第几个 $k$ 计数排序 – 改进实现1234567891011121314151617181920212223242526272829303132333435protected void sort() &#123; // 找出最值 int max = array[0]; int min = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; // 开辟内存空间，存储次数 int[] counts = new int[max - min + 1]; // 统计每个整数出现的次数 for (Integer integer : array) &#123; counts[integer - min]++; &#125; // 累加次数 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // 从后往前遍历元素，将它放到有序数组中的合适位置 int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] - min]] = array[i]; &#125; // 将有序数组赋值到array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125;&#125; 最好、最坏、平均时间复杂度：$O(n + k)$ 空间复杂度：$O(n + k)$ $k$ 是整数的取值范围 属于稳定排序 计数排序 – 对自定义对象进行排序如果自定义对象可以提供用以排序的整数类型，依然可以使用计数排序 12345678910111213private static class Person &#123; int age; String name; Person(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return "Person [age=" + age + ", name=" + name + "]"; &#125;&#125; 12345678Person[] persons = new Person[] &#123; new Person(20, "A"), new Person(-13, "B"), new Person(17, "C"), new Person(12, "D"), new Person(-13, "E"), new Person(20, "F")&#125;; 1234567891011// 找出最值int max = persons[0].age;int min = persons[0].age;for (int i = 1; i &lt; persons.length; i++) &#123; if (persons[i].age &gt; max) &#123; max = persons[i].age; &#125; if (persons[i].age &lt; min) &#123; min = persons[i].age; &#125;&#125; 1234567891011121314151617181920212223// 开辟内存空间，存储次数int[] counts = new int[max - min + 1];// 统计每个整数出现的次数for (Person person : persons) &#123; counts[person.age - min]++;&#125;// 累加次数for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1];&#125;// 从后往前遍历元素，将它放到有序数组中的合适位置Person[] newArray = new Person[persons.length];for (int i = persons.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[persons[i].age - min]] = persons[i];&#125;// 将有序数组赋值到arraySystem.arraycopy(newArray, 0, persons, 0, newArray.length);for (Person person : persons) &#123; System.out.println(person);&#125; 排序之后的结果 ① $Person [age=-13, name=B]$ ② $Person [age=-13, name=E]$ ③ $Person [age=12, name=D]$ ④ $Person [age=17, name=C]$ ⑤ $Person [age=20, name=A]$ ⑥ $Person [age=20, name=F]$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序（Shell Sort）什么是希尔排序 1959年由唐纳德·希尔（Donald Shell）提出 希尔排序把序列看作是一个矩阵，分成 𝑚 列，逐列进行排序 𝑚 从某个整数逐渐减为1 当 𝑚 为1时，整个序列将完全有序 因此，希尔排序也被称为递减增量排序（Diminishing Increment Sort） 矩阵的列数取决于步长序列（step sequence） 比如，如果步长序列为 ${1,5,19,41,109,…}$，就代表依次分成109列、41列、19列、5列、1列进行排序 不同的步长序列，执行效率也不同 希尔排序 – 实例希尔本人给出的步长序列是 $𝑛/2^𝑘$，比如 $𝑛$ 为 $16$ 时，步长序列是 {$1, 2, 4, 8$} 分成8列进行排序 分成4列进行排序 分成2列进行排序 分成1列进行排序 不难看出来，从8列变为1列的过程中，逆序对的数量在逐渐减少 因此希尔排序底层一般使用插入排序对每一列进行排序，很多资料认为希尔排序是插入排序的改进版 假设有11个元素，步长序列是{1, 2, 5} 假设元素在第 $col$ 列、第 $row$ 行，步长（总列数）是 $step$ 那么这个元素在数组中的索引是 $col + row * step$ 比如 $9$ 在排序前是第 $2$ 列、第 $0$ 行，那么它排序前的索引是 $2 + 0 * 5 = 2$ 比如 $4$ 在排序前是第 $2$ 列、第 $1$ 行，那么它排序前的索引是 $2 + 1 * 5 = 7$ 希尔排序 – 实现1234567891011121314151617181920protected void sort() &#123; List&lt;Integer&gt; shellSequence = shellStepSequence(); for (Integer shell : shellSequence) &#123; sort(shell); &#125;&#125;// 分成step列进行排序private void sort(int step) &#123; // col : 第几列，column的简称 for (int col = 0; col &lt; step; col++) &#123; // 对第col列进行排序 // col、col+step、col+2*step、col+3*step for (int begin = col + step; begin &lt; array.length; begin += step) &#123; int cur = begin; while (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; 0) &#123; swap(cur, cur - step); cur -= step; &#125; &#125; &#125;&#125; 最好情况是步长序列只有 $1$，且序列几乎有序，时间复杂度为 $O(n)$ 空间复杂度为 $O(1)$，属于不稳定排序 希尔排序 – 步长序列希尔本人给出的步长序列，最坏情况时间复杂度是 $O(n^2)$ 12345678private List&lt;Integer&gt; shellStepSequence() &#123; List&lt;Integer&gt; stepSequence = new ArrayList&lt;&gt;(); int step = array.length; while ((step &gt;&gt;= 1) &gt; 0) &#123; stepSequence.add(step); &#125; return stepSequence;&#125; 目前已知的最好的步长序列，最坏情况时间复杂度是 $O(n^{4/3})$ ，1986年由Robert Sedgewick提出 \begin{cases} 9 \left(2^k - 2^{\frac{k}{2}}\right) +1, & \text {k even} \\ 8 \cdot 2^k - 6 \cdot 2^{\frac{(k+1)}{2}} + 1, & \text {k odd} \\ \end{cases} \\ 1,5,19,41,109,...123456789101112131415161718private List&lt;Integer&gt; SedgewickStepSequence() &#123; List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;(); int k = 0, step = 0; while (true) &#123; if (k % 2 == 0) &#123; int pow = (int) Math.pow(2, k &gt;&gt; 1); step = 1 + 9 * (pow * pow - pow); &#125; else &#123; int pow1 = (int) Math.pow(2, (k - 1) &gt;&gt; 1); int pow2 = (int) Math.pow(2, (k + 1) &gt;&gt; 1); step = 1 + 8 * pow1 * pow2 - 6 * pow2; &#125; if (step &gt;= array.length) break; stepSequence.add(0, step); k++; &#125; return stepSequence;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quick Sort）什么是快速排序1960年由查尔斯·安东尼·理查德·霍尔（Charles Antony Richard Hoare，缩写为C. A. R. Hoare）提出 昵称为东尼·霍尔（Tony Hoare） 快速排序 – 执行流程① 从序列中选择一个轴点元素（pivot） ​ 假设每次选择 0 位置的元素为轴点元素 ② 利用 pivot 将序列分割成 2 个子序列 ​ 将小于 pivot 的元素放在pivot前面（左侧） ​ 将大于 pivot 的元素放在pivot后面（右侧） ​ 等于pivot的元素放哪边都可以 ③ 对子序列进行 ① ② 操作 ​ 直到不能再分割（子序列中只剩下1个元素） 快速排序的本质 逐渐将每一个元素都转换成轴点元素 快速排序 – 轴点构造 快速排序 – 时间复杂度 在轴点左右元素数量比较均匀的情况下，同时也是最好的情况 $T(n) = 2 ∗ T(n/2) + O(n) = O(nlogn)$ 如果轴点左右元素数量极度不均匀，最坏情况 $T(n) = T(n − 1) + O(n) = O(n^2)$ 为了降低最坏情况的出现概率，一般采取的做法是 随机选择轴点元素 最好、平均时间复杂度：$O(nlogn)$ 最坏时间复杂度：$O(n^2)$ 由于递归调用的缘故，空间复杂度：$O(logn)$ 属于不稳定排序 快速排序 – 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051protected void sort() &#123; sort(0, array.length);&#125;// 对 [begin, end) 范围的元素进行快速排序private void sort(int begin, int end) &#123; if (end - begin &lt; 2) return; // 确定轴点位置 O(n) int mid = pivotIndex(begin, end); // 对子序列进行快速排序 sort(begin, mid); sort(mid + 1, end); &#125; /** * 构造出 [begin, end) 范围的轴点元素 * @return 轴点元素的最终位置 */private int pivotIndex(int begin, int end) &#123; // 随机选择一个元素跟begin位置进行交换 swap(begin, begin + (int)(Math.random() * (end - begin))); // 备份begin位置的元素 T pivot = array[begin]; // end指向最后一个元素 end--; while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt; 0) &#123; // 右边元素 &gt; 轴点元素 end--; &#125; else &#123; // 右边元素 &lt;= 轴点元素 array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt; 0) &#123; // 左边元素 &lt; 轴点元素 begin++; &#125; else &#123; // 左边元素 &gt;= 轴点元素 array[end--] = array[begin]; break; &#125; &#125; &#125; // 将轴点元素放入最终的位置 array[begin] = pivot; // 返回轴点元素的位置 return begin;&#125; 快速排序 – 与轴点相等的元素 如果序列中的所有元素都与轴点元素相等，利用目前的算法实现，轴点元素可以将序列分割成 2 个均匀的子序列 思考：cmp 位置的判断分别改为 ≤、≥ 会起到什么效果？ 123456789101112131415161718while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt;= 0) &#123; // 右边元素 &gt; 轴点元素 end--; &#125; else &#123; // 右边元素 &lt;= 轴点元素 array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt;= 0) &#123; // 左边元素 &lt; 轴点元素 begin++; &#125; else &#123; // 左边元素 &gt;= 轴点元素 array[end--] = array[begin]; break; &#125; &#125;&#125; 轴点元素分割出来的子序列极度不均匀 导致出现最坏时间复杂度 $O(n^2)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序（Merge Sort）什么是归并排序1945年由约翰·冯·诺伊曼（John von Neumann）首次提出 执行流程 ① 不断地将当前序列平均分割成2个子序列 ​ 直到不能再分割（序列中只剩1个元素） ② 不断地将2个子序列合并成一个有序序列 ​ 直到最终只剩下1个有序序列 归并排序 – divide实现12345protected void sort() &#123; // 准备一段临时的数组空间，在merge操作中使用 leftArray = (T[]) new Comparable[array.length &gt;&gt; 1]; sort(0, array.length);&#125; 12345678private void sort(int begin, int end) &#123; if (end - begin &lt; 2) return; int mid = (begin + end) &gt;&gt; 1; sort(begin, mid); sort(mid, end); merge(begin, mid, end);&#125; 归并排序 – merge归并排序 – merge细节 需要 merge 的 2 组序列存在于同一个数组中，并且是挨在一起的 为了更好地完成 merge 操作，最好将其中 1 组序列备份出来，比如 $[begin, mid)$ $li == 0，le == mid – begin$ $ri == mid，re == end$ 归并排序 – merge – 左边先结束 归并排序 – merge – 右边先结束 归并排序 – merge实现1234567891011121314151617181920// 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列private void merge(int begin, int mid, int end) &#123; int li = 0, le = mid - begin; int ri = mid, re = end; int ai = begin; // 备份左边数组 for (int i = li; i &lt; le; i++) &#123; leftArray[i] = array[begin + i]; &#125; // 如果左边还没有结束 while (li &lt; le) &#123; if (ri &lt; re &amp;&amp; cmp(array[ri], leftArray[li]) &lt; 0) &#123; array[ai++] = array[ri++]; &#125; else &#123; array[ai++] = leftArray[li++]; &#125; &#125;&#125; 归并排序 – 复杂度分析归并排序花费的时间 $T(n) = 2 ∗ T (n/2) + O(n)$ $T(1) = O(1)$ $T(n) /n = T(n/2) / (n/2) + O(1)$ 令 $S(n) = T(n) /n$ $S(1) = O(1)$ $S(n) = S(n/2) + O(1) = S(n/4)+ O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)$ $T(n) = n ∗ S(n) = O(nlogn)$ 由于归并排序总是平均分割子序列，所以最好、最坏、平均时间复杂度都是 $O(nlogn)$ ，属于稳定排序 从代码中不难看出：归并排序的空间复杂度是 $O(n/2 + logn) = O(n)$ $n/2$ 用于临时存放左侧数组，$logn$ 是因为递归调用 常见的递推式与复杂度 递推式 复杂度 $T(n) = T(n/2) + O(1)$ $O(logn)$ $T(n) = T(n − 1) + O(1)$ $O(n)$ $T(n) = T(n/2) + O(n)$ $O(n)$ $T(n) = 2 ∗ T(n/2) + O(1) $ $O(n)$ $T(n) = 2 ∗ T(n/2) + O(n)$ $O(nlogn)$ $T(n) = T(n − 1) + O(n)$ $O(n^2)$ $T(n) = 2 ∗ T(n − 1) + O(1)$ $O(2^n)$ $T(n) = 2 ∗ T(n − 1) + O(n)$ $O(2^n)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序（Insertion Sort）什么是插入排序插入排序非常类似于扑克牌的排序 执行流程 ① 在执行过程中，插入排序会将序列分为2部分 ​ 头部是已经排好序的，尾部是待排序的 ② 从头开始扫描每一个元素 ​ 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序 插入排序 - 实现(无优化)1234567for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; while (cur &gt; 0 &amp;&amp; cmp(cur, cur - 1) &lt; 0) &#123; swap(cur, cur - 1); cur--; &#125;&#125; 插入排序 – 逆序对（Inversion） 什么是逆序对？ 数组 的逆序对为： ，共5个逆序对 插入排序的时间复杂度与逆序对的数量成正比关系 逆序对的数量越多，插入排序的时间复杂度越高 最坏、平均时间复杂度：$O(n^2)$ 最好时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 属于稳定排序 当逆序对的数量极少时，插入排序的效率特别高 甚至速度比 $O(nlogn)$级别的快速排序还要快 数据量不是特别大的时候，插入排序的效率也是非常好的 插入排序 – 优化思路是将【交换】转为【挪动】 ① 先将待插入的元素备份 ② 头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置 ③ 将待插入元素放到最终的合适位置 123456789for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; T v = array[cur]; while (cur &gt; 0 &amp;&amp; cmp(v, array[cur - 1]) &lt; 0) &#123; array[cur] = array[cur - 1]; cur--; &#125; array[cur] = v;&#125; 插入排序 – 二分搜索优化二分搜索（Binary Search）如何确定一个元素在数组中的位置？（假设数组里面全都是整数） 如果是无序数组，从第 0 个位置开始遍历搜索，平均时间复杂度：$O(n)$ 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 如果是有序数组，可以使用二分搜索，最坏时间复杂度：$O(logn)$ 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 二分搜索 – 思路假设在 $[begin, end)$ 范围内搜索某个元素 v，$mid == (begin + end) /2$ 如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索 如果 $v &gt; m$，去 $[mid + 1, end)$ 范围内二分搜索 如果 $v == m$，直接返回 mid 二分搜索 – 实例 二分搜索 – 实现1234567891011121314public static int search(int[] array, int v) &#123; if (array == null || array.length == 0) return -1; int begin = 0; int end = array.length; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &lt; array[mid]) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; return begin;&#125; 插入排序 – 二分搜索优化在元素 v 的插入过程中，可以先二分搜索出合适的插入位置，然后再将元素 v 插入 要求二分搜索返回的插入位置：第1个大于 v 的元素位置 如果 v 是 5，返回 2 如果 v 是 1，返回 0 如果 v 是 15，返回 7 如果 v 是 8，返回 5 插入排序 – 二分搜索优化 – 思路假设在 $[begin, end)$ 范围内搜索某个元素 $v$，$mid == (begin + end) /2$ 如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索 如果 $v ≥ m$，去 $[mid + 1, end)$ 范围内二分搜索 插入排序 – 二分搜索优化 – 实例 插入排序 – 二分搜索优化 – 实现12345678910111213141516171819202122232425262728for (int begin = 1; begin &lt; array.length; begin++) &#123; insert(begin, search(begin));&#125;// 将source位置的元素插入到dest位置private void insert(int source, int dest) &#123; T v = array[source]; for (int i = source; i &gt; dest; i--) &#123; array[i] = array[i - 1]; &#125; array[dest] = v;&#125;// 利用二分搜索找到 index 位置元素的待插入位置// 已经排好序数组的区间范围是 [0, index)private int search(int index) &#123; int begin = 0; int end = index; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (cmp(array[index], array[mid]) &lt; 0) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; return begin;&#125; 需要注意的是，使用了二分搜索后，只是减少了比较次数，但插入排序的平均时间复杂度依然是 $O(n^2)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序（Heap Sort）什么是堆排序堆排序可以认为是对选择排序的一种优化 选择排序的实现 / 二叉堆的实现 执行流程 ① 对序列进行原地建堆（heapify） ② 重复执行以下操作，直到堆的元素数量为 1 ​ 交换堆顶元素与尾元素 ​ 堆的元素数量减 1 ​ 对 0 位置进行 1 次 siftDown 操作 堆排序 - 实现12345678910111213// 原地建堆heapSize = array.length;for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i);&#125;while (heapSize &gt; 1) &#123; // 交换堆顶元素和尾部元素 swap(0, --heapSize); // 对0位置进行siftDown（恢复堆的性质） siftDown(0);&#125; 123456789101112131415161718192021222324private void siftDown(int index) &#123; T element = array[index]; int half = heapSize &gt;&gt; 1; while (index &lt; half) &#123; // index必须是非叶子节点 // 默认是左边跟父节点比 int childIndex = (index &lt;&lt; 1) + 1; T child = array[childIndex]; int rightIndex = childIndex + 1; // 右子节点比左子节点大 if (rightIndex &lt; heapSize &amp;&amp; cmp(array[rightIndex], child) &gt; 0) &#123; child = array[childIndex = rightIndex]; &#125; // 大于等于子节点 if (cmp(element, child) &gt;= 0) break; array[index] = child; index = childIndex; &#125; array[index] = element;&#125; 最好、最坏、平均时间复杂度：O(nlogn)，空间复杂度：O(1)，属于不稳定排序]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序（Selection Sort）执行流程 ① 从序列中找出最大的那个元素，然后与最末尾的元素交换位置 ​ 执行完一轮后，最末尾的那个元素就是最大的元素 ② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ① 123456789for (int end = array.length - 1; end &gt; 0; end--) &#123; int max = 0; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(max, begin) &lt; 0) &#123; max = begin; &#125; &#125; swap(max, end);&#125; 选择排序的交换次数要远远少于冒泡排序，平均性能优于冒泡排序 最好、最坏、平均时间复杂度：$O(n^2)$，空间复杂度：$O(1)$，属于不稳定排序]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序（Bubble Sort）冒泡排序（无优化实现）冒泡排序也叫做起泡排序 执行流程（统一以升序为例子） ① 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置 ​ 执行完一轮后，最末尾那个元素就是最大的元素 ② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①，直到全部元素有序 123456789for (int end = array.length - 1; end &gt; 0; end--) &#123; for (int begin = 1; begin &lt;= end; begin++) &#123; // 比大小 if (cmp(begin, begin - 1) &lt; 0) &#123; // 交换 swap(begin, begin - 1); &#125; &#125;&#125; 冒泡排序 – 优化①如果序列已经完全有序，可以提前终止冒泡排序 12345678910for (int end = array.length - 1; end &gt; 0; end--) &#123; boolean sorted = true; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sorted = false; &#125; &#125; if (sorted) break;&#125; 冒泡排序 – 优化②如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数 最后1次交换的位置是 6 1234567891011for (int end = array.length - 1; end &gt; 0; end--) &#123; int sortedIndex = 1; for (int begin = 1; begin &lt;= end; begin++) &#123; // if (array[begin] &lt; array[begin - 1]) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sortedIndex = begin; &#125; &#125; end = sortedIndex;&#125; 最坏、平均时间复杂度：$O(n^2)$ 最好时间复杂度：$O(n)$ 空间复杂度：$O(1)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大排序算法]]></title>
    <url>%2F2020%2F07%2F14%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[10大排序算法以下表格是基于数组进行排序的一般性结论 冒泡、选择、插入、归并、快速、希尔、堆排序，属于比较排序（Comparison Sorting） 排序算法的稳定性（Stability）如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法 排序前：5, 1, 3𝑎, 4, 7, 3𝑏 稳定的排序： 1, 3𝑎, 3𝑏, 4, 5, 7 不稳定的排序：1, 3𝑏, 3𝑎, 4, 5, 7 原地算法（In-place Algorithm）不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入 空间复杂度为𝑂(1) 的都可以认为是原地算法 非原地算法，称为 Not-in-place 或者 Out-of-place]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2020%2F07%2F14%2FTrie%2F</url>
    <content type="text"><![CDATA[TrieTrie 也叫做字典树、前缀树（Prefix Tree）、单词查找树 Trie 搜索字符串的效率主要跟字符串的长度有关 假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词 Trie代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class Trie&lt;V&gt; &#123; private int size; private Node&lt;V&gt; root; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; size = 0; root = null; &#125; public V get(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.word ? node.value : null; &#125; public boolean contains(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.word; &#125; public V add(String key, V value) &#123; keyCheck(key); // 创建根节点 if (root == null) &#123; root = new Node&lt;&gt;(null); &#125; Node&lt;V&gt; node = root; int len = key.length(); for (int i = 0; i &lt; len; i++) &#123; char c = key.charAt(i); boolean emptyChildren = node.children == null; Node&lt;V&gt; childNode = emptyChildren ? null : node.children.get(c); if (childNode == null) &#123; childNode = new Node&lt;&gt;(node); childNode.character = c; node.children = emptyChildren ? new HashMap&lt;&gt;() : node.children; node.children.put(c, childNode); &#125; node = childNode; &#125; if (node.word) &#123; // 已经存在这个单词 V oldValue = node.value; node.value = value; return oldValue; &#125; // 新增一个单词 node.word = true; node.value = value; size++; return null; &#125; public V remove(String key) &#123; // 找到最后一个节点 Node&lt;V&gt; node = node(key); // 如果不是单词结尾，不用作任何处理 if (node == null || !node.word) return null; size--; V oldValue = node.value; // 如果还有子节点 if (node.children != null &amp;&amp; !node.children.isEmpty()) &#123; node.word = false; node.value = null; return oldValue; &#125; // 如果没有子节点 Node&lt;V&gt; parent = null; while ((parent = node.parent) != null) &#123; parent.children.remove(node.character); if (parent.word || !parent.children.isEmpty()) break; node = parent; &#125; return oldValue; &#125; public boolean startsWith(String prefix) &#123; return node(prefix) != null; &#125; private Node&lt;V&gt; node(String key) &#123; keyCheck(key); Node&lt;V&gt; node = root; int len = key.length(); for (int i = 0; i &lt; len; i++) &#123; if (node == null || node.children == null || node.children.isEmpty()) return null; char c = key.charAt(i); node = node.children.get(c); &#125; return node; &#125; private void keyCheck(String key) &#123; if (key == null || key.length() == 0) &#123; throw new IllegalArgumentException("key must not be empty"); &#125; &#125; private static class Node&lt;V&gt; &#123; Node&lt;V&gt; parent; HashMap&lt;Character, Node&lt;V&gt;&gt; children; Character character; V value; boolean word; // 是否为单词的结尾（是否为一个完整的单词） public Node(Node&lt;V&gt; parent) &#123; this.parent = parent; &#125; &#125;&#125; 总结Trie 的优点：搜索前缀的效率主要跟前缀的长度有关 Trie 的缺点：需要耗费大量的内存，因此还有待改进 更多Trie 相关的数据结构和算法 Double-array Trie、Suffix Tree、Patricia Tree、Crit-bit Tree、AC自动机]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼树]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%2F</url>
    <content type="text"><![CDATA[哈夫曼编码（Huffman Coding）哈夫曼编码，又称为霍夫曼编码，它是现代压缩算法的基础 假设要把字符串【ABBBCCCCCCCCDDDDDDEE】转成二进制编码进行传输 可以转成ASCII编码（65 ~ 69，1000001~1000101），但是有点冗长，如果希望编码更短呢？ 可以先约定5个字母对应的二进制 A B C D E 000 001 010 011 100 对应的二进制编码：000001001001010010010010010010010010011011011011011011100100 一共20个字母，转成了60个二进制位 如果使用哈夫曼编码，可以压缩至41个二进制位，约为原来长度的68.3% 哈夫曼树先计算出每个字母的出现频率（权值，这里直接用出现次数），【ABBBCCCCCCCCDDDDDDEE】 A B C D E 1 3 8 6 2 利用这些权值，构建一棵哈夫曼树（又称为霍夫曼树、最优二叉树） 如何构建一棵哈夫曼树？（假设有 n 个权值） 以权值作为根节点构建 n 棵二叉树，组成森林 在森林中选出 2 个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点为其左右子树根节点之和 从森林中删除刚才选取的 2 棵树，并将新树加入森林 重复 2、3 步骤，直到森林只剩一棵树为止，该树即为哈夫曼树 构建哈夫曼树 left为0，right为1，可以得出5个字母对应的哈夫曼编码 A B C D E 1110 110 0 10 1111 【ABBBCCCCCCCCDDDDDDEE】的哈夫曼编码是 1110110110110000000001010101010101111 总结n 个权值构建出来的哈夫曼树拥有 n 个叶子节点 每个哈夫曼编码都不是另一个哈夫曼编码的前缀 哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近 带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径长度。与最终的哈夫曼编码总长度成正比关系。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先级队列]]></title>
    <url>%2F2020%2F07%2F14%2F%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[优先级队列（Priority Queue）队列实现 优先级队列的接口设计普通的队列是 FIFO 原则，也就是先进先出 优先级队列则是按照优先级高低进行出队，比如将优先级最高的元素作为队头优先出队 1234567891011121314151617181920212223242526272829303132333435public class PriorityQueue&lt;E&gt; &#123; private BinaryHeap&lt;E&gt; heap; public PriorityQueue(Comparator&lt;E&gt; comparator) &#123; heap = new BinaryHeap&lt;&gt;(comparator); &#125; public PriorityQueue() &#123; this(null); &#125; public int size() &#123; return heap.size(); &#125; public boolean isEmpty() &#123; return heap.isEmpty(); &#125; public void clear() &#123; heap.clear(); &#125; public void enQueue(E element) &#123; heap.add(element); &#125; public E deQueue() &#123; return heap.remove(); &#125; public E front() &#123; return heap.get(); &#125;&#125; 优先级队列的应用场景举例 医院的夜间门诊 队列元素是病人 优先级是病情的严重情况、挂号时间 操作系统的多任务调度 队列元素是任务 优先级是任务类型 优先队列的底层实现根据优先队列的特点，很容易想到：可以直接利用二叉堆作为优先队列的底层实现 二叉堆实现 可以通过 Comparator 或 Comparable 去自定义优先级高低 123456789101112131415161718public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int boneBreak; public Person(String name, int boneBreak) &#123; this.name = name; this.boneBreak = boneBreak; &#125; @Override public int compareTo(Person person) &#123; return this.boneBreak - person.boneBreak; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", boneBreak=" + boneBreak + "]"; &#125;&#125; 12345678910111213public class Main &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Person&gt; queue = new PriorityQueue&lt;&gt;(); queue.enQueue(new Person("Jack", 2)); queue.enQueue(new Person("Rose", 10)); queue.enQueue(new Person("Jake", 5)); queue.enQueue(new Person("James", 15)); while (!queue.isEmpty()) &#123; System.out.println(queue.deQueue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉堆]]></title>
    <url>%2F2020%2F07%2F14%2F%E4%BA%8C%E5%8F%89%E5%A0%86%2F</url>
    <content type="text"><![CDATA[二叉堆思考设计一种数据结构，用来存放整数，要求提供 3 个接口 添加元素 获取最大值 删除最大值 有没有更优的数据结构？ 堆：获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn) 堆（Heap）堆（Heap）也是一种树状的数据结构（不要跟内存模型中的“堆空间”混淆），常见的堆实现有 二叉堆（Binary Heap，完全二叉堆） 多叉堆（D-heap、D-ary Heap） 索引堆（Index Heap） 二项堆（Binomial Heap） 斐波那契堆（Fibonacci Heap） 左倾堆（Leftist Heap，左式堆） 斜堆（Skew Heap） 堆的一个重要性质：任意节点的值总是 ≥（ ≤ ）子节点的值 如果任意节点的值总是 ≥ 子节点的值，称为：最大堆、大根堆、大顶堆 如果任意节点的值总是 ≤ 子节点的值，称为：最小堆、小根堆、小顶堆 由此可见，堆中的元素必须具备可比较性（跟二叉搜索树一样） 堆的基本接口设计123456789public interface Heap&lt;E&gt; &#123; int size(); // 元素的数量 boolean isEmpty(); // 是否为空 void clear(); // 清空 void add(E element); // 添加元素 E get(); // 获得堆顶元素 E remove(); // 删除堆顶元素 E replace(E element); // 删除堆顶元素的同时插入一个新元素&#125; 12345678910111213141516171819202122232425262728public abstract class AbstractHeap&lt;E&gt; implements Heap&lt;E&gt; &#123; protected int size; protected Comparator&lt;E&gt; comparator; public AbstractHeap(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator; &#125; public AbstractHeap() &#123; this(null); &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; // 比较器 protected int compare(E e1, E e2) &#123; return comparator != null ? comparator.compare(e1, e2) : ((Comparable&lt;E&gt;)e1).compareTo(e2); &#125;&#125; 二叉堆（Binary Heap）二叉堆的逻辑结构就是一棵完全二叉树，所以也叫完全二叉堆 鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）一般用数组实现即可 索引 i 的规律（ n 是元素数量） 如果 i = 0 ，它是根节点 如果 i &gt; 0 ，它的父节点的索引为 floor( (i – 1) / 2 ) 如果 2i + 1 ≤ n – 1，它的左子节点的索引为 2i + 1 如果 2i + 1 &gt; n – 1 ，它无左子节点 如果 2i + 2 ≤ n – 1 ，它的右子节点的索引为 2i + 2 如果 2i + 2 &gt; n – 1 ，它无右子节点 二叉堆获取最大值123456789public E get() &#123; emptyCheck(); return elements[0];&#125;private void emptyCheck() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("Heap is empty"); &#125;&#125; 最大堆 – 添加 循环执行以下操作（图中的 80 简称为 node） 如果 node ＞ 父节点 与父节点交换位置 如果 node ≤ 父节点，或者 node 没有父节点 退出循环 这个过程，叫做上滤（Sift Up） 时间复杂度：O(logn) 1234567891011121314151617181920212223public void add(E element) &#123; elementNotNullCheck(element); ensureCapacity(size + 1); elements[size++] = element; siftUp(size - 1);&#125;private void siftUp(int index) &#123; E e = elements[index]; while (index &gt; 0) &#123; int pindex = (index - 1) &gt;&gt; 1; E p = elements[pindex]; if (compare(e, p) &lt;= 0) return; // 交换index、pindex位置的内容 E tmp = elements[index]; elements[index] = elements[pindex]; elements[pindex] = tmp; // 重新赋值index index = pindex; &#125;&#125; 最大堆 – 添加 – 交换位置的优化一般交换位置需要3行代码，可以进一步优化 将新添加节点备份，确定最终位置才摆放上去 仅从交换位置的代码角度看 可以由大概的 3 O(logn) 优化到 1 O(logn) + 1 1234567891011121314private void siftUp(int index) &#123; E element = elements[index]; while (index &gt; 0) &#123; int parentIndex = (index - 1) &gt;&gt; 1; E parent = elements[parentIndex]; if (compare(element, parent) &lt;= 0) break; // 将父元素存储在index位置 elements[index] = parent; // 重新赋值index index = parentIndex; &#125; elements[index] = element;&#125; 最大堆 – 删除 用最后一个节点覆盖根节点 删除最后一个节点 循环执行以下操作（图中的 43 简称为 node） 如果 node &lt; 最大的子节点，与最大的子节点交换位置 如果 node ≥ 最大的子节点， 或者 node 没有子节点，退出循环 这个过程，叫做下滤（Sift Down），时间复杂度：O(logn) 同样的，交换位置的操作可以像添加那样进行优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344public E remove() &#123; emptyCheck(); int lastIndex = --size; E root = elements[0]; elements[0] = elements[lastIndex]; elements[lastIndex] = null; siftDown(0); return root;&#125;private void siftDown(int index) &#123; E element = elements[index]; int half = size &gt;&gt; 1; // 第一个叶子节点的索引 == 非叶子节点的数量 // index &lt; 第一个叶子节点的索引 // 必须保证index位置是非叶子节点 while (index &lt; half) &#123; // index的节点有2种情况 // 1.只有左子节点 // 2.同时有左右子节点 // 默认为左子节点跟它进行比较 int childIndex = (index &lt;&lt; 1) + 1; E child = elements[childIndex]; // 右子节点 int rightIndex = childIndex + 1; // 选出左右子节点最大的那个 if (rightIndex &lt; size &amp;&amp; compare(elements[rightIndex], child) &gt; 0) &#123; child = elements[childIndex = rightIndex]; &#125; if (compare(element, child) &gt;= 0) break; // 将子节点存放到index位置 elements[index] = child; // 重新设置index index = childIndex; &#125; elements[index] = element;&#125; 最大堆 - 替换堆顶1234567891011121314public E replace(E element) &#123; elementNotNullCheck(element); E root = null; if (size == 0) &#123; elements[0] = element; size++; &#125; else &#123; root = elements[0]; elements[0] = element; siftDown(0); &#125; return root;&#125; 最大堆 – 批量建堆（Heapify）批量建堆，有 2 种做法 自上而下的上滤 自下而上的下滤 最大堆 – 批量建堆 – 自上而下的上滤 123456private void heapify() &#123; // 自上而下的上滤 for (int i = 1; i &lt; size; i++) &#123; siftUp(i); &#125;&#125; 最大堆 – 批量建堆 – 自下而上的下滤 123456private void heapify() &#123; // 自下而上的下滤 for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125;&#125; 最大堆 – 批量建堆 – 效率对比所有节点的深度之和 仅仅是叶子节点，就有近 n/2 个，而且每一个叶子节点的深度都是 O(logn) 级别的 因此，在叶子节点这一块，就达到了 O(nlogn) 级别 O(nlogn) 的时间复杂度足以利用排序算法对所有节点进行全排序 所有节点的高度之和 假设是满树，节点总个数为 $n$，树高为 $h$，那么 $n = 2h − 1$ 所有节点的树高之和 $H(n) = 2^0 ∗ (h − 0) + 2^1 ∗ (h − 1) + 2^2 ∗ (h − 2) + ⋯ + 2^{h −1} ∗ [h − (h − 1)]$ $H(n) = h ∗ (2^0 + 2^1 + 2^2 + ⋯ + 2^{h −1}) − [1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 1)∗ 2^{h−1}]$ $H(n) = h ∗ (2^h − 1) − [(h − 2) ∗ 2^h + 2]$ $H(n) = h ∗ 2^h − h − h ∗ 2^h + 2^{h+1} − 2$ $H(n) = 2^{h+1} − h − 2 = 2 ∗ (2^h − 1) − h = 2n − h = 2n − log_2(n + 1) = O(n)$ 公式推导 $S(h) = 1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 2) ∗ 2^{h−2} + (h − 1) * 2^{h−1}$ $2S(h) = 1 ∗ 2^2 + 2 ∗ 2^3 + 3 ∗ 2^4 + ⋯ + (h − 2) ∗ 2^{h−1} +(h − 1) ∗ 2^h$ $S(h) – 2S(h) = [2^1 + 2^2 + 2^3 + ⋯ + 2^{h−1}] − (h − 1) ∗ 2^h = (2^h − 2) − (h − 1) ∗ 2^h$ $S(h) = (h − 1) ∗ 2^h − (2^h − 2) = (h − 2) ∗ 2^h + 2$ 批量建堆12345678910111213141516171819202122public BinaryHeap(E[] elements, Comparator&lt;E&gt; comparator) &#123; super(comparator); if (elements == null || elements.length == 0) &#123; this.elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; else &#123; size = elements.length; int capacity = Math.max(elements.length, DEFAULT_CAPACITY); this.elements = (E[]) new Object[capacity]; for (int i = 0; i &lt; elements.length; i++) &#123; this.elements[i] = elements[i]; &#125; heapify(); &#125;&#125;private void heapify() &#123; // 自下而上的下滤 for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125;&#125; 如何构建一个小顶堆？1234567Integer[] data = &#123;88, 44, 53, 41, 16, 6, 70, 18, 85, 98, 81, 23, 36, 43, 37&#125;;BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(data, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125;&#125;);BinaryTrees.println(heap); Top K问题从 n 个整数中，找出最大的前 k 个数（ k 远远小于 n ） 如果使用排序算法进行全排序，需要 O(nlogn) 的时间复杂度 如果使用二叉堆来解决，可以使用 O(nlogk) 的时间复杂度来解决 新建一个小顶堆 扫描 n 个整数 先将遍历到的前 k 个数放入堆中 从第 k + 1 个数开始，如果大于堆顶元素，就使用 replace 操作（删除堆顶元素，将第 k + 1 个数添加到堆中） 扫描完毕后，堆中剩下的就是最大的前 k 个数 如果是找出最小的前 k 个数呢？ 用大顶堆 如果小于堆顶元素，就使用 replace 操作 1234567891011121314151617181920212223static void test() &#123; // 新建一个小顶堆 BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); // 找出最大的前k个数 int k = 3; Integer[] data = &#123;51, 30, 39, 92, 74, 25, 16, 93, 91, 19, 54, 47, 73, 62, 76, 63, 35, 18, 90, 6, 65, 49, 3, 26, 61, 21, 48&#125;; for (int i = 0; i &lt; data.length; i++) &#123; if (heap.size() &lt; k) &#123; // 前k个数添加到小顶堆 heap.add(data[i]); // logk &#125; else if (data[i] &gt; heap.get()) &#123; // 如果是第k + 1个数，并且大于堆顶元素 heap.replace(data[i]); // logk &#125; &#125; // O(nlogk) BinaryTrees.println(heap);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表（HashTable）先来分析TreeMap（红黑树映射实现） 时间复杂度（平均） 添加、删除、搜索：O(logn) 特点 Key 必须具备可比较性 元素的分布是有顺序的 在实际应用中，很多时候的需求 Map 中存储的元素不需要讲究顺序 Map 中的 Key 不需要具备可比较性 不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)，那就是采取哈希表来实现 Map 什么是哈希表（HashTable）哈希表也叫做散列表（ hash 有“剁碎”的意思） 添加、搜索、删除的流程都是类似的 利用哈希函数生成 key 对应的 index【O(1)】 根据 index 操作定位数组元素【O(1)】 哈希表是【空间换时间】的典型应用 哈希函数，也叫做散列函数 哈希表内部的数组元素，很多地方也叫 Bucket（桶），整个数组叫 Buckets 或者 Bucket Array 哈希冲突（Hash Collision）哈希冲突也叫做哈希碰撞 2 个不同的 key，经过哈希函数计算出相同的结果 key1 ≠ key2 ，hash(key1) = hash(key2) 解决哈希冲突的常见方法 开放定址法（Open Addressing） 按照一定规则向其他地址探测，直到遇到空桶 再哈希法（Re-Hashing） 设计多个哈希函数 链地址法（Separate Chaining） 比如通过链表将同一index的元素串起来 JDK1.8的哈希冲突解决方案JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突 默认使用单向链表将元素串起来 在添加元素时，可能会由单向链表转为红黑树来存储元素 比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时 当红黑树节点数量少到一定程度时，又会转为单向链表 哈希函数哈希表中哈希函数的实现步骤大概如下 先生成 key 的哈希值（必须是整数） 再让 key 的哈希值跟数组的大小进行相关运算，生成一个索引值 123private int hash(K key) &#123; return hash_code(key) % table.length;&#125; 为了提高效率，可以使用 &amp; 位运算取代 % 运算【前提：将数组的长度设计为 2 的幂（2n）】 1100 1010 1011 1100 &amp; 1111 &amp; 1111 1010 1100 123private int hash(K key) &#123; return hash_code(key) % (table.length - 1);&#125; 良好的哈希函数 让哈希值更加均匀分布 → 减少哈希冲突次数 → 提升哈希表的性能 如何生成key的哈希值key 的常见种类可能有 整数、浮点数、字符串、自定义对象 不同种类的 key，哈希值的生成方式不一样，但目标是一致的 尽量让每个 key 的哈希值是唯一的 尽量让 key 的所有信息参与运算 在Java中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null 整数的哈希值整数值当做哈希值 比如 10 的哈希值就是 10 123public static int hashCode(int value)&#123; return value;&#125; 浮点数的哈希值将存储的二进制格式转为整数值 123public static int hashCode(float value)&#123; return floatToIntBits(value);&#125; Long和Double的哈希值123public static int hashCode(long value)&#123; return (int)(value ^ (value &gt;&gt;&gt; 32));&#125; 1234public static int hashCode(double value)&#123; long bits = doubleToLongBits(value); return (int)(bits ^ (bits &gt;&gt;&gt; 32));&#125; >&gt;&gt; 和 ^ 的作用是？ 高32bit 和 低32bit 混合计算出 32bit 的哈希值 充分利用所有信息计算出哈希值 字符串的哈希值字符串是由若干个字符组成的 比如字符串 jack，由 j、a、c、k 四个字符组成（字符的本质就是一个整数） 因此，jack 的哈希值可以表示为 $ j ∗ n^3 + a ∗ n^2 + c ∗ n^1 + k ∗ n^0$，等价于 $[ ( j ∗ n + a ) ∗ n + c ] ∗ n + k$ 在JDK中，乘数 n 为 31，为什么使用 31？ 31 是一个奇素数，JVM会将 31 * i 优化成 (i &lt;&lt; 5) – i 31 * i = (2^5 - 1) * i = i * 2^5 - i = (i < 5) -i]]></content>
      <categories>
        <category>数据结构</category>
        <category>映射</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>映射</tag>
        <tag>红黑树</tag>
        <tag>哈希表</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[映射]]></title>
    <url>%2F2020%2F07%2F13%2F%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[映射（Map）Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C、Swift 等） Map 的每一个 key 是唯一的 Map的接口设计12345678910111213141516public interface Map&lt;K, V&gt; &#123; int size(); boolean isEmpty(); void clear(); V put(K key, V value); V get(K key); V remove(K key); boolean containsKey(K key); boolean containsValue(V value); void traversal(Visitor&lt;K, V&gt; visitor); public static abstract class Visitor&lt;K, V&gt; &#123; boolean stop; public abstract boolean visit(K key, V value); &#125;&#125; 类似 Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现 Map利用红黑树实现红黑树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479public class TreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private static final boolean RED = false; private static final boolean BLACK = true; private int size; private Node&lt;K, V&gt; root; private Comparator&lt;K&gt; comparator; public TreeMap() &#123; this(null); &#125; public TreeMap(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; root = null; size = 0; &#125; @Override public V put(K key, V value) &#123; keyNotNullCheck(key); // 添加第一个节点 if (root == null) &#123; root = new Node&lt;&gt;(key, value, null); size++; // 新添加节点之后的处理 afterPut(root); return null; &#125; // 添加的不是第一个节点 // 找到父节点 Node&lt;K, V&gt; parent = root; Node&lt;K, V&gt; node = root; int cmp = 0; do &#123; cmp = compare(key, node.key); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // 相等 node.key = key; V oldValue = node.value; node.value = value; return oldValue; &#125; &#125; while (node != null); // 看看插入到父节点的哪个位置 Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // 新添加节点之后的处理 afterPut(newNode); return null; &#125; @Override public V get(K key) &#123; Node&lt;K, V&gt; node = node(key); return node != null ? node.value : null; &#125; @Override public V remove(K key) &#123; return remove(node(key)); &#125; @Override public boolean containsKey(K key) &#123; return node(key) != null; &#125; @Override public boolean containsValue(V value) &#123; if (root == null) return false; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;K, V&gt; node = queue.poll(); if (valEquals(value, node.value)) return true; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return false; &#125; @Override public void traversal(Visitor&lt;K, V&gt; visitor) &#123; if (visitor == null) return; traversal(root, visitor); &#125; private void traversal(Node&lt;K, V&gt; node, Visitor&lt;K, V&gt; visitor) &#123; if (node == null || visitor.stop) return; traversal(node.left, visitor); if (visitor.stop) return; visitor.visit(node.key, node.value); traversal(node.right, visitor); &#125; private boolean valEquals(V v1, V v2) &#123; return v1 == null ? v2 == null : v1.equals(v2); &#125; private V remove(Node&lt;K, V&gt; node) &#123; if (node == null) return null; size--; V oldValue = node.value; if (node.hasTwoChildren()) &#123; // 度为2的节点 // 找到后继节点 Node&lt;K, V&gt; s = successor(node); // 用后继节点的值覆盖度为2的节点的值 node.key = s.key; node.value = s.value; // 删除后继节点 node = s; &#125; // 删除node节点（node的度必然是1或者0） Node&lt;K, V&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // node是度为1的节点 // 更改parent replacement.parent = node.parent; // 更改parent的left、right的指向 if (node.parent == null) &#123; // node是度为1的节点并且是根节点 root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // 删除节点之后的处理 afterRemove(replacement); &#125; else if (node.parent == null) &#123; // node是叶子节点并且是根节点 root = null; &#125; else &#123; // node是叶子节点，但不是根节点 if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // 删除节点之后的处理 afterRemove(node); &#125; return oldValue; &#125; private void afterRemove(Node&lt;K, V&gt; node) &#123; // 如果删除的节点是红色 // 或者 用以取代删除节点的子节点是红色 if (isRed(node)) &#123; black(node); return; &#125; Node&lt;K, V&gt; parent = node.parent; if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;K, V&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125; private Node&lt;K, V&gt; predecessor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） Node&lt;K, V&gt; p = node.left; if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.parent == null // node == node.parent.right return node.parent; &#125; private Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） Node&lt;K, V&gt; p = node.right; if (p != null) &#123; while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; private Node&lt;K, V&gt; node(K key) &#123; Node&lt;K, V&gt; node = root; while (node != null) &#123; int cmp = compare(key, node.key); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null; &#125; private void afterPut(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) &#123; black(node); return; &#125; // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node&lt;K, V&gt; uncle = parent.sibling(); // 祖父节点 Node&lt;K, V&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterPut(grand); return; &#125; // 叔父节点不是红色 if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125; &#125; private void rotateLeft(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.right; Node&lt;K, V&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void rotateRight(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.left; Node&lt;K, V&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent; &#125; private Node&lt;K, V&gt; color(Node&lt;K, V&gt; node, boolean color) &#123; if (node == null) return node; node.color = color; return node; &#125; private Node&lt;K, V&gt; red(Node&lt;K, V&gt; node) &#123; return color(node, RED); &#125; private Node&lt;K, V&gt; black(Node&lt;K, V&gt; node) &#123; return color(node, BLACK); &#125; private boolean colorOf(Node&lt;K, V&gt; node) &#123; return node == null ? BLACK : node.color; &#125; private boolean isBlack(Node&lt;K, V&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean isRed(Node&lt;K, V&gt; node) &#123; return colorOf(node) == RED; &#125; private int compare(K e1, K e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;K&gt;)e1).compareTo(e2); &#125; private void keyNotNullCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null"); &#125; &#125; private static class Node&lt;K, V&gt; &#123; K key; V value; boolean color = RED; Node&lt;K, V&gt; left; Node&lt;K, V&gt; right; Node&lt;K, V&gt; parent; public Node(K key, V value, Node&lt;K, V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; public Node&lt;K, V&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>映射</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>映射</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2020%2F07%2F13%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合（Set）集合的特点不存放重复的元素，常用于去重 存放新增 IP，统计新增 IP 量 存放词汇，统计词汇量 集合接口定义1234567891011121314public interface Set&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(E element); void add(E element); void remove(E element); void traversal(Visitor&lt;E&gt; visitor); public static abstract class Visitor&lt;E&gt; &#123; boolean stop; public abstract boolean visit(E element); &#125;&#125; 集合的内部实现直接利用学过的数据结构实现（链表，动态数组，红黑树、AVL树） 集合利用链表实现链表的实现 1234567891011121314151617181920212223242526272829303132333435363738394041public class ListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); @Override public int size() &#123; return list.size(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public void clear() &#123; list.clear(); &#125; @Override public boolean contains(E element) &#123; return list.contains(element); &#125; @Override public void add(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; // 存在就覆盖 list.set(index, element); &#125; else &#123; // 不存在就添加 list.add(element); &#125; &#125; @Override public void remove(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; list.remove(index); &#125; &#125;&#125; 集合利用红黑树实现红黑树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142public class TreeSet&lt;E&gt; implements Set&lt;E&gt; &#123; private RBTree&lt;E&gt; tree; public TreeSet() &#123; this(null); &#125; public TreeSet(Comparator&lt;E&gt; comparator) &#123; tree = new RBTree&lt;&gt;(comparator); &#125; @Override public int size() &#123; return tree.size(); &#125; @Override public boolean isEmpty() &#123; return tree.isEmpty(); &#125; @Override public void clear() &#123; tree.clear(); &#125; @Override public boolean contains(E element) &#123; return tree.contains(element); &#125; @Override public void add(E element) &#123; tree.add(element); &#125; @Override public void remove(E element) &#123; tree.remove(element); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>链表</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2020%2F07%2F12%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树（Red Black Tree）什么是红黑树红黑树也是一种自平衡的二叉搜索树 以前也叫做平衡二叉B树（Symmetric Binary B-tree） 红黑树必须满足以下 5 条性质 节点是 RED 或者 BLACK 根节点是 BLACK 叶子节点（外部节点，空节点）都是 BLACK RED 节点的子节点都是 BLACK RED 节点的 parent 都是 BLACK 从根节点到叶子节点的所有路径上不能有 2 个连续的 RED 节点 从任一节点到叶子节点的所有路径都包含相同数目的 BLACK 节点 红黑树的等价变换红黑树 和 4阶B树（2-3-4树）具有等价性 BLACK 节点与它的 RED 子节点融合在一起，形成1个B树节点 红黑树的 BLACK 节点个数 与 4阶B树的节点总个数相等 注意：后面展示的红黑树都会省略 NULL 节点 红黑树 vs 2-3-4树 如果上图最底层的 BLACK 节点是不存在的，在B树中是什么样的情形？ 整棵B树只有1个节点，而且是超级节点 一些辅助函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// parent：父节点// sibling：兄弟节点// uncle：叔父节点（parent 的兄弟节点）// grand：祖父节点（parent 的父节点）// 指定颜色private Node&lt;E&gt; color(Node&lt;E&gt; node, boolean color) &#123; if (node == null) return node; ((RBNode&lt;E&gt;)node).color = color; return node;&#125;// 染红private Node&lt;E&gt; red(Node&lt;E&gt; node) &#123; return color(node, RED);&#125;// 染黑private Node&lt;E&gt; black(Node&lt;E&gt; node) &#123; return color(node, BLACK);&#125;// 查看颜色private boolean colorOf(Node&lt;E&gt; node) &#123; return node == null ? BLACK : ((RBNode&lt;E&gt;)node).color;&#125;// 判断是否是黑色private boolean isBlack(Node&lt;E&gt; node) &#123; return colorOf(node) == BLACK;&#125;// 判断是否是红色private boolean isRed(Node&lt;E&gt; node) &#123; return colorOf(node) == RED;&#125;// 查看是否有兄弟节点public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null;&#125; 红黑树的添加已知 B树中，新元素必定是添加到叶子节点中 4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3 建议新添加的节点默认为 RED，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定） 有 4 种情况满足红黑树的性质 4 ：parent 为BLACK同样也满足4阶B树的性质 因此不用做任何额外处理 12// 如果父节点是黑色，直接返回if (isBlack(parent)) return; 有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）其中前 4 种属于B树节点上溢的情况 添加 – 修复性质4 – LL\RR判定条件：uncle 不是 RED 1.parent 染成 BLACK，grand 染成 RED 2.grand 进行单旋操作 LL：右旋转 RR：左旋转 123456789101112131415161718192021// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点染成红色Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 return;&#125;// 叔父节点不是红色if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (!node.isLeftChild()) &#123; // RR black(parent); &#125; rotateLeft(grand);&#125; 添加 – 修复性质4 – LR\RL判定条件：uncle 不是 RED 自己染成 BLACK，grand 染成 RED 进行双旋操作 LR：parent 左旋转， grand 右旋转 RL：parent 右旋转， grand 左旋转 1234567891011121314151617181920212223// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点染成红色Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 return;&#125;// 叔父节点不是红色if (parent.isLeftChild()) &#123; // L if (!node.isLeftChild()) &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; rotateLeft(grand);&#125; 添加 – 修复性质4 – 上溢 – LL判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 grand 向上合并时，可能继续发生上溢 若上溢持续到根节点，只需将根节点染成 BLACK 12345678910111213141516// 添加的是根节点 或者 上溢到达了根节点if (parent == null) &#123; black(node); return;&#125;// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return;&#125; 添加 – 修复性质4 – 上溢 – RR判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 123456789101112// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return;&#125; 添加 – 修复性质4 – 上溢 – LR判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 添加 – 修复性质4 – 上溢 – RL判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 红黑树添加后完整修复的代码12345678910111213141516171819202122232425262728293031323334353637383940414243protected void afterAdd(Node&lt;E&gt; node) &#123; Node&lt;E&gt; parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) &#123; black(node); return; &#125; // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node&lt;E&gt; uncle = parent.sibling(); // 祖父节点 Node&lt;E&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return; &#125; // 叔父节点不是红色 if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125;&#125; 红黑树的删除B树中，最后真正被删除的元素都在叶子节点中 删除 – RED节点直接删除，不用作任何调整 1234protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // 如果删除的节点是红色 if (isRed(node)) return;&#125; 删除 – BLACK节点有 3 种情况 拥有 2 个 RED 子节点的 BLACK 节点 不可能被直接删除，因为会找它的子节点替代删除 因此不用考虑这种情况 拥有 1 个 RED 子节点的 BLACK 节点 BLACK 叶子节点 下文举例采用: 被删除的节点在右边，兄弟节点在左边，（反之交换左右方向即可） 删除 - 拥有 1 个 RED 子节点的 BLACK 节点判定条件：用以替代的子节点是 RED 将替代的子节点染成 BLACK 即可保持红黑树性质 1234567protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // 用以取代node的子节点是红色 if (isRed(replacement)) &#123; black(replacement); return; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 RED 子节点BLACK 叶子节点被删除后，会导致B树节点下溢（比如删除88） 如果 sibling 至少有 1 个 RED 子节点（一个或两个RED子节点） 兄弟节点的左边是黑色，(没有子节点也算是黑色) 兄弟节点左旋 改变兄弟节点为parent的左边 后续再按兄弟节点的左边是红色执行即可 兄弟节点的左边是红色 兄弟节点继承 parent 的颜色 兄弟节点的左边变成黑色 parent节点变成黑色 parent右旋 1234567891011121314151617181920212223242526272829303132protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125;else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isBlack(sibling)) &#123; // 兄弟节点是黑色 // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 if (isRed(sibling.left) || isRed(sibling.right)) &#123; // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; // 兄弟节点的左边是红色或兄弟旋转后 color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 RED 子节点判定条件：sibling 没有 1 个 RED 子节点 将 sibling 染成 RED、parent 染成 BLACK 即可修复红黑树性质 如果 parent 是 BLACK 会导致 parent 也下溢 这时只需要把 parent 当做被删除的节点处理即可 123456789101112131415161718192021222324252627protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 // 兄弟节点是黑色 if(isBlack(sibling))&#123; if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent, null); &#125; &#125; &#125; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为RED如果 sibling 是 RED sibling 染成 BLACK，parent 染成 RED，进行旋转 于是又回到 sibling 是 BLACK 的情况 1234567891011121314151617181920protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; &#125;&#125; 红黑树删除后完整修复的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void afterRemove(Node&lt;E&gt; node) &#123; // 如果删除的节点是红色 // 或者 用以取代删除节点的子节点是红色 if (isRed(node)) &#123; black(node); return; &#125; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125;&#125; 红黑树的平衡为何那5条性质，就能保证红黑树是平衡的？ 那5条性质，可以保证红黑树等价于4阶B树 相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍 是一种弱平衡、黑高度平衡 红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是 O(logn) 级别 平均时间复杂度搜索：O(logn) 添加：O(logn)，O(1) 次的旋转操作 删除：O(logn)，O(1) 次的旋转操作 AVL树 vs 红黑树AVL树 AVL树的实现 平衡标准比较严格：每个左右子树的高度差不超过1 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W个节点，AVL树最大树高28） 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整 红黑树 平衡标准比较宽松：没有一条路径会大于其他路径的2倍 最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40） 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整 总结 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树 BST vs AVL Tree vs Red Black Tree10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树]]></title>
    <url>%2F2020%2F07%2F12%2FB%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树（B - tree、B - 树）​ B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现 B树特点 1个节点可以存储超过 2 个元素、可以拥有超过 2 个子节点 拥有二叉搜索树的一些性质 平衡，每个节点的所有子树高度一致 比较矮 m阶B树的性质（m≥2）假设一个节点存储的元素个数为 x 根节点：1 ≤ x ≤ m − 1 非根节点：┌ m/2 ┐ − 1 ≤ x ≤ m − 1 如果有子节点，子节点个数 y = x + 1 根节点：2 ≤ y ≤ m 非根节点：┌ m/2 ┐ ≤ y ≤ m 比如 m = 3，2 ≤ y ≤ 3，因此可以称为（2, 3）树、2-3树 比如 m = 4，2 ≤ y ≤ 4，因此可以称为（2, 4）树、2-3-4树 比如 m = 5，3 ≤ y ≤ 5，因此可以称为（3, 5）树 比如 m = 6，3 ≤ y ≤ 6，因此可以称为（3, 6）树 比如 m = 7，4 ≤ y ≤ 7，因此可以称为（4, 7）树 B树 VS 二叉搜索树B树和二叉搜索树，在逻辑上是等价的 多代节点合并，可以获得一个超级节点 2代合并的超级节点，最多拥有 4 个子节点（至少是 4阶B树） 3代合并的超级节点，最多拥有 8 个子节点（至少是 8阶B树） n代合并的超级节点，最多拥有 2n个子节点（ 至少是 2n阶B树） m阶B树，最多需要 log2m 代合并 B树的搜索跟二叉搜索树的搜索类似 先在节点内部从小到大开始搜索元素 如果命中，搜索结束 如果未命中，再去对应的子节点中搜索元素，重复步骤 1 B树的添加新添加的元素必定是添加到叶子节点 插入55 插入95 再插入 98 呢？（假设这是一棵 4阶B树） 最右下角的叶子节点的元素个数将超过限制 这种现象可以称之为：上溢（overflow） 添加 – 上溢的解决(假设5阶)上溢节点的元素个数必然等于m 假设上溢节点最中间元素的位置为k 将 k 位置的元素向上与父节点合并 将 [0, k-1] 和 [k + 1, m - 1] 位置的元素分裂成 2 个子节点 这 2 个子节点的元素个数，必然都不会低于最低限制（┌ m/2 ┐ − 1） 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决 最极端的情况，有可能一直分裂到根节点 B树的删除删除 – 叶子节点假如需要删除的元素在叶子节点中，那么直接删除即可 删除 – 非叶子节点假如需要删除的元素在非叶子节点中 先找到前驱或后继元素，覆盖所需删除元素的值 再把前驱或后继元素删除 非叶子节点的前驱或后继元素，必定在叶子节点中 所以这里的删除前驱或后继元素 ，就是最开始提到的情况：删除的元素在叶子节点中 真正的删除元素都是发生在叶子节点中 删除 – 下溢删除 22 ？（假设这是一棵 5阶B树） 叶子节点被删掉一个元素后，元素个数可能会低于最低限制（ ≥ ┌ m/2 ┐ − 1 ） 这种现象称为：下溢（underflow） 删除 – 下溢的解决下溢节点的元素数量必然等于 ┌ m/2 ┐ − 2 如果下溢节点临近的兄弟节点，有至少 ┌ m/2 ┐ 个元素，可以向其借一个元素 将父节点的元素 b 插入到下溢节点的 0 位置（最小位置） 用兄弟节点的元素 a（最大的元素）替代父节点的元素 b 这种操作其实就是：旋转 如果下溢节点临近的兄弟节点，只有 ┌ m/2 ┐ − 1 个元素 将父节点的元素 b 挪下来跟左右子节点进行合并 合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播 总结了解B树的性质后，就可以来学习红黑树了 红黑树的实现]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2020%2F07%2F12%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVL树起源AVL树是最早发明的自平衡二叉搜索树之一 AVL 取名于两位发明者的名字 G. M. Adelson-Velsky 和 E. M. Landis（来自苏联的科学家） AVL树特点平衡因子（Balance Factor）：某结点的左右子树的高度差 每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”） 每个节点的左右子树高度差不超过 1 搜索、添加、删除的时间复杂度是 O(logn) 平衡对比输入数据：35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82 简单的继承结构二叉树的实现 二叉搜索树的实现 平衡修复添加导致的失衡示例：往下面这棵子树中添加 13 最坏情况：可能会导致所有祖先节点都失衡 父节点、非祖先节点，都不可能失衡 LL – 右旋转（R单旋）——- LL（n在g的LL） g.left = p.right p.right = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T2、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateRight(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; RR – 左旋转（L单旋）——- RR（n在g的RR） g.right = p.left p.left = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T1、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateLeft(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR） RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL） 旋转之后的修复12345678910111213141516171819202122232425/** * 公共代码：不管是左旋转、右旋转，都要执行 * @param grand 失衡节点 * @param parent 失衡节点的tallerChild * @param child g和p 需要交换的子树（本来是p的子树，后面会变成g的子树 */protected void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent;&#125; 节点的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 二叉树的节点protected static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; left; Node&lt;E&gt; right; Node&lt;E&gt; parent; public Node(E element, Node&lt;E&gt; parent) &#123; this.element = element; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; // 是否有兄弟节点 public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125;&#125;// AVL树节点private static class AVLNode&lt;E&gt; extends Node&lt;E&gt; &#123; int height = 1; public AVLNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; // 每个节点的平衡因子只可能是 1、0、-1 public int balanceFactor() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; return leftHeight - rightHeight; &#125; // 更新树高 public void updateHeight() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; height = 1 + Math.max(leftHeight, rightHeight); &#125; // 返回树高的子节点 public Node&lt;E&gt; tallerChild() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; if (leftHeight &gt; rightHeight) return left; if (leftHeight &lt; rightHeight) return right; return isLeftChild() ? left : right; &#125;&#125; 添加之后的修复12345678910111213protected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); // 整棵树恢复平衡 break; &#125; &#125;&#125; 判断是否平衡123private boolean isBalanced(Node&lt;E&gt; node) &#123; return Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= 1;&#125; 查看树的高度123private void updateHeight(Node&lt;E&gt; node) &#123; ((AVLNode&lt;E&gt;)node).updateHeight();&#125; 恢复平衡1234567891011121314151617181920// grand 高度最低的不平衡节点private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotateRight(grand); &#125; else &#123; // LR rotateLeft(parent); rotateRight(grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotateRight(parent); rotateLeft(grand); &#125; else &#123; // RR rotateLeft(grand); &#125; &#125;&#125; 示例输入数据：13, 14, 15, 12, 11, 17, 16, 8, 9,1 统一所有旋转操作的实现 123456789101112131415161718192021222324252627282930313233protected void rotate( Node&lt;E&gt; r, // 子树的根节点 Node&lt;E&gt; b, Node&lt;E&gt; c, Node&lt;E&gt; d, Node&lt;E&gt; e, Node&lt;E&gt; f) &#123; // 让d成为这棵子树的根节点 d.parent = r.parent; if (r.isLeftChild()) &#123; r.parent.left = d; &#125; else if (r.isRightChild()) &#123; r.parent.right = d; &#125; else &#123; root = d; &#125; //b-c b.right = c; if (c != null) &#123; c.parent = b; &#125; // e-f f.left = e; if (e != null) &#123; e.parent = f; &#125; // b-d-f d.left = b; d.right = f; b.parent = d; f.parent = d;&#125; 123456789101112131415161718192021/** * 恢复平衡 * @param grand 高度最低的那个不平衡节点 */private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotate(grand, node, node.right, parent, parent.right, grand); &#125; else &#123; // LR rotate(grand, parent, node.left, node, node.right, grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotate(grand, grand, node.left, node, node.right, parent); &#125; else &#123; // RR rotate(grand, grand, parent.left, parent, node.left, node); &#125; &#125;&#125; 删除导致的失衡示例：删除子树中的 16 可能会导致父节点或祖先节点失衡（只有1个节点会失衡），其他节点，都不可能失衡 LL – 右旋转（单旋）如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡… 极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整 RR – 左旋转（单旋） LR – RR左旋转，LL右旋转（双旋） RL – LL右旋转，RR左旋转（双旋） 删除之后的修复1234567891011protected void afterRemove(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); &#125; &#125;&#125; 总结 添加 可能会导致所有祖先节点都失衡 只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需 O(1) 次调整】 删除 可能会导致父节点或祖先节点失衡（只有1个节点会失衡） 恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要 O(logn) 次调整】 平均时间复杂度 搜索：O(logn) 添加：O(logn)，仅需 O(1) 次的旋转操作 删除：O(logn)，最多需要 O(logn) 次的旋转操作]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2020%2F07%2F12%2FAVL%E6%A0%91%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[AVL树起源AVL树是最早发明的自平衡二叉搜索树之一 AVL 取名于两位发明者的名字 G. M. Adelson-Velsky 和 E. M. Landis（来自苏联的科学家） AVL树特点平衡因子（Balance Factor）：某结点的左右子树的高度差 每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”） 每个节点的左右子树高度差不超过 1 搜索、添加、删除的时间复杂度是 O(logn) 平衡对比输入数据：35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82 简单的继承结构二叉树的实现 二叉搜索树的实现 平衡修复添加导致的失衡示例：往下面这棵子树中添加 13 最坏情况：可能会导致所有祖先节点都失衡 父节点、非祖先节点，都不可能失衡 LL – 右旋转（R单旋）——- LL（n在g的LL） g.left = p.right p.right = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T2、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateRight(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; RR – 左旋转（L单旋）——- RR（n在g的RR） g.right = p.left p.left = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T1、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateLeft(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR） RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL） 旋转之后的修复12345678910111213141516171819202122232425/** * 公共代码：不管是左旋转、右旋转，都要执行 * @param grand 失衡节点 * @param parent 失衡节点的tallerChild * @param child g和p 需要交换的子树（本来是p的子树，后面会变成g的子树 */protected void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent;&#125; 节点的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 二叉树的节点protected static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; left; Node&lt;E&gt; right; Node&lt;E&gt; parent; public Node(E element, Node&lt;E&gt; parent) &#123; this.element = element; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; // 是否有兄弟节点 public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125;&#125;// AVL树节点private static class AVLNode&lt;E&gt; extends Node&lt;E&gt; &#123; int height = 1; public AVLNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; // 每个节点的平衡因子只可能是 1、0、-1 public int balanceFactor() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; return leftHeight - rightHeight; &#125; // 更新树高 public void updateHeight() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; height = 1 + Math.max(leftHeight, rightHeight); &#125; // 返回树高的子节点 public Node&lt;E&gt; tallerChild() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; if (leftHeight &gt; rightHeight) return left; if (leftHeight &lt; rightHeight) return right; return isLeftChild() ? left : right; &#125;&#125; 添加之后的修复12345678910111213protected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); // 整棵树恢复平衡 break; &#125; &#125;&#125; 判断是否平衡123private boolean isBalanced(Node&lt;E&gt; node) &#123; return Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= 1;&#125; 查看树的高度123private void updateHeight(Node&lt;E&gt; node) &#123; ((AVLNode&lt;E&gt;)node).updateHeight();&#125; 恢复平衡1234567891011121314151617181920// grand 高度最低的不平衡节点private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotateRight(grand); &#125; else &#123; // LR rotateLeft(parent); rotateRight(grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotateRight(parent); rotateLeft(grand); &#125; else &#123; // RR rotateLeft(grand); &#125; &#125;&#125; 示例输入数据：13, 14, 15, 12, 11, 17, 16, 8, 9,1 统一所有旋转操作的实现 123456789101112131415161718192021222324252627282930313233protected void rotate( Node&lt;E&gt; r, // 子树的根节点 Node&lt;E&gt; b, Node&lt;E&gt; c, Node&lt;E&gt; d, Node&lt;E&gt; e, Node&lt;E&gt; f) &#123; // 让d成为这棵子树的根节点 d.parent = r.parent; if (r.isLeftChild()) &#123; r.parent.left = d; &#125; else if (r.isRightChild()) &#123; r.parent.right = d; &#125; else &#123; root = d; &#125; //b-c b.right = c; if (c != null) &#123; c.parent = b; &#125; // e-f f.left = e; if (e != null) &#123; e.parent = f; &#125; // b-d-f d.left = b; d.right = f; b.parent = d; f.parent = d;&#125; 123456789101112131415161718192021/** * 恢复平衡 * @param grand 高度最低的那个不平衡节点 */private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotate(grand, node, node.right, parent, parent.right, grand); &#125; else &#123; // LR rotate(grand, parent, node.left, node, node.right, grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotate(grand, grand, node.left, node, node.right, parent); &#125; else &#123; // RR rotate(grand, grand, parent.left, parent, node.left, node); &#125; &#125;&#125; 删除导致的失衡示例：删除子树中的 16 可能会导致父节点或祖先节点失衡（只有1个节点会失衡），其他节点，都不可能失衡 LL – 右旋转（单旋）如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡… 极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整 RR – 左旋转（单旋） LR – RR左旋转，LL右旋转（双旋） RL – LL右旋转，RR左旋转（双旋） 删除之后的修复1234567891011protected void afterRemove(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); &#125; &#125;&#125; 总结 添加 可能会导致所有祖先节点都失衡 只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需 O(1) 次调整】 删除 可能会导致父节点或祖先节点失衡（只有1个节点会失衡） 恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要 O(logn) 次调整】 平均时间复杂度 搜索：O(logn) 添加：O(logn)，仅需 O(1) 次的旋转操作 删除：O(logn)，最多需要 O(logn) 次的旋转操作]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2020%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉搜索树思考 在 n 个动态的整数中搜索某个整数？（查看其是否存在） 假设使用动态数组存放元素，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n) 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 如果维护一个有序的动态数组，使用二分搜索，最坏时间复杂度：O(logn) 但是添加、删除的平均时间复杂度是 O(n) 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 针对这个需求，有没有更好的方案？ 使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)​ 什么是二叉搜索树（Binary Search Tree） 二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST，又被称为：二叉查找树、二叉排序树 任意一个节点的值都大于其左子树所有节点的值 任意一个节点的值都小于其右子树所有节点的值 它的左右子树也是一棵二叉搜索树 二叉搜索树可以大大提高搜索数据的效率 二叉搜索树存储的元素必须具备可比较性 比如 int、double 等 如果是自定义类型，需要指定比较方式 不允许为 null 二叉搜索树的接口设计123456int size() // 元素的数量boolean isEmpty() // 是否为空void clear() // 清空所有元素void add(E element) // 添加元素void remove(E element) // 删除元素boolean contains(E element) // 是否包含某元素 需要注意的是 对于我们现在使用的二叉树来说，它的元素没有索引的概念 元素的比较方案设计 允许外界传入一个 Comparator 自定义比较方案 如果没有传入 Comparator，强制认定元素实现了 Comparable 接口 12345678910111213141516private Comparator&lt;E&gt; comparator;public BST() &#123; this(null);&#125;public BST(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator;&#125;private int compare(E e1, E e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;E&gt;)e1).compareTo(e2);&#125; 根据元素内容获取节点12345678910111213private Node&lt;E&gt; node(E element) &#123; Node&lt;E&gt; node = root; while (node != null) &#123; int cmp = compare(element, node.element); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null;&#125; 添加节点12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(E element) &#123; elementNotNullCheck(element); // 添加第一个节点 if (root == null) &#123; root = createNode(element, null); size++; // 新添加节点之后的处理 afterAdd(root); return; &#125; // 添加的不是第一个节点 // 找到父节点 Node&lt;E&gt; parent = root; Node&lt;E&gt; node = root; int cmp = 0; do &#123; cmp = compare(element, node.element); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // 相等 node.element = element; return; &#125; &#125; while (node != null); // 看看插入到父节点的哪个位置 Node&lt;E&gt; newNode = createNode(element, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // 新添加节点之后的处理 afterAdd(newNode);&#125; 删除节点删除节点 – 叶子节点（分析） 123456789// 直接删除1. node == node.parent.left node.parent.left = null2. node == node.parent.right node.parent.right = null3. node.parent == null root = null 删除节点 - 度为1的节点（分析） 123456789101112131415// 用子节点替代原节点的位置child 是 node.left 或 者 child 是 node.right用 child 替代 node 的位置1. 如果 node 是左子节点 child.parent = node.parent node.parent.left = child2. 如果 node 是右子节点 child.parent = node.parent node.parent.right = child3. 如果 node 是根节点 root = child child.parent = null 删除节点 - 度为2的节点（分析） 举例：先删除 5、再删除 4 先用前驱或者后继节点的值覆盖原节点的值 然后删除相应的前驱或者后继节点 如果一个节点的度为 2，那么，它的前驱、后继节点的度只可能是 1 和 0 二叉树的前驱、后继实现 删除节点（代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 判断节点是否有两个叶子节点public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null;&#125;private void remove(Node&lt;E&gt; node) &#123; if (node == null) return; size--; // 找到度为二节点的后继节点覆盖后，将后继节点s作为度为1的节点执行后面的操作 if (node.hasTwoChildren()) &#123; // 度为2的节点 // 找到后继节点 Node&lt;E&gt; s = successor(node); // 用后继节点的值覆盖度为2的节点的值 node.element = s.element; // 删除后继节点,使用后面的代码删除度为1的节点 node = s; &#125; // 删除node节点（node的度必然是1或者0） // 判断node节点有左节点还是右节点，也可能没有节点 Node&lt;E&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // node是度为1的节点 // 更改parent replacement.parent = node.parent; // 更改parent的left、right的指向 if (node.parent == null) &#123; // node是度为1的节点并且是根节点 root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // 删除节点之后的处理 afterRemove(replacement); &#125; else if (node.parent == null) &#123; // node是叶子节点并且是根节点 root = null; // 删除节点之后的处理 afterRemove(node); &#125; else &#123; // node是叶子节点，但不是根节点 if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // 删除节点之后的处理 afterRemove(node); &#125;&#125; 二叉搜索树的复杂度分析当 n 比较大时，两者的性能差异比较大 比如 n = 1000000 时，二叉搜索树的最低高度是 20 退化成链表的另一种情况 有没有办法防止二叉搜索树退化成链表？ 让添加、删除、搜索的复杂度维持在 O(logn) 平衡（Balance）平衡：当节点数量固定时，左右子树的高度越接近，这棵二叉树就越平衡（高度越低） 理想平衡最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的 如何改进二叉搜索树？首先，节点的添加、删除顺序是无法限制的，可以认为是随机的 所以，改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度） 如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大 比如调整的次数会比较多，反而增加了时间复杂度 总结来说，比较合理的改进方案是：用尽量少的调整次数达到适度平衡即可 一棵达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树 平衡二叉搜索树（Balanced Binary Search Tree）英文简称为：BBST 经典常见的平衡二叉搜索树有 AVL树 Windows NT 内核中广泛使用 红黑树 C++ STL（比如 map、set ） Java 的 TreeMap、TreeSet、HashMap、HashSet Linux 的进程调度 Ngix 的 timer 管理 一般也称它们为：自平衡的二叉搜索树（Self-balancing Binary Search Tree） AVL树的实现 红黑树的实现]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2020%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树树（Tree）的基本概念 节点、根节点、父节点、子节点、兄弟节点 一棵树可以没有任何节点，称为空树 一棵树可以只有 1 个节点，也就是只有根节点 子树、左子树、右子树 节点的度（degree）：子树的个数 树的度：所有节点度中的最大值 叶子节点（leaf）：度为 0 的节点 非叶子节点：度不为 0 的节点 层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算） 节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数 节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数 树的深度：所有节点深度中的最大值 树的高度：所有节点高度中的最大值 树的深度 等于 树的高度 有序树、无序树、森林 有序树 树中任意节点的子节点之间有顺序关系 无序树，也称为“自由树” 树中任意节点的子节点之间没有顺序关系 森林 由 m（m ≥ 0）棵互不相交的树组成的集合 二叉树（Binary Tree）二叉树的特点 每个节点的度最大为 2（最多拥有 2 棵子树） 左子树和右子树是有顺序的 即使某节点只有一棵子树，也要区分左右子树 二叉树的性质 非空二叉树的第 $i$ 层，最多有 $2^{i − 1}$个节点 （ $i \geq 1$） 在高度为 h 的二叉树上最多有 $2^h − 1 $个结点（$h \geq 1$ ） 对于任何一棵非空二叉树，如果叶子节点个数为 $n0$，度为 $2$ 的节点个数为 $ n2$，则有: $n0 = n2 + 1$ 假设度为$ 1 $的节点个数为 $n1$，那么二叉树的节点总数 $ n = n0 + n1 + n2$ 二叉树的边数 $ T = n1 + 2 * n2 = n – 1 = n0 + n1 + n2 – 1$ 因此 $ n0 = n2 + 1$ 真二叉树（Proper Binary Tree）真二叉树：所有节点的度都要么为 0，要么为 2 满二叉树（Full Binary Tree）最后一层节点的度都为 $0$，其他节点的度都为 $2$ 在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多 满二叉树一定是真二叉树，真二叉树不一定是满二叉树 假设满二叉树的高度为 $h（ h ≥ 1 ）$，那么 第 i 层的节点数量：$ 2i − 1$ ， 叶子节点数量： $2h − 1$ ， 总节点数量$ n$ $n = 2h − 1 = 20 + 21 + 22 + ⋯ + 2h−1$ $h = log2(n + 1)$ 完全二叉树（Complete Binary Tree）对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应 叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐 完全二叉树从根结点至倒数第 2 层是一棵满二叉树 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树的性质 度为 1 的节点只有左子树 度为 1 的节点要么是 1 个，要么是 0 个 同样节点数量的二叉树，完全二叉树的高度最小 假设完全二叉树的高度为 $h（ h ≥ 1 ）$，那么 ​ 至少有 $2h − 1$ 个节点 $（ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−2} + 1 ）$ ​ 最多有 $2h − 1$ 个节点（$ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−1}$，满二叉树 ） ​ 总节点数量为 $n$ ​ $2^{h − 1} ≤ n &lt; 2^h $ ​ $h − 1 ≤ log_2n &lt; h$ ​ $h = floor( log_2n ) + 1$ ​ $floor $是向下取整，另外，$ceiling $是向上取整 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $ 1$ 开始进行编号，对任意第 $ i $ 个节点 ​ 如果 $i = 1$，它是根节点 ​ 如果 $i &gt; 1$ ，它的父节点编号为 $floor( i / 2 )$ ​ 如果 $2i ≤ n$ ，它的左子节点编号为 $2i$ ​ 如果 $2i &gt; n$ ，它无左子节点 ​ 如果 $2i + 1 ≤ n$ ，它的右子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n$ ，它无右子节点 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $0$ 开始进行编号，对任意第 $i$ 个节点 ​ 如果 $i = 0$ ，它是根节点 ​ 如果 $i &gt; 0$ ，它的父节点编号为 $floor( (i – 1) / 2 )$ ​ 如果 $2i + 1 ≤ n – 1$ ，它的左子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n – 1$ ，它无左子节点 ​ 如果 $2i + 2 ≤ n – 1$ ，它的右子节点编号为 $2i + 2$ ​ 如果 $2i + 2 &gt; n – 1$ ，它无右子节点 面试题如果一棵完全二叉树有 $768$ 个节点，求叶子节点的个数 假设叶子节点个数为 $n0$，度为 $1$ 的节点个数为 $n1$，度为 $2$ 的节点个数为 $n2$ 总结点个数 $n = n0 + n1 + n2$，而且 $n0 = n2 + 1$ $n = 2n0 + n1 – 1$ 完全二叉树的 $n1$ 要么为 $0$，要么为 $1$ $n1$为 $1$ 时，$n = 2n0$，$n$ 必然是偶数 叶子节点个数 $n0 = n / 2$，非叶子节点个数 $n1 + n2 = n / 2$ $n1$为 $0$ 时，$n = 2n0 – 1$，$n$ 必然是奇数 叶子节点个数 $n0 = (n + 1) / 2$，非叶子节点个数 $n1 + n2 = (n – 1) / 2$ 叶子节点个数 $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$ 非叶子节点个数 $n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )$ 因此叶子节点个数为 $384$ 二叉树的遍历二叉树的常见遍历方式有4种 前序遍历（Preorder Traversal） 中序遍历（Inorder Traversal） 后序遍历（Postorder Traversal） 层序遍历（Level Order Traversal） 前序遍历（Preorder Traversal）访问顺序 根节点、前序遍历左子树、前序遍历右子树 7、4、2、1、3、5、9、8、11、10、12 递归实现 123456private void preorder(Node&lt;E&gt; node) &#123; if (node == null) return; System.out.println(node.element); preorder(node.left); preorder(node.right);&#125; 非递归，利用栈实现 123456789101112131415161718192021public void preorder() &#123; if (root == null) return; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 弹出栈顶节点 top，进行访问 Node&lt;E&gt; node = stack.pop(); // 访问node节点 System.out.println(node.element); if (node.right != null) &#123; // 将 top.right 入 栈 stack.push(node.right); &#125; // 将 top.left 入 栈 if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 中序遍历（Inorder Traversal）访问顺序 中序遍历左子树、根节点、中序遍历右子树 1、2、3、4、5、7、8、9、10、11、12 递归实现 123456private void inorder(Node&lt;E&gt; node) &#123; if (node == null) return; inorder(node.left); System.out.println(node.element); inorder(node.right);&#125; 非递归，利用栈实现 12345678910111213141516171819202122public void inorder(Visitor&lt;E&gt; visitor) &#123; if (root == null) return; // 设置 node = root Node&lt;E&gt; node = root; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); while (true) &#123; if (node != null) &#123; stack.push(node); // 向左走 node = node.left; &#125; else if (stack.isEmpty()) &#123; // 如果栈为空，结束遍历 return; &#125; else &#123; // 如果栈不为空，弹出栈顶元素并赋值给 node node = stack.pop(); // 访问node节点 System.out.println(node.element); // 让右节点进行中序遍历 node = node.right; &#125; &#125;&#125; 后序遍历（Postorder Traversal）访问顺序 后序遍历左子树、后序遍历右子树、根节点 1、3、2、5、4、8、10、12、11、9、7 递归实现 123456private void postorder(Node&lt;E&gt; node) &#123; if (node == null) return; postorder(node.left); postorder(node.right); System.out.println(node.element);&#125; 非递归，利用栈实现123456789101112131415161718192021222324252627282930public boolean isLeaf() &#123; return left == null &amp;&amp; right == null;&#125;public void postorder() &#123; if (root == null) return; // 记录上一次弹出访问的节点 Node&lt;E&gt; prev = null; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 查看栈顶元素，不删除 Node&lt;E&gt; top = stack.peek(); // 如果栈顶节点是叶子节点 或者 上一次访问的节点是栈顶节点的子节点 if (top.isLeaf() || (prev != null &amp;&amp; prev.parent == top)) &#123; // 定义prev，下次再遇到，不会再入栈，避免重复访问 prev = stack.pop(); // 访问节点 System.out.println(prev.element); &#125; else &#123; if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125;&#125; 层序遍历（Level Order Traversal）访问顺序 从上到下、从左到右依次访问每一个节点 7、4、9、2、5、8、11、1、3、10、12 非递归，利用队列实现 123456789101112131415161718192021222324public void levelOrder() &#123; if (root == null) return; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.offer(root); // 循环执行以下操作，直到队列为空 while (!queue.isEmpty()) &#123; // 将队头节点 A 出队，进行访问 Node&lt;E&gt; node = queue.poll(); System.out.println(node.element); // 将左子节点入队 if (node.left != null) &#123; queue.offer(node.left); &#125; // 将右子节点入队 if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; 遍历的应用 前序遍历 树状结构展示（注意左右子树的顺序） 中序遍历 二叉搜索树的中序遍历按升序或者降序处理节点 后序遍历 适用于一些先子后父的操作 层序遍历 计算二叉树的高度 判断一棵树是否为完全二叉树 根据遍历结果重构二叉树以下结果可以保证重构出唯一的一棵二叉树 前序遍历 + 中序遍历 后序遍历 + 中序遍历 前序遍历 + 后序遍历 ​ 如果它是一棵真二叉树（Proper Binary Tree），结果是唯一的，不然结果不唯一 前序遍历+中序遍历重构二叉树前序遍历：4 2 1 3 6 5 中序遍历：1 2 3 4 5 6 前驱、后继节点前驱节点（predecessor）前驱节点：中序遍历时的前一个节点 如果是二叉搜索树，前驱节点就是前一个比它小的节点 123456789101112131415161718192021222324252627282930protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） // node.left != null时 // 举例：6-》5、13-》12、8-》7 // predecessor = node.left.right.right.right... Node&lt;E&gt; p = node.left; // 终止条件：right 为 null if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 // node.left == null &amp;&amp; node.parent != null // 举例：7-》6、11-》10、9-》8 // predecessor = node.parent.parent.parent... // 终止条件：node 在 parent 的右子树中 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.left == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有左子树的根节点 1 return node.parent;&#125; 后继节点（successor）后继节点：中序遍历时的后一个节点 如果是二叉搜索树，后继节点就是后一个比它大的节点 1234567891011121314151617181920212223242526272829protected Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） // node.right != null // 举例：1、8、4、10 // successor = node.right.left.left.left... Node&lt;E&gt; p = node.right; if (p != null) &#123; // 终止条件：left 为 null while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // node.right == null &amp;&amp; node.parent != null // 举例：6、3、11 // successor = node.parent.parent.parent... // 终止条件：node 在 parent 的左子树中 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; // node.right == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有右子树的根节点 return node.parent;&#125; 计算二叉树的高度非递归，利用队列实现123456789101112131415161718192021222324252627282930public int height() &#123; if (root == null) return 0; // 树的高度 int height = 0; // 存储着每一层的元素数量 int levelSize = 1; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;E&gt; node = queue.poll(); levelSize--; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; if (levelSize == 0) &#123; // 意味着即将要访问下一层 levelSize = queue.size(); height++; &#125; &#125; return height;&#125; 递归1234567public int height() &#123; return height(root);&#125;private int height(Node&lt;E&gt; node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 练习翻转二叉树leetcode地址 1234567891011121314class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列（Queue）什么是队列队列是一种特殊的线性表，只能在头尾两端进行操作 队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队 队头（front）：只能从队头移除元素，一般叫做 deQueue，出队 先进先出的原则，First In First Out，FIFO 队列的代码实现队列的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Queue&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueue(E element) &#123; //入队 list.add(element); &#125; public E deQueue() &#123; // 出队 return list.remove(0); &#125; public E front() &#123; // 获取队首元素，不删除 return list.get(0); &#125;&#125; 双端队列（Deque）双端队列是能在头尾两端添加、删除的队列，英文 deque 是 double ended queue 的简称 123456789101112131415161718192021222324252627282930313233343536373839public class Deque&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueueRear(E element) &#123; // 从队尾入队 list.add(element); &#125; public E deQueueFront() &#123; // 从队头出队 return list.remove(0); &#125; public void enQueueFront(E element) &#123; // 从队头入队 list.add(0, element); &#125; public E deQueueRear() &#123; // 从队尾出队 return list.remove(list.size() - 1); &#125; public E front() &#123; // 获取队列的头元素 return list.get(0); &#125; public E rear() &#123; // 获取队列的尾元素 return list.get(list.size() - 1); &#125;&#125; 循环队列（Circle Queue）可以进行两端添加、删除操作的循环队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CircleQueue&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleQueue() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; public void enQueue(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; public E deQueue() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; public E front() &#123; return elements[front]; &#125; private int index(int index) &#123; index += front; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125; 循环双端队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class CircleDeque&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleDeque() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; // 从尾部入队 public void enQueueRear(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; // 从头部出队 public E deQueueFront() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; // 从头部入队 public void enQueueFront(E element) &#123; ensureCapacity(size + 1); front = index(-1); elements[front] = element; size++; &#125; // 从尾部出队 public E deQueueRear() &#123; int rearIndex = index(size - 1); E rear = elements[rearIndex]; elements[rearIndex] = null; size--; return rear; &#125; public E front() &#123; return elements[front]; &#125; public E rear() &#123; return elements[index(size - 1)]; &#125; private int index(int index) &#123; index += front; if (index &lt; 0) &#123; return index + elements.length; &#125; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2020%2F07%2F11%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈（stack）什么是栈栈是一种特殊的线性表，只能在一端进行操作 往栈中添加元素的操作，一般叫做 push，入栈 从栈中移除元素的操作，一般叫做 pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素） 后进先出的原则，Last In First Out，LIFO 注意：这里说的“栈”与内存中的“栈空间”是两个不同的概念 栈的代码实现栈的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Stack&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;&gt;(); public void clear() &#123; // 清空 list.clear(); &#125; public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void push(E element) &#123; // 入栈 list.add(element); &#125; public E pop() &#123; // 出栈 return list.remove(list.size() - 1); &#125; public E top() &#123; // 获取栈顶元素，不删除 return list.get(list.size() - 1); &#125;&#125; 练习有效的括号leetcode地址 123456789101112131415161718192021222324class Solution &#123; private static HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); static &#123; map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']'); &#125; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; char c = s.charAt(i); // 判断是否是左边，是就入栈 if (map.containsKey(c))&#123; stack.push(c); &#125;else &#123; // 左边出栈，进行比较 if (stack.isEmpty()) return false; char left = stack.pop(); if (c != map.get(left)) return false; &#125; &#125; return stack.isEmpty(); &#125;&#125; 用栈实现队列leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; /** 入栈 */ public void push(int x) &#123; inStack.push(x); &#125; /** 出栈 */ public int pop() &#123; checkOutStack(); return outStack.pop(); &#125; /** 得到栈顶元素，不删除 */ public int peek() &#123; checkOutStack(); return outStack.peek(); &#125; /** 判断是否为空 */ public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; private void checkOutStack()&#123; if (outStack.isEmpty())&#123; while (!inStack.isEmpty())&#123; outStack.push(inStack.pop()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表（Linked List）为什么有链表动态数组有个明显的缺点，可能会造成内存空间的大量浪费 能否用到多少就申请多少内存？ 链表可以办到这一点 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的 链表的设计 接口设计链表的大部分接口和动态数组是一致的 1234567891011121314151617181920212223242526272829303132333435// 接口定义public interface List&lt;E&gt; &#123; // 元素不存在在返回-1 static final int ELEMENT_NOT_FOUND = -1; // 清除所有元素 void clear(); // 元素的数量 int size(); // 是否为空 boolean isEmpty(); // 是否包含某个元素 boolean contains(E element); // 添加元素到尾部 void add(E element); // 获取index位置的元素 E get(int index); // 设置index位置的元素 E set(int index, E element); // 在index位置插入一个元素 void add(int index, E element); // 删除index位置的元素 E remove(int index); // 查看元素的索引 int indexOf(E element);&#125; 检测传入的下标是否合法123456789101112131415protected void outOfBounds(int index) &#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);&#125;protected void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125;&#125;protected void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125;&#125; node方法用于获取index位置的节点12345678private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node;&#125; 创建节点123456789private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; next; // element新节点的值，next新节点指向的下一个节点 public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 1234567891011121314151617// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; // 在编写链表过程中，要注意边界测试，比如 index 为 0 、size – 0 、size 时 rangeCheckForAdd(index); if (index == 0)&#123; first = new Node&lt;&gt;(element,first); &#125;else&#123; // 找到插入下标的上一个元素 Node&lt;E&gt; prev = node(index - 1); // 新创建的节点指向原先prev.next（如上图：1指向2）,再将prev.next指向新节点（如上图：0指向1） prev.next = new Node&lt;&gt;(element,prev.next); &#125; size++;&#125; 删除元素 12345678910111213141516public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = first; // 注意0位置 if (index == 0)&#123; first = first.next; &#125;else&#123; // 找到待删除元素上一个元素的下标 Node&lt;E&gt; prev = node(index - 1); // node待删除的元素 node = prev.next; prev.next = node.next; &#125; size--; return node.element;&#125; 清空链表12345public void clear() &#123; size = 0; // next不需要设置为null first = null;&#125; 判断链表中某个元素的下标1234567891011121314151617public int indexOf(E element) &#123; // 链表中允许有null值元素 if (element == null)&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) return i; node = node.next; &#125; &#125;else&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) return i; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND;&#125; 判断链表中是否包含某个元素123public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND;&#125; 双向链表使用双向链表可以提升链表的综合性能 node方法用于获取index位置的节点1234567891011121314151617private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); // 分两条路寻找节点 if (index &lt; (size &gt;&gt; 1))&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node; &#125;else &#123; Node&lt;E&gt; node = last; for (int i = size - 1; i &gt; index; i--) &#123; node = node.prev; &#125; return node; &#125;&#125; 创建节点1234567891011private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next) &#123; this.prev = prev; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 12345678910111213141516171819202122// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); if (index == size)&#123; Node&lt;E&gt; oldLast = last; last = new Node&lt;&gt;(oldLast,element,null); oldLast.next = last; &#125;else&#123; Node&lt;E&gt; next = node(index); Node&lt;E&gt; prev = next.prev; Node&lt;E&gt; node = new Node&lt;&gt;(prev,element,next); next.prev = node; if (prev == null)&#123; first = node; &#125;else&#123; prev.next = node; &#125; &#125;&#125; 删除元素 – remove(int index) 1234567891011121314151617181920public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = node(index); Node&lt;E&gt; prev = node.prev; Node&lt;E&gt; next = node.next; if (prev == null)&#123; first = next; &#125;else&#123; prev.next = next; &#125; if (next == null)&#123; last = prev; &#125;else&#123; next.prev = prev; &#125; size--; return node.element;&#125; 双向链表 vs 单向链表粗略对比一下删除的操作数量 单向链表： $1+2+3+…+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$ ${n^2} \over {2}$， 除以$n$ 平均一下是 ${1} \over {2}$ + ${n} \over {2}$ 双向链表：$(1+2+3+…+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ，除以$n$平均一下是 ${1} \over {2}$ + ${n} \over{4}$ 操作数量缩减了近一半 练习删除链表中的节点leetcode地址 123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 反转一个链表leetcode地址 递归实现 12345678910// 递归public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; // 定义新的头节点 ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; 非递归 – 头插法 1234567891011121314// 迭代public ListNode reverseList2(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode newHead = null; while (head != null)&#123; ListNode tmp = head.next; // 每次遍历让head.next成为头节点 head.next = newHead; newHead = head; // head重新指向tmp，使循环按顺序继续遍历 head = tmp; &#125; return newHead;&#125; 判断一个链表是否有环leetcode地址 123456789101112131415// 快慢指针，相遇则有环public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; // 慢指针，每次走一步 ListNode slow = head; // 快指针，每次走两步 ListNode fast = head.next; while (fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数组]]></title>
    <url>%2F2020%2F07%2F09%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组数组是一种顺序存储的线性表，所有元素的内存地址是连续的 1int[] array = new int[]&#123;11,22,33&#125;; 在很多编程语言中，数组都有个致命的缺点，无法动态修改容量 实际开发中，我们更希望数组的容量是可以动态改变的 动态数组（Dynamic Array）接口设计12345678910int size(); // 元素的数量boolean isEmpty(); // 是否为空boolean contains(E element); // 是否包含某个元素void add(E element); // 添加元素到最后E get(int index); // 返回indext位置对应的元素E set(int index,E element); // 设置indext位置对应的元素void add(int index,E element); // 往index位置添加元素E remove(int index); // 删除index位置对应的元素int indexOf(E element); // 查看元素的位置void clear(); //清除所有元素 动态数组的设计 在Java中，成员变量会自动初始化，比如 int 类型自动初始化为 0 对象类型自动初始化为 null 添加元素 - add(E element) 12345678910111213141516171819//没有索引下标，默认放在数组最后public void add(E element)&#123; add(size,element);&#125;// 向数组某个位置插入元素public void add(int index,E element)&#123; // 检测下标是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacity(size + 1); // 从最后一个元素开始，到index下标（逆序），数组元素向后覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++;&#125; 删除元素 - remove(int index) 1234567891011public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; // 从index下标开始，数组元素向前挪动 for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old;&#125; 如何扩容 - ensureCapacity(int capacity) 1234567891011// 数组容量不够时，扩容private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半(再加上原来的容量) E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import org.omg.CORBA.Object;import java.util.Arrays;@SuppressWarnings("unchecked")public class dynamicArray&lt;E&gt;&#123; /** * 元素的数量 */ private int size; /** * 所以的元素 */ private E[] elements; private static final int DEFAULT_CAPATICY = 10; //初始容量 private static final int ELEMENT_NOT_FOUND = -1; //找不到查找的元素 public dynamicArray(int capaticy)&#123; capaticy = Math.max(capaticy, DEFAULT_CAPATICY); elements = (E[]) new Object[capaticy]; //初始化数组容量 &#125; public dynamicArray()&#123; this(DEFAULT_CAPATICY); &#125; /** * 清除所有元素 */ public void clear()&#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; public void add(E element)&#123; add(size,element); &#125; // 向数组某个位置插入元素 public void add(int index,E element)&#123; rangeCheckForAdd(index); ensureCapacity(size + 1); // 数组元素向前覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++; &#125; // 数组容量不够时，扩容 private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半 E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements; &#125; public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old; &#125; public boolean contains(E element)&#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; public E get(int index)&#123; rangeCheck(index); return elements[index]; &#125; public E set(int index,E element)&#123; rangeCheck(index); E old = elements[index]; elements[index] = element; return old; &#125; public int indexOf(E element)&#123; if (element == null)&#123; for (int i = 0; i &lt; size; i++) &#123; if (elements[i] == null) return i; &#125; &#125;else&#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(elements[i])) return i; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private void outOfBounds(int index)&#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size); &#125; // 检测传入的下标是否越界 private void rangeCheck(int index)&#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125; &#125; private void rangeCheckForAdd(int index)&#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125; &#125; @Override public String toString() &#123; return "dynamicArray&#123;" + "size=" + size + ", elements=" + Arrays.toString(elements) + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构什么是数据结构？数据结构是计算机存储、组织数据的方式 线性表 二叉树 邻接矩阵 数组、链表 AVL树、红黑树 邻接表 栈、队列 B树、堆、Trie 哈希表 哈夫曼树、并查集 在实际应用中，根据使用场景来选择最合适的数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2020%2F07%2F09%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[复杂度如何评判一个算法的好坏？一般从以下维度来评估算法的优劣 正确性、可读性、健壮性（对不合理输入的反应能力和处理能力） 时间复杂度（time complexity）：估算程序指令的执行次数（执行时间） 空间复杂度（space complexity）：估算所需占用的存储空间 大O表示法（Big O）一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度，忽略常数、系数、低阶$9 &gt;&gt; O(1)$ $2n + 3 &gt;&gt; O(n)$ $n^2 + 2n + 6 &gt;&gt; O(n^2)$ $4n^3 + 3n^2 + 22n + 100 &gt;&gt; O(n^3)$ 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率 对数阶的细节对数阶一般省略底数 $log_2n = log_29 ∗ log_9n$ 所以 $log_2n$ 、$log_9n$ 统称为$logn$ 常见的复杂度 执行次数 复杂度 非正式术语 $12$ $O(1)$ 常数阶 $2n + 3$ $O(n)$ 线性阶 $4n^2 + 2n + 6$ $O(n^2)$ 平方阶 $4log_2n + 25$ $O(logn)$ 对数阶 $3n + 2nlog_3n + 15$ $O(nlogn)$ $nlogn$阶 $4n^3 + 3n^2 + 22n + 100$ $O(n^3)$ 立方阶 $2^n$ $O(2n)$ 指数阶 $O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n_n)$ 算法的优化方向用尽量少的存储空间 用尽量少的执行步骤（执行时间） 根据情况，可以 空间换时间 时间换空间]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习路线]]></title>
    <url>%2F2019%2F09%2F17%2FJAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JAVA学习路线1. 语言的入门和进阶 Java基础语法,OO编程思想, 集合, IO, 异常, 泛型, 反射, 多线程, 函数式 2. Web基础和工具 前端基础(html/javascript/css) jquery, ajax, jsp , cookie, session http基础 servlet基础 git, svn 代码管理工具 3. 企业级应用框架 maven/gradle项目管理工具 Spring全家桶(Spring, Spring MVC, Spring Boot) 关系型数据库相关(MySQL, jdbc, MyBatis, Hibernate) 非关系型数据库(Redis) 模板引擎(thymeleaf, freemarker) 4. 高级应用框架 搜索引擎(elastic search) RPCk框架(Dubbo, Spring Cloud) 中间件技术(RabbitMQ, RocketMQ, ActiveMQ, Kafka) 虚拟化技术(Docker, Kubernetes) 5. 高级话题 jvm优化和排错, GC分析, 数据库高级优化]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
</search>
