<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2020%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树树（Tree）的基本概念 节点、根节点、父节点、子节点、兄弟节点 一棵树可以没有任何节点，称为空树 一棵树可以只有 1 个节点，也就是只有根节点 子树、左子树、右子树 节点的度（degree）：子树的个数 树的度：所有节点度中的最大值 叶子节点（leaf）：度为 0 的节点 非叶子节点：度不为 0 的节点 层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算） 节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数 节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数 树的深度：所有节点深度中的最大值 树的高度：所有节点高度中的最大值 树的深度 等于 树的高度 有序树、无序树、森林 有序树 树中任意节点的子节点之间有顺序关系 无序树，也称为“自由树” 树中任意节点的子节点之间没有顺序关系 森林 由 m（m ≥ 0）棵互不相交的树组成的集合 二叉树（Binary Tree）二叉树的特点 每个节点的度最大为 2（最多拥有 2 棵子树） 左子树和右子树是有顺序的 即使某节点只有一棵子树，也要区分左右子树 二叉树的性质 非空二叉树的第 $i$ 层，最多有 $2^{i − 1}$个节点 （ $i \geq 1$） 在高度为 h 的二叉树上最多有 $2^h − 1 $个结点（$h \geq 1$ ） 对于任何一棵非空二叉树，如果叶子节点个数为 $n0$，度为 $2$ 的节点个数为 $ n2$，则有: $n0 = n2 + 1$ 假设度为$ 1 $的节点个数为 $n1$，那么二叉树的节点总数 $ n = n0 + n1 + n2$ 二叉树的边数 $ T = n1 + 2 * n2 = n – 1 = n0 + n1 + n2 – 1$ 因此 $ n0 = n2 + 1$ 真二叉树（Proper Binary Tree）真二叉树：所有节点的度都要么为 0，要么为 2 满二叉树（Full Binary Tree）最后一层节点的度都为 $0$，其他节点的度都为 $2$ 在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多 满二叉树一定是真二叉树，真二叉树不一定是满二叉树 假设满二叉树的高度为 $h（ h ≥ 1 ）$，那么 第 i 层的节点数量：$ 2i − 1$ ， 叶子节点数量： $2h − 1$ ， 总节点数量$ n$ $n = 2h − 1 = 20 + 21 + 22 + ⋯ + 2h−1$ $h = log2(n + 1)$ 完全二叉树（Complete Binary Tree）对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应 叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐 完全二叉树从根结点至倒数第 2 层是一棵满二叉树 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树的性质 度为 1 的节点只有左子树 度为 1 的节点要么是 1 个，要么是 0 个 同样节点数量的二叉树，完全二叉树的高度最小 假设完全二叉树的高度为 $h（ h ≥ 1 ）$，那么 ​ 至少有 $2h − 1$ 个节点 $（ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−2} + 1 ）$ ​ 最多有 $2h − 1$ 个节点（$ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−1}$，满二叉树 ） ​ 总节点数量为 $n$ ​ $2^{h − 1} ≤ n &lt; 2^h $ ​ $h − 1 ≤ log_2n &lt; h$ ​ $h = floor( log_2n ) + 1$ ​ $floor $是向下取整，另外，$ceiling $是向上取整 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $ 1$ 开始进行编号，对任意第 $ i $ 个节点 ​ 如果 $i = 1$，它是根节点 ​ 如果 $i &gt; 1$ ，它的父节点编号为 $floor( i / 2 )$ ​ 如果 $2i ≤ n$ ，它的左子节点编号为 $2i$ ​ 如果 $2i &gt; n$ ，它无左子节点 ​ 如果 $2i + 1 ≤ n$ ，它的右子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n$ ，它无右子节点 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $0$ 开始进行编号，对任意第 $i$ 个节点 ​ 如果 $i = 0$ ，它是根节点 ​ 如果 $i &gt; 0$ ，它的父节点编号为 $floor( (i – 1) / 2 )$ ​ 如果 $2i + 1 ≤ n – 1$ ，它的左子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n – 1$ ，它无左子节点 ​ 如果 $2i + 2 ≤ n – 1$ ，它的右子节点编号为 $2i + 2$ ​ 如果 $2i + 2 &gt; n – 1$ ，它无右子节点 面试题如果一棵完全二叉树有 $768$ 个节点，求叶子节点的个数 假设叶子节点个数为 $n0$，度为 $1$ 的节点个数为 $n1$，度为 $2$ 的节点个数为 $n2$ 总结点个数 $n = n0 + n1 + n2$，而且 $n0 = n2 + 1$ $n = 2n0 + n1 – 1$ 完全二叉树的 $n1$ 要么为 $0$，要么为 $1$ $n1$为 $1$ 时，$n = 2n0$，$n$ 必然是偶数 叶子节点个数 $n0 = n / 2$，非叶子节点个数 $n1 + n2 = n / 2$ $n1$为 $0$ 时，$n = 2n0 – 1$，$n$ 必然是奇数 叶子节点个数 $n0 = (n + 1) / 2$，非叶子节点个数 $n1 + n2 = (n – 1) / 2$ 叶子节点个数 $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$ 非叶子节点个数 $n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )$ 因此叶子节点个数为 $384$ 二叉树的遍历二叉树的常见遍历方式有4种 前序遍历（Preorder Traversal） 中序遍历（Inorder Traversal） 后序遍历（Postorder Traversal） 层序遍历（Level Order Traversal） 前序遍历（Preorder Traversal）访问顺序 根节点、前序遍历左子树、前序遍历右子树 7、4、2、1、3、5、9、8、11、10、12 递归实现 123456private void preorder(Node&lt;E&gt; node) &#123; if (node == null) return; System.out.println(node.element); preorder(node.left); preorder(node.right);&#125; 非递归，利用栈实现 123456789101112131415161718192021public void preorder() &#123; if (root == null) return; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 弹出栈顶节点 top，进行访问 Node&lt;E&gt; node = stack.pop(); // 访问node节点 System.out.println(node.element); if (node.right != null) &#123; // 将 top.right 入 栈 stack.push(node.right); &#125; // 将 top.left 入 栈 if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 中序遍历（Inorder Traversal）访问顺序 中序遍历左子树、根节点、中序遍历右子树 1、2、3、4、5、7、8、9、10、11、12 递归实现 123456private void inorder(Node&lt;E&gt; node) &#123; if (node == null) return; inorder(node.left); System.out.println(node.element); inorder(node.right);&#125; 非递归，利用栈实现 12345678910111213141516171819202122public void inorder(Visitor&lt;E&gt; visitor) &#123; if (root == null) return; // 设置 node = root Node&lt;E&gt; node = root; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); while (true) &#123; if (node != null) &#123; stack.push(node); // 向左走 node = node.left; &#125; else if (stack.isEmpty()) &#123; // 如果栈为空，结束遍历 return; &#125; else &#123; // 如果栈不为空，弹出栈顶元素并赋值给 node node = stack.pop(); // 访问node节点 System.out.println(node.element); // 让右节点进行中序遍历 node = node.right; &#125; &#125;&#125; 后序遍历（Postorder Traversal）访问顺序 后序遍历左子树、后序遍历右子树、根节点 1、3、2、5、4、8、10、12、11、9、7 递归实现 123456private void postorder(Node&lt;E&gt; node) &#123; if (node == null) return; postorder(node.left); postorder(node.right); System.out.println(node.element);&#125; 非递归，利用栈实现12345678910111213141516171819202122232425262728public boolean isLeaf() &#123; return left == null &amp;&amp; right == null;&#125;public void postorder() &#123; if (root == null) return; // 记录上一次弹出访问的节点 Node&lt;E&gt; prev = null; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; Node&lt;E&gt; top = stack.peek(); // 如果栈顶节点是叶子节点 或者 上一次访问的节点是栈顶节点的子节点 if (top.isLeaf() || (prev != null &amp;&amp; prev.parent == top)) &#123; prev = stack.pop(); // 访问节点 System.out.println(node.element); &#125; else &#123; if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125;&#125; 层序遍历（Level Order Traversal）访问顺序 从上到下、从左到右依次访问每一个节点 7、4、9、2、5、8、11、1、3、10、12 非递归，利用队列实现 1234567891011121314151617181920212223public void levelOrder() &#123; if (root == null) return; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.offer(root); // 循环执行以下操作，直到队列为空 while (!queue.isEmpty()) &#123; // 将队头节点 A 出队，进行访问 Node&lt;E&gt; node = queue.poll(); System.out.println(node.element); // 将左子节点入队 if (node.left != null) &#123; queue.offer(node.left); &#125; // 将右子节点入队 if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; 遍历的应用 前序遍历 树状结构展示（注意左右子树的顺序） 中序遍历 二叉搜索树的中序遍历按升序或者降序处理节点 后序遍历 适用于一些先子后父的操作 层序遍历 计算二叉树的高度 判断一棵树是否为完全二叉树 根据遍历结果重构二叉树以下结果可以保证重构出唯一的一棵二叉树 前序遍历 + 中序遍历 后序遍历 + 中序遍历 前序遍历 + 后序遍历 ​ 如果它是一棵真二叉树（Proper Binary Tree），结果是唯一的，不然结果不唯一 前序遍历+中序遍历重构二叉树前序遍历：4 2 1 3 6 5 中序遍历：1 2 3 4 5 6 前驱、后继节点前驱节点（predecessor）前驱节点：中序遍历时的前一个节点 如果是二叉搜索树，前驱节点就是前一个比它小的节点 123456789101112131415161718192021222324252627282930protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） // node.left != null时 // 举例：6-》5、13-》12、8-》7 // predecessor = node.left.right.right.right... Node&lt;E&gt; p = node.left; // 终止条件：right 为 null if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 // node.left == null &amp;&amp; node.parent != null // 举例：7-》6、11-》10、9-》8 // predecessor = node.parent.parent.parent... // 终止条件：node 在 parent 的右子树中 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.left == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有左子树的根节点 1 return node.parent;&#125; 后继节点（successor）后继节点：中序遍历时的后一个节点 如果是二叉搜索树，后继节点就是后一个比它大的节点 1234567891011121314151617181920212223242526272829protected Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） // node.right != null // 举例：1、8、4、10 // successor = node.right.left.left.left... Node&lt;E&gt; p = node.right; if (p != null) &#123; // 终止条件：left 为 null while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // node.right == null &amp;&amp; node.parent != null // 举例：6、3、11 // successor = node.parent.parent.parent... // 终止条件：node 在 parent 的左子树中 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; // node.right == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有右子树的根节点 return node.parent;&#125; 计算二叉树的高度非递归，利用队列实现123456789101112131415161718192021222324252627282930public int height() &#123; if (root == null) return 0; // 树的高度 int height = 0; // 存储着每一层的元素数量 int levelSize = 1; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;E&gt; node = queue.poll(); levelSize--; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; if (levelSize == 0) &#123; // 意味着即将要访问下一层 levelSize = queue.size(); height++; &#125; &#125; return height;&#125; 递归1234567public int height() &#123; return height(root);&#125;private int height(Node&lt;E&gt; node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 练习翻转二叉树leetcode地址 1234567891011121314class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列（Queue）什么是队列队列是一种特殊的线性表，只能在头尾两端进行操作 队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队 队头（front）：只能从队头移除元素，一般叫做 deQueue，出队 先进先出的原则，First In First Out，FIFO 队列的代码实现队列的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Queue&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueue(E element) &#123; //入队 list.add(element); &#125; public E deQueue() &#123; // 出队 return list.remove(0); &#125; public E front() &#123; // 获取队首元素，不删除 return list.get(0); &#125;&#125; 双端队列（Deque）双端队列是能在头尾两端添加、删除的队列，英文 deque 是 double ended queue 的简称 123456789101112131415161718192021222324252627282930313233343536373839public class Deque&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueueRear(E element) &#123; // 从队尾入队 list.add(element); &#125; public E deQueueFront() &#123; // 从队头出队 return list.remove(0); &#125; public void enQueueFront(E element) &#123; // 从队头入队 list.add(0, element); &#125; public E deQueueRear() &#123; // 从队尾出队 return list.remove(list.size() - 1); &#125; public E front() &#123; // 获取队列的头元素 return list.get(0); &#125; public E rear() &#123; // 获取队列的尾元素 return list.get(list.size() - 1); &#125;&#125; 循环队列（Circle Queue）可以进行两端添加、删除操作的循环队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CircleQueue&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleQueue() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; public void enQueue(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; public E deQueue() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; public E front() &#123; return elements[front]; &#125; private int index(int index) &#123; index += front; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125; 循环双端队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class CircleDeque&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleDeque() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; // 从尾部入队 public void enQueueRear(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; // 从头部出队 public E deQueueFront() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; // 从头部入队 public void enQueueFront(E element) &#123; ensureCapacity(size + 1); front = index(-1); elements[front] = element; size++; &#125; // 从尾部出队 public E deQueueRear() &#123; int rearIndex = index(size - 1); E rear = elements[rearIndex]; elements[rearIndex] = null; size--; return rear; &#125; public E front() &#123; return elements[front]; &#125; public E rear() &#123; return elements[index(size - 1)]; &#125; private int index(int index) &#123; index += front; if (index &lt; 0) &#123; return index + elements.length; &#125; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2020%2F07%2F11%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈（stack）什么是栈栈是一种特殊的线性表，只能在一端进行操作 往栈中添加元素的操作，一般叫做 push，入栈 从栈中移除元素的操作，一般叫做 pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素） 后进先出的原则，Last In First Out，LIFO 注意：这里说的“栈”与内存中的“栈空间”是两个不同的概念 栈的代码实现栈的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Stack&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;&gt;(); public void clear() &#123; // 清空 list.clear(); &#125; public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void push(E element) &#123; // 入栈 list.add(element); &#125; public E pop() &#123; // 出栈 return list.remove(list.size() - 1); &#125; public E top() &#123; // 获取栈顶元素，不删除 return list.get(list.size() - 1); &#125;&#125; 练习有效的括号leetcode地址 123456789101112131415161718192021222324class Solution &#123; private static HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); static &#123; map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']'); &#125; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; char c = s.charAt(i); // 判断是否是左边，是就入栈 if (map.containsKey(c))&#123; stack.push(c); &#125;else &#123; // 左边出栈，进行比较 if (stack.isEmpty()) return false; char left = stack.pop(); if (c != map.get(left)) return false; &#125; &#125; return stack.isEmpty(); &#125;&#125; 用站实现队列leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; /** 入栈 */ public void push(int x) &#123; inStack.push(x); &#125; /** 出栈 */ public int pop() &#123; checkOutStack(); return outStack.pop(); &#125; /** 得到栈顶元素，不删除 */ public int peek() &#123; checkOutStack(); return outStack.peek(); &#125; /** 判断是否为空 */ public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; private void checkOutStack()&#123; if (outStack.isEmpty())&#123; while (!inStack.isEmpty())&#123; outStack.push(inStack.pop()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表（Linked List）为什么有链表动态数组有个明显的缺点，可能会造成内存空间的大量浪费 能否用到多少就申请多少内存？ 链表可以办到这一点 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的 链表的设计 接口设计链表的大部分接口和动态数组是一致的 1234567891011121314151617181920212223242526272829303132333435// 接口定义public interface List&lt;E&gt; &#123; // 元素不存在在返回-1 static final int ELEMENT_NOT_FOUND = -1; // 清除所有元素 void clear(); // 元素的数量 int size(); // 是否为空 boolean isEmpty(); // 是否包含某个元素 boolean contains(E element); // 添加元素到尾部 void add(E element); // 获取index位置的元素 E get(int index); // 设置index位置的元素 E set(int index, E element); // 在index位置插入一个元素 void add(int index, E element); // 删除index位置的元素 E remove(int index); // 查看元素的索引 int indexOf(E element);&#125; 检测传入的下标是否合法123456789101112131415protected void outOfBounds(int index) &#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);&#125;protected void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125;&#125;protected void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125;&#125; node方法用于获取index位置的节点12345678private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node;&#125; 创建节点123456789private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; next; // element新节点的值，next新节点指向的下一个节点 public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 12345678910111213141516// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; // 在编写链表过程中，要注意边界测试，比如 index 为 0 、size – 0 、size 时 rangeCheckForAdd(index); if (index == 0)&#123; first = new Node&lt;&gt;(element,first); &#125;else&#123; // 找到插入下标的上一个元素 Node&lt;E&gt; prev = node(index - 1); prev.next = new Node&lt;&gt;(element,prev.next); &#125; size++;&#125; 删除元素 12345678910111213141516public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = first; // 注意0位置 if (index == 0)&#123; first = first.next; &#125;else&#123; // 找到删除下标的上一个元素 Node&lt;E&gt; prev = node(index - 1); // node待删除的元素 node = prev.next; prev.next = node.next; &#125; size--; return node.element;&#125; 清空链表12345public void clear() &#123; size = 0; // next不需要设置为null first = null;&#125; 判断链表中某个元素的下标1234567891011121314151617public int indexOf(E element) &#123; // 链表中运行有null值元素 if (element == null)&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) return i; node = node.next; &#125; &#125;else&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) return i; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND;&#125; 判断链表中是否包含某个元素123public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND;&#125; 双向链表使用双向链表可以提升链表的综合性能 node方法用于获取index位置的节点12345678910111213141516private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); if (index &lt; (size &gt;&gt; 1))&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node; &#125;else &#123; Node&lt;E&gt; node = last; for (int i = size - 1; i &gt; index; i--) &#123; node = node.prev; &#125; return node; &#125;&#125; 创建节点1234567891011private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next) &#123; this.prev = prev; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 12345678910111213141516171819202122// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); if (index == size)&#123; Node&lt;E&gt; oldLast = last; last = new Node&lt;&gt;(oldLast,element,null); oldLast.next = last; &#125;else&#123; Node&lt;E&gt; next = node(index); Node&lt;E&gt; prev = next.prev; Node&lt;E&gt; node = new Node&lt;&gt;(prev,element,next); next.prev = node; if (prev == null)&#123; first = node; &#125;else&#123; prev.next = node; &#125; &#125;&#125; 删除元素1234567891011121314151617181920public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = node(index); Node&lt;E&gt; prev = node.prev; Node&lt;E&gt; next = node.next; if (prev == null)&#123; first = next; &#125;else&#123; prev.next = next; &#125; if (next == null)&#123; last = prev; &#125;else&#123; next.prev = prev; &#125; size--; return node.element;&#125; 双向链表 vs 单向链表粗略对比一下删除的操作数量 单向链表： $1+2+3+…+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$ ${n^2} \over {2}$， 除以$n$ 平均一下是 ${1} \over {2}$ + ${n} \over {2}$ 双向链表：$(1+2+3+…+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ，除以$n$平均一下是 ${1} \over {2}$ + ${n} \over{4}$ 操作数量缩减了近一半 练习删除链表中的节点leetcode地址 123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 反转一个链表leetcode地址 递归实现 12345678910// 递归public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; // 定义新的头节点 ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; 非递归 – 头插法 1234567891011121314// 迭代public ListNode reverseList2(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode newHead = null; while (head != null)&#123; ListNode tmp = head.next; // 每次遍历让head.next成为头节点 head.next = newHead; newHead = head; // head重新指向tmp，使循环按顺序继续遍历 head = tmp; &#125; return newHead;&#125; 判断一个链表是否有环leetcode地址 123456789101112131415// 快慢指针，相遇则有环public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; // 慢指针，每次走一步 ListNode slow = head; // 快指针，每次走两步 ListNode fast = head.next; while (fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数组]]></title>
    <url>%2F2020%2F07%2F09%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组数组是一种顺序存储的线性表，所有元素的内存地址是连续的 1int[] array = new int[]&#123;11,22,33&#125;; 在很多编程语言中，数组都有个致命的缺点，无法动态修改容量 实际开发中，我们更希望数组的容量是可以动态改变的 动态数组（Dynamic Array）接口设计12345678910int size(); // 元素的数量boolean isEmpty(); // 是否为空boolean contains(E element); // 是否包含某个元素void add(E element); // 添加元素到最后E get(int index); // 返回indext位置对应的元素E set(int index,E element); // 设置indext位置对应的元素void add(int index,E element); // 往index位置添加元素E remove(int index); // 删除index位置对应的元素int indexOf(E element); // 查看元素的位置void clear(); //清除所有元素 动态数组的设计 在Java中，成员变量会自动初始化，比如 int 类型自动初始化为 0 对象类型自动初始化为 null 添加元素 - add(E element) 12345678910111213141516171819//没有索引下标，默认放在数组最后public void add(E element)&#123; add(size,element);&#125;// 向数组某个位置插入元素public void add(int index,E element)&#123; // 检测下标是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacity(size + 1); // 数组元素向前覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++;&#125; 删除元素 - remove(int index) 如何扩容 - ensureCapacity(int capacity) 1234567891011// 数组容量不够时，扩容private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半 E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import org.omg.CORBA.Object;import java.util.Arrays;@SuppressWarnings("unchecked")public class dynamicArray&lt;E&gt;&#123; /** * 元素的数量 */ private int size; /** * 所以的元素 */ private E[] elements; private static final int DEFAULT_CAPATICY = 10; //初始容量 private static final int ELEMENT_NOT_FOUND = -1; //找不到查找的元素 public dynamicArray(int capaticy)&#123; capaticy = Math.max(capaticy, DEFAULT_CAPATICY); elements = (E[]) new Object[capaticy]; //初始化数组容量 &#125; public dynamicArray()&#123; this(DEFAULT_CAPATICY); &#125; /** * 清除所有元素 */ public void clear()&#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; public void add(E element)&#123; add(size,element); &#125; // 向数组某个位置插入元素 public void add(int index,E element)&#123; rangeCheckForAdd(index); ensureCapacity(size + 1); // 数组元素向前覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++; &#125; // 数组容量不够时，扩容 private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半 E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements; &#125; public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old; &#125; public boolean contains(E element)&#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; public E get(int index)&#123; rangeCheck(index); return elements[index]; &#125; public E set(int index,E element)&#123; rangeCheck(index); E old = elements[index]; elements[index] = element; return old; &#125; public int indexOf(E element)&#123; if (element == null)&#123; for (int i = 0; i &lt; size; i++) &#123; if (elements[i] == null) return i; &#125; &#125;else&#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(elements[i])) return i; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private void outOfBounds(int index)&#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size); &#125; // 检测传入的下标是否越界 private void rangeCheck(int index)&#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125; &#125; private void rangeCheckForAdd(int index)&#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125; &#125; @Override public String toString() &#123; return "dynamicArray&#123;" + "size=" + size + ", elements=" + Arrays.toString(elements) + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构什么是数据结构？数据结构是计算机存储、组织数据的方式 线性表 二叉树 邻接矩阵 数组、链表 AVL树、红黑树 邻接表 栈、队列 B树、堆、Trie 哈希表 哈夫曼树、并查集 在实际应用中，根据使用场景来选择最合适的数据结构]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2020%2F07%2F09%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[复杂度如何评判一个算法的好坏？一般从以下维度来评估算法的优劣 正确性、可读性、健壮性（对不合理输入的反应能力和处理能力） 时间复杂度（time complexity）：估算程序指令的执行次数（执行时间） 空间复杂度（space complexity）：估算所需占用的存储空间 大O表示法（Big O）一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度，忽略常数、系数、低阶$9 &gt;&gt; O(1)$ $2n + 3 &gt;&gt; O(n)$ $n^2 + 2n + 6 &gt;&gt; O(n^2)$ $4n^3 + 3n^2 + 22n + 100 &gt;&gt; O(n^3)$ 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率 对数阶的细节对数阶一般省略底数 $log_2n = log_29 ∗ log_9n$ 所以 $log_2n$ 、$log_9n$ 统称为$logn$ 常见的复杂度 执行次数 复杂度 非正式术语 $12$ $O(1)$ 常数阶 $2n + 3$ $O(n)$ 线性阶 $4n^2 + 2n + 6$ $O(n^2)$ 平方阶 $4log_2n + 25$ $O(logn)$ 对数阶 $3n + 2nlog_3n + 15$ $O(nlogn)$ $nlogn$阶 $4n^3 + 3n^2 + 22n + 100$ $O(n^3)$ 立方阶 $2^n$ $O(2n)$ 指数阶 $O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n_n)$ 算法的优化方向用尽量少的存储空间 用尽量少的执行步骤（执行时间） 根据情况，可以 空间换时间 时间换空间]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习路线]]></title>
    <url>%2F2019%2F09%2F17%2FJAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JAVA学习路线1. 语言的入门和进阶 Java基础语法,OO编程思想, 集合, IO, 异常, 泛型, 反射, 多线程, 函数式 2. Web基础和工具 前端基础(html/javascript/css) jquery, ajax, jsp, cookie, session http基础 servlet基础 git,svn代码管理工具 3. 企业级应用框架 maven/gradle项目管理工具 Spring全家桶(Spring, Spring MVC, Spring Boot) 关系型数据库相关(MySQL, jdbc, MyBatis, Hibernate) 非关系型数据库(Redis) 模板引擎(thymeleaf, freemarker) 4. 高级应用框架 搜索引擎(elastic search) RPCk框架(Dubbo, Spring Cloud) 中间件技术(RabbitMQ, RocketMQ, ActiveMQ, Kafka) 虚拟化技术(Docker, Kubernetes) 5. 高级话题 jvm优化和排错, GC分析, 数据库高级优化]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
</search>
