<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序（Shell Sort）什么是希尔排序 1959年由唐纳德·希尔（Donald Shell）提出 希尔排序把序列看作是一个矩阵，分成 𝑚 列，逐列进行排序 𝑚 从某个整数逐渐减为1 当 𝑚 为1时，整个序列将完全有序 因此，希尔排序也被称为递减增量排序（Diminishing Increment Sort） 矩阵的列数取决于步长序列（step sequence） 比如，如果步长序列为 ${1,5,19,41,109,…}$，就代表依次分成109列、41列、19列、5列、1列进行排序 不同的步长序列，执行效率也不同 希尔排序 – 实例希尔本人给出的步长序列是 $𝑛/2^𝑘$，比如 $𝑛$ 为 $16$ 时，步长序列是 {$1, 2, 4, 8$} 分成8列进行排序 分成4列进行排序 分成2列进行排序 分成1列进行排序 不难看出来，从8列变为1列的过程中，逆序对的数量在逐渐减少 因此希尔排序底层一般使用插入排序对每一列进行排序，很多资料认为希尔排序是插入排序的改进版 假设有11个元素，步长序列是{1, 2, 5} 假设元素在第 $col$ 列、第 $row$ 行，步长（总列数）是 $step$ 那么这个元素在数组中的索引是 $col + row * step$ 比如 $9$ 在排序前是第 $2$ 列、第 $0$ 行，那么它排序前的索引是 $2 + 0 * 5 = 2$ 比如 $4$ 在排序前是第 $2$ 列、第 $1$ 行，那么它排序前的索引是 $2 + 1 * 5 = 7$ 希尔排序 – 实现1234567891011121314151617181920protected void sort() &#123; List&lt;Integer&gt; shellSequence = shellStepSequence(); for (Integer shell : shellSequence) &#123; sort(shell); &#125;&#125;// 分成step列进行排序private void sort(int step) &#123; // col : 第几列，column的简称 for (int col = 0; col &lt; step; col++) &#123; // 对第col列进行排序 // col、col+step、col+2*step、col+3*step for (int begin = col + step; begin &lt; array.length; begin += step) &#123; int cur = begin; while (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; 0) &#123; swap(cur, cur - step); cur -= step; &#125; &#125; &#125;&#125; 最好情况是步长序列只有 $1$，且序列几乎有序，时间复杂度为 $O(n)$ 空间复杂度为 $O(1)$，属于不稳定排序 希尔排序 – 步长序列希尔本人给出的步长序列，最坏情况时间复杂度是 $O(n^2)$ 12345678private List&lt;Integer&gt; shellStepSequence() &#123; List&lt;Integer&gt; stepSequence = new ArrayList&lt;&gt;(); int step = array.length; while ((step &gt;&gt;= 1) &gt; 0) &#123; stepSequence.add(step); &#125; return stepSequence;&#125; 目前已知的最好的步长序列，最坏情况时间复杂度是 $O(n^{4/3})$ ，1986年由Robert Sedgewick提出 \begin{cases} 9 \left(2^k - 2^{\frac{k}{2}}\right) +1, & \text {k even} \\ 8 \cdot 2^k - 6 \cdot 2^{\frac{(k+1)}{2}} + 1, & \text {k odd} \\ \end{cases} \\ 1,5,19,41,109,...123456789101112131415161718private List&lt;Integer&gt; SedgewickStepSequence() &#123; List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;(); int k = 0, step = 0; while (true) &#123; if (k % 2 == 0) &#123; int pow = (int) Math.pow(2, k &gt;&gt; 1); step = 1 + 9 * (pow * pow - pow); &#125; else &#123; int pow1 = (int) Math.pow(2, (k - 1) &gt;&gt; 1); int pow2 = (int) Math.pow(2, (k + 1) &gt;&gt; 1); step = 1 + 8 * pow1 * pow2 - 6 * pow2; &#125; if (step &gt;= array.length) break; stepSequence.add(0, step); k++; &#125; return stepSequence;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序（Quick Sort）什么是快速排序1960年由查尔斯·安东尼·理查德·霍尔（Charles Antony Richard Hoare，缩写为C. A. R. Hoare）提出 昵称为东尼·霍尔（Tony Hoare） 快速排序 – 执行流程① 从序列中选择一个轴点元素（pivot） ​ 假设每次选择 0 位置的元素为轴点元素 ② 利用 pivot 将序列分割成 2 个子序列 ​ 将小于 pivot 的元素放在pivot前面（左侧） ​ 将大于 pivot 的元素放在pivot后面（右侧） ​ 等于pivot的元素放哪边都可以 ③ 对子序列进行 ① ② 操作 ​ 直到不能再分割（子序列中只剩下1个元素） 快速排序的本质 逐渐将每一个元素都转换成轴点元素 快速排序 – 轴点构造 快速排序 – 时间复杂度 在轴点左右元素数量比较均匀的情况下，同时也是最好的情况 $T(n) = 2 ∗ T(n/2) + O(n) = O(nlogn)$ 如果轴点左右元素数量极度不均匀，最坏情况 $T(n) = T(n − 1) + O(n) = O(n^2)$ 为了降低最坏情况的出现概率，一般采取的做法是 随机选择轴点元素 最好、平均时间复杂度：$O(nlogn)$ 最坏时间复杂度：$O(n^2)$ 由于递归调用的缘故，空间复杂度：$O(logn)$ 属于不稳定排序 快速排序 – 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051protected void sort() &#123; sort(0, array.length);&#125;// 对 [begin, end) 范围的元素进行快速排序private void sort(int begin, int end) &#123; if (end - begin &lt; 2) return; // 确定轴点位置 O(n) int mid = pivotIndex(begin, end); // 对子序列进行快速排序 sort(begin, mid); sort(mid + 1, end); &#125; /** * 构造出 [begin, end) 范围的轴点元素 * @return 轴点元素的最终位置 */private int pivotIndex(int begin, int end) &#123; // 随机选择一个元素跟begin位置进行交换 swap(begin, begin + (int)(Math.random() * (end - begin))); // 备份begin位置的元素 T pivot = array[begin]; // end指向最后一个元素 end--; while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt; 0) &#123; // 右边元素 &gt; 轴点元素 end--; &#125; else &#123; // 右边元素 &lt;= 轴点元素 array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt; 0) &#123; // 左边元素 &lt; 轴点元素 begin++; &#125; else &#123; // 左边元素 &gt;= 轴点元素 array[end--] = array[begin]; break; &#125; &#125; &#125; // 将轴点元素放入最终的位置 array[begin] = pivot; // 返回轴点元素的位置 return begin;&#125; 快速排序 – 与轴点相等的元素 如果序列中的所有元素都与轴点元素相等，利用目前的算法实现，轴点元素可以将序列分割成 2 个均匀的子序列 思考：cmp 位置的判断分别改为 ≤、≥ 会起到什么效果？ 123456789101112131415161718while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt;= 0) &#123; // 右边元素 &gt; 轴点元素 end--; &#125; else &#123; // 右边元素 &lt;= 轴点元素 array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt;= 0) &#123; // 左边元素 &lt; 轴点元素 begin++; &#125; else &#123; // 左边元素 &gt;= 轴点元素 array[end--] = array[begin]; break; &#125; &#125;&#125; 轴点元素分割出来的子序列极度不均匀 导致出现最坏时间复杂度 $O(n^2)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序（Merge Sort）什么是归并排序1945年由约翰·冯·诺伊曼（John von Neumann）首次提出 执行流程 ① 不断地将当前序列平均分割成2个子序列 ​ 直到不能再分割（序列中只剩1个元素） ② 不断地将2个子序列合并成一个有序序列 ​ 直到最终只剩下1个有序序列 归并排序 – divide实现12345protected void sort() &#123; // 准备一段临时的数组空间，在merge操作中使用 leftArray = (T[]) new Comparable[array.length &gt;&gt; 1]; sort(0, array.length);&#125; 12345678private void sort(int begin, int end) &#123; if (end - begin &lt; 2) return; int mid = (begin + end) &gt;&gt; 1; sort(begin, mid); sort(mid, end); merge(begin, mid, end);&#125; 归并排序 – merge归并排序 – merge细节 需要 merge 的 2 组序列存在于同一个数组中，并且是挨在一起的 为了更好地完成 merge 操作，最好将其中 1 组序列备份出来，比如 $[begin, mid)$ $li == 0，le == mid – begin$ $ri == mid，re == end$ 归并排序 – merge – 左边先结束 归并排序 – merge – 右边先结束 归并排序 – merge实现1234567891011121314151617181920// 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列private void merge(int begin, int mid, int end) &#123; int li = 0, le = mid - begin; int ri = mid, re = end; int ai = begin; // 备份左边数组 for (int i = li; i &lt; le; i++) &#123; leftArray[i] = array[begin + i]; &#125; // 如果左边还没有结束 while (li &lt; le) &#123; if (ri &lt; re &amp;&amp; cmp(array[ri], leftArray[li]) &lt; 0) &#123; array[ai++] = array[ri++]; &#125; else &#123; array[ai++] = leftArray[li++]; &#125; &#125;&#125; 归并排序 – 复杂度分析归并排序花费的时间 $T(n) = 2 ∗ T (n/2) + O(n)$ $T(1) = O(1)$ $T(n) /n = T(n/2) / (n/2) + O(1)$ 令 $S(n) = T(n) /n$ $S(1) = O(1)$ $S(n) = S(n/2) + O(1) = S(n/4)+ O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)$ $T(n) = n ∗ S(n) = O(nlogn)$ 由于归并排序总是平均分割子序列，所以最好、最坏、平均时间复杂度都是 $O(nlogn)$ ，属于稳定排序 从代码中不难看出：归并排序的空间复杂度是 $O(n/2 + logn) = O(n)$ $n/2$ 用于临时存放左侧数组，$logn$ 是因为递归调用 常见的递推式与复杂度 递推式 复杂度 $T(n) = T(n/2) + O(1)$ $O(logn)$ $T(n) = T(n − 1) + O(1)$ $O(n)$ $T(n) = T(n/2) + O(n)$ $O(n)$ $T(n) = 2 ∗ T(n/2) + O(1) $ $O(n)$ $T(n) = 2 ∗ T(n/2) + O(n)$ $O(nlogn)$ $T(n) = T(n − 1) + O(n)$ $O(n^2)$ $T(n) = 2 ∗ T(n − 1) + O(1)$ $O(2^n)$ $T(n) = 2 ∗ T(n − 1) + O(n)$ $O(2^n)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序（Insertion Sort）什么是插入排序插入排序非常类似于扑克牌的排序 执行流程 ① 在执行过程中，插入排序会将序列分为2部分 ​ 头部是已经排好序的，尾部是待排序的 ② 从头开始扫描每一个元素 ​ 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序 插入排序 - 实现(无优化)1234567for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; while (cur &gt; 0 &amp;&amp; cmp(cur, cur - 1) &lt; 0) &#123; swap(cur, cur - 1); cur--; &#125;&#125; 插入排序 – 逆序对（Inversion） 什么是逆序对？ 数组 的逆序对为： ，共5个逆序对 插入排序的时间复杂度与逆序对的数量成正比关系 逆序对的数量越多，插入排序的时间复杂度越高 最坏、平均时间复杂度：$O(n^2)$ 最好时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 属于稳定排序 当逆序对的数量极少时，插入排序的效率特别高 甚至速度比 $O(nlogn)$级别的快速排序还要快 数据量不是特别大的时候，插入排序的效率也是非常好的 插入排序 – 优化思路是将【交换】转为【挪动】 ① 先将待插入的元素备份 ② 头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置 ③ 将待插入元素放到最终的合适位置 123456789for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; T v = array[cur]; while (cur &gt; 0 &amp;&amp; cmp(v, array[cur - 1]) &lt; 0) &#123; array[cur] = array[cur - 1]; cur--; &#125; array[cur] = v;&#125; 插入排序 – 二分搜索优化二分搜索（Binary Search）如何确定一个元素在数组中的位置？（假设数组里面全都是整数） 如果是无序数组，从第 0 个位置开始遍历搜索，平均时间复杂度：$O(n)$ 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 如果是有序数组，可以使用二分搜索，最坏时间复杂度：$O(logn)$ 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 二分搜索 – 思路假设在 $[begin, end)$ 范围内搜索某个元素 v，$mid == (begin + end) /2$ 如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索 如果 $v &gt; m$，去 $[mid + 1, end)$ 范围内二分搜索 如果 $v == m$，直接返回 mid 二分搜索 – 实例 二分搜索 – 实现1234567891011121314public static int search(int[] array, int v) &#123; if (array == null || array.length == 0) return -1; int begin = 0; int end = array.length; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &lt; array[mid]) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; return begin;&#125; 插入排序 – 二分搜索优化在元素 v 的插入过程中，可以先二分搜索出合适的插入位置，然后再将元素 v 插入 要求二分搜索返回的插入位置：第1个大于 v 的元素位置 如果 v 是 5，返回 2 如果 v 是 1，返回 0 如果 v 是 15，返回 7 如果 v 是 8，返回 5 插入排序 – 二分搜索优化 – 思路假设在 $[begin, end)$ 范围内搜索某个元素 $v$，$mid == (begin + end) /2$ 如果 $v &lt; m$，去 $[begin, mid)$ 范围内二分搜索 如果 $v ≥ m$，去 $[mid + 1, end)$ 范围内二分搜索 插入排序 – 二分搜索优化 – 实例 插入排序 – 二分搜索优化 – 实现12345678910111213141516171819202122232425262728for (int begin = 1; begin &lt; array.length; begin++) &#123; insert(begin, search(begin));&#125;// 将source位置的元素插入到dest位置private void insert(int source, int dest) &#123; T v = array[source]; for (int i = source; i &gt; dest; i--) &#123; array[i] = array[i - 1]; &#125; array[dest] = v;&#125;// 利用二分搜索找到 index 位置元素的待插入位置// 已经排好序数组的区间范围是 [0, index)private int search(int index) &#123; int begin = 0; int end = index; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (cmp(array[index], array[mid]) &lt; 0) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; return begin;&#125; 需要注意的是，使用了二分搜索后，只是减少了比较次数，但插入排序的平均时间复杂度依然是 $O(n^2)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序（Heap Sort）什么是堆排序堆排序可以认为是对选择排序的一种优化 选择排序的实现 / 二叉堆的实现 执行流程 ① 对序列进行原地建堆（heapify） ② 重复执行以下操作，直到堆的元素数量为 1 ​ 交换堆顶元素与尾元素 ​ 堆的元素数量减 1 ​ 对 0 位置进行 1 次 siftDown 操作 堆排序 - 实现12345678910111213// 原地建堆heapSize = array.length;for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i);&#125;while (heapSize &gt; 1) &#123; // 交换堆顶元素和尾部元素 swap(0, --heapSize); // 对0位置进行siftDown（恢复堆的性质） siftDown(0);&#125; 123456789101112131415161718192021222324private void siftDown(int index) &#123; T element = array[index]; int half = heapSize &gt;&gt; 1; while (index &lt; half) &#123; // index必须是非叶子节点 // 默认是左边跟父节点比 int childIndex = (index &lt;&lt; 1) + 1; T child = array[childIndex]; int rightIndex = childIndex + 1; // 右子节点比左子节点大 if (rightIndex &lt; heapSize &amp;&amp; cmp(array[rightIndex], child) &gt; 0) &#123; child = array[childIndex = rightIndex]; &#125; // 大于等于子节点 if (cmp(element, child) &gt;= 0) break; array[index] = child; index = childIndex; &#125; array[index] = element;&#125; 最好、最坏、平均时间复杂度：O(nlogn)，空间复杂度：O(1)，属于不稳定排序]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序（Selection Sort）执行流程 ① 从序列中找出最大的那个元素，然后与最末尾的元素交换位置 ​ 执行完一轮后，最末尾的那个元素就是最大的元素 ② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ① 123456789for (int end = array.length - 1; end &gt; 0; end--) &#123; int max = 0; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(max, begin) &lt; 0) &#123; max = begin; &#125; &#125; swap(max, end);&#125; 选择排序的交换次数要远远少于冒泡排序，平均性能优于冒泡排序 最好、最坏、平均时间复杂度：$O(n^2)$，空间复杂度：$O(1)$，属于不稳定排序]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序（Bubble Sort）冒泡排序（无优化实现）冒泡排序也叫做起泡排序 执行流程（统一以升序为例子） ① 从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置 ​ 执行完一轮后，最末尾那个元素就是最大的元素 ② 忽略 ① 中曾经找到的最大元素，重复执行步骤 ①，直到全部元素有序 123456789for (int end = array.length - 1; end &gt; 0; end--) &#123; for (int begin = 1; begin &lt;= end; begin++) &#123; // 比大小 if (cmp(begin, begin - 1) &lt; 0) &#123; // 交换 swap(begin, begin - 1); &#125; &#125;&#125; 冒泡排序 – 优化①如果序列已经完全有序，可以提前终止冒泡排序 12345678910for (int end = array.length - 1; end &gt; 0; end--) &#123; boolean sorted = true; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sorted = false; &#125; &#125; if (sorted) break;&#125; 冒泡排序 – 优化②如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数 最后1次交换的位置是 6 1234567891011for (int end = array.length - 1; end &gt; 0; end--) &#123; int sortedIndex = 1; for (int begin = 1; begin &lt;= end; begin++) &#123; // if (array[begin] &lt; array[begin - 1]) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sortedIndex = begin; &#125; &#125; end = sortedIndex;&#125; 最坏、平均时间复杂度：$O(n^2)$ 最好时间复杂度：$O(n)$ 空间复杂度：$O(1)$]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大排序算法]]></title>
    <url>%2F2020%2F07%2F14%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[10大排序算法以下表格是基于数组进行排序的一般性结论 冒泡、选择、插入、归并、快速、希尔、堆排序，属于比较排序（Comparison Sorting） 排序算法的稳定性（Stability）如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法 排序前：5, 1, 3𝑎, 4, 7, 3𝑏 稳定的排序： 1, 3𝑎, 3𝑏, 4, 5, 7 不稳定的排序：1, 3𝑏, 3𝑎, 4, 5, 7 原地算法（In-place Algorithm）不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入 空间复杂度为𝑂(1) 的都可以认为是原地算法 非原地算法，称为 Not-in-place 或者 Out-of-place]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2020%2F07%2F14%2FTrie%2F</url>
    <content type="text"><![CDATA[TrieTrie 也叫做字典树、前缀树（Prefix Tree）、单词查找树 Trie 搜索字符串的效率主要跟字符串的长度有关 假设使用 Trie 存储 cat、dog、doggy、does、cast、add 六个单词 Trie代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class Trie&lt;V&gt; &#123; private int size; private Node&lt;V&gt; root; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; size = 0; root = null; &#125; public V get(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.word ? node.value : null; &#125; public boolean contains(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.word; &#125; public V add(String key, V value) &#123; keyCheck(key); // 创建根节点 if (root == null) &#123; root = new Node&lt;&gt;(null); &#125; Node&lt;V&gt; node = root; int len = key.length(); for (int i = 0; i &lt; len; i++) &#123; char c = key.charAt(i); boolean emptyChildren = node.children == null; Node&lt;V&gt; childNode = emptyChildren ? null : node.children.get(c); if (childNode == null) &#123; childNode = new Node&lt;&gt;(node); childNode.character = c; node.children = emptyChildren ? new HashMap&lt;&gt;() : node.children; node.children.put(c, childNode); &#125; node = childNode; &#125; if (node.word) &#123; // 已经存在这个单词 V oldValue = node.value; node.value = value; return oldValue; &#125; // 新增一个单词 node.word = true; node.value = value; size++; return null; &#125; public V remove(String key) &#123; // 找到最后一个节点 Node&lt;V&gt; node = node(key); // 如果不是单词结尾，不用作任何处理 if (node == null || !node.word) return null; size--; V oldValue = node.value; // 如果还有子节点 if (node.children != null &amp;&amp; !node.children.isEmpty()) &#123; node.word = false; node.value = null; return oldValue; &#125; // 如果没有子节点 Node&lt;V&gt; parent = null; while ((parent = node.parent) != null) &#123; parent.children.remove(node.character); if (parent.word || !parent.children.isEmpty()) break; node = parent; &#125; return oldValue; &#125; public boolean startsWith(String prefix) &#123; return node(prefix) != null; &#125; private Node&lt;V&gt; node(String key) &#123; keyCheck(key); Node&lt;V&gt; node = root; int len = key.length(); for (int i = 0; i &lt; len; i++) &#123; if (node == null || node.children == null || node.children.isEmpty()) return null; char c = key.charAt(i); node = node.children.get(c); &#125; return node; &#125; private void keyCheck(String key) &#123; if (key == null || key.length() == 0) &#123; throw new IllegalArgumentException("key must not be empty"); &#125; &#125; private static class Node&lt;V&gt; &#123; Node&lt;V&gt; parent; HashMap&lt;Character, Node&lt;V&gt;&gt; children; Character character; V value; boolean word; // 是否为单词的结尾（是否为一个完整的单词） public Node(Node&lt;V&gt; parent) &#123; this.parent = parent; &#125; &#125;&#125; 总结Trie 的优点：搜索前缀的效率主要跟前缀的长度有关 Trie 的缺点：需要耗费大量的内存，因此还有待改进 更多Trie 相关的数据结构和算法 Double-array Trie、Suffix Tree、Patricia Tree、Crit-bit Tree、AC自动机]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼树]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%2F</url>
    <content type="text"><![CDATA[哈夫曼编码（Huffman Coding）哈夫曼编码，又称为霍夫曼编码，它是现代压缩算法的基础 假设要把字符串【ABBBCCCCCCCCDDDDDDEE】转成二进制编码进行传输 可以转成ASCII编码（65 ~ 69，1000001~1000101），但是有点冗长，如果希望编码更短呢？ 可以先约定5个字母对应的二进制 A B C D E 000 001 010 011 100 对应的二进制编码：000001001001010010010010010010010010011011011011011011100100 一共20个字母，转成了60个二进制位 如果使用哈夫曼编码，可以压缩至41个二进制位，约为原来长度的68.3% 哈夫曼树先计算出每个字母的出现频率（权值，这里直接用出现次数），【ABBBCCCCCCCCDDDDDDEE】 A B C D E 1 3 8 6 2 利用这些权值，构建一棵哈夫曼树（又称为霍夫曼树、最优二叉树） 如何构建一棵哈夫曼树？（假设有 n 个权值） 以权值作为根节点构建 n 棵二叉树，组成森林 在森林中选出 2 个根节点最小的树合并，作为一棵新树的左右子树，且新树的根节点为其左右子树根节点之和 从森林中删除刚才选取的 2 棵树，并将新树加入森林 重复 2、3 步骤，直到森林只剩一棵树为止，该树即为哈夫曼树 构建哈夫曼树 left为0，right为1，可以得出5个字母对应的哈夫曼编码 A B C D E 1110 110 0 10 1111 【ABBBCCCCCCCCDDDDDDEE】的哈夫曼编码是 1110110110110000000001010101010101111 总结n 个权值构建出来的哈夫曼树拥有 n 个叶子节点 每个哈夫曼编码都不是另一个哈夫曼编码的前缀 哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近 带权路径长度：树中所有的叶子节点的权值乘上其到根节点的路径长度。与最终的哈夫曼编码总长度成正比关系。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先级队列]]></title>
    <url>%2F2020%2F07%2F14%2F%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[优先级队列（Priority Queue）队列实现 优先级队列的接口设计普通的队列是 FIFO 原则，也就是先进先出 优先级队列则是按照优先级高低进行出队，比如将优先级最高的元素作为队头优先出队 1234567891011121314151617181920212223242526272829303132333435public class PriorityQueue&lt;E&gt; &#123; private BinaryHeap&lt;E&gt; heap; public PriorityQueue(Comparator&lt;E&gt; comparator) &#123; heap = new BinaryHeap&lt;&gt;(comparator); &#125; public PriorityQueue() &#123; this(null); &#125; public int size() &#123; return heap.size(); &#125; public boolean isEmpty() &#123; return heap.isEmpty(); &#125; public void clear() &#123; heap.clear(); &#125; public void enQueue(E element) &#123; heap.add(element); &#125; public E deQueue() &#123; return heap.remove(); &#125; public E front() &#123; return heap.get(); &#125;&#125; 优先级队列的应用场景举例 医院的夜间门诊 队列元素是病人 优先级是病情的严重情况、挂号时间 操作系统的多任务调度 队列元素是任务 优先级是任务类型 优先队列的底层实现根据优先队列的特点，很容易想到：可以直接利用二叉堆作为优先队列的底层实现 二叉堆实现 可以通过 Comparator 或 Comparable 去自定义优先级高低 123456789101112131415161718public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int boneBreak; public Person(String name, int boneBreak) &#123; this.name = name; this.boneBreak = boneBreak; &#125; @Override public int compareTo(Person person) &#123; return this.boneBreak - person.boneBreak; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", boneBreak=" + boneBreak + "]"; &#125;&#125; 12345678910111213public class Main &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Person&gt; queue = new PriorityQueue&lt;&gt;(); queue.enQueue(new Person("Jack", 2)); queue.enQueue(new Person("Rose", 10)); queue.enQueue(new Person("Jake", 5)); queue.enQueue(new Person("James", 15)); while (!queue.isEmpty()) &#123; System.out.println(queue.deQueue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉堆]]></title>
    <url>%2F2020%2F07%2F14%2F%E4%BA%8C%E5%8F%89%E5%A0%86%2F</url>
    <content type="text"><![CDATA[二叉堆思考设计一种数据结构，用来存放整数，要求提供 3 个接口 添加元素 获取最大值 删除最大值 有没有更优的数据结构？ 堆：获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn) 堆（Heap）堆（Heap）也是一种树状的数据结构（不要跟内存模型中的“堆空间”混淆），常见的堆实现有 二叉堆（Binary Heap，完全二叉堆） 多叉堆（D-heap、D-ary Heap） 索引堆（Index Heap） 二项堆（Binomial Heap） 斐波那契堆（Fibonacci Heap） 左倾堆（Leftist Heap，左式堆） 斜堆（Skew Heap） 堆的一个重要性质：任意节点的值总是 ≥（ ≤ ）子节点的值 如果任意节点的值总是 ≥ 子节点的值，称为：最大堆、大根堆、大顶堆 如果任意节点的值总是 ≤ 子节点的值，称为：最小堆、小根堆、小顶堆 由此可见，堆中的元素必须具备可比较性（跟二叉搜索树一样） 堆的基本接口设计123456789public interface Heap&lt;E&gt; &#123; int size(); // 元素的数量 boolean isEmpty(); // 是否为空 void clear(); // 清空 void add(E element); // 添加元素 E get(); // 获得堆顶元素 E remove(); // 删除堆顶元素 E replace(E element); // 删除堆顶元素的同时插入一个新元素&#125; 12345678910111213141516171819202122232425262728public abstract class AbstractHeap&lt;E&gt; implements Heap&lt;E&gt; &#123; protected int size; protected Comparator&lt;E&gt; comparator; public AbstractHeap(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator; &#125; public AbstractHeap() &#123; this(null); &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; // 比较器 protected int compare(E e1, E e2) &#123; return comparator != null ? comparator.compare(e1, e2) : ((Comparable&lt;E&gt;)e1).compareTo(e2); &#125;&#125; 二叉堆（Binary Heap）二叉堆的逻辑结构就是一棵完全二叉树，所以也叫完全二叉堆 鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）一般用数组实现即可 索引 i 的规律（ n 是元素数量） 如果 i = 0 ，它是根节点 如果 i &gt; 0 ，它的父节点的索引为 floor( (i – 1) / 2 ) 如果 2i + 1 ≤ n – 1，它的左子节点的索引为 2i + 1 如果 2i + 1 &gt; n – 1 ，它无左子节点 如果 2i + 2 ≤ n – 1 ，它的右子节点的索引为 2i + 2 如果 2i + 2 &gt; n – 1 ，它无右子节点 二叉堆获取最大值123456789public E get() &#123; emptyCheck(); return elements[0];&#125;private void emptyCheck() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("Heap is empty"); &#125;&#125; 最大堆 – 添加 循环执行以下操作（图中的 80 简称为 node） 如果 node ＞ 父节点 与父节点交换位置 如果 node ≤ 父节点，或者 node 没有父节点 退出循环 这个过程，叫做上滤（Sift Up） 时间复杂度：O(logn) 1234567891011121314151617181920212223public void add(E element) &#123; elementNotNullCheck(element); ensureCapacity(size + 1); elements[size++] = element; siftUp(size - 1);&#125;private void siftUp(int index) &#123; E e = elements[index]; while (index &gt; 0) &#123; int pindex = (index - 1) &gt;&gt; 1; E p = elements[pindex]; if (compare(e, p) &lt;= 0) return; // 交换index、pindex位置的内容 E tmp = elements[index]; elements[index] = elements[pindex]; elements[pindex] = tmp; // 重新赋值index index = pindex; &#125;&#125; 最大堆 – 添加 – 交换位置的优化一般交换位置需要3行代码，可以进一步优化 将新添加节点备份，确定最终位置才摆放上去 仅从交换位置的代码角度看 可以由大概的 3 O(logn) 优化到 1 O(logn) + 1 1234567891011121314private void siftUp(int index) &#123; E element = elements[index]; while (index &gt; 0) &#123; int parentIndex = (index - 1) &gt;&gt; 1; E parent = elements[parentIndex]; if (compare(element, parent) &lt;= 0) break; // 将父元素存储在index位置 elements[index] = parent; // 重新赋值index index = parentIndex; &#125; elements[index] = element;&#125; 最大堆 – 删除 用最后一个节点覆盖根节点 删除最后一个节点 循环执行以下操作（图中的 43 简称为 node） 如果 node &lt; 最大的子节点，与最大的子节点交换位置 如果 node ≥ 最大的子节点， 或者 node 没有子节点，退出循环 这个过程，叫做下滤（Sift Down），时间复杂度：O(logn) 同样的，交换位置的操作可以像添加那样进行优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344public E remove() &#123; emptyCheck(); int lastIndex = --size; E root = elements[0]; elements[0] = elements[lastIndex]; elements[lastIndex] = null; siftDown(0); return root;&#125;private void siftDown(int index) &#123; E element = elements[index]; int half = size &gt;&gt; 1; // 第一个叶子节点的索引 == 非叶子节点的数量 // index &lt; 第一个叶子节点的索引 // 必须保证index位置是非叶子节点 while (index &lt; half) &#123; // index的节点有2种情况 // 1.只有左子节点 // 2.同时有左右子节点 // 默认为左子节点跟它进行比较 int childIndex = (index &lt;&lt; 1) + 1; E child = elements[childIndex]; // 右子节点 int rightIndex = childIndex + 1; // 选出左右子节点最大的那个 if (rightIndex &lt; size &amp;&amp; compare(elements[rightIndex], child) &gt; 0) &#123; child = elements[childIndex = rightIndex]; &#125; if (compare(element, child) &gt;= 0) break; // 将子节点存放到index位置 elements[index] = child; // 重新设置index index = childIndex; &#125; elements[index] = element;&#125; 最大堆 - 替换堆顶1234567891011121314public E replace(E element) &#123; elementNotNullCheck(element); E root = null; if (size == 0) &#123; elements[0] = element; size++; &#125; else &#123; root = elements[0]; elements[0] = element; siftDown(0); &#125; return root;&#125; 最大堆 – 批量建堆（Heapify）批量建堆，有 2 种做法 自上而下的上滤 自下而上的下滤 最大堆 – 批量建堆 – 自上而下的上滤 123456private void heapify() &#123; // 自上而下的上滤 for (int i = 1; i &lt; size; i++) &#123; siftUp(i); &#125;&#125; 最大堆 – 批量建堆 – 自下而上的下滤 123456private void heapify() &#123; // 自下而上的下滤 for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125;&#125; 最大堆 – 批量建堆 – 效率对比所有节点的深度之和 仅仅是叶子节点，就有近 n/2 个，而且每一个叶子节点的深度都是 O(logn) 级别的 因此，在叶子节点这一块，就达到了 O(nlogn) 级别 O(nlogn) 的时间复杂度足以利用排序算法对所有节点进行全排序 所有节点的高度之和 假设是满树，节点总个数为 $n$，树高为 $h$，那么 $n = 2h − 1$ 所有节点的树高之和 $H(n) = 2^0 ∗ (h − 0) + 2^1 ∗ (h − 1) + 2^2 ∗ (h − 2) + ⋯ + 2^{h −1} ∗ [h − (h − 1)]$ $H(n) = h ∗ (2^0 + 2^1 + 2^2 + ⋯ + 2^{h −1}) − [1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 1)∗ 2^{h−1}]$ $H(n) = h ∗ (2^h − 1) − [(h − 2) ∗ 2^h + 2]$ $H(n) = h ∗ 2^h − h − h ∗ 2^h + 2^{h+1} − 2$ $H(n) = 2^{h+1} − h − 2 = 2 ∗ (2^h − 1) − h = 2n − h = 2n − log_2(n + 1) = O(n)$ 公式推导 $S(h) = 1 ∗ 2^1 + 2 ∗ 2^2 + 3 ∗ 2^3 + ⋯ + (h − 2) ∗ 2^{h−2} + (h − 1) * 2^{h−1}$ $2S(h) = 1 ∗ 2^2 + 2 ∗ 2^3 + 3 ∗ 2^4 + ⋯ + (h − 2) ∗ 2^{h−1} +(h − 1) ∗ 2^h$ $S(h) – 2S(h) = [2^1 + 2^2 + 2^3 + ⋯ + 2^{h−1}] − (h − 1) ∗ 2^h = (2^h − 2) − (h − 1) ∗ 2^h$ $S(h) = (h − 1) ∗ 2^h − (2^h − 2) = (h − 2) ∗ 2^h + 2$ 批量建堆12345678910111213141516171819202122public BinaryHeap(E[] elements, Comparator&lt;E&gt; comparator) &#123; super(comparator); if (elements == null || elements.length == 0) &#123; this.elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; else &#123; size = elements.length; int capacity = Math.max(elements.length, DEFAULT_CAPACITY); this.elements = (E[]) new Object[capacity]; for (int i = 0; i &lt; elements.length; i++) &#123; this.elements[i] = elements[i]; &#125; heapify(); &#125;&#125;private void heapify() &#123; // 自下而上的下滤 for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125;&#125; 如何构建一个小顶堆？1234567Integer[] data = &#123;88, 44, 53, 41, 16, 6, 70, 18, 85, 98, 81, 23, 36, 43, 37&#125;;BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(data, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125;&#125;);BinaryTrees.println(heap); Top K问题从 n 个整数中，找出最大的前 k 个数（ k 远远小于 n ） 如果使用排序算法进行全排序，需要 O(nlogn) 的时间复杂度 如果使用二叉堆来解决，可以使用 O(nlogk) 的时间复杂度来解决 新建一个小顶堆 扫描 n 个整数 先将遍历到的前 k 个数放入堆中 从第 k + 1 个数开始，如果大于堆顶元素，就使用 replace 操作（删除堆顶元素，将第 k + 1 个数添加到堆中） 扫描完毕后，堆中剩下的就是最大的前 k 个数 如果是找出最小的前 k 个数呢？ 用大顶堆 如果小于堆顶元素，就使用 replace 操作 1234567891011121314151617181920212223static void test() &#123; // 新建一个小顶堆 BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); // 找出最大的前k个数 int k = 3; Integer[] data = &#123;51, 30, 39, 92, 74, 25, 16, 93, 91, 19, 54, 47, 73, 62, 76, 63, 35, 18, 90, 6, 65, 49, 3, 26, 61, 21, 48&#125;; for (int i = 0; i &lt; data.length; i++) &#123; if (heap.size() &lt; k) &#123; // 前k个数添加到小顶堆 heap.add(data[i]); // logk &#125; else if (data[i] &gt; heap.get()) &#123; // 如果是第k + 1个数，并且大于堆顶元素 heap.replace(data[i]); // logk &#125; &#125; // O(nlogk) BinaryTrees.println(heap);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表（HashTable）先来分析TreeMap（红黑树映射实现） 时间复杂度（平均） 添加、删除、搜索：O(logn) 特点 Key 必须具备可比较性 元素的分布是有顺序的 在实际应用中，很多时候的需求 Map 中存储的元素不需要讲究顺序 Map 中的 Key 不需要具备可比较性 不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到 O(1)，那就是采取哈希表来实现 Map 什么是哈希表（HashTable）哈希表也叫做散列表（ hash 有“剁碎”的意思） 添加、搜索、删除的流程都是类似的 利用哈希函数生成 key 对应的 index【O(1)】 根据 index 操作定位数组元素【O(1)】 哈希表是【空间换时间】的典型应用 哈希函数，也叫做散列函数 哈希表内部的数组元素，很多地方也叫 Bucket（桶），整个数组叫 Buckets 或者 Bucket Array 哈希冲突（Hash Collision）哈希冲突也叫做哈希碰撞 2 个不同的 key，经过哈希函数计算出相同的结果 key1 ≠ key2 ，hash(key1) = hash(key2) 解决哈希冲突的常见方法 开放定址法（Open Addressing） 按照一定规则向其他地址探测，直到遇到空桶 再哈希法（Re-Hashing） 设计多个哈希函数 链地址法（Separate Chaining） 比如通过链表将同一index的元素串起来 JDK1.8的哈希冲突解决方案JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突 默认使用单向链表将元素串起来 在添加元素时，可能会由单向链表转为红黑树来存储元素 比如当哈希表容量 ≥ 64 且 单向链表的节点数量大于 8 时 当红黑树节点数量少到一定程度时，又会转为单向链表 哈希函数哈希表中哈希函数的实现步骤大概如下 先生成 key 的哈希值（必须是整数） 再让 key 的哈希值跟数组的大小进行相关运算，生成一个索引值 123private int hash(K key) &#123; return hash_code(key) % table.length;&#125; 为了提高效率，可以使用 &amp; 位运算取代 % 运算【前提：将数组的长度设计为 2 的幂（2n）】 1100 1010 1011 1100 &amp; 1111 &amp; 1111 1010 1100 123private int hash(K key) &#123; return hash_code(key) % (table.length - 1);&#125; 良好的哈希函数 让哈希值更加均匀分布 → 减少哈希冲突次数 → 提升哈希表的性能 如何生成key的哈希值key 的常见种类可能有 整数、浮点数、字符串、自定义对象 不同种类的 key，哈希值的生成方式不一样，但目标是一致的 尽量让每个 key 的哈希值是唯一的 尽量让 key 的所有信息参与运算 在Java中，HashMap 的 key 必须实现 hashCode、equals 方法，也允许 key 为 null 整数的哈希值整数值当做哈希值 比如 10 的哈希值就是 10 123public static int hashCode(int value)&#123; return value;&#125; 浮点数的哈希值将存储的二进制格式转为整数值 123public static int hashCode(float value)&#123; return floatToIntBits(value);&#125; Long和Double的哈希值123public static int hashCode(long value)&#123; return (int)(value ^ (value &gt;&gt;&gt; 32));&#125; 1234public static int hashCode(double value)&#123; long bits = doubleToLongBits(value); return (int)(bits ^ (bits &gt;&gt;&gt; 32));&#125; >&gt;&gt; 和 ^ 的作用是？ 高32bit 和 低32bit 混合计算出 32bit 的哈希值 充分利用所有信息计算出哈希值 字符串的哈希值字符串是由若干个字符组成的 比如字符串 jack，由 j、a、c、k 四个字符组成（字符的本质就是一个整数） 因此，jack 的哈希值可以表示为 $ j ∗ n^3 + a ∗ n^2 + c ∗ n^1 + k ∗ n^0$，等价于 $[ ( j ∗ n + a ) ∗ n + c ] ∗ n + k$ 在JDK中，乘数 n 为 31，为什么使用 31？ 31 是一个奇素数，JVM会将 31 * i 优化成 (i &lt;&lt; 5) – i 31 * i = (2^5 - 1) * i = i * 2^5 - i = (i < 5) -i]]></content>
      <categories>
        <category>数据结构</category>
        <category>映射</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>映射</tag>
        <tag>哈希表</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[映射]]></title>
    <url>%2F2020%2F07%2F13%2F%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[映射（Map）Map 在有些编程语言中也叫做字典（dictionary，比如 Python、Objective-C、Swift 等） Map 的每一个 key 是唯一的 Map的接口设计12345678910111213141516public interface Map&lt;K, V&gt; &#123; int size(); boolean isEmpty(); void clear(); V put(K key, V value); V get(K key); V remove(K key); boolean containsKey(K key); boolean containsValue(V value); void traversal(Visitor&lt;K, V&gt; visitor); public static abstract class Visitor&lt;K, V&gt; &#123; boolean stop; public abstract boolean visit(K key, V value); &#125;&#125; 类似 Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现 Map利用红黑树实现红黑树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479public class TreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private static final boolean RED = false; private static final boolean BLACK = true; private int size; private Node&lt;K, V&gt; root; private Comparator&lt;K&gt; comparator; public TreeMap() &#123; this(null); &#125; public TreeMap(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; root = null; size = 0; &#125; @Override public V put(K key, V value) &#123; keyNotNullCheck(key); // 添加第一个节点 if (root == null) &#123; root = new Node&lt;&gt;(key, value, null); size++; // 新添加节点之后的处理 afterPut(root); return null; &#125; // 添加的不是第一个节点 // 找到父节点 Node&lt;K, V&gt; parent = root; Node&lt;K, V&gt; node = root; int cmp = 0; do &#123; cmp = compare(key, node.key); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // 相等 node.key = key; V oldValue = node.value; node.value = value; return oldValue; &#125; &#125; while (node != null); // 看看插入到父节点的哪个位置 Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // 新添加节点之后的处理 afterPut(newNode); return null; &#125; @Override public V get(K key) &#123; Node&lt;K, V&gt; node = node(key); return node != null ? node.value : null; &#125; @Override public V remove(K key) &#123; return remove(node(key)); &#125; @Override public boolean containsKey(K key) &#123; return node(key) != null; &#125; @Override public boolean containsValue(V value) &#123; if (root == null) return false; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;K, V&gt; node = queue.poll(); if (valEquals(value, node.value)) return true; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return false; &#125; @Override public void traversal(Visitor&lt;K, V&gt; visitor) &#123; if (visitor == null) return; traversal(root, visitor); &#125; private void traversal(Node&lt;K, V&gt; node, Visitor&lt;K, V&gt; visitor) &#123; if (node == null || visitor.stop) return; traversal(node.left, visitor); if (visitor.stop) return; visitor.visit(node.key, node.value); traversal(node.right, visitor); &#125; private boolean valEquals(V v1, V v2) &#123; return v1 == null ? v2 == null : v1.equals(v2); &#125; private V remove(Node&lt;K, V&gt; node) &#123; if (node == null) return null; size--; V oldValue = node.value; if (node.hasTwoChildren()) &#123; // 度为2的节点 // 找到后继节点 Node&lt;K, V&gt; s = successor(node); // 用后继节点的值覆盖度为2的节点的值 node.key = s.key; node.value = s.value; // 删除后继节点 node = s; &#125; // 删除node节点（node的度必然是1或者0） Node&lt;K, V&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // node是度为1的节点 // 更改parent replacement.parent = node.parent; // 更改parent的left、right的指向 if (node.parent == null) &#123; // node是度为1的节点并且是根节点 root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // 删除节点之后的处理 afterRemove(replacement); &#125; else if (node.parent == null) &#123; // node是叶子节点并且是根节点 root = null; &#125; else &#123; // node是叶子节点，但不是根节点 if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // 删除节点之后的处理 afterRemove(node); &#125; return oldValue; &#125; private void afterRemove(Node&lt;K, V&gt; node) &#123; // 如果删除的节点是红色 // 或者 用以取代删除节点的子节点是红色 if (isRed(node)) &#123; black(node); return; &#125; Node&lt;K, V&gt; parent = node.parent; if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;K, V&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125; private Node&lt;K, V&gt; predecessor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） Node&lt;K, V&gt; p = node.left; if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.parent == null // node == node.parent.right return node.parent; &#125; private Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） Node&lt;K, V&gt; p = node.right; if (p != null) &#123; while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; private Node&lt;K, V&gt; node(K key) &#123; Node&lt;K, V&gt; node = root; while (node != null) &#123; int cmp = compare(key, node.key); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null; &#125; private void afterPut(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) &#123; black(node); return; &#125; // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node&lt;K, V&gt; uncle = parent.sibling(); // 祖父节点 Node&lt;K, V&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterPut(grand); return; &#125; // 叔父节点不是红色 if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125; &#125; private void rotateLeft(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.right; Node&lt;K, V&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void rotateRight(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.left; Node&lt;K, V&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent; &#125; private Node&lt;K, V&gt; color(Node&lt;K, V&gt; node, boolean color) &#123; if (node == null) return node; node.color = color; return node; &#125; private Node&lt;K, V&gt; red(Node&lt;K, V&gt; node) &#123; return color(node, RED); &#125; private Node&lt;K, V&gt; black(Node&lt;K, V&gt; node) &#123; return color(node, BLACK); &#125; private boolean colorOf(Node&lt;K, V&gt; node) &#123; return node == null ? BLACK : node.color; &#125; private boolean isBlack(Node&lt;K, V&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean isRed(Node&lt;K, V&gt; node) &#123; return colorOf(node) == RED; &#125; private int compare(K e1, K e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;K&gt;)e1).compareTo(e2); &#125; private void keyNotNullCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null"); &#125; &#125; private static class Node&lt;K, V&gt; &#123; K key; V value; boolean color = RED; Node&lt;K, V&gt; left; Node&lt;K, V&gt; right; Node&lt;K, V&gt; parent; public Node(K key, V value, Node&lt;K, V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; public Node&lt;K, V&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>映射</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2020%2F07%2F13%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合（Set）集合的特点不存放重复的元素，常用于去重 存放新增 IP，统计新增 IP 量 存放词汇，统计词汇量 集合接口定义1234567891011121314public interface Set&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(E element); void add(E element); void remove(E element); void traversal(Visitor&lt;E&gt; visitor); public static abstract class Visitor&lt;E&gt; &#123; boolean stop; public abstract boolean visit(E element); &#125;&#125; 集合的内部实现直接利用学过的数据结构实现（链表，动态数组，红黑树、AVL树） 集合利用链表实现链表的实现 1234567891011121314151617181920212223242526272829303132333435363738394041public class ListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); @Override public int size() &#123; return list.size(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public void clear() &#123; list.clear(); &#125; @Override public boolean contains(E element) &#123; return list.contains(element); &#125; @Override public void add(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; // 存在就覆盖 list.set(index, element); &#125; else &#123; // 不存在就添加 list.add(element); &#125; &#125; @Override public void remove(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; list.remove(index); &#125; &#125;&#125; 集合利用红黑树实现红黑树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142public class TreeSet&lt;E&gt; implements Set&lt;E&gt; &#123; private RBTree&lt;E&gt; tree; public TreeSet() &#123; this(null); &#125; public TreeSet(Comparator&lt;E&gt; comparator) &#123; tree = new RBTree&lt;&gt;(comparator); &#125; @Override public int size() &#123; return tree.size(); &#125; @Override public boolean isEmpty() &#123; return tree.isEmpty(); &#125; @Override public void clear() &#123; tree.clear(); &#125; @Override public boolean contains(E element) &#123; return tree.contains(element); &#125; @Override public void add(E element) &#123; tree.add(element); &#125; @Override public void remove(E element) &#123; tree.remove(element); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>集合</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2020%2F07%2F12%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树（Red Black Tree）什么是红黑树红黑树也是一种自平衡的二叉搜索树 以前也叫做平衡二叉B树（Symmetric Binary B-tree） 红黑树必须满足以下 5 条性质 节点是 RED 或者 BLACK 根节点是 BLACK 叶子节点（外部节点，空节点）都是 BLACK RED 节点的子节点都是 BLACK RED 节点的 parent 都是 BLACK 从根节点到叶子节点的所有路径上不能有 2 个连续的 RED 节点 从任一节点到叶子节点的所有路径都包含相同数目的 BLACK 节点 红黑树的等价变换红黑树 和 4阶B树（2-3-4树）具有等价性 BLACK 节点与它的 RED 子节点融合在一起，形成1个B树节点 红黑树的 BLACK 节点个数 与 4阶B树的节点总个数相等 注意：后面展示的红黑树都会省略 NULL 节点 红黑树 vs 2-3-4树 如果上图最底层的 BLACK 节点是不存在的，在B树中是什么样的情形？ 整棵B树只有1个节点，而且是超级节点 一些辅助函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// parent：父节点// sibling：兄弟节点// uncle：叔父节点（parent 的兄弟节点）// grand：祖父节点（parent 的父节点）// 指定颜色private Node&lt;E&gt; color(Node&lt;E&gt; node, boolean color) &#123; if (node == null) return node; ((RBNode&lt;E&gt;)node).color = color; return node;&#125;// 染红private Node&lt;E&gt; red(Node&lt;E&gt; node) &#123; return color(node, RED);&#125;// 染黑private Node&lt;E&gt; black(Node&lt;E&gt; node) &#123; return color(node, BLACK);&#125;// 查看颜色private boolean colorOf(Node&lt;E&gt; node) &#123; return node == null ? BLACK : ((RBNode&lt;E&gt;)node).color;&#125;// 判断是否是黑色private boolean isBlack(Node&lt;E&gt; node) &#123; return colorOf(node) == BLACK;&#125;// 判断是否是红色private boolean isRed(Node&lt;E&gt; node) &#123; return colorOf(node) == RED;&#125;// 查看是否有兄弟节点public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null;&#125; 红黑树的添加已知 B树中，新元素必定是添加到叶子节点中 4阶B树所有节点的元素个数 x 都符合 1 ≤ x ≤ 3 建议新添加的节点默认为 RED，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定） 有 4 种情况满足红黑树的性质 4 ：parent 为BLACK同样也满足4阶B树的性质 因此不用做任何额外处理 12// 如果父节点是黑色，直接返回if (isBlack(parent)) return; 有 8 种情况不满足红黑树的性质 4 ：parent 为 RED（ Double Red ）其中前 4 种属于B树节点上溢的情况 添加 – 修复性质4 – LL\RR判定条件：uncle 不是 RED 1.parent 染成 BLACK，grand 染成 RED 2.grand 进行单旋操作 LL：右旋转 RR：左旋转 123456789101112131415161718192021// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点染成红色Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 return;&#125;// 叔父节点不是红色if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (!node.isLeftChild()) &#123; // RR black(parent); &#125; rotateLeft(grand);&#125; 添加 – 修复性质4 – LR\RL判定条件：uncle 不是 RED 自己染成 BLACK，grand 染成 RED 进行双旋操作 LR：parent 左旋转， grand 右旋转 RL：parent 右旋转， grand 左旋转 1234567891011121314151617181920212223// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点染成红色Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 return;&#125;// 叔父节点不是红色if (parent.isLeftChild()) &#123; // L if (!node.isLeftChild()) &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; rotateLeft(grand);&#125; 添加 – 修复性质4 – 上溢 – LL判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 grand 向上合并时，可能继续发生上溢 若上溢持续到根节点，只需将根节点染成 BLACK 12345678910111213141516// 添加的是根节点 或者 上溢到达了根节点if (parent == null) &#123; black(node); return;&#125;// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return;&#125; 添加 – 修复性质4 – 上溢 – RR判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 123456789101112// 叔父节点Node&lt;E&gt; uncle = parent.sibling();// 祖父节点Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return;&#125; 添加 – 修复性质4 – 上溢 – LR判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 添加 – 修复性质4 – 上溢 – RL判定条件：uncle 是 RED parent、uncle 染成 BLACK grand 向上合并 grand染成 RED，当做是新添加的节点进行处理 红黑树添加后完整修复的代码12345678910111213141516171819202122232425262728293031323334353637383940414243protected void afterAdd(Node&lt;E&gt; node) &#123; Node&lt;E&gt; parent = node.parent; // 添加的是根节点 或者 上溢到达了根节点 if (parent == null) &#123; black(node); return; &#125; // 如果父节点是黑色，直接返回 if (isBlack(parent)) return; // 叔父节点 Node&lt;E&gt; uncle = parent.sibling(); // 祖父节点 Node&lt;E&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // 叔父节点是红色【B树节点上溢】 black(parent); black(uncle); // 把祖父节点当做是新添加的节点 afterAdd(grand); return; &#125; // 叔父节点不是红色 if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125;&#125; 红黑树的删除B树中，最后真正被删除的元素都在叶子节点中 删除 – RED节点直接删除，不用作任何调整 1234protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // 如果删除的节点是红色 if (isRed(node)) return;&#125; 删除 – BLACK节点有 3 种情况 拥有 2 个 RED 子节点的 BLACK 节点 不可能被直接删除，因为会找它的子节点替代删除 因此不用考虑这种情况 拥有 1 个 RED 子节点的 BLACK 节点 BLACK 叶子节点 下文举例采用: 被删除的节点在右边，兄弟节点在左边，（反之交换左右方向即可） 删除 - 拥有 1 个 RED 子节点的 BLACK 节点判定条件：用以替代的子节点是 RED 将替代的子节点染成 BLACK 即可保持红黑树性质 1234567protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // 用以取代node的子节点是红色 if (isRed(replacement)) &#123; black(replacement); return; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为BLACK - sibling 至少有 1 个 RED 子节点BLACK 叶子节点被删除后，会导致B树节点下溢（比如删除88） 如果 sibling 至少有 1 个 RED 子节点（一个或两个RED子节点） 兄弟节点的左边是黑色，(没有子节点也算是黑色) 兄弟节点左旋 改变兄弟节点为parent的左边 后续再按兄弟节点的左边是红色执行即可 兄弟节点的左边是红色 兄弟节点继承 parent 的颜色 兄弟节点的左边变成黑色 parent节点变成黑色 parent右旋 1234567891011121314151617181920212223242526272829303132protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125;else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isBlack(sibling)) &#123; // 兄弟节点是黑色 // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 if (isRed(sibling.left) || isRed(sibling.right)) &#123; // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; // 兄弟节点的左边是红色或兄弟旋转后 color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为BLACK - sibling 没有 1 个 RED 子节点判定条件：sibling 没有 1 个 RED 子节点 将 sibling 染成 RED、parent 染成 BLACK 即可修复红黑树性质 如果 parent 是 BLACK 会导致 parent 也下溢 这时只需要把 parent 当做被删除的节点处理即可 123456789101112131415161718192021222324252627protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 // 兄弟节点是黑色 if(isBlack(sibling))&#123; if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent, null); &#125; &#125; &#125; &#125;&#125; 删除 - BLACK 叶子节点 - sibling为RED如果 sibling 是 RED sibling 染成 BLACK，parent 染成 RED，进行旋转 于是又回到 sibling 是 BLACK 的情况 1234567891011121314151617181920protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 // .... 代码省略，可查看最后完整代码 &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; &#125;&#125; 红黑树删除后完整修复的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void afterRemove(Node&lt;E&gt; node) &#123; // 如果删除的节点是红色 // 或者 用以取代删除节点的子节点是红色 if (isRed(node)) &#123; black(node); return; &#125; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125;&#125; 红黑树的平衡为何那5条性质，就能保证红黑树是平衡的？ 那5条性质，可以保证红黑树等价于4阶B树 相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍 是一种弱平衡、黑高度平衡 红黑树的最大高度是 2 ∗ log2(n + 1) ，依然是 O(logn) 级别 平均时间复杂度搜索：O(logn) 添加：O(logn)，O(1) 次的旋转操作 删除：O(logn)，O(1) 次的旋转操作 AVL树 vs 红黑树AVL树 AVL树的实现 平衡标准比较严格：每个左右子树的高度差不超过1 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W个节点，AVL树最大树高28） 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整 红黑树 平衡标准比较宽松：没有一条路径会大于其他路径的2倍 最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40） 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整 总结 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树 BST vs AVL Tree vs Red Black Tree10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树]]></title>
    <url>%2F2020%2F07%2F12%2FB%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树（B - tree、B - 树）​ B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现 B树特点 1个节点可以存储超过 2 个元素、可以拥有超过 2 个子节点 拥有二叉搜索树的一些性质 平衡，每个节点的所有子树高度一致 比较矮 m阶B树的性质（m≥2）假设一个节点存储的元素个数为 x 根节点：1 ≤ x ≤ m − 1 非根节点：┌ m/2 ┐ − 1 ≤ x ≤ m − 1 如果有子节点，子节点个数 y = x + 1 根节点：2 ≤ y ≤ m 非根节点：┌ m/2 ┐ ≤ y ≤ m 比如 m = 3，2 ≤ y ≤ 3，因此可以称为（2, 3）树、2-3树 比如 m = 4，2 ≤ y ≤ 4，因此可以称为（2, 4）树、2-3-4树 比如 m = 5，3 ≤ y ≤ 5，因此可以称为（3, 5）树 比如 m = 6，3 ≤ y ≤ 6，因此可以称为（3, 6）树 比如 m = 7，4 ≤ y ≤ 7，因此可以称为（4, 7）树 B树 VS 二叉搜索树B树和二叉搜索树，在逻辑上是等价的 多代节点合并，可以获得一个超级节点 2代合并的超级节点，最多拥有 4 个子节点（至少是 4阶B树） 3代合并的超级节点，最多拥有 8 个子节点（至少是 8阶B树） n代合并的超级节点，最多拥有 2n个子节点（ 至少是 2n阶B树） m阶B树，最多需要 log2m 代合并 B树的搜索跟二叉搜索树的搜索类似 先在节点内部从小到大开始搜索元素 如果命中，搜索结束 如果未命中，再去对应的子节点中搜索元素，重复步骤 1 B树的添加新添加的元素必定是添加到叶子节点 插入55 插入95 再插入 98 呢？（假设这是一棵 4阶B树） 最右下角的叶子节点的元素个数将超过限制 这种现象可以称之为：上溢（overflow） 添加 – 上溢的解决(假设5阶)上溢节点的元素个数必然等于m 假设上溢节点最中间元素的位置为k 将 k 位置的元素向上与父节点合并 将 [0, k-1] 和 [k + 1, m - 1] 位置的元素分裂成 2 个子节点 这 2 个子节点的元素个数，必然都不会低于最低限制（┌ m/2 ┐ − 1） 一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决 最极端的情况，有可能一直分裂到根节点 B树的删除删除 – 叶子节点假如需要删除的元素在叶子节点中，那么直接删除即可 删除 – 非叶子节点假如需要删除的元素在非叶子节点中 先找到前驱或后继元素，覆盖所需删除元素的值 再把前驱或后继元素删除 非叶子节点的前驱或后继元素，必定在叶子节点中 所以这里的删除前驱或后继元素 ，就是最开始提到的情况：删除的元素在叶子节点中 真正的删除元素都是发生在叶子节点中 删除 – 下溢删除 22 ？（假设这是一棵 5阶B树） 叶子节点被删掉一个元素后，元素个数可能会低于最低限制（ ≥ ┌ m/2 ┐ − 1 ） 这种现象称为：下溢（underflow） 删除 – 下溢的解决下溢节点的元素数量必然等于 ┌ m/2 ┐ − 2 如果下溢节点临近的兄弟节点，有至少 ┌ m/2 ┐ 个元素，可以向其借一个元素 将父节点的元素 b 插入到下溢节点的 0 位置（最小位置） 用兄弟节点的元素 a（最大的元素）替代父节点的元素 b 这种操作其实就是：旋转 如果下溢节点临近的兄弟节点，只有 ┌ m/2 ┐ − 1 个元素 将父节点的元素 b 挪下来跟左右子节点进行合并 合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播 总结了解B树的性质后，就可以来学习红黑树了 红黑树的实现]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2020%2F07%2F12%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVL树起源AVL树是最早发明的自平衡二叉搜索树之一 AVL 取名于两位发明者的名字 G. M. Adelson-Velsky 和 E. M. Landis（来自苏联的科学家） AVL树特点平衡因子（Balance Factor）：某结点的左右子树的高度差 每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”） 每个节点的左右子树高度差不超过 1 搜索、添加、删除的时间复杂度是 O(logn) 平衡对比输入数据：35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82 简单的继承结构二叉树的实现 二叉搜索树的实现 平衡修复添加导致的失衡示例：往下面这棵子树中添加 13 最坏情况：可能会导致所有祖先节点都失衡 父节点、非祖先节点，都不可能失衡 LL – 右旋转（R单旋）——- LL（n在g的LL） g.left = p.right p.right = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T2、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateRight(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; RR – 左旋转（L单旋）——- RR（n在g的RR） g.right = p.left p.left = g 让p成为这棵子树的根节点 仍然是一棵二叉搜索树：T0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3，整棵树都达到平衡 还需要注意维护的内容，T1、p、g 的 parent 属性，先后更新 g、p 的高度 123456789protected void rotateLeft(Node&lt;E&gt; grand) &#123; // 交换子树 Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; // 维护parent和height afterRotate(grand, parent, child);&#125; LR – RR左旋转，LL右旋转（双旋）——- LR（n在g的LR） RL – LL右旋转，RR左旋转（双旋）——- RL（n在g的RL） 旋转之后的修复12345678910111213141516171819202122232425/** * 公共代码：不管是左旋转、右旋转，都要执行 * @param grand 失衡节点 * @param parent 失衡节点的tallerChild * @param child g和p 需要交换的子树（本来是p的子树，后面会变成g的子树 */protected void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; // 让parent称为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grand是root节点 root = parent; &#125; // 更新child的parent if (child != null) &#123; child.parent = grand; &#125; // 更新grand的parent grand.parent = parent;&#125; 节点的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 二叉树的节点protected static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; left; Node&lt;E&gt; right; Node&lt;E&gt; parent; public Node(E element, Node&lt;E&gt; parent) &#123; this.element = element; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; // 是否有兄弟节点 public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125;&#125;// AVL树节点private static class AVLNode&lt;E&gt; extends Node&lt;E&gt; &#123; int height = 1; public AVLNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; // 每个节点的平衡因子只可能是 1、0、-1 public int balanceFactor() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; return leftHeight - rightHeight; &#125; // 更新树高 public void updateHeight() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; height = 1 + Math.max(leftHeight, rightHeight); &#125; // 返回树高的子节点 public Node&lt;E&gt; tallerChild() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; if (leftHeight &gt; rightHeight) return left; if (leftHeight &lt; rightHeight) return right; return isLeftChild() ? left : right; &#125;&#125; 添加之后的修复12345678910111213protected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); // 整棵树恢复平衡 break; &#125; &#125;&#125; 判断是否平衡123private boolean isBalanced(Node&lt;E&gt; node) &#123; return Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= 1;&#125; 查看树的高度123private void updateHeight(Node&lt;E&gt; node) &#123; ((AVLNode&lt;E&gt;)node).updateHeight();&#125; 恢复平衡1234567891011121314151617181920// grand 高度最低的不平衡节点private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotateRight(grand); &#125; else &#123; // LR rotateLeft(parent); rotateRight(grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotateRight(parent); rotateLeft(grand); &#125; else &#123; // RR rotateLeft(grand); &#125; &#125;&#125; 示例输入数据：13, 14, 15, 12, 11, 17, 16, 8, 9,1 统一所有旋转操作的实现 123456789101112131415161718192021222324252627282930313233protected void rotate( Node&lt;E&gt; r, // 子树的根节点 Node&lt;E&gt; b, Node&lt;E&gt; c, Node&lt;E&gt; d, Node&lt;E&gt; e, Node&lt;E&gt; f) &#123; // 让d成为这棵子树的根节点 d.parent = r.parent; if (r.isLeftChild()) &#123; r.parent.left = d; &#125; else if (r.isRightChild()) &#123; r.parent.right = d; &#125; else &#123; root = d; &#125; //b-c b.right = c; if (c != null) &#123; c.parent = b; &#125; // e-f f.left = e; if (e != null) &#123; e.parent = f; &#125; // b-d-f d.left = b; d.right = f; b.parent = d; f.parent = d;&#125; 123456789101112131415161718192021/** * 恢复平衡 * @param grand 高度最低的那个不平衡节点 */private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotate(grand, node, node.right, parent, parent.right, grand); &#125; else &#123; // LR rotate(grand, parent, node.left, node, node.right, grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotate(grand, grand, node.left, node, node.right, parent); &#125; else &#123; // RR rotate(grand, grand, parent.left, parent, node.left, node); &#125; &#125;&#125; 删除导致的失衡示例：删除子树中的 16 可能会导致父节点或祖先节点失衡（只有1个节点会失衡），其他节点，都不可能失衡 LL – 右旋转（单旋）如果绿色节点不存在，更高层的祖先节点可能也会失衡，需要再次恢复平衡，然后又可能导致更高层的祖先节点失衡… 极端情况下，所有祖先节点都需要进行恢复平衡的操作，共 O(logn) 次调整 RR – 左旋转（单旋） LR – RR左旋转，LL右旋转（双旋） RL – LL右旋转，RR左旋转（双旋） 删除之后的修复1234567891011protected void afterRemove(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // 更新高度 updateHeight(node); &#125; else &#123; // 恢复平衡 rebalance(node); &#125; &#125;&#125; 总结 添加 可能会导致所有祖先节点都失衡 只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需 O(1) 次调整】 删除 可能会导致父节点或祖先节点失衡（只有1个节点会失衡） 恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要 O(logn) 次调整】 平均时间复杂度 搜索：O(logn) 添加：O(logn)，仅需 O(1) 次的旋转操作 删除：O(logn)，最多需要 O(logn) 次的旋转操作]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2020%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉搜索树思考 在 n 个动态的整数中搜索某个整数？（查看其是否存在） 假设使用动态数组存放元素，从第 0 个位置开始遍历搜索，平均时间复杂度：O(n) 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 如果维护一个有序的动态数组，使用二分搜索，最坏时间复杂度：O(logn) 但是添加、删除的平均时间复杂度是 O(n) 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 针对这个需求，有没有更好的方案？ 使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)​ 什么是二叉搜索树（Binary Search Tree） 二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为 BST，又被称为：二叉查找树、二叉排序树 任意一个节点的值都大于其左子树所有节点的值 任意一个节点的值都小于其右子树所有节点的值 它的左右子树也是一棵二叉搜索树 二叉搜索树可以大大提高搜索数据的效率 二叉搜索树存储的元素必须具备可比较性 比如 int、double 等 如果是自定义类型，需要指定比较方式 不允许为 null 二叉搜索树的接口设计123456int size() // 元素的数量boolean isEmpty() // 是否为空void clear() // 清空所有元素void add(E element) // 添加元素void remove(E element) // 删除元素boolean contains(E element) // 是否包含某元素 需要注意的是 对于我们现在使用的二叉树来说，它的元素没有索引的概念 元素的比较方案设计 允许外界传入一个 Comparator 自定义比较方案 如果没有传入 Comparator，强制认定元素实现了 Comparable 接口 12345678910111213141516private Comparator&lt;E&gt; comparator;public BST() &#123; this(null);&#125;public BST(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator;&#125;private int compare(E e1, E e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;E&gt;)e1).compareTo(e2);&#125; 根据元素内容获取节点12345678910111213private Node&lt;E&gt; node(E element) &#123; Node&lt;E&gt; node = root; while (node != null) &#123; int cmp = compare(element, node.element); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null;&#125; 添加节点12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(E element) &#123; elementNotNullCheck(element); // 添加第一个节点 if (root == null) &#123; root = createNode(element, null); size++; // 新添加节点之后的处理 afterAdd(root); return; &#125; // 添加的不是第一个节点 // 找到父节点 Node&lt;E&gt; parent = root; Node&lt;E&gt; node = root; int cmp = 0; do &#123; cmp = compare(element, node.element); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // 相等 node.element = element; return; &#125; &#125; while (node != null); // 看看插入到父节点的哪个位置 Node&lt;E&gt; newNode = createNode(element, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // 新添加节点之后的处理 afterAdd(newNode);&#125; 删除节点删除节点 – 叶子节点（分析） 123456789// 直接删除1. node == node.parent.left node.parent.left = null2. node == node.parent.right node.parent.right = null3. node.parent == null root = null 删除节点 - 度为1的节点（分析） 123456789101112131415// 用子节点替代原节点的位置child 是 node.left 或 者 child 是 node.right用 child 替代 node 的位置1. 如果 node 是左子节点 child.parent = node.parent node.parent.left = child2. 如果 node 是右子节点 child.parent = node.parent node.parent.right = child3. 如果 node 是根节点 root = child child.parent = null 删除节点 - 度为2的节点（分析） 举例：先删除 5、再删除 4 先用前驱或者后继节点的值覆盖原节点的值 然后删除相应的前驱或者后继节点 如果一个节点的度为 2，那么，它的前驱、后继节点的度只可能是 1 和 0 二叉树的前驱、后继实现 删除节点（代码实现）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 判断节点是否有两个叶子节点public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null;&#125;private void remove(Node&lt;E&gt; node) &#123; if (node == null) return; size--; // 找到度为二节点的后继节点覆盖后，将后继节点s作为度为1的节点执行后面的操作 if (node.hasTwoChildren()) &#123; // 度为2的节点 // 找到后继节点 Node&lt;E&gt; s = successor(node); // 用后继节点的值覆盖度为2的节点的值 node.element = s.element; // 删除后继节点,使用后面的代码删除度为1的节点 node = s; &#125; // 删除node节点（node的度必然是1或者0） // 判断node节点有左节点还是右节点，也可能没有节点 Node&lt;E&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // node是度为1的节点 // 更改parent replacement.parent = node.parent; // 更改parent的left、right的指向 if (node.parent == null) &#123; // node是度为1的节点并且是根节点 root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // 删除节点之后的处理 afterRemove(replacement); &#125; else if (node.parent == null) &#123; // node是叶子节点并且是根节点 root = null; // 删除节点之后的处理 afterRemove(node); &#125; else &#123; // node是叶子节点，但不是根节点 if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // 删除节点之后的处理 afterRemove(node); &#125;&#125; 二叉搜索树的复杂度分析当 n 比较大时，两者的性能差异比较大 比如 n = 1000000 时，二叉搜索树的最低高度是 20 退化成链表的另一种情况 有没有办法防止二叉搜索树退化成链表？ 让添加、删除、搜索的复杂度维持在 O(logn) 平衡（Balance）平衡：当节点数量固定时，左右子树的高度越接近，这棵二叉树就越平衡（高度越低） 理想平衡最理想的平衡，就是像完全二叉树、满二叉树那样，高度是最小的 如何改进二叉搜索树？首先，节点的添加、删除顺序是无法限制的，可以认为是随机的 所以，改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度） 如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大 比如调整的次数会比较多，反而增加了时间复杂度 总结来说，比较合理的改进方案是：用尽量少的调整次数达到适度平衡即可 一棵达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树 平衡二叉搜索树（Balanced Binary Search Tree）英文简称为：BBST 经典常见的平衡二叉搜索树有 AVL树 Windows NT 内核中广泛使用 红黑树 C++ STL（比如 map、set ） Java 的 TreeMap、TreeSet、HashMap、HashSet Linux 的进程调度 Ngix 的 timer 管理 一般也称它们为：自平衡的二叉搜索树（Self-balancing Binary Search Tree） AVL树的实现 红黑树的实现]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2020%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树树（Tree）的基本概念 节点、根节点、父节点、子节点、兄弟节点 一棵树可以没有任何节点，称为空树 一棵树可以只有 1 个节点，也就是只有根节点 子树、左子树、右子树 节点的度（degree）：子树的个数 树的度：所有节点度中的最大值 叶子节点（leaf）：度为 0 的节点 非叶子节点：度不为 0 的节点 层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算） 节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数 节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数 树的深度：所有节点深度中的最大值 树的高度：所有节点高度中的最大值 树的深度 等于 树的高度 有序树、无序树、森林 有序树 树中任意节点的子节点之间有顺序关系 无序树，也称为“自由树” 树中任意节点的子节点之间没有顺序关系 森林 由 m（m ≥ 0）棵互不相交的树组成的集合 二叉树（Binary Tree）二叉树的特点 每个节点的度最大为 2（最多拥有 2 棵子树） 左子树和右子树是有顺序的 即使某节点只有一棵子树，也要区分左右子树 二叉树的性质 非空二叉树的第 $i$ 层，最多有 $2^{i − 1}$个节点 （ $i \geq 1$） 在高度为 h 的二叉树上最多有 $2^h − 1 $个结点（$h \geq 1$ ） 对于任何一棵非空二叉树，如果叶子节点个数为 $n0$，度为 $2$ 的节点个数为 $ n2$，则有: $n0 = n2 + 1$ 假设度为$ 1 $的节点个数为 $n1$，那么二叉树的节点总数 $ n = n0 + n1 + n2$ 二叉树的边数 $ T = n1 + 2 * n2 = n – 1 = n0 + n1 + n2 – 1$ 因此 $ n0 = n2 + 1$ 真二叉树（Proper Binary Tree）真二叉树：所有节点的度都要么为 0，要么为 2 满二叉树（Full Binary Tree）最后一层节点的度都为 $0$，其他节点的度都为 $2$ 在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多 满二叉树一定是真二叉树，真二叉树不一定是满二叉树 假设满二叉树的高度为 $h（ h ≥ 1 ）$，那么 第 i 层的节点数量：$ 2i − 1$ ， 叶子节点数量： $2h − 1$ ， 总节点数量$ n$ $n = 2h − 1 = 20 + 21 + 22 + ⋯ + 2h−1$ $h = log2(n + 1)$ 完全二叉树（Complete Binary Tree）对节点从上至下、左至右开始编号，其所有编号都能与相同高度的满二叉树中的编号对应 叶子节点只会出现最后 2 层，最后 1 层的叶子结点都靠左对齐 完全二叉树从根结点至倒数第 2 层是一棵满二叉树 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树 完全二叉树的性质 度为 1 的节点只有左子树 度为 1 的节点要么是 1 个，要么是 0 个 同样节点数量的二叉树，完全二叉树的高度最小 假设完全二叉树的高度为 $h（ h ≥ 1 ）$，那么 ​ 至少有 $2h − 1$ 个节点 $（ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−2} + 1 ）$ ​ 最多有 $2h − 1$ 个节点（$ 2^0 + 2^1 + 2^2 + ⋯ + 2^{h−1}$，满二叉树 ） ​ 总节点数量为 $n$ ​ $2^{h − 1} ≤ n &lt; 2^h $ ​ $h − 1 ≤ log_2n &lt; h$ ​ $h = floor( log_2n ) + 1$ ​ $floor $是向下取整，另外，$ceiling $是向上取整 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $ 1$ 开始进行编号，对任意第 $ i $ 个节点 ​ 如果 $i = 1$，它是根节点 ​ 如果 $i &gt; 1$ ，它的父节点编号为 $floor( i / 2 )$ ​ 如果 $2i ≤ n$ ，它的左子节点编号为 $2i$ ​ 如果 $2i &gt; n$ ，它无左子节点 ​ 如果 $2i + 1 ≤ n$ ，它的右子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n$ ，它无右子节点 一棵有 $n$ 个节点的完全二叉树$（n &gt; 0）$，从上到下、从左到右对节点从 $0$ 开始进行编号，对任意第 $i$ 个节点 ​ 如果 $i = 0$ ，它是根节点 ​ 如果 $i &gt; 0$ ，它的父节点编号为 $floor( (i – 1) / 2 )$ ​ 如果 $2i + 1 ≤ n – 1$ ，它的左子节点编号为 $2i + 1$ ​ 如果 $2i + 1 &gt; n – 1$ ，它无左子节点 ​ 如果 $2i + 2 ≤ n – 1$ ，它的右子节点编号为 $2i + 2$ ​ 如果 $2i + 2 &gt; n – 1$ ，它无右子节点 面试题如果一棵完全二叉树有 $768$ 个节点，求叶子节点的个数 假设叶子节点个数为 $n0$，度为 $1$ 的节点个数为 $n1$，度为 $2$ 的节点个数为 $n2$ 总结点个数 $n = n0 + n1 + n2$，而且 $n0 = n2 + 1$ $n = 2n0 + n1 – 1$ 完全二叉树的 $n1$ 要么为 $0$，要么为 $1$ $n1$为 $1$ 时，$n = 2n0$，$n$ 必然是偶数 叶子节点个数 $n0 = n / 2$，非叶子节点个数 $n1 + n2 = n / 2$ $n1$为 $0$ 时，$n = 2n0 – 1$，$n$ 必然是奇数 叶子节点个数 $n0 = (n + 1) / 2$，非叶子节点个数 $n1 + n2 = (n – 1) / 2$ 叶子节点个数 $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$ 非叶子节点个数 $n1 + n2 = floor( n / 2 ) = ceiling( (n – 1) / 2 )$ 因此叶子节点个数为 $384$ 二叉树的遍历二叉树的常见遍历方式有4种 前序遍历（Preorder Traversal） 中序遍历（Inorder Traversal） 后序遍历（Postorder Traversal） 层序遍历（Level Order Traversal） 前序遍历（Preorder Traversal）访问顺序 根节点、前序遍历左子树、前序遍历右子树 7、4、2、1、3、5、9、8、11、10、12 递归实现 123456private void preorder(Node&lt;E&gt; node) &#123; if (node == null) return; System.out.println(node.element); preorder(node.left); preorder(node.right);&#125; 非递归，利用栈实现 123456789101112131415161718192021public void preorder() &#123; if (root == null) return; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 弹出栈顶节点 top，进行访问 Node&lt;E&gt; node = stack.pop(); // 访问node节点 System.out.println(node.element); if (node.right != null) &#123; // 将 top.right 入 栈 stack.push(node.right); &#125; // 将 top.left 入 栈 if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; 中序遍历（Inorder Traversal）访问顺序 中序遍历左子树、根节点、中序遍历右子树 1、2、3、4、5、7、8、9、10、11、12 递归实现 123456private void inorder(Node&lt;E&gt; node) &#123; if (node == null) return; inorder(node.left); System.out.println(node.element); inorder(node.right);&#125; 非递归，利用栈实现 12345678910111213141516171819202122public void inorder(Visitor&lt;E&gt; visitor) &#123; if (root == null) return; // 设置 node = root Node&lt;E&gt; node = root; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); while (true) &#123; if (node != null) &#123; stack.push(node); // 向左走 node = node.left; &#125; else if (stack.isEmpty()) &#123; // 如果栈为空，结束遍历 return; &#125; else &#123; // 如果栈不为空，弹出栈顶元素并赋值给 node node = stack.pop(); // 访问node节点 System.out.println(node.element); // 让右节点进行中序遍历 node = node.right; &#125; &#125;&#125; 后序遍历（Postorder Traversal）访问顺序 后序遍历左子树、后序遍历右子树、根节点 1、3、2、5、4、8、10、12、11、9、7 递归实现 123456private void postorder(Node&lt;E&gt; node) &#123; if (node == null) return; postorder(node.left); postorder(node.right); System.out.println(node.element);&#125; 非递归，利用栈实现123456789101112131415161718192021222324252627282930public boolean isLeaf() &#123; return left == null &amp;&amp; right == null;&#125;public void postorder() &#123; if (root == null) return; // 记录上一次弹出访问的节点 Node&lt;E&gt; prev = null; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // 将 root 入 栈 stack.push(root); // 循环执行以下操作，直到栈为空 while (!stack.isEmpty()) &#123; // 查看栈顶元素，不删除 Node&lt;E&gt; top = stack.peek(); // 如果栈顶节点是叶子节点 或者 上一次访问的节点是栈顶节点的子节点 if (top.isLeaf() || (prev != null &amp;&amp; prev.parent == top)) &#123; // 定义prev，下次再遇到，不会再入栈，避免重复访问 prev = stack.pop(); // 访问节点 System.out.println(prev.element); &#125; else &#123; if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125;&#125; 层序遍历（Level Order Traversal）访问顺序 从上到下、从左到右依次访问每一个节点 7、4、9、2、5、8、11、1、3、10、12 非递归，利用队列实现 123456789101112131415161718192021222324public void levelOrder() &#123; if (root == null) return; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // 将根节点入队 queue.offer(root); // 循环执行以下操作，直到队列为空 while (!queue.isEmpty()) &#123; // 将队头节点 A 出队，进行访问 Node&lt;E&gt; node = queue.poll(); System.out.println(node.element); // 将左子节点入队 if (node.left != null) &#123; queue.offer(node.left); &#125; // 将右子节点入队 if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; 遍历的应用 前序遍历 树状结构展示（注意左右子树的顺序） 中序遍历 二叉搜索树的中序遍历按升序或者降序处理节点 后序遍历 适用于一些先子后父的操作 层序遍历 计算二叉树的高度 判断一棵树是否为完全二叉树 根据遍历结果重构二叉树以下结果可以保证重构出唯一的一棵二叉树 前序遍历 + 中序遍历 后序遍历 + 中序遍历 前序遍历 + 后序遍历 ​ 如果它是一棵真二叉树（Proper Binary Tree），结果是唯一的，不然结果不唯一 前序遍历+中序遍历重构二叉树前序遍历：4 2 1 3 6 5 中序遍历：1 2 3 4 5 6 前驱、后继节点前驱节点（predecessor）前驱节点：中序遍历时的前一个节点 如果是二叉搜索树，前驱节点就是前一个比它小的节点 123456789101112131415161718192021222324252627282930protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（left.right.right.right....） // node.left != null时 // 举例：6-》5、13-》12、8-》7 // predecessor = node.left.right.right.right... Node&lt;E&gt; p = node.left; // 终止条件：right 为 null if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // 从父节点、祖父节点中寻找前驱节点 // node.left == null &amp;&amp; node.parent != null // 举例：7-》6、11-》10、9-》8 // predecessor = node.parent.parent.parent... // 终止条件：node 在 parent 的右子树中 while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.left == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有左子树的根节点 1 return node.parent;&#125; 后继节点（successor）后继节点：中序遍历时的后一个节点 如果是二叉搜索树，后继节点就是后一个比它大的节点 1234567891011121314151617181920212223242526272829protected Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123; if (node == null) return null; // 前驱节点在左子树当中（right.left.left.left....） // node.right != null // 举例：1、8、4、10 // successor = node.right.left.left.left... Node&lt;E&gt; p = node.right; if (p != null) &#123; // 终止条件：left 为 null while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // node.right == null &amp;&amp; node.parent != null // 举例：6、3、11 // successor = node.parent.parent.parent... // 终止条件：node 在 parent 的左子树中 while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; // node.right == null &amp;&amp; node.parent == null // 那就没有前驱节点 // 举例：没有右子树的根节点 return node.parent;&#125; 计算二叉树的高度非递归，利用队列实现123456789101112131415161718192021222324252627282930public int height() &#123; if (root == null) return 0; // 树的高度 int height = 0; // 存储着每一层的元素数量 int levelSize = 1; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;E&gt; node = queue.poll(); levelSize--; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; if (levelSize == 0) &#123; // 意味着即将要访问下一层 levelSize = queue.size(); height++; &#125; &#125; return height;&#125; 递归1234567public int height() &#123; return height(root);&#125;private int height(Node&lt;E&gt; node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; 练习翻转二叉树leetcode地址 1234567891011121314class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列（Queue）什么是队列队列是一种特殊的线性表，只能在头尾两端进行操作 队尾（rear）：只能从队尾添加元素，一般叫做 enQueue，入队 队头（front）：只能从队头移除元素，一般叫做 deQueue，出队 先进先出的原则，First In First Out，FIFO 队列的代码实现队列的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Queue&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueue(E element) &#123; //入队 list.add(element); &#125; public E deQueue() &#123; // 出队 return list.remove(0); &#125; public E front() &#123; // 获取队首元素，不删除 return list.get(0); &#125;&#125; 双端队列（Deque）双端队列是能在头尾两端添加、删除的队列，英文 deque 是 double ended queue 的简称 123456789101112131415161718192021222324252627282930313233343536373839public class Deque&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void clear() &#123; // 清空 list.clear(); &#125; public void enQueueRear(E element) &#123; // 从队尾入队 list.add(element); &#125; public E deQueueFront() &#123; // 从队头出队 return list.remove(0); &#125; public void enQueueFront(E element) &#123; // 从队头入队 list.add(0, element); &#125; public E deQueueRear() &#123; // 从队尾出队 return list.remove(list.size() - 1); &#125; public E front() &#123; // 获取队列的头元素 return list.get(0); &#125; public E rear() &#123; // 获取队列的尾元素 return list.get(list.size() - 1); &#125;&#125; 循环队列（Circle Queue）可以进行两端添加、删除操作的循环队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CircleQueue&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleQueue() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; public void enQueue(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; public E deQueue() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; public E front() &#123; return elements[front]; &#125; private int index(int index) &#123; index += front; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125; 循环双端队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class CircleDeque&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleDeque() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; // 从尾部入队 public void enQueueRear(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; // 从头部出队 public E deQueueFront() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; // 从头部入队 public void enQueueFront(E element) &#123; ensureCapacity(size + 1); front = index(-1); elements[front] = element; size++; &#125; // 从尾部出队 public E deQueueRear() &#123; int rearIndex = index(size - 1); E rear = elements[rearIndex]; elements[rearIndex] = null; size--; return rear; &#125; public E front() &#123; return elements[front]; &#125; public E rear() &#123; return elements[index(size - 1)]; &#125; private int index(int index) &#123; index += front; if (index &lt; 0) &#123; return index + elements.length; &#125; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // 保证要有capacity的容量 private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 新容量为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // 重置front front = 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2020%2F07%2F11%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈（stack）什么是栈栈是一种特殊的线性表，只能在一端进行操作 往栈中添加元素的操作，一般叫做 push，入栈 从栈中移除元素的操作，一般叫做 pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素） 后进先出的原则，Last In First Out，LIFO 注意：这里说的“栈”与内存中的“栈空间”是两个不同的概念 栈的代码实现栈的内部实现可以直接利用动态数组、链表实现。 123456789101112131415161718192021222324252627public class Stack&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;&gt;(); public void clear() &#123; // 清空 list.clear(); &#125; public int size() &#123; // 元素的数量 return list.size(); &#125; public boolean isEmpty() &#123; // 是否为空 return list.isEmpty(); &#125; public void push(E element) &#123; // 入栈 list.add(element); &#125; public E pop() &#123; // 出栈 return list.remove(list.size() - 1); &#125; public E top() &#123; // 获取栈顶元素，不删除 return list.get(list.size() - 1); &#125;&#125; 练习有效的括号leetcode地址 123456789101112131415161718192021222324class Solution &#123; private static HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); static &#123; map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']'); &#125; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; char c = s.charAt(i); // 判断是否是左边，是就入栈 if (map.containsKey(c))&#123; stack.push(c); &#125;else &#123; // 左边出栈，进行比较 if (stack.isEmpty()) return false; char left = stack.pop(); if (c != map.get(left)) return false; &#125; &#125; return stack.isEmpty(); &#125;&#125; 用栈实现队列leetcode地址 123456789101112131415161718192021222324252627282930313233343536373839class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; /** 入栈 */ public void push(int x) &#123; inStack.push(x); &#125; /** 出栈 */ public int pop() &#123; checkOutStack(); return outStack.pop(); &#125; /** 得到栈顶元素，不删除 */ public int peek() &#123; checkOutStack(); return outStack.peek(); &#125; /** 判断是否为空 */ public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; private void checkOutStack()&#123; if (outStack.isEmpty())&#123; while (!inStack.isEmpty())&#123; outStack.push(inStack.pop()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表（Linked List）为什么有链表动态数组有个明显的缺点，可能会造成内存空间的大量浪费 能否用到多少就申请多少内存？ 链表可以办到这一点 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的 链表的设计 接口设计链表的大部分接口和动态数组是一致的 1234567891011121314151617181920212223242526272829303132333435// 接口定义public interface List&lt;E&gt; &#123; // 元素不存在在返回-1 static final int ELEMENT_NOT_FOUND = -1; // 清除所有元素 void clear(); // 元素的数量 int size(); // 是否为空 boolean isEmpty(); // 是否包含某个元素 boolean contains(E element); // 添加元素到尾部 void add(E element); // 获取index位置的元素 E get(int index); // 设置index位置的元素 E set(int index, E element); // 在index位置插入一个元素 void add(int index, E element); // 删除index位置的元素 E remove(int index); // 查看元素的索引 int indexOf(E element);&#125; 检测传入的下标是否合法123456789101112131415protected void outOfBounds(int index) &#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);&#125;protected void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125;&#125;protected void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125;&#125; node方法用于获取index位置的节点12345678private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node;&#125; 创建节点123456789private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; next; // element新节点的值，next新节点指向的下一个节点 public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 1234567891011121314151617// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; // 在编写链表过程中，要注意边界测试，比如 index 为 0 、size – 0 、size 时 rangeCheckForAdd(index); if (index == 0)&#123; first = new Node&lt;&gt;(element,first); &#125;else&#123; // 找到插入下标的上一个元素 Node&lt;E&gt; prev = node(index - 1); // 新创建的节点指向原先prev.next（如上图：1指向2）,再将prev.next指向新节点（如上图：0指向1） prev.next = new Node&lt;&gt;(element,prev.next); &#125; size++;&#125; 删除元素 12345678910111213141516public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = first; // 注意0位置 if (index == 0)&#123; first = first.next; &#125;else&#123; // 找到待删除元素上一个元素的下标 Node&lt;E&gt; prev = node(index - 1); // node待删除的元素 node = prev.next; prev.next = node.next; &#125; size--; return node.element;&#125; 清空链表12345public void clear() &#123; size = 0; // next不需要设置为null first = null;&#125; 判断链表中某个元素的下标1234567891011121314151617public int indexOf(E element) &#123; // 链表中允许有null值元素 if (element == null)&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) return i; node = node.next; &#125; &#125;else&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) return i; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND;&#125; 判断链表中是否包含某个元素123public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND;&#125; 双向链表使用双向链表可以提升链表的综合性能 node方法用于获取index位置的节点1234567891011121314151617private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); // 分两条路寻找节点 if (index &lt; (size &gt;&gt; 1))&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node; &#125;else &#123; Node&lt;E&gt; node = last; for (int i = size - 1; i &gt; index; i--) &#123; node = node.prev; &#125; return node; &#125;&#125; 创建节点1234567891011private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next) &#123; this.prev = prev; this.element = element; this.next = next; &#125;&#125; 添加元素-add(int index,E element) 12345678910111213141516171819202122// 添加元素到尾部public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); if (index == size)&#123; Node&lt;E&gt; oldLast = last; last = new Node&lt;&gt;(oldLast,element,null); oldLast.next = last; &#125;else&#123; Node&lt;E&gt; next = node(index); Node&lt;E&gt; prev = next.prev; Node&lt;E&gt; node = new Node&lt;&gt;(prev,element,next); next.prev = node; if (prev == null)&#123; first = node; &#125;else&#123; prev.next = node; &#125; &#125;&#125; 删除元素 – remove(int index) 1234567891011121314151617181920public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = node(index); Node&lt;E&gt; prev = node.prev; Node&lt;E&gt; next = node.next; if (prev == null)&#123; first = next; &#125;else&#123; prev.next = next; &#125; if (next == null)&#123; last = prev; &#125;else&#123; next.prev = prev; &#125; size--; return node.element;&#125; 双向链表 vs 单向链表粗略对比一下删除的操作数量 单向链表： $1+2+3+…+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$ ${n^2} \over {2}$， 除以$n$ 平均一下是 ${1} \over {2}$ + ${n} \over {2}$ 双向链表：$(1+2+3+…+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ，除以$n$平均一下是 ${1} \over {2}$ + ${n} \over{4}$ 操作数量缩减了近一半 练习删除链表中的节点leetcode地址 123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 反转一个链表leetcode地址 递归实现 12345678910// 递归public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; // 定义新的头节点 ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; 非递归 – 头插法 1234567891011121314// 迭代public ListNode reverseList2(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode newHead = null; while (head != null)&#123; ListNode tmp = head.next; // 每次遍历让head.next成为头节点 head.next = newHead; newHead = head; // head重新指向tmp，使循环按顺序继续遍历 head = tmp; &#125; return newHead;&#125; 判断一个链表是否有环leetcode地址 123456789101112131415// 快慢指针，相遇则有环public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; // 慢指针，每次走一步 ListNode slow = head; // 快指针，每次走两步 ListNode fast = head.next; while (fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数组]]></title>
    <url>%2F2020%2F07%2F09%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组数组是一种顺序存储的线性表，所有元素的内存地址是连续的 1int[] array = new int[]&#123;11,22,33&#125;; 在很多编程语言中，数组都有个致命的缺点，无法动态修改容量 实际开发中，我们更希望数组的容量是可以动态改变的 动态数组（Dynamic Array）接口设计12345678910int size(); // 元素的数量boolean isEmpty(); // 是否为空boolean contains(E element); // 是否包含某个元素void add(E element); // 添加元素到最后E get(int index); // 返回indext位置对应的元素E set(int index,E element); // 设置indext位置对应的元素void add(int index,E element); // 往index位置添加元素E remove(int index); // 删除index位置对应的元素int indexOf(E element); // 查看元素的位置void clear(); //清除所有元素 动态数组的设计 在Java中，成员变量会自动初始化，比如 int 类型自动初始化为 0 对象类型自动初始化为 null 添加元素 - add(E element) 12345678910111213141516171819//没有索引下标，默认放在数组最后public void add(E element)&#123; add(size,element);&#125;// 向数组某个位置插入元素public void add(int index,E element)&#123; // 检测下标是否越界 rangeCheckForAdd(index); // 扩容 ensureCapacity(size + 1); // 从最后一个元素开始，到index下标（逆序），数组元素向后覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++;&#125; 删除元素 - remove(int index) 1234567891011public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; // 从index下标开始，数组元素向前挪动 for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old;&#125; 如何扩容 - ensureCapacity(int capacity) 1234567891011// 数组容量不够时，扩容private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半(再加上原来的容量) E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import org.omg.CORBA.Object;import java.util.Arrays;@SuppressWarnings("unchecked")public class dynamicArray&lt;E&gt;&#123; /** * 元素的数量 */ private int size; /** * 所以的元素 */ private E[] elements; private static final int DEFAULT_CAPATICY = 10; //初始容量 private static final int ELEMENT_NOT_FOUND = -1; //找不到查找的元素 public dynamicArray(int capaticy)&#123; capaticy = Math.max(capaticy, DEFAULT_CAPATICY); elements = (E[]) new Object[capaticy]; //初始化数组容量 &#125; public dynamicArray()&#123; this(DEFAULT_CAPATICY); &#125; /** * 清除所有元素 */ public void clear()&#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; public void add(E element)&#123; add(size,element); &#125; // 向数组某个位置插入元素 public void add(int index,E element)&#123; rangeCheckForAdd(index); ensureCapacity(size + 1); // 数组元素向前覆盖 for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++; &#125; // 数组容量不够时，扩容 private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // 容量添加1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 左移，缩小一半 E[] newElements = (E[]) new Object[newCapacity]; // 将旧数组的元素拷贝到新数组 if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements; &#125; public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old; &#125; public boolean contains(E element)&#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; public E get(int index)&#123; rangeCheck(index); return elements[index]; &#125; public E set(int index,E element)&#123; rangeCheck(index); E old = elements[index]; elements[index] = element; return old; &#125; public int indexOf(E element)&#123; if (element == null)&#123; for (int i = 0; i &lt; size; i++) &#123; if (elements[i] == null) return i; &#125; &#125;else&#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(elements[i])) return i; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private void outOfBounds(int index)&#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size); &#125; // 检测传入的下标是否越界 private void rangeCheck(int index)&#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125; &#125; private void rangeCheckForAdd(int index)&#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125; &#125; @Override public String toString() &#123; return "dynamicArray&#123;" + "size=" + size + ", elements=" + Arrays.toString(elements) + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构什么是数据结构？数据结构是计算机存储、组织数据的方式 线性表 二叉树 邻接矩阵 数组、链表 AVL树、红黑树 邻接表 栈、队列 B树、堆、Trie 哈希表 哈夫曼树、并查集 在实际应用中，根据使用场景来选择最合适的数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习路线]]></title>
    <url>%2F2019%2F09%2F17%2FJAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JAVA学习路线1. 语言的入门和进阶 Java基础语法,OO编程思想, 集合, IO, 异常, 泛型, 反射, 多线程, 函数式 2. Web基础和工具 前端基础(html/javascript/css) jquery, ajax, jsp, cookie, session http基础 servlet基础 git,svn代码管理工具 3. 企业级应用框架 maven/gradle项目管理工具 Spring全家桶(Spring, Spring MVC, Spring Boot) 关系型数据库相关(MySQL, jdbc, MyBatis, Hibernate) 非关系型数据库(Redis) 模板引擎(thymeleaf, freemarker) 4. 高级应用框架 搜索引擎(elastic search) RPCk框架(Dubbo, Spring Cloud) 中间件技术(RabbitMQ, RocketMQ, ActiveMQ, Kafka) 虚拟化技术(Docker, Kubernetes) 5. 高级话题 jvm优化和排错, GC分析, 数据库高级优化]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
      </tags>
  </entry>
</search>
