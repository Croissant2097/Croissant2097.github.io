<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[B+æ ‘]]></title>
    <url>%2F2020%2F07%2F23%2FB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B+æ ‘$B+$æ ‘æ˜¯ $B$ æ ‘çš„å˜ä½“ï¼Œå¸¸ç”¨äºæ•°æ®åº“å’Œæ“ä½œç³»ç»Ÿçš„æ–‡ä»¶ç³»ç»Ÿä¸­ $MySQL$ æ•°æ®åº“çš„ç´¢å¼•å°±æ˜¯åŸºäº $B+$ æ ‘å®ç°çš„ B+æ ‘çš„ç‰¹ç‚¹ åˆ†ä¸ºå†…éƒ¨èŠ‚ç‚¹ï¼ˆéå¶å­ï¼‰ã€å¶å­èŠ‚ç‚¹ $2$ ç§èŠ‚ç‚¹ å†…éƒ¨èŠ‚ç‚¹åªå­˜å‚¨ $key$ï¼Œä¸å­˜å‚¨å…·ä½“æ•°æ® å¶å­èŠ‚ç‚¹å­˜å‚¨ $key$ å’Œå…·ä½“æ•°æ® $value$ æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹å½¢æˆä¸€æ¡æœ‰åºé“¾è¡¨ $m$ é˜¶ $B+$ æ ‘éæ ¹èŠ‚ç‚¹çš„å…ƒç´ æ•°é‡ $x$ $â”Œ m/2 â” â‰¤ x â‰¤ m$ MySQLçš„ç´¢å¼•åº•å±‚ä¸ºä½•ä½¿ç”¨B+æ ‘ï¼Ÿ ä¸ºäº†å‡å° $IO$ æ“ä½œæ•°é‡ï¼Œä¸€èˆ¬æŠŠä¸€ä¸ªèŠ‚ç‚¹çš„å¤§å°è®¾è®¡æˆæœ€å°è¯»å†™å•ä½çš„å¤§å° $MySQL$ çš„å­˜å‚¨å¼•æ“ $InnoDB$ çš„æœ€å°è¯»å†™å•ä½æ˜¯ $16K$ å¯¹æ¯” $B$ æ ‘ï¼Œ$B+$ æ ‘çš„ä¼˜åŠ¿æ˜¯ æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨çš„ $key$ æ•°é‡æ›´å¤šï¼Œæ ‘çš„é«˜åº¦æ›´ä½ æ‰€æœ‰çš„å…·ä½“æ•°æ®éƒ½å­˜åœ¨å¶å­èŠ‚ç‚¹ä¸Šï¼Œæ‰€ä»¥æ¯æ¬¡æŸ¥è¯¢éƒ½è¦æŸ¥åˆ°å¶å­èŠ‚ç‚¹ï¼ŒæŸ¥è¯¢é€Ÿåº¦æ¯”è¾ƒç¨³å®š æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹æ„æˆäº†ä¸€ä¸ªæœ‰åºé“¾è¡¨ï¼ŒåšåŒºé—´æŸ¥è¯¢æ—¶æ›´æ–¹ä¾¿ B*æ ‘$B*$ æ ‘æ˜¯ $B+$ æ ‘çš„å˜ä½“ï¼šç»™å†…éƒ¨èŠ‚ç‚¹å¢åŠ äº†æŒ‡å‘å…„å¼ŸèŠ‚ç‚¹çš„æŒ‡é’ˆ $m$ é˜¶ $B*$ æ ‘éæ ¹èŠ‚ç‚¹çš„å…ƒç´ æ•°é‡ $x$ $â”Œ 2m/3 â” â‰¤ x â‰¤ m$]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>B+æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸²]]></title>
    <url>%2F2020%2F07%2F22%2F%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[ä¸²ï¼ˆSequenceï¼‰å­—ç¬¦ä¸² $thank$ çš„å‰ç¼€ï¼ˆ $prefix$ ï¼‰ã€çœŸå‰ç¼€ï¼ˆ $proper prefix$ ï¼‰ã€åç¼€ï¼ˆ $suffix$ ï¼‰ã€çœŸåç¼€ï¼ˆ $proper suffix$ï¼‰ å‰ç¼€ t, th, tha, than, thank çœŸå‰ç¼€ t, th, tha, than åç¼€ thank, hank, ank, nk, k çœŸåç¼€ hank, ank, nk, k ä¸²åŒ¹é…ç®—æ³•æŸ¥æ‰¾ä¸€ä¸ªæ¨¡å¼ä¸²ï¼ˆ $pattern$ ï¼‰åœ¨æ–‡æœ¬ä¸²ï¼ˆ $text$ ï¼‰ä¸­çš„ä½ç½® å‡ ä¸ªç»å…¸çš„ä¸²åŒ¹é…ç®—æ³• è›®åŠ›ï¼ˆ $Brute Force$ ï¼‰ $KMP$ $Boyer-Moore$ $Karp-Rabin$ $Sunday$ ç”¨ $tlen$ ä»£è¡¨æ–‡æœ¬ä¸² $text$ çš„é•¿åº¦ï¼Œ$plen$ ä»£è¡¨æ¨¡å¼ä¸² $pattern$ çš„é•¿åº¦ è›®åŠ›ï¼ˆBrute Forceï¼‰ä»¥å­—ç¬¦ä¸ºå•ä½ï¼Œä»å·¦åˆ°å³ç§»åŠ¨æ¨¡å¼ä¸²ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸ è›®åŠ›ç®—æ³•æœ‰ $2$ ç§å¸¸è§å®ç°æ€è·¯ è›®åŠ›1 â€“ æ‰§è¡Œè¿‡ç¨‹$pi$ çš„å–å€¼èŒƒå›´ $[0, plen)$ $ti$ çš„å–å€¼èŒƒå›´ $[0, tlen)$ å½“åŒ¹é…çš„ä¸¤ä¸ªå­—ç¬¦ä¸ç›¸ç­‰æ—¶ï¼š $textChars[ti] != patternChars[pi]$ $pi = 0$ $ti â€“= pi â€“ 1$ å½“åŒ¹é…çš„ä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰æ—¶ï¼š $textChars[ti] == patternChars[pi]$ $pi ++$ $ti ++$ ç»§ç»­å‘ååŒ¹é… å½“ $pi == plen$ï¼šä»£è¡¨åŒ¹é…æˆåŠŸ è›®åŠ›1 â€“ å®ç°1234567891011121314151617181920212223public static int indexOf01(String text, String pattern)&#123; // åˆ¤æ–­åˆæ³•æ€§ if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; int pi = 0, ti = 0; while (pi &lt; plen &amp;&amp; ti &lt; tlen)&#123; if (textChars[ti] == patternChars[pi])&#123; ti++; pi++; &#125;else&#123; ti -= pi - 1; pi = 0; &#125; &#125; return (pi == plen) ? (ti - pi) : -1;&#125; è›®åŠ›1 â€“ ä¼˜åŒ– æ­¤å‰å®ç°çš„è›®åŠ›ç®—æ³•ï¼Œåœ¨æ°å½“çš„æ—¶å€™å¯ä»¥æå‰é€€å‡ºï¼Œå‡å°‘æ¯”è¾ƒæ¬¡æ•° å› æ­¤ï¼Œ$ti$ çš„é€€å‡ºæ¡ä»¶å¯ä»¥ä» $ti &lt; tlen$ æ”¹ä¸º $ti â€“ pi &lt;= tlen â€“ plen$ $ti â€“ pi$ æ˜¯æŒ‡æ¯ä¸€è½®æ¯”è¾ƒä¸­ $text$ é¦–ä¸ªæ¯”è¾ƒå­—ç¬¦çš„ä½ç½® è›®åŠ›1 â€“ ä¼˜åŒ–å®ç°12345678910111213141516171819202122232425public static int indexOf02(String text, String pattern)&#123; if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; int pi = 0, ti = 0; // ti - pi æ–‡æœ¬ä¸²æ­£åœ¨åŒ¹é…çš„å­ä¸²çš„å¼€å§‹ç´¢å¼• // tlen - plen å¼€å§‹ç´¢å¼•çš„ä¸´ç•Œå€¼ int lenDelta = tlen - plen; while (pi &lt; plen &amp;&amp; ti - pi &lt;= lenDelta)&#123; if (textChars[ti] == patternChars[pi])&#123; ti++; pi++; &#125;else&#123; ti -= pi - 1; pi = 0; &#125; &#125; return (pi == plen) ? (ti - pi) : -1;&#125; è›®åŠ›2 â€“ æ‰§è¡Œè¿‡ç¨‹$pi$ çš„å–å€¼èŒƒå›´ $[0, plen)$ $ti$ çš„å–å€¼èŒƒå›´ $[0, tlen â€“ plen]$ å½“åŒ¹é…çš„ä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰æ—¶ï¼š $textChars[ti]==patternChars[pi]$ $pi ++$ $ti += pi$ å½“åŒ¹é…çš„ä¸¤ä¸ªå­—ç¬¦ä¸ç›¸ç­‰æ—¶ï¼š $textChars[ti]==patternChars[pi]$ $pi = 0$ $ti++$ å½“ $pi == plen$ï¼šä»£è¡¨åŒ¹é…æˆåŠŸ è›®åŠ›2 â€“ å®ç°1234567891011121314151617181920public static int indexOf(String text, String pattern)&#123; if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; int tiMax = tlen - plen; for (int ti = 0; ti &lt;= tiMax; ti++) &#123; int pi = 0; for (; pi &lt; plen; pi++) &#123; if (textChars[ti + pi] != patternChars[pi]) break;; &#125; if (pi == plen) return ti; &#125; return -1;&#125; è›®åŠ› â€“ æ€§èƒ½åˆ†æ$n$ æ˜¯æ–‡æœ¬ä¸²é•¿åº¦ï¼Œ$m$ æ˜¯æ¨¡å¼ä¸²é•¿åº¦ æœ€å¥½æƒ…å†µ åªéœ€ä¸€è½®æ¯”è¾ƒå°±å®Œå…¨åŒ¹é…æˆåŠŸï¼Œæ¯”è¾ƒ $m$ æ¬¡ï¼ˆ $m$ æ˜¯æ¨¡å¼ä¸²çš„é•¿åº¦ï¼‰ æ—¶é—´å¤æ‚åº¦ä¸º $O(m)$ æœ€åæƒ…å†µï¼ˆå­—ç¬¦é›†è¶Šå¤§ï¼Œå‡ºç°æ¦‚ç‡è¶Šä½ï¼‰ æ‰§è¡Œäº† $n â€“ m + 1$ è½®æ¯”è¾ƒï¼ˆ $n$ æ˜¯æ–‡æœ¬ä¸²çš„é•¿åº¦ï¼‰ æ¯è½®éƒ½æ¯”è¾ƒè‡³æ¨¡å¼ä¸²çš„æœ«å­—ç¬¦åå¤±è´¥ï¼ˆ $m â€“ 1$ æ¬¡æˆåŠŸï¼Œ$1$ æ¬¡å¤±è´¥ï¼‰ æ—¶é—´å¤æ‚åº¦ä¸º $O(m âˆ— (n âˆ’ m + 1))$ï¼Œç”±äºä¸€èˆ¬ $m$ è¿œå°äº $n$ï¼Œæ‰€ä»¥ä¸º $O(mn)$ KMP$KMP$ æ˜¯ $Knuthâ€“Morrisâ€“Pratt$ çš„ç®€ç§°ï¼ˆå–åè‡ª $3$ ä½å‘æ˜äººçš„åå­—ï¼‰ï¼Œäº $1977$ å¹´å‘å¸ƒ KMP â€“ nextè¡¨çš„ä½¿ç”¨$KMP$ ä¼šé¢„å…ˆæ ¹æ®æ¨¡å¼ä¸²çš„å†…å®¹ç”Ÿæˆä¸€å¼  $next$ è¡¨ï¼ˆä¸€èˆ¬æ˜¯ä¸ªæ•°ç»„ï¼‰ åé¢å†è®²æ€ä¹ˆç”Ÿæˆ $next$ è¡¨ï¼ˆå…ˆå­¦ä¼šä½¿ç”¨ï¼‰ ä¸¾ä¾‹ï¼š å½“åœ¨ $E(ti = 8ï¼Œpi = 7)$ å‘ç”Ÿå¤±é…æ—¶ï¼Œ$ti$ ä¸å˜ï¼Œ$pi$ å˜æˆ $next$ è¡¨ä¸­çš„å€¼ å½“åœ¨ $D(ti = 5ï¼Œpi = 3)$ å‘ç”Ÿå¤±é…æ—¶ï¼Œ$ti$ ä¸å˜ï¼Œ$pi$ å˜æˆ $next$ è¡¨ä¸­çš„å€¼ KMP â€“ æ ¸å¿ƒåŸç†$Aã€B$ æ˜¯ä¸ªå­ä¸²ï¼ˆæœ‰å¤šä¸ªå­—ç¬¦ï¼‰ $cã€dã€e$ æ˜¯å•ä¸ªå­—ç¬¦ å½“ $dã€e$ å¤±é…æ—¶ï¼Œå¦‚æœå¸Œæœ› $pattern$ èƒ½å¤Ÿä¸€æ¬¡æ€§å‘å³ç§»åŠ¨ä¸€å¤§æ®µè·ç¦»ï¼Œç„¶åç›´æ¥æ¯”è¾ƒ $dã€c$ å­—ç¬¦ å‰ææ¡ä»¶æ˜¯å­ä¸² $A$ å¿…é¡»ç­‰äºå­ä¸² $B$ æ‰€ä»¥ $KMP$ å¿…é¡»åœ¨å¤±é…å­—ç¬¦ $e$ å·¦è¾¹çš„å­ä¸²ä¸­æ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„å­ä¸² $A ã€B$ï¼Œä»è€Œå¾—çŸ¥å‘å³ç§»åŠ¨çš„è·ç¦» å‘å³ç§»åŠ¨çš„è·ç¦»ï¼š$e$ å·¦è¾¹å­ä¸²çš„é•¿åº¦ $â€“ A$ çš„é•¿åº¦ï¼ˆä¹Ÿç­‰äº $-B$ çš„é•¿åº¦ï¼‰ï¼Œç­‰ä»·äºï¼š$e$ çš„ç´¢å¼• $â€“ c$ çš„ç´¢å¼• ä¸” $c$ çš„ç´¢å¼• == $next[$ $e$ çš„ç´¢å¼• $]$ï¼Œæ‰€ä»¥å‘å³ç§»åŠ¨çš„è·ç¦»ï¼š$e$ çš„ç´¢å¼• $â€“ next$ [ $e$ çš„ç´¢å¼• ] ä¸¾ä¾‹ï¼š $text: \underbrace{abc}_{\rm A}$ $c$ $\underbrace{abc}_{\rm B}$ $d$ $patternï¼šabce$ å½“ $A = \underbrace{abc}_{\rm A} ã€B = \underbrace{abc}_{\rm B}$ $pi$ ä¸€æ¬¡æ€§å‘å³ç§»åŠ¨çš„è·ç¦»ï¼š$7 - 3 = 4$ æ€»ç»“ å¦‚æœåœ¨ $pi$ ä½ç½®å¤±é…ï¼Œå‘å³ç§»åŠ¨çš„è·ç¦»æ˜¯ $pi â€“ next[pi]$ï¼Œæ‰€ä»¥ $next[pi]$ è¶Šå°ï¼Œç§»åŠ¨è·ç¦»è¶Šå¤§ $next[pi]$ æ˜¯ $pi$ å·¦è¾¹å­ä¸²çš„çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦ KMP â€“ çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦ KMP â€“ å¾—åˆ°nextè¡¨ å°†æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦éƒ½å‘åç§»åŠ¨ $1$ ä½ï¼Œé¦–å­—ç¬¦è®¾ç½®ä¸º è´Ÿ $1$ï¼Œå°±å¾—åˆ°äº† $next$ è¡¨ KMP â€“ è´Ÿ1çš„ç²¾å¦™ä¹‹å¤„å¦‚æœï¼š$pi = next[pi] â†’ (-1)$ $(pi++) â†’ (-1) â†’ 0$ $(ti++) â†’ 2 â†’ 3$ ç›¸å½“äºåœ¨è´Ÿ $1$ ä½ç½®æœ‰ä¸ªå‡æƒ³çš„é€šé…å­—ç¬¦ï¼ˆå“¨å…µï¼‰ åŒ¹é…æˆåŠŸå $ti++ã€pi++$ KMP â€“ ä¸»ç®—æ³•å®ç°123456789101112131415161718192021222324252627public static int indexOf(String text, String pattern)&#123; // åˆ¤æ–­åˆæ³•æ€§ if (text == null || pattern == null) return -1; char[] textChars = text.toCharArray(); int tlen = textChars.length; if (tlen == 0) return -1; char[] patternChars = pattern.toCharArray(); int plen = patternChars.length; if (plen == 0) return -1; if (tlen &lt; plen) return -1; // nextè¡¨ int[] next = next(pattern); int pi = 0, ti = 0; int lenDelta = tlen - plen; while (pi &lt; plen &amp;&amp; ti - pi &lt;= lenDelta)&#123; if (pi &lt; 0 || textChars[ti] == patternChars[pi])&#123; ti++; pi++; &#125;else&#123; // pi ä¸€æ¬¡æ€§å‘å³ç§»åŠ¨çš„è·ç¦» pi = next[pi]; &#125; &#125; return (pi == plen) ? (ti - pi) : -1;&#125; KMP â€“ ä¸ºä»€ä¹ˆæ˜¯â€œæœ€å¤§â€œå…¬å…±å­ä¸²é•¿åº¦ï¼Ÿå‡è®¾æ–‡æœ¬ä¸²æ˜¯ $AAAAABCDEF$ï¼Œæ¨¡å¼ä¸²æ˜¯ $AAAAB$ åº”è¯¥å°† $1ã€2ã€3$ ä¸­çš„å“ªä¸ªå€¼èµ‹å€¼ç»™ $pi$ æ˜¯æ­£ç¡®çš„ï¼Ÿ å°† $3$ èµ‹å€¼ç»™ $pi$ å‘å³ç§»åŠ¨äº† $1$ ä¸ªå­—ç¬¦å•ä½ï¼Œæœ€åæˆåŠŸåŒ¹é… å°† $1$ èµ‹å€¼ç»™ $pi$ å‘å³ç§»åŠ¨äº† $3$ ä¸ªå­—ç¬¦å•ä½ï¼Œé”™è¿‡äº†æˆåŠŸåŒ¹é…çš„æœºä¼š å…¬å…±å­ä¸²é•¿åº¦è¶Šå°ï¼Œå‘å³ç§»åŠ¨çš„è·ç¦»è¶Šå¤§ï¼Œè¶Šä¸å®‰å…¨ å…¬å…±å­ä¸²é•¿åº¦è¶Šå¤§ï¼Œå‘å³ç§»åŠ¨çš„è·ç¦»è¶Šå°ï¼Œè¶Šå®‰å…¨ KMP â€“ nextè¡¨çš„æ„é€ æ€è·¯å‡è®¾(å·²çŸ¥) $next[i] == n$ ï¼ˆæ•°ç»„ä¸‹æ ‡ä¸º $i$ å·¦è¾¹å­ä¸²çš„çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦æœ‰ $n$ ä¸ªï¼‰ è®©ä¸‹æ ‡ä¸º $i$ ä¸ä¸‹æ ‡ä¸º $n$ ä½ç½®çš„å€¼åšæ¯”è¾ƒ â‘  å¦‚ æœ $pattern.charAt(i) == pattern.charAt(n)$ â€‹ é‚£ä¹ˆ $next[i + 1] == n + 1$ â‘¡ å¦‚ æœ $pattern.charAt(i) != pattern.charAt(n)$ â€‹ å·²çŸ¥ $next[n] == k$ï¼Œ$k$ ï¼ˆå·¦è¾¹å­ä¸²çš„çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦ï¼‰ â€‹ ä¹Ÿå°±æ˜¯å†å» $n$ çš„å·¦è¾¹å¯»æ‰¾çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦ å¦‚æœ $pattern.charAt(i) == pattern.charAt(k)$ é‚£ä¹ˆ $next[i + 1] == k + 1$ å¦‚æœ $pattern.charAt(i) != pattern.charAt(k)$ å°† $k$ ä»£å…¥ $n$ï¼Œ $ï¼ˆn = next[n]ï¼‰$ï¼Œé‡å¤æ‰§è¡Œ â‘¡ KMP â€“ nextè¡¨çš„ä»£ç å®ç°123456789101112131415161718private static int[] next(String pattern)&#123; char[] chars = pattern.toCharArray(); int[] next = new int[chars.length]; // next[i] ç¬¬ i é¡¹å·¦è¾¹å­ä¸²çš„çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦ // å·²çŸ¥ n == next[i] int i = 0; int n = next[i] = -1; int iMax = chars.length -1; while (i &lt; iMax)&#123; if (n &lt; 0 || chars[i] == chars[n])&#123; next[++i] = ++n; &#125;else&#123; n = next[n]; // å›¾ç¤ºä¸º n = k &#125; &#125; return next;&#125; KMP â€“ nextè¡¨çš„ä¸è¶³ä¹‹å¤„å‡è®¾æ–‡æœ¬ä¸²æ˜¯ $AAABAAAAB$ ï¼Œæ¨¡å¼ä¸²æ˜¯ $AAAAB$ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ$KMP$ æ˜¾å¾—æ¯”è¾ƒç¬¨æ‹™ KMP â€“ nextè¡¨çš„ä¼˜åŒ–æ€è·¯å·²çŸ¥ï¼š$next[i] == nï¼Œnext[n] == k$ å¦‚æœ $pattern[i] != d$ï¼Œå°±è®©æ¨¡å¼ä¸²æ»‘åŠ¨åˆ° $next[i]$ï¼ˆä¹Ÿå°±æ˜¯ $n$ ï¼‰ä½ç½®è·Ÿ $d$ è¿›è¡Œæ¯”è¾ƒ å¦‚æœ $pattern[n] != d$ï¼Œå°±è®©æ¨¡å¼ä¸²æ»‘åŠ¨åˆ° $next[n]$ï¼ˆä¹Ÿå°±æ˜¯ $k$ ï¼‰ä½ç½®è·Ÿ $d$ è¿›è¡Œæ¯”è¾ƒ å¦‚æœ $pattern[i] == pattern[n]$ï¼Œé‚£ä¹ˆå½“ $i$ ä½ç½®å¤±é…æ—¶ï¼Œæ¨¡å¼ä¸²æœ€ç»ˆå¿…ç„¶ä¼šæ»‘åˆ° $k$ ä½ç½®è·Ÿ $d$ è¿›è¡Œæ¯”è¾ƒ æ‰€ä»¥ $next[i]$ ç›´æ¥å­˜å‚¨ $next[n]$ï¼ˆä¹Ÿå°±æ˜¯ $k$ ï¼‰å³å¯ KMP â€“ nextè¡¨çš„ä¼˜åŒ–å®ç°12345678910111213141516171819202122232425private static int[] next(String pattern)&#123; char[] chars = pattern.toCharArray(); int[] next = new int[chars.length]; // next[i] ç¬¬ i é¡¹å·¦è¾¹å­ä¸²çš„çœŸå‰ç¼€åç¼€çš„æœ€å¤§å…¬å…±å­ä¸²é•¿åº¦ // å·²çŸ¥ n == next[i] int i = 0; int n = next[i] = -1; int iMax = chars.length -1; while (i &lt; iMax)&#123; if (n &lt; 0 || chars[i] == chars[n])&#123; ++i; ++n; // ++åï¼Œå…ˆæ¯”è¾ƒï¼Œç›¸ç­‰ï¼Œç›´æ¥è·³åˆ°ä¸‹ä¸€ä¸ªï¼Œä¸Šå›¾ä¸­å¯è®¤ä¸ºæ˜¯k if (chars[i] == chars[n])&#123; next[i] = next[n]; &#125;else&#123; next[i] = n; &#125; &#125;else&#123; n = next[n]; &#125; &#125; return next;&#125; KMP â€“ nextè¡¨çš„ä¼˜åŒ–æ•ˆæœ KMP â€“ æ€§èƒ½åˆ†æ $KMP$ ä¸»é€»è¾‘ æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼š$O(m)$ æœ€åæ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œä¸è¶…è¿‡ $O(2n)$ $next$ è¡¨çš„æ„é€ è¿‡ç¨‹è·Ÿ $KMP$ ä¸»ä½“é€»è¾‘ç±»ä¼¼ æ—¶é—´å¤æ‚åº¦ï¼š$O(m)$ $KMP$ æ•´ä½“ æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼š$O(m)$ æœ€åæ—¶é—´å¤æ‚åº¦ï¼š$O(n + m)$ ç©ºé—´å¤æ‚åº¦ï¼š $O(m)$ è›®åŠ› vs KMPè›®åŠ›ç®—æ³•ä¸ºä½•ä½æ•ˆï¼Ÿ å½“å­—ç¬¦å¤±é…æ—¶ è›®åŠ›ç®—æ³• $ti$ å›æº¯åˆ°å·¦è¾¹ä½ç½® $pi$ å›æº¯åˆ° $0$ KMP ç®—æ³• $ti$ ä¸å¿…å›æº¯ $pi$ ä¸ä¸€å®šè¦å›æº¯åˆ° $0$ å¯¹æ¯”è›®åŠ›ç®—æ³•ï¼Œ$KMP$ çš„ç²¾å¦™ä¹‹å¤„ï¼šå……åˆ†åˆ©ç”¨äº†æ­¤å‰æ¯”è¾ƒè¿‡çš„å†…å®¹ï¼Œå¯ä»¥å¾ˆèªæ˜åœ°è·³è¿‡ä¸€äº›ä¸å¿…è¦çš„æ¯”è¾ƒä½ç½®]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è·³è¡¨]]></title>
    <url>%2F2020%2F07%2F21%2F%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[è·³è¡¨ï¼ˆSkipListï¼‰æ€è€ƒä¸€ä¸ªæœ‰åºé“¾è¡¨æœç´¢ã€æ·»åŠ ã€åˆ é™¤çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ $O(n)$ èƒ½å¦åˆ©ç”¨äºŒåˆ†æœç´¢ä¼˜åŒ–æœ‰åºé“¾è¡¨ï¼Œå°†æœç´¢ã€æ·»åŠ ã€åˆ é™¤çš„å¹³å‡æ—¶é—´å¤æ‚åº¦é™ä½è‡³ $O(logn)$ï¼Ÿ é“¾è¡¨æ²¡æœ‰åƒæ•°ç»„é‚£æ ·çš„é«˜æ•ˆéšæœºè®¿é—®ï¼ˆ$O(1)$ æ—¶é—´å¤æ‚åº¦ï¼‰ï¼Œæ‰€ä»¥ä¸èƒ½åƒæœ‰åºæ•°ç»„é‚£æ ·ç›´æ¥è¿›è¡ŒäºŒåˆ†æœç´¢ä¼˜åŒ– é‚£æœ‰æ²¡æœ‰å…¶ä»–åŠæ³•è®©æœ‰åºé“¾è¡¨æœç´¢ã€æ·»åŠ ã€åˆ é™¤çš„å¹³å‡æ—¶é—´å¤æ‚åº¦é™ä½è‡³ $O(logn)$ï¼Ÿ ä½¿ç”¨è·³è¡¨ï¼ˆ$SkipList$ï¼‰ è·³è¡¨æ˜¯ä»€ä¹ˆ è·³è¡¨ï¼Œåˆå«åšè·³è·ƒè¡¨ã€è·³è·ƒåˆ—è¡¨ï¼Œåœ¨æœ‰åºé“¾è¡¨çš„åŸºç¡€ä¸Šå¢åŠ äº†â€œè·³è·ƒâ€çš„åŠŸèƒ½ ç”± $William Pugh$äº $1990$ å¹´å‘å¸ƒï¼Œè®¾è®¡çš„åˆè¡·æ˜¯ä¸ºäº†å–ä»£å¹³è¡¡æ ‘ï¼ˆæ¯”å¦‚çº¢é»‘æ ‘ï¼‰ $Redis$ ä¸­ çš„ $SortedSetã€LevelDB$ ä¸­çš„ $MemTable$ éƒ½ç”¨åˆ°äº†è·³è¡¨ $Redisã€LevelDB$ éƒ½æ˜¯è‘—åçš„ $Key-Value$ æ•°æ®åº“ å¯¹æ¯”å¹³è¡¡æ ‘ è·³è¡¨çš„å®ç°å’Œç»´æŠ¤ä¼šæ›´åŠ ç®€å• è·³è¡¨çš„æœç´¢ã€åˆ é™¤ã€æ·»åŠ çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ $O(logn)$ ä½¿ç”¨è·³è¡¨ä¼˜åŒ–é“¾è¡¨ è·³è¡¨çš„åŸºæœ¬å®šä¹‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// æœ€é«˜å±‚æ•°private static final int MAX_LEVEL = 32;// æ–°å¢å±‚æ•°çš„æ¦‚ç‡private static final double P = 0.25;private int size;private Comparator&lt;K&gt; comparator;// æœ‰æ•ˆå±‚æ•°private int level;// é¦–èŠ‚ç‚¹ï¼Œä¸å­˜æ”¾ä»»ä½•K-Vprivate Node&lt;K, V&gt; first;public SkipList(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; first = new Node&lt;&gt;(null, null, MAX_LEVEL);&#125;public SkipList() &#123; this(null);&#125;public int size() &#123; return size;&#125;public boolean isEmpty() &#123; return size == 0;&#125;// éšæœºè¿”å›æ–°å¢èŠ‚ç‚¹çš„å±‚æ•°private int randomLevel() &#123; int level = 1; while (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123; level++; &#125; return level;&#125;private void keyCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null."); &#125;&#125;private int compare(K k1, K k2) &#123; return comparator != null ? comparator.compare(k1, k2) : ((Comparable&lt;K&gt;)k1).compareTo(k2);&#125;@Overridepublic String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("ä¸€å…±" + level + "å±‚").append("\n"); for (int i = level - 1; i &gt;= 0; i--) &#123; Node&lt;K, V&gt; node = first; while (node.nexts[i] != null) &#123; sb.append(node.nexts[i]); sb.append(" "); node = node.nexts[i]; &#125; sb.append("\n"); &#125; return sb.toString();&#125; è·³è¡¨èŠ‚ç‚¹çš„å®šä¹‰123456789101112131415private static class Node&lt;K, V&gt; &#123; K key; V value; // èŠ‚ç‚¹æŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå¤šä¸ªï¼‰ Node&lt;K, V&gt;[] nexts; public Node(K key, V value, int level) &#123; this.key = key; this.value = value; nexts = new Node[level]; &#125; @Override public String toString() &#123; return key + ":" + value + "_" + nexts.length; &#125;&#125; è·³è¡¨çš„æœç´¢â‘  ä»é¡¶å±‚é“¾è¡¨çš„é¦–å…ƒç´ å¼€å§‹ï¼Œä»å·¦å¾€å³æœç´¢ï¼Œç›´è‡³æ‰¾åˆ°ä¸€ä¸ªå¤§äºæˆ–ç­‰äºç›®æ ‡çš„å…ƒç´ ï¼Œæˆ–è€…åˆ°è¾¾å½“å‰å±‚é“¾è¡¨çš„å°¾éƒ¨ â‘¡ å¦‚æœè¯¥å…ƒç´ ç­‰äºç›®æ ‡å…ƒç´ ï¼Œåˆ™è¡¨æ˜è¯¥å…ƒç´ å·²è¢«æ‰¾åˆ° â‘¢ å¦‚æœè¯¥å…ƒç´ å¤§äºç›®æ ‡å…ƒç´ æˆ–å·²åˆ°è¾¾é“¾è¡¨çš„å°¾éƒ¨ï¼Œåˆ™é€€å›åˆ°å½“å‰å±‚çš„å‰ä¸€ä¸ªå…ƒç´ ï¼Œç„¶åè½¬å…¥ä¸‹ä¸€å±‚è¿›è¡Œæœç´¢ ä¸¾ä¾‹ï¼š æŸ¥æ‰¾å­˜åœ¨çš„ $17$ ä»é¦–èŠ‚ç‚¹ $first$ çš„é¡¶å±‚é“¾è¡¨å¼€å§‹ï¼Œæ‰¾åˆ° $21$ï¼Œ$21&gt;17$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $first$ ï¼Œå±‚æ•° $-1$ï¼Œ ä» $first$ å‡ºå‘,æ‰¾åˆ° $9$ï¼Œ$9 &lt; 17$ï¼Œç»§ç»­å¾€åæ‰¾ï¼Œæ‰¾åˆ° $21$ï¼Œ$21 &gt; 17$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $9$ ï¼Œå±‚æ•° $-1$, ä» $9$ å‡ºå‘ï¼Œæ‰¾åˆ° $17$ï¼Œ$17==17$ï¼Œæ‰¾åˆ°äº†è¯¥å…ƒç´  æŸ¥æ‰¾ä¸å­˜åœ¨çš„ $18$ ä»é¦–èŠ‚ç‚¹ $first$ çš„é¡¶å±‚é“¾è¡¨å¼€å§‹ï¼Œæ‰¾åˆ° $21$ï¼Œ$21&gt;18$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $first$ ï¼Œå±‚æ•° $-1$ï¼Œ ä» $first$ å‡ºå‘,æ‰¾åˆ° $9$ï¼Œ$9 &lt; 18$ï¼Œç»§ç»­å¾€åæ‰¾ï¼Œæ‰¾åˆ° $21$ï¼Œ$21 &gt; 18$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $9$ ï¼Œå±‚æ•° $-1$, ä» $9$ å‡ºå‘ï¼Œæ‰¾åˆ° $17$ï¼Œ$17 &lt; 18$ï¼Œç»§ç»­å¾€åæ‰¾ï¼Œæ‰¾åˆ° $21$ï¼Œ$21&gt;18$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $17$ï¼Œå±‚æ•° $-1$, ä» $17$ å‡ºå‘ï¼Œæ‰¾åˆ° $19$ï¼Œ$19 &gt; 18$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $17$ï¼Œå±‚æ•° $-1$, å‘ç°æ˜¯åœ¨æœ€åä¸€å±‚ï¼Œè¿”å› $false$ï¼Œæ²¡æœ‰æ‰¾åˆ° 12345678910111213141516171819202122232425public V get(K key) &#123; keyCheck(key); // ä¸¾ä¾‹ï¼š // first.nexts[3] == 21èŠ‚ç‚¹ // first.nexts[2] == 9èŠ‚ç‚¹ // first.nexts[1] == 6èŠ‚ç‚¹ // first.nexts[0] == 3èŠ‚ç‚¹ // level = 4 Node&lt;K, V&gt; node = first; for (int i = level - 1; i &gt;= 0; i--) &#123; int cmp = -1; // ä¸€ä¸ªæŠ€å·§ï¼š // ç›´æ¥è®©nodeçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹è·Ÿä¼ å…¥çš„å€¼åšæ¯”è¾ƒ // ä¼ å…¥çš„å€¼è¾ƒå°æ—¶ï¼Œå°±ä¸ç”¨é€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; // æ‰¾åˆ°keyå€¼äº†ï¼Œå¯ä»¥ä¸ç”¨å…ˆé€€å‡ºï¼Œå±‚æ•°ä¼šä¸æ–­-1 // ä¾‹å¦‚ 17ï¼Œåœ¨level == 1 æ—¶ å°±æ‰¾åˆ°äº† if (cmp == 0) return node.nexts[i].value; &#125; return null;&#125; è·³è¡¨çš„æ·»åŠ  æ·»åŠ çš„ç»†èŠ‚ éšæœºå†³å®šæ–°æ·»åŠ å…ƒç´ çš„å±‚æ•° å¯»æ‰¾èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨æ—¶ï¼Œä¸€å®šè¦éå†å®Œæ‰€æœ‰å±‚æ•°ï¼Œæ‰¾åˆ°æ–°æ·»åŠ èŠ‚ç‚¹çš„æ‰€æœ‰å‰é©±èŠ‚ç‚¹ å‰é©±èŠ‚ç‚¹å¯ä»¥è®¤ä¸ºæ˜¯å±‚æ•° $-1$ æ—¶ï¼Œå½“æ—¶çš„èŠ‚ç‚¹å°±æ˜¯å‰é©±èŠ‚ç‚¹ ä¸¾ä¾‹ï¼š æ·»åŠ ä¸å­˜åœ¨çš„èŠ‚ç‚¹ $17$ ä»é¦–èŠ‚ç‚¹ $first[3]$ çš„é¡¶å±‚é“¾è¡¨å¼€å§‹ï¼Œæ‰¾åˆ° $6$ï¼Œ$6 &lt; 17$ï¼Œç»§ç»­å¾€åæ‰¾ï¼Œæ‰¾åˆ° $NULL$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $6$ ï¼Œå±‚æ•° $-1$ï¼Œä¿å­˜å‰é©±èŠ‚ç‚¹ $6[3]$ ä» $6[2]$ å‡ºå‘,æ‰¾åˆ° $25$ï¼Œ$25 &gt; 17$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $6 [2]$ ï¼Œå±‚æ•° $-1$ï¼Œä¿å­˜å‰é©±èŠ‚ç‚¹ $6[2]$ ä» $6[1]$ å‡ºå‘ï¼Œæ‰¾åˆ° $9$ï¼Œ$9 &lt; 17$ï¼Œç»§ç»­å¾€åæ‰¾ï¼Œæ‰¾åˆ°$25$ï¼Œ$25 &gt; 17$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $9$ï¼Œå±‚æ•° $-1$ï¼Œä¿å­˜å‰é©±èŠ‚ç‚¹ $9[1]$ ä» $9[0]$ å‡ºå‘ï¼Œæ‰¾åˆ° $12$ï¼Œ$12 &lt; 17$ï¼Œç»§ç»­å¾€åæ‰¾ï¼Œæ‰¾åˆ° $19$ï¼Œ$19 &gt; 17$ï¼Œé€€å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $12$ï¼Œå±‚æ•° $-1$ï¼Œä¿å­˜å‰é©±èŠ‚ç‚¹ $12[0]$ å‘ç°å±‚æ•°ä¸º $0$ äº†ï¼Œæ‰¾åˆ° $17$ æ·»åŠ çš„ä½ç½®äº†ï¼Œå‰é©±èŠ‚ç‚¹åˆ†åˆ«ä¸º $6[3],6[2],9[1],12[0]$ ä¸‹é¢åªéœ€æ›´æ”¹å‰é©±èŠ‚ç‚¹å’Œæ–°èŠ‚ç‚¹çš„æŒ‡å‘å°±è¡Œ æ·»åŠ å­˜åœ¨çš„èŠ‚ç‚¹ $9$ æ–¹æ³•ä¸ä¸Šé¢ç±»ä¼¼ï¼Œæ‰¾åˆ°è¯¥èŠ‚ç‚¹çš„ä½ç½®ï¼Œæ›´æ”¹è¯¥èŠ‚ç‚¹çš„ $value$ï¼Œè¿”å› $oldvalue$ å°±è¡Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public V put(K key, V value) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; // å‰é©±èŠ‚ç‚¹çš„ä¸ªæ•°å°±æ˜¯å±‚æ•° $level Node&lt;K, V&gt;[] prevs = new Node[level]; for (int i = level - 1; i &gt;= 0; i--) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; if (cmp == 0) &#123; // èŠ‚ç‚¹æ˜¯å­˜åœ¨çš„ V oldV = node.nexts[i].value; node.nexts[i].value = value; return oldV; &#125; // ä¿å­˜å‰é©±èŠ‚ç‚¹ prevs[i] = node; &#125; // éšæœºäº§ç”Ÿæ–°èŠ‚ç‚¹çš„å±‚æ•° int newLevel = randomLevel(); // æ·»åŠ æ–°èŠ‚ç‚¹ Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, newLevel); // è®¾ç½®å‰é©±å’Œåç»§ for (int i = 0; i &lt; newLevel; i++) &#123; // æ–°èŠ‚ç‚¹çš„å±‚æ•°å¯èƒ½æ¯”åŸæ¥çš„å¤§ if (i &gt;= level) &#123; first.nexts[i] = newNode; &#125; else &#123; newNode.nexts[i] = prevs[i].nexts[i]; prevs[i].nexts[i] = newNode; &#125; &#125; // èŠ‚ç‚¹æ•°é‡å¢åŠ  size++; // è®¡ç®—è·³è¡¨çš„æœ€ç»ˆå±‚æ•° level = Math.max(level, newLevel); return null;&#125; è·³è¡¨çš„åˆ é™¤åˆ é™¤çš„ç»†èŠ‚ åˆ é™¤ä¸€ä¸ªå…ƒç´ åï¼Œæ•´ä¸ªè·³è¡¨çš„å±‚æ•°å¯èƒ½ä¼šé™ä½ æ‰¾åˆ°å…ƒç´ åï¼Œä¸èƒ½æå‰é€€å‡ºï¼Œè¦æ‰¾åˆ°è¦åˆ é™¤èŠ‚ç‚¹çš„å…¨éƒ¨å‰é©±èŠ‚ç‚¹ 123456789101112131415161718192021222324252627282930313233343536public V remove(K key) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; Node&lt;K, V&gt;[] prevs = new Node[level]; boolean exist = false; for (int i = level - 1; i &gt;= 0; i--) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; prevs[i] = node; if (cmp == 0) exist = true; &#125; if (!exist) return null; // éœ€è¦è¢«åˆ é™¤çš„èŠ‚ç‚¹ Node&lt;K, V&gt; removedNode = node.nexts[0]; // æ•°é‡å‡å°‘ size--; // è®¾ç½®åç»§ for (int i = 0; i &lt; removedNode.nexts.length; i++) &#123; prevs[i].nexts[i] = removedNode.nexts[i]; &#125; // æ›´æ–°è·³è¡¨çš„å±‚æ•° int newLevel = level; while (--newLevel &gt;= 0 &amp;&amp; first.nexts[newLevel] == null) &#123; level = newLevel; &#125; return removedNode.value;&#125; è·³è¡¨çš„å±‚æ•°è·³è¡¨æ˜¯æŒ‰å±‚æ„é€ çš„ï¼Œåº•å±‚æ˜¯ä¸€ä¸ªæ™®é€šçš„æœ‰åºé“¾è¡¨ï¼Œé«˜å±‚ç›¸å½“äºæ˜¯ä½å±‚çš„ â€œå¿«é€Ÿé€šé“â€ åœ¨ç¬¬ $i$ å±‚ä¸­çš„å…ƒç´ æŒ‰æŸä¸ªå›ºå®šçš„æ¦‚ç‡ $p$ï¼ˆé€šå¸¸ä¸º $\frac{1}{2}$ æˆ– $\frac{1}{4}$ å‡ºç°åœ¨ç¬¬ $i + 1$å±‚ä¸­ï¼Œäº§ç”Ÿè¶Šé«˜çš„å±‚æ•°ï¼Œæ¦‚ç‡è¶Šä½ å…ƒç´ å±‚æ•°æ°å¥½ç­‰äº $1$ çš„æ¦‚ç‡ä¸º $1 â€“ p$ å…ƒç´ å±‚æ•°å¤§äºç­‰äº $2$ çš„æ¦‚ç‡ä¸º $p$ï¼Œè€Œå…ƒç´ å±‚æ•°æ°å¥½ç­‰äº $2$ çš„æ¦‚ç‡ä¸º $p * (1 â€“ p)$ å…ƒç´ å±‚æ•°å¤§äºç­‰äº $3$ çš„æ¦‚ç‡ä¸º $p^2$ï¼Œè€Œå…ƒç´ å±‚æ•°æ°å¥½ç­‰äº $3$ çš„æ¦‚ç‡ä¸º $p^2 * (1 â€“ p)$ å…ƒç´ å±‚æ•°å¤§äºç­‰äº $4$ çš„æ¦‚ç‡ä¸º $p^3$ï¼Œè€Œå…ƒç´ å±‚æ•°æ°å¥½ç­‰äº $4$ çš„æ¦‚ç‡ä¸º $p^3 * (1 â€“ p)$ $\ldots\ldots$ ä¸€ä¸ªå…ƒç´ çš„å¹³å‡å±‚æ•°æ˜¯ $\frac{1}{(1 â€“ p)}$ 1\times(1-p)+2p(1-p)+3p^2(1-p)+4p^3(1-p)+\ldots=(1-p) \sum_{k=1}^{+\infty}kp^{k-1}=(1-p)\cdot \frac{1}{(1-p)^2}= \frac{1}{1-p}å½“ $p = \frac12$ æ—¶ï¼Œæ¯ä¸ªå…ƒç´ æ‰€åŒ…å«çš„å¹³å‡æŒ‡é’ˆæ•°é‡æ˜¯ $2$ å½“ $p = \frac14$ æ—¶ï¼Œæ¯ä¸ªå…ƒç´ æ‰€åŒ…å«çš„å¹³å‡æŒ‡é’ˆæ•°é‡æ˜¯ $1.33$ è·³è¡¨çš„å¤æ‚åº¦åˆ†ææ¯ä¸€å±‚çš„å…ƒç´ æ•°é‡ ç¬¬ $1$ å±‚é“¾è¡¨å›ºå®šæœ‰ $n$ ä¸ªå…ƒç´  ç¬¬ $2$ å±‚é“¾è¡¨å¹³å‡æœ‰ $n * p$ ä¸ªå…ƒç´  ç¬¬ $3$ å±‚é“¾è¡¨å¹³å‡æœ‰ $n * p^2$ ä¸ªå…ƒç´  ç¬¬ $k$ å±‚é“¾è¡¨å¹³å‡æœ‰ $n * p^k$ ä¸ªå…ƒç´  $\ldots\ldots$ å¦å¤– æœ€é«˜å±‚çš„å±‚æ•°æ˜¯ $log_\frac1p n$ï¼Œå¹³å‡æœ‰ä¸ª $\frac1p$ å…ƒç´  åœ¨æœç´¢æ—¶ï¼Œæ¯ä¸€å±‚é“¾è¡¨çš„é¢„æœŸæŸ¥æ‰¾æ­¥æ•°æœ€å¤šæ˜¯ $\frac1p$ï¼Œæ‰€ä»¥æ€»çš„æŸ¥æ‰¾æ­¥æ•°æ˜¯ $â€“(log_p\frac np)$ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(logn)$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>è·³è¡¨</tag>
        <tag>SkipList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¸ƒéš†è¿‡æ»¤å™¨]]></title>
    <url>%2F2020%2F07%2F21%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[å¸ƒéš†è¿‡æ»¤å™¨ï¼ˆBloom Filterï¼‰æ€è€ƒ å¦‚æœè¦ç»å¸¸åˆ¤æ–­ 1 ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œä½ ä¼šæ€ä¹ˆåšï¼Ÿ å¾ˆå®¹æ˜“æƒ³åˆ°ä½¿ç”¨å“ˆå¸Œè¡¨ï¼ˆ$HashSetã€HashMap$ï¼‰ï¼Œå°†å…ƒç´ ä½œä¸º $key$ å»æŸ¥æ‰¾ æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$ï¼Œä½†æ˜¯ç©ºé—´åˆ©ç”¨ç‡ä¸é«˜ï¼Œéœ€è¦å ç”¨æ¯”è¾ƒå¤šçš„å†…å­˜èµ„æº å¦‚æœéœ€è¦ç¼–å†™ä¸€ä¸ªç½‘ç»œçˆ¬è™«å»çˆ¬ $10äº¿$ ä¸ªç½‘ç«™æ•°æ®ï¼Œä¸ºäº†é¿å…çˆ¬åˆ°é‡å¤çš„ç½‘ç«™ï¼Œå¦‚ä½•åˆ¤æ–­æŸä¸ªç½‘ç«™æ˜¯å¦çˆ¬è¿‡ï¼Ÿ å¾ˆæ˜¾ç„¶ï¼Œ$HashSetã€HashMap$ å¹¶ä¸æ˜¯éå¸¸å¥½çš„é€‰æ‹© æ˜¯å¦å­˜åœ¨æ—¶é—´å¤æ‚åº¦ä½ã€å ç”¨å†…å­˜è¾ƒå°‘çš„æ–¹æ¡ˆï¼Ÿ å¸ƒéš†è¿‡æ»¤å™¨$ï¼ˆBloom Filterï¼‰$ å¸ƒéš†è¿‡æ»¤å™¨ - æ˜¯ä»€ä¹ˆ 1970å¹´ç”±å¸ƒéš†æå‡º å®ƒæ˜¯ä¸€ä¸ªç©ºé—´æ•ˆç‡é«˜çš„æ¦‚ç‡å‹æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨æ¥å‘Šè¯‰ä½ ï¼šä¸€ä¸ªå…ƒç´ ä¸€å®šä¸å­˜åœ¨æˆ–è€…å¯èƒ½å­˜åœ¨ ä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ï¼šç©ºé—´æ•ˆç‡å’ŒæŸ¥è¯¢æ—¶é—´éƒ½è¿œè¿œè¶…è¿‡ä¸€èˆ¬çš„ç®—æ³• ç¼ºç‚¹ï¼šæœ‰ä¸€å®šçš„è¯¯åˆ¤ç‡ã€åˆ é™¤å›°éš¾ å®ƒå®è´¨ä¸Šæ˜¯ä¸€ä¸ªå¾ˆé•¿çš„äºŒè¿›åˆ¶å‘é‡å’Œä¸€ç³»åˆ—éšæœºæ˜ å°„å‡½æ•°ï¼ˆHashå‡½æ•°ï¼‰ å¸¸è§åº”ç”¨ ç½‘é¡µé»‘åå•ç³»ç»Ÿã€åƒåœ¾é‚®ä»¶è¿‡æ»¤ç³»ç»Ÿã€çˆ¬è™«çš„ç½‘å€åˆ¤é‡ç³»ç»Ÿã€è§£å†³ç¼“å­˜ç©¿é€é—®é¢˜ å¸ƒéš†è¿‡æ»¤å™¨ - åŸç†å‡è®¾å¸ƒéš†è¿‡æ»¤å™¨ç”± $20$ ä½äºŒè¿›åˆ¶ã€ $3$ ä¸ªå“ˆå¸Œå‡½æ•°ç»„æˆï¼Œæ¯ä¸ªå…ƒç´ ç»è¿‡å“ˆå¸Œå‡½æ•°å¤„ç†éƒ½èƒ½ç”Ÿæˆä¸€ä¸ªç´¢å¼•ä½ç½® æ·»åŠ å…ƒç´ ï¼šå°†æ¯ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ç”Ÿæˆçš„ç´¢å¼•ä½ç½®éƒ½è®¾ä¸º $1$ æŸ¥è¯¢å…ƒç´ æ˜¯å¦å­˜åœ¨ å¦‚æœæœ‰ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ç”Ÿæˆçš„ç´¢å¼•ä½ç½®ä¸ä¸º $1$ï¼Œå°±ä»£è¡¨ä¸å­˜åœ¨ï¼ˆ$100\%$ å‡†ç¡®ï¼‰ å¦‚æœæ¯ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ç”Ÿæˆçš„ç´¢å¼•ä½ç½®éƒ½ä¸º $1$ï¼Œå°±ä»£è¡¨å­˜åœ¨ï¼ˆå­˜åœ¨ä¸€å®šçš„è¯¯åˆ¤ç‡ï¼‰ æ·»åŠ ã€æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ï¼š$O(k)$ ï¼Œ$k$ æ˜¯å“ˆå¸Œå‡½æ•°çš„ä¸ªæ•°ã€‚ç©ºé—´å¤æ‚åº¦æ˜¯ï¼š$O(m)$ ï¼Œ$m$ æ˜¯äºŒè¿›åˆ¶ä½çš„ä¸ªæ•° å¸ƒéš†è¿‡æ»¤å™¨ - è¯¯åˆ¤ç‡è¯¯åˆ¤ç‡ $p$ å— $3$ ä¸ªå› ç´ å½±å“ï¼šäºŒè¿›åˆ¶ä½çš„ä¸ªæ•° $m$ã€å“ˆå¸Œå‡½æ•°çš„ä¸ªæ•° $k$ã€æ•°æ®è§„æ¨¡ $n$ p = (1 - e^{-\frac{k(n+0.5)}{m-1}})^k â‰ˆ (1 - e^{-\frac{kn}{m}})^kå·²çŸ¥è¯¯åˆ¤ç‡ $p$ã€æ•°æ®è§„æ¨¡ $n$ï¼Œæ±‚äºŒè¿›åˆ¶ä½çš„ä¸ªæ•° $m$ã€å“ˆå¸Œå‡½æ•°çš„ä¸ªæ•° $k$ m = - \frac{nlnp}{(ln2)^2} \\ k = \frac{m}{n} ln2å¸ƒéš†è¿‡æ»¤å™¨ - å®ç°å¸ƒéš†è¿‡æ»¤å™¨ - åŸºæœ¬å®šä¹‰æ•°æ®çš„å­˜æ”¾æ ¼å¼æ˜¯æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„å­˜æ”¾ç€Longä¸ªå­—èŠ‚ 123456789101112131415161718192021222324252627282930313233343536373839public class BloomFilter&lt;T&gt; &#123; /** * äºŒè¿›åˆ¶å‘é‡çš„é•¿åº¦(ä¸€å…±æœ‰å¤šå°‘ä¸ªäºŒè¿›åˆ¶ä½) */ private int bitSize; /** * äºŒè¿›åˆ¶å‘é‡ */ private long[] bits; /** * å“ˆå¸Œå‡½æ•°çš„ä¸ªæ•° */ private int hashSize; /** * @param n æ•°æ®è§„æ¨¡ * @param p è¯¯åˆ¤ç‡, å–å€¼èŒƒå›´(0, 1) */ public BloomFilter(int n, double p) &#123; if (n &lt;= 0 || p &lt;= 0 || p &gt;= 1) &#123; throw new IllegalArgumentException("wrong n or p"); &#125; // ä¸‹é¢ä¸‰ä¸ªå‚æ•°æ˜¯æ ¹æ®å…¬å¼è®¡ç®—çš„ double ln2 = Math.log(2); // æ±‚å‡ºäºŒè¿›åˆ¶å‘é‡çš„é•¿åº¦ bitSize = (int) (- (n * Math.log(p)) / (ln2 * ln2)); // æ±‚å‡ºå“ˆå¸Œå‡½æ•°çš„ä¸ªæ•° hashSize = (int) (bitSize * ln2 / n); // bitsæ•°ç»„çš„é•¿åº¦ bits = new long[(bitSize + Long.SIZE - 1) / Long.SIZE]; &#125; private void nullCheck(T value) &#123; if (value == null) &#123; throw new IllegalArgumentException("Value must not be null."); &#125; &#125;&#125; å¸ƒéš†è¿‡æ»¤å™¨ - è®¾ç½®indexä½ç½®çš„äºŒè¿›ä½ä¸º1(æŒ‰ä½æˆ– | ) $101010101010010101$ $\mid 000000000000000100$ $(1 &lt;&lt; index)$ $101010111010010101$ 123456789private boolean set(int index) &#123; // ï¼ˆindex / Long.SIZEï¼‰ indexåœ¨æ•°ç»„ä¸­çš„ä¸‹æ ‡ // valueæ”¹ä¸‹æ ‡çš„å€¼ long value = bits[index / Long.SIZE]; int bitValue = 1 &lt;&lt; (index % Long.SIZE); bits[index / Long.SIZE] = value | bitValue; return (value &amp; bitValue) == 0;&#125; å¸ƒéš†è¿‡æ»¤å™¨ - æŸ¥çœ‹indexä½ç½®çš„äºŒè¿›ä½çš„å€¼ $101010101010010101$ &amp;$000000000000000100$ $(1 &lt;&lt; index)$ $000000000000000100$ 123456// @return trueä»£è¡¨1, falseä»£è¡¨0private boolean get(int index) &#123; long value = bits[index / Long.SIZE]; int bitValue = 1 &lt;&lt; (index % Long.SIZE); return (value &amp; bitValue) != 0;&#125; å¸ƒéš†è¿‡æ»¤å™¨ - æ·»åŠ å…ƒç´ 1234567891011121314151617181920public boolean put(T value) &#123; nullCheck(value); // åˆ©ç”¨valueç”Ÿæˆ2ä¸ªæ•´æ•° int hash1 = value.hashCode(); int hash2 = hash1 &gt;&gt;&gt; 16; boolean result = false; for (int i = 1; i &lt;= hashSize; i++) &#123; int combinedHash = hash1 + (i * hash2); if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; // ç”Ÿæˆä¸€ä¸ªäºŒè¿›ä½çš„ç´¢å¼• int index = combinedHash % bitSize; // è®¾ç½®indexä½ç½®çš„äºŒè¿›ä½ä¸º1 if (set(index)) result = true; &#125; return result;&#125; å¸ƒéš†è¿‡æ»¤å™¨ - åˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨123456789101112131415161718public boolean contains(T value) &#123; nullCheck(value); // åˆ©ç”¨valueç”Ÿæˆ2ä¸ªæ•´æ•° int hash1 = value.hashCode(); int hash2 = hash1 &gt;&gt;&gt; 16; for (int i = 1; i &lt;= hashSize; i++) &#123; int combinedHash = hash1 + (i * hash2); if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; // ç”Ÿæˆä¸€ä¸ªäºŒè¿›ä½çš„ç´¢å¼• int index = combinedHash % bitSize; // æŸ¥è¯¢indexä½ç½®çš„äºŒè¿›ä½æ˜¯å¦ä¸º0 if (!get(index)) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å¸ƒéš†è¿‡æ»¤å™¨</tag>
        <tag>BloomFilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ¨æ€è§„åˆ’]]></title>
    <url>%2F2020%2F07%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰åŠ¨æ€è§„åˆ’ - æ˜¯ä»€ä¹ˆåŠ¨æ€è§„åˆ’ï¼Œç®€ç§° $DP$ æ˜¯æ±‚è§£æœ€ä¼˜åŒ–é—®é¢˜çš„ä¸€ç§å¸¸ç”¨ç­–ç•¥ é€šå¸¸çš„ä½¿ç”¨å¥—è·¯ï¼ˆä¸€æ­¥ä¸€æ­¥ä¼˜åŒ–ï¼‰ â‘  æš´åŠ›é€’å½’ï¼ˆè‡ªé¡¶å‘ä¸‹ï¼Œå‡ºç°äº†é‡å å­é—®é¢˜ï¼‰ â‘¡ è®°å¿†åŒ–æœç´¢ï¼ˆè‡ªé¡¶å‘ä¸‹ï¼‰ â‘¢ é€’æ¨ï¼ˆè‡ªåº•å‘ä¸Šï¼‰ åŠ¨æ€è§„åˆ’ - å¸¸è§„æ­¥éª¤åŠ¨æ€è§„åˆ’ä¸­çš„â€œåŠ¨æ€â€å¯ä»¥ç†è§£ä¸ºæ˜¯â€œä¼šå˜åŒ–çš„çŠ¶æ€â€ â‘  å®šä¹‰çŠ¶æ€ï¼ˆçŠ¶æ€æ˜¯åŸé—®é¢˜ã€å­é—®é¢˜çš„è§£ï¼‰ â€‹ æ¯”å¦‚å®šä¹‰ $dp(i)$ çš„å«ä¹‰ â‘¡ è®¾ç½®åˆå§‹çŠ¶æ€ï¼ˆè¾¹ç•Œï¼‰ â€‹ æ¯”å¦‚è®¾ç½® $dp(0)$ çš„å€¼ â‘¢ ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹ â€‹ æ¯”å¦‚ç¡®å®š $dp(i)$ å’Œ $dp(i â€“ 1)$ çš„å…³ç³» åŠ¨æ€è§„åˆ’ - ä¸€äº›ç›¸å…³æ¦‚å¿µæ¥è‡ªç»´åŸºç™¾ç§‘çš„è§£é‡Š Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions. â‘  å°†å¤æ‚çš„åŸé—®é¢˜æ‹†è§£æˆè‹¥å¹²ä¸ªç®€å•çš„å­é—®é¢˜ â‘¡ æ¯ä¸ªå­é—®é¢˜ä»…ä»…è§£å†³1æ¬¡ï¼Œå¹¶ä¿å­˜å®ƒä»¬çš„è§£ â‘¢ æœ€åæ¨å¯¼å‡ºåŸé—®é¢˜çš„è§£ å¯ä»¥ç”¨åŠ¨æ€è§„åˆ’æ¥è§£å†³çš„é—®é¢˜ï¼Œé€šå¸¸å…·å¤‡ $2$ ä¸ªç‰¹ç‚¹ æœ€ä¼˜å­ç»“æ„ï¼ˆæœ€ä¼˜åŒ–åŸç†ï¼‰ï¼šé€šè¿‡æ±‚è§£å­é—®é¢˜çš„æœ€ä¼˜è§£ï¼Œå¯ä»¥è·å¾—åŸé—®é¢˜çš„æœ€ä¼˜è§£ æ— åæ•ˆæ€§ æŸé˜¶æ®µçš„çŠ¶æ€ä¸€æ—¦ç¡®å®šï¼Œåˆ™æ­¤åè¿‡ç¨‹çš„æ¼”å˜ä¸å†å—æ­¤å‰å„çŠ¶æ€åŠå†³ç­–çš„å½±å“ï¼ˆæœªæ¥ä¸è¿‡å»æ— å…³ï¼‰ åœ¨æ¨å¯¼åé¢é˜¶æ®µçš„çŠ¶æ€æ—¶ï¼Œåªå…³å¿ƒå‰é¢é˜¶æ®µçš„å…·ä½“çŠ¶æ€å€¼ï¼Œä¸å…³å¿ƒè¿™ä¸ªçŠ¶æ€æ˜¯æ€ä¹ˆä¸€æ­¥æ­¥æ¨å¯¼å‡ºæ¥çš„ ç»ƒä¹ 1 â€“ æ‰¾é›¶é’±LeetCodeåœ°å€ å‡è®¾æœ‰ $25$ åˆ†ã€$20$ åˆ†ã€$5$ åˆ†ã€$1$ åˆ†çš„ç¡¬å¸ï¼Œç°è¦æ‰¾ç»™å®¢æˆ· $41$ åˆ†çš„é›¶é’±ï¼Œå¦‚ä½•åŠåˆ°ç¡¬å¸ä¸ªæ•°æœ€å°‘ï¼Ÿ æ­¤å‰ç”¨è´ªå¿ƒç­–ç•¥å¾—åˆ°çš„å¹¶éæ˜¯æœ€ä¼˜è§£ï¼ˆè´ªå¿ƒå¾—åˆ°çš„è§£æ˜¯ $5$ æšç¡¬å¸ï¼‰ å‡è®¾ $dp(n)$ æ˜¯å‡‘åˆ° $n$ åˆ†éœ€è¦çš„æœ€å°‘ç¡¬å¸ä¸ªæ•° å¦‚æœç¬¬ $1$ æ¬¡é€‰æ‹©äº† $25$ åˆ†çš„ç¡¬å¸ï¼Œé‚£ä¹ˆ $dp(n) = dp(n â€“ 25) + 1$ å¦‚æœç¬¬ $1$ æ¬¡é€‰æ‹©äº† $20$ åˆ†çš„ç¡¬å¸ï¼Œé‚£ä¹ˆ $dp(n) = dp(n â€“ 20) + 1$ å¦‚æœç¬¬ $1$ æ¬¡é€‰æ‹©äº† $5$ åˆ†çš„ç¡¬å¸ï¼Œé‚£ä¹ˆ $dp(n) = dp(n â€“ 5) + 1$ å¦‚æœç¬¬ $1$ æ¬¡é€‰æ‹©äº† $1$ åˆ†çš„ç¡¬å¸ï¼Œé‚£ä¹ˆ $dp(n) = dp(n â€“ 1) + 1$ æ‰€ä»¥ $dp(n) = min \{ dp(n â€“ 25), dp(n â€“ 20), dp(n â€“ 5), dp(n â€“ 1) \} + 1$ æ‰¾é›¶é’± â€“ æš´åŠ›é€’å½’12345678// æš´åŠ›é€’å½’ï¼ˆè‡ªé¡¶å‘ä¸‹çš„è°ƒç”¨ï¼Œå‡ºç°äº†é‡å å­é—®é¢˜ï¼‰static int coins(int n) &#123; if (n &lt; 1) return Integer.MAX_VALUE; if (n == 25 || n == 20 || n == 5 || n == 1) return 1; int min1 = Math.min(coins(n - 25), coins(n - 20)); int min2 = Math.min(coins(n - 5), coins(n - 1)); return Math.min(min1, min2) + 1;&#125; ç±»ä¼¼äºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„é€’å½’ç‰ˆï¼Œä¼šæœ‰å¤§é‡çš„é‡å¤è®¡ç®—ï¼Œæ—¶é—´å¤æ‚åº¦è¾ƒé«˜ æ‰¾é›¶é’± â€“ è®°å¿†åŒ–æœç´¢1234567891011121314151617181920212223// è®°å¿†åŒ–æœç´¢ï¼ˆè‡ªé¡¶å‘ä¸‹çš„è°ƒç”¨ï¼‰static int coins(int n) &#123; if (n &lt; 1) return -1; int[] dp = new int[n + 1]; // åˆ¤æ–­ä¼ å…¥çš„ n æ˜¯å¦å¤§äºé¢å€¼ int[] faces = &#123;1, 5, 20, 25&#125;; for (int face : faces) &#123; if (n &lt; face) break; dp[face] = 1; &#125; return coins(n, dp);&#125;static int coins(int n, int[] dp) &#123; if (n &lt; 1) return Integer.MAX_VALUE; if (dp[n] == 0) &#123; int min1 = Math.min(coins(n - 25, dp), coins(n - 20, dp)); int min2 = Math.min(coins(n - 5, dp), coins(n - 1, dp)); dp[n] = Math.min(min1, min2) + 1; &#125; return dp[n];&#125; æ‰¾é›¶é’± â€“ é€’æ¨12345678910111213// é€’æ¨ï¼ˆè‡ªåº•å‘ä¸Šï¼‰static int coins3(int n) &#123; if (n &lt; 1) return -1; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; int min = dp[i - 1]; if (i &gt;= 5) min = Math.min(dp[i - 5], min); if (i &gt;= 20) min = Math.min(dp[i - 20], min); if (i &gt;= 25) min = Math.min(dp[i - 25], min); dp[i] = min + 1; &#125; return dp[n];&#125; æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ è¾“å‡ºæ‰¾é›¶é’±çš„å…·ä½“æ–¹æ¡ˆ123456789101112131415161718192021222324252627282930313233343536static int coins4(int n) &#123; if (n &lt; 1) return -1; int[] dp = new int[n + 1]; // faces[i]æ˜¯å‡‘å¤Ÿiåˆ†æ—¶æœ€åé‚£æšç¡¬å¸çš„é¢å€¼ int[] faces = new int[dp.length]; for (int i = 1; i &lt;= n; i++) &#123; int min = dp[i - 1]; faces[i] = 1; if (i &gt;= 5 &amp;&amp; dp[i - 5] &lt; min) &#123; min = dp[i - 5]; faces[i] = 5; &#125; if (i &gt;= 20 &amp;&amp; dp[i - 20] &lt; min) &#123; min = dp[i - 20]; faces[i] = 20; &#125; if (i &gt;= 25 &amp;&amp; dp[i - 25] &lt; min) &#123; min = dp[i - 25]; faces[i] = 25; &#125; dp[i] = min + 1; print(faces, i); &#125; // print(faces, n); return dp[n];&#125;static void print(int[] faces, int n) &#123; System.out.print("[" + n + "] = "); while (n &gt; 0) &#123; System.out.print(faces[n] + " "); n -= faces[n]; &#125; System.out.println();&#125; æ‰¾é›¶é’± â€“ é€šç”¨å®ç°12345678910111213141516171819static int coins5(int n, int[] faces) &#123; if (n &lt; 1 || faces == null || faces.length == 0) return -1; int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; int min = Integer.MAX_VALUE; for (int face : faces) &#123; if (i &lt; face) continue; int v = dp[i - face]; if (v &lt; 0 || v &gt;= min) continue; min = v; &#125; if (min == Integer.MAX_VALUE) &#123; dp[i] = -1; &#125; else &#123; dp[i] = min + 1; &#125; &#125; return dp[n];&#125; ç»ƒä¹ 2 â€“ æœ€å¤§è¿ç»­å­åºåˆ—å’Œç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•´æ•°åºåˆ—ï¼Œæ±‚å®ƒçš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œ æ¯”å¦‚ $â€“2ã€1ã€â€“3ã€4ã€â€“1ã€2ã€1ã€â€“5ã€4$ çš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œæ˜¯ $4 + (â€“1) + 2 + 1 = 6$ çŠ¶æ€å®šä¹‰ å‡è®¾ $dp(i)$ æ˜¯ä»¥ $nums[i]$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œï¼ˆ$nums$ æ˜¯æ•´ä¸ªåºåˆ—ï¼‰ ä»¥ $nums[0] â€“ 2$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $â€“2$ï¼Œæ‰€ä»¥ $dp(0) = â€“2$ ä»¥ $nums[1] 1$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $1$ï¼Œæ‰€ä»¥ $dp(1) = 1$ ä»¥ $nums[2] â€“3$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $1ã€â€“3$ï¼Œæ‰€ä»¥ $dp(2) = dp(1) + (â€“3) = â€“2$ ä»¥ $nums[3] 4$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $4$ï¼Œæ‰€ä»¥ $dp(3) = 4$ ä»¥ $nums[4] â€“1$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $4ã€â€“1$ï¼Œæ‰€ä»¥ $dp(4) = dp(3) + (â€“1) = 3$ ä»¥ $nums[5] 2$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $4ã€â€“1ã€2$ï¼Œæ‰€ä»¥ $dp(5) = dp(4) + 2 = 5$ ä»¥ $nums[6] 1$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $4ã€â€“1ã€2ã€1$ï¼Œæ‰€ä»¥ $dp(6) = dp(5) + 1 = 6$ ä»¥ $nums[7] â€“5$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $4ã€â€“1ã€2ã€1ã€â€“5$ï¼Œæ‰€ä»¥ $dp(7) = dp(6) + (â€“5) = 1$ ä»¥ $nums[8] 4$ ç»“å°¾çš„æœ€å¤§è¿ç»­å­åºåˆ—æ˜¯ $4ã€â€“1ã€2ã€1ã€â€“5ã€4$ï¼Œæ‰€ä»¥ $dp(8) = dp(7) + 4 = 5$ æœ€å¤§è¿ç»­å­åºåˆ—å’Œ â€“ çŠ¶æ€è½¬ç§»æ–¹ç¨‹å’Œåˆå§‹çŠ¶æ€çŠ¶æ€è½¬ç§»æ–¹ç¨‹ å¦‚æœ $dp(i â€“ 1) â‰¤ 0$ï¼Œé‚£ä¹ˆ $dp(i) = nums[i]$ å¦‚æœ $dp(i â€“ 1) &gt; 0$ï¼Œé‚£ä¹ˆ $dp(i) = dp(i â€“ 1) + nums[i]$ åˆå§‹çŠ¶æ€ $dp(0)$ çš„å€¼æ˜¯ $nums[0]$ æœ€ç»ˆçš„è§£ æœ€å¤§è¿ç»­å­åºåˆ—å’Œæ˜¯æ‰€æœ‰ $dp(i)$ ä¸­çš„æœ€å¤§å€¼ $max \{ dp(i) \}ï¼Œi âˆˆ [0, nums.length)$ æœ€å¤§è¿ç»­å­åºåˆ—å’Œ â€“ åŠ¨æ€è§„åˆ’ â€“ ä¸€ç»´æ•°ç»„å®ç°1234567891011121314151617public int maxSubArray1(int[] nums) &#123; // nums = &#123;â€“2ã€1ã€â€“3ã€4ã€â€“1ã€2ã€1ã€â€“5ã€4&#125; if (nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; dp.length; i++) &#123; int prev = dp[i - 1]; if (prev &lt;= 0) &#123; dp[i] = nums[i]; &#125; else &#123; dp[i] = prev + nums[i]; &#125; max = Math.max(dp[i], max); &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œæ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ æœ€å¤§è¿ç»­å­åºåˆ—å’Œ â€“ åŠ¨æ€è§„åˆ’ â€“ ä¼˜åŒ–å®ç°(å»æ‰ä¸€ç»´æ•°ç»„)123456789101112131415public int maxSubArray2(int[] nums) &#123; // nums = &#123;â€“2ã€1ã€â€“3ã€4ã€â€“1ã€2ã€1ã€â€“5ã€4&#125; if (nums == null || nums.length == 0) return 0; int dp = nums[0]; int max = dp; for (int i = 1; i &lt; nums.length; i++) &#123; if (dp &lt;= 0) &#123; dp = nums[i]; &#125; else &#123; dp = dp + nums[i]; &#125; max = Math.max(dp, max); &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ï¼Œæ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ ç»ƒä¹ 3 â€“ æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆæœ€é•¿é€’å¢å­åºåˆ—ï¼Œ$Longest Increasing Subsequenceï¼ŒLIS$ï¼‰ leetcodeåœ°å€ æœ€é•¿ä¸Šå‡å­åºåˆ— â€“ åŠ¨æ€è§„åˆ’ â€“ çŠ¶æ€å®šä¹‰å‡è®¾æ•°ç»„æ˜¯ $numsï¼Œ [10, 2, 2, 5, 1, 7, 101, 18]$ $dp(i)$ æ˜¯ä»¥ $nums[i]$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ï¼Œ$i âˆˆ [0, nums.length)$ ä»¥ $nums[0] 10$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $10$ï¼Œæ‰€ä»¥ $dp(0) = 1$ ä»¥ $nums[1] 2$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $2$ï¼Œæ‰€ä»¥ $dp(1) = 1$ ä»¥ $nums[2] 2$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $2$ï¼Œæ‰€ä»¥ $dp(2) = 1$ ä»¥ $nums[3] 5$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $2ã€5$ï¼Œæ‰€ä»¥ $dp(3) = dp(1) + 1 = dp(2) + 1 = 2$ ä»¥ $nums[4] 1$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $1$ï¼Œæ‰€ä»¥ $dp(4) = 1$ ä»¥ $nums[5] 7$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $2ã€5ã€7$ï¼Œæ‰€ä»¥ $dp(5) = dp(3) + 1 = 3$ ä»¥ $nums[6] 101$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $2ã€5ã€7ã€101$ï¼Œæ‰€ä»¥ $dp(6) = dp(5) + 1 = 4$ ä»¥ $nums[7] 18$ ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—æ˜¯ $2ã€5ã€7ã€18$ï¼Œæ‰€ä»¥ $dp(7) = dp(5) + 1 = 4$ æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦æ˜¯æ‰€æœ‰ $dp(i)$ ä¸­çš„æœ€å¤§å€¼ $max \{ dp(i) \}ï¼Œi âˆˆ [0, nums.length)$ æœ€é•¿ä¸Šå‡å­åºåˆ— â€“ åŠ¨æ€è§„åˆ’ â€“ çŠ¶æ€è½¬ç§»æ–¹ç¨‹éå† $j âˆˆ [0, i)$ å½“ $nums[i] &gt; nums[ j]$ $nums[i]$ å¯ä»¥æ¥åœ¨ $nums[j]$ åé¢ï¼Œå½¢æˆä¸€ä¸ªæ¯” $dp(j)$ æ›´é•¿çš„ä¸Šå‡å­åºåˆ—ï¼Œé•¿åº¦ä¸º $dp(j) + 1$ $dp(i) = max \{ dp(i), dp( j) + 1 \}$ å½“ $nums[i] â‰¤ nums[j]$ $nums[i]$ ä¸èƒ½æ¥åœ¨ $nums[j]$ åé¢ï¼Œè·³è¿‡æ­¤æ¬¡éå†$ï¼ˆcontinueï¼‰$ çŠ¶æ€çš„åˆå§‹å€¼ $dp(0) = 1$ æ‰€æœ‰çš„ $dp(i)$ é»˜è®¤éƒ½åˆå§‹åŒ–ä¸º $1$ æœ€é•¿ä¸Šå‡å­åºåˆ— â€“ åŠ¨æ€è§„åˆ’ â€“ å®ç°1234567891011121314static int lengthOfLIS1(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length]; int max = dp[0] = 1; for (int i = 1; i &lt; dp.length; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &lt;= nums[j]) continue; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; max = Math.max(dp[i], max); &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œæ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ æœ€é•¿ä¸Šå‡å­åºåˆ— â€“ äºŒåˆ†æœç´¢ â€“ æ€è·¯æŠŠæ¯ä¸ªæ•°å­—çœ‹åšæ˜¯ä¸€å¼ æ‰‘å…‹ç‰Œï¼Œä»å·¦åˆ°å³æŒ‰é¡ºåºå¤„ç†æ¯ä¸€ä¸ªæ‰‘å…‹ç‰Œ å°†å®ƒå‹åœ¨ï¼ˆä»å·¦è¾¹æ•°è¿‡æ¥ï¼‰ç¬¬ä¸€ä¸ªç‰Œé¡¶ â‰¥ å®ƒçš„ç‰Œå †ä¸Šé¢ å¦‚æœæ‰¾ä¸åˆ°ç‰Œé¡¶ â‰¥ å®ƒçš„ç‰Œå †ï¼Œå°±åœ¨æœ€å³è¾¹æ–°å»ºä¸€ä¸ªç‰Œå †ï¼Œå°†å®ƒæ”¾å…¥è¿™ä¸ªæ–°ç‰Œå †ä¸­ å½“å¤„ç†å®Œæ‰€æœ‰ç‰Œï¼Œæœ€ç»ˆç‰Œå †çš„æ•°é‡å°±æ˜¯æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ æ€è·¯ï¼ˆå‡è®¾æ•°ç»„æ˜¯ $nums$ï¼Œä¹Ÿå°±æ˜¯æœ€åˆçš„ç‰Œæ•°ç»„ï¼‰ $top[i]$ æ˜¯ç¬¬ $i$ ä¸ªç‰Œå †çš„ç‰Œé¡¶ï¼Œ$len$ æ˜¯ç‰Œå †çš„æ•°é‡ï¼Œåˆå§‹å€¼ä¸º $0$ éå†æ¯ä¸€å¼ ç‰Œ $num$ åˆ©ç”¨äºŒåˆ†æœç´¢æ‰¾å‡º $num$ æœ€ç»ˆè¦æ”¾å…¥çš„ç‰Œå †ä½ç½® $index$ $num$ ä½œä¸ºç¬¬ $index$ ä¸ªç‰Œå †çš„ç‰Œé¡¶ï¼Œ$top[index] = num$ å¦‚æœ $index$ ç­‰äº $len$ï¼Œç›¸å½“äºæ–°å»ºä¸€ä¸ªç‰Œå †ï¼Œç‰Œå †æ•°é‡ $+1$ï¼Œä¹Ÿå°±æ˜¯ $len++$ æœ€é•¿ä¸Šå‡å­åºåˆ— â€“ äºŒåˆ†æœç´¢ â€“ å®ç°1234567891011121314151617181920212223242526static int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; // ç‰Œå †çš„æ•°é‡ int len = 0; // ç‰Œé¡¶æ•°ç»„ int[] top = new int[nums.length]; // éå†æ‰€æœ‰çš„ç‰Œ for (int num : nums) &#123; int begin = 0; int end = len; // äºŒåˆ†æœç´¢ while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (num &lt;= top[mid]) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; // è¦†ç›–ç‰Œé¡¶ top[begin] = num; // æ£€æŸ¥æ˜¯å¦è¦æ–°å»ºä¸€ä¸ªç‰Œå † if (begin == len) len++; &#125; return len;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼›æ—¶é—´å¤æ‚åº¦ï¼š$O(nlogn)$ ç»ƒä¹ 4 â€“ æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆ$Longest Common Subsequenceï¼ŒLCS$ï¼‰ leetcodeåœ°å€ æœ€é•¿å…¬å…±å­åºåˆ— â€“ æ€è·¯å‡è®¾ $2$ ä¸ªåºåˆ—åˆ†åˆ«æ˜¯ $nums1ã€nums2$ $i âˆˆ [1, nums1.length]$ $j âˆˆ [1, nums2.length]$ å‡è®¾ $dp(i, j)$ æ˜¯ã€$nums1$ å‰ $i$ ä¸ªå…ƒç´ ã€‘ä¸ã€$nums2$ å‰ $j$ ä¸ªå…ƒç´ ã€‘çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ $dp(i, 0)ã€dp(0, j)$ åˆå§‹å€¼å‡ä¸º $0$ å¦‚æœ $nums1[i â€“ 1] = nums2[ j â€“ 1]$ï¼Œé‚£ä¹ˆ $dp(i, j) = dp(i â€“ 1, j â€“ 1) + 1$ å¦‚æœ $nums1[i â€“ 1] â‰  nums2[ j â€“ 1]$ï¼Œé‚£ä¹ˆ $dp(i, j) = max \{ dp(i â€“ 1, j), dp(i, j â€“ 1) \}$ æœ€é•¿å…¬å…±å­åºåˆ— â€“ é€’å½’å®ç°12345678910111213141516int lcs1(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; return lcs1(nums1, nums1.length, nums2, nums2.length);&#125;/** * æ±‚nums1å‰iä¸ªå…ƒç´ å’Œnums2å‰jä¸ªå…ƒç´ çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ */int lcs1(int[] nums1, int i, int[] nums2, int j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; return lcs1(nums1, i - 1, nums2, j - 1) + 1; &#125; return Math.max(lcs1(nums1, i - 1, nums2, j), lcs1(nums1, i, nums2, j - 1));&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(k)$ , $k = min\{n, m\}ï¼Œnã€m$ æ˜¯ $2$ ä¸ªåºåˆ—çš„é•¿åº¦ æ—¶é—´å¤æ‚åº¦ï¼š$O(2^n)$ï¼Œå½“ $n = m$ æ—¶ æœ€é•¿å…¬å…±å­åºåˆ— â€“ é€’å½’å®ç°åˆ†æ å‡ºç°äº†é‡å¤çš„é€’å½’è°ƒç”¨ æœ€é•¿å…¬å…±å­åºåˆ— â€“ éé€’å½’å®ç° - äºŒç»´æ•°ç»„å®ç°123456789101112131415int lcs2(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[][] dp = new int[nums1.length + 1][nums2.length + 1]; for (int i = 1; i &lt;= nums1.length; i++) &#123; for (int j = 1; j &lt;= nums2.length; j++) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[nums1.length][nums2.length];&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(n âˆ— m)$ï¼Œæ—¶é—´å¤æ‚åº¦ï¼š$O(n âˆ— m)$ $dp$ æ•°ç»„çš„è®¡ç®—ç»“æœåˆ†æ ä¸¾ä¾‹ï¼šè®¡ç®— $dp[1][2]$ æ—¶ï¼Œéœ€è¦çš„å‰æè®¡ç®—ç»“æœä¸º $dp[1,1]ã€dp[0,2]$ å’Œ $dp[0,1]$ çš„å€¼ æœ€é•¿å…¬å…±å­åºåˆ— â€“ éé€’å½’å®ç° â€“ æ»šåŠ¨æ•°ç»„å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦ 1234567891011121314151617static int lcs3(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[][] dp = new int[2][nums2.length + 1]; for (int i = 1; i &lt;= nums1.length; i++) &#123; int row = i &amp; 1; int prevRow = (i - 1) &amp; 1; for (int j = 1; j &lt;= nums2.length; j++) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[row][j] = dp[prevRow][j - 1] + 1; &#125; else &#123; dp[row][j] = Math.max(dp[prevRow][j], dp[row][j - 1]); &#125; &#125; &#125; return dp[nums1.length &amp; 1][nums2.length];&#125; æœ€é•¿å…¬å…±å­åºåˆ— â€“ éé€’å½’å®ç° â€“ ä¸€ç»´æ•°ç»„å¯ä»¥å°† äºŒç»´æ•°ç»„ ä¼˜åŒ–æˆ ä¸€ç»´æ•°ç»„ï¼Œè¿›ä¸€æ­¥é™ä½ç©ºé—´å¤æ‚åº¦ ä¸¾ä¾‹ï¼šå½“è®¡ç®— $dp[6]$ æ—¶ï¼Œ$dp[]$ æ•°ç»„ä¸­çš„å€¼å­˜æ”¾çš„å°±æ˜¯ä¸‹å›¾ä¸­åœ†åœˆçš„å€¼ï¼Œå†å°† $dp[6]$ å·¦ä¸Šè§’çš„å€¼å­˜æ”¾åœ¨ $leftTop$ ä¸­å³å¯ã€‚ å¦ä¸€ç§æ€è·¯ï¼šæ¯è¡Œçš„åˆ—ä»åå¾€å‰è®¡ç®—ï¼Œ$leftTop$ ä¹Ÿå¯çœç•¥ï¼Œåªéœ€ä¸€ä¸ªä¸€ç»´æ•°ç»„ã€‚ 123456789101112131415161718static int lcs4(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[] dp = new int[nums2.length + 1]; for (int i = 1; i &lt;= nums1.length; i++) &#123; int cur = 0; for (int j = 1; j &lt;= nums2.length; j++) &#123; int leftTop = cur; cur = dp[j]; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = leftTop + 1; &#125; else &#123; dp[j] = Math.max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[nums2.length];&#125; æœ€é•¿å…¬å…±å­åºåˆ— â€“ éé€’å½’å®ç° â€“ ä¸€ç»´æ•°ç»„å†æ¬¡ä¼˜åŒ–å¯ä»¥å°†ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–è‡³$O(k) , k = min\{n, m\}$ æ•°ç»„å…ƒç´ æ•°é‡å°‘çš„åšåˆ— $row$ 1234567891011121314151617181920212223static int lcs(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums1.length == 0) return 0; if (nums2 == null || nums2.length == 0) return 0; int[] rowsNums = nums1, colsNums = nums2; if (nums1.length &lt; nums2.length) &#123; colsNums = nums1; rowsNums = nums2; &#125; int[] dp = new int[colsNums.length + 1]; for (int i = 1; i &lt;= rowsNums.length; i++) &#123; int cur = 0; for (int j = 1; j &lt;= colsNums.length; j++) &#123; int leftTop = cur; cur = dp[j]; if (rowsNums[i - 1] == colsNums[j - 1]) &#123; dp[j] = leftTop + 1; &#125; else &#123; dp[j] = Math.max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[colsNums.length];&#125; æœ€é•¿å…¬å…±å­åºåˆ— - å­—ç¬¦ä¸²å®ç°1234567891011121314151617181920212223242526public int longestCommonSubsequence(String text1, String text2) &#123; if (text1 == null || text2 == null) return 0; char[] chars1 = text1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = text2.toCharArray(); if (chars2.length == 0) return 0; char[] rowsChars = chars1, colsChars = chars2; if (chars1.length &lt; chars2.length) &#123; colsChars = chars1; rowsChars = chars2; &#125; int[] dp = new int[colsChars.length + 1]; for (int i = 1; i &lt;= rowsChars.length; i++) &#123; int cur = 0; for (int j = 1; j &lt;= colsChars.length; j++) &#123; int leftTop = cur; cur = dp[j]; if (rowsChars[i - 1] == colsChars[j - 1]) &#123; dp[j] = leftTop + 1; &#125; else &#123; dp[j] = Math.max(dp[j], dp[j - 1]); &#125; &#125; &#125; return dp[colsChars.length];&#125; ç»ƒä¹ 5 â€“ æœ€é•¿å…¬å…±å­ä¸²æœ€é•¿å…¬å…±å­ä¸²$ï¼ˆLongest Common Substringï¼‰$ å­ä¸²æ˜¯è¿ç»­çš„å­åºåˆ— æ±‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­ä¸²é•¿åº¦ $ABCBA$ å’Œ $BABCA$ çš„æœ€é•¿å…¬å…±å­ä¸²æ˜¯ $ABC$ï¼Œé•¿åº¦ä¸º $3$ æœ€é•¿å…¬å…±å­ä¸² â€“ æ€è·¯ å‡è®¾ $2$ ä¸ªå­—ç¬¦ä¸²åˆ†åˆ«æ˜¯ $str1ã€str2$ $i âˆˆ [1, str1.length]$ $j âˆˆ [1, str2.length]$ å‡è®¾ $dp(i, j)$ æ˜¯ä»¥ $str1[i â€“ 1]ã€str2[ j â€“ 1]$ ç»“å°¾çš„æœ€é•¿å…¬å…±å­ä¸²é•¿åº¦ $dp(i, 0)ã€dp(0, j)$ åˆå§‹å€¼å‡ä¸º $0$ å¦‚æœ $str1[i â€“ 1] = str2[ j â€“ 1]$ï¼Œé‚£ä¹ˆ $dp(i, j) = dp(i â€“ 1, j â€“ 1) + 1$ å¦‚æœ $str1[i â€“ 1] â‰  str2[ j â€“ 1]$ï¼Œé‚£ä¹ˆ $dp(i, j) = 0$ æœ€é•¿å…¬å…±å­ä¸²çš„é•¿åº¦æ˜¯æ‰€æœ‰ $dp(i, j)$ ä¸­çš„æœ€å¤§å€¼ $max \{ dp(i, j) \}$ æœ€é•¿å…¬å…±å­ä¸² â€“ å®ç° - äºŒç»´æ•°ç»„12345678910111213141516171819int lcs1(String str1, String str2) &#123; if (str1 == null || str2 == null) return 0; char[] chars1 = str1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = str2.toCharArray(); if (chars2.length == 0) return 0; int[][] dp = new int[chars1.length + 1][chars2.length + 1]; int max = 0; for (int i = 1; i &lt;= chars1.length; i++) &#123; for (int j = 1; j &lt;= chars2.length; j++) &#123; if (chars1[i - 1] != chars2[j - 1]) continue; dp[i][j] = dp[i - 1][j - 1] + 1; max = Math.max(dp[i][j], max); &#125; &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(n âˆ— m)$ æ—¶é—´å¤æ‚åº¦ï¼š$O(n âˆ— m)$ æœ€é•¿å…¬å…±å­ä¸² â€“ ä¸€ç»´æ•°ç»„å®ç°(ä¼˜åŒ–åŸç†è·Ÿç»ƒä¹ 4ç±»ä¼¼)12345678910111213141516171819202122232425262728293031int lcs2(String str1, String str2) &#123; if (str1 == null || str2 == null) return 0; char[] chars1 = str1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = str2.toCharArray(); if (chars2.length == 0) return 0; char[] rowsChars = chars1, colsChars = chars2; if (chars1.length &lt; chars2.length) &#123; colsChars = chars1; rowsChars = chars2; &#125; // ä¸Šæ–¹æ•´è¡Œçš„å€¼ int[] dp = new int[colsChars.length + 1]; int max = 0; for (int row = 1; row &lt;= rowsChars.length; row++) &#123; // å·¦ä¸Šè§’çš„å€¼ int cur = 0; for (int col = 1; col &lt;= colsChars.length; col++) &#123; int leftTop = cur; cur = dp[col]; if (chars1[row - 1] != chars2[col - 1]) &#123; dp[col] = 0; &#125; else &#123; dp[col] = leftTop + 1; max = Math.max(dp[col], max); &#125; &#125; &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(k),k = min\{n, m\}$ æ—¶é—´å¤æ‚åº¦ï¼š$O(n âˆ— m)$ æœ€é•¿å…¬å…±å­ä¸² â€“ ä¸€ç»´æ•°ç»„ä¼˜åŒ– - æ¯è¡Œçš„åˆ—ä»åå¾€å‰å¼€å§‹è®¡ç®—1234567891011121314151617181920212223242526static int lcs(String str1, String str2) &#123; if (str1 == null || str2 == null) return 0; char[] chars1 = str1.toCharArray(); if (chars1.length == 0) return 0; char[] chars2 = str2.toCharArray(); if (chars2.length == 0) return 0; char[] rowsChars = chars1, colsChars = chars2; if (chars1.length &lt; chars2.length) &#123; colsChars = chars1; rowsChars = chars2; &#125; int[] dp = new int[colsChars.length + 1]; int max = 0; for (int row = 1; row &lt;= rowsChars.length; row++) &#123; for (int col = colsChars.length; col &gt;= 1; col--) &#123; if (chars1[row - 1] != chars2[col - 1]) &#123; dp[col] = 0; &#125; else &#123; dp[col] = dp[col - 1] + 1; max = Math.max(dp[col], max); &#125; &#125; &#125; return max;&#125; ç»ƒä¹ 6 â€“ 0-1èƒŒåŒ… æœ‰ $n$ ä»¶ç‰©å“å’Œä¸€ä¸ªæœ€å¤§æ‰¿é‡ä¸º $W$ çš„èƒŒåŒ…ï¼Œæ¯ä»¶ç‰©å“çš„é‡é‡æ˜¯ $ğ‘¤i$ã€ä»·å€¼æ˜¯ $ğ‘£i$ åœ¨ä¿è¯æ€»é‡é‡ä¸è¶…è¿‡ $W$ çš„å‰æä¸‹ï¼Œé€‰æ‹©æŸäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼ŒèƒŒåŒ…çš„æœ€å¤§æ€»ä»·å€¼æ˜¯å¤šå°‘ï¼Ÿ æ³¨æ„ï¼šæ¯ä¸ªç‰©å“åªæœ‰ $1$ ä»¶ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªç‰©å“åªèƒ½é€‰æ‹© $0$ ä»¶æˆ–è€… $1$ ä»¶ å‡è®¾ $values$ æ˜¯ä»·å€¼æ•°ç»„ï¼Œ$weights$ æ˜¯é‡é‡æ•°ç»„ ç¼–å·ä¸º $k$ çš„ç‰©å“ï¼Œä»·å€¼æ˜¯ $values[k]$ï¼Œé‡é‡æ˜¯ $weights[k]ï¼Œk âˆˆ [0, n)$ å‡è®¾ $dp(i, j)$ æ˜¯æœ€å¤§æ‰¿é‡ä¸º $j$ã€æœ‰å‰ $i$ ä»¶ç‰©å“å¯é€‰æ—¶çš„æœ€å¤§æ€»ä»·å€¼ï¼Œ$i âˆˆ [1, n]ï¼Œj âˆˆ [1, W]$ $dp(i, 0)ã€dp(0, j)$ åˆå§‹å€¼å‡ä¸º $0$ å¦‚æœ $j &lt; weights[i â€“ 1]$ï¼Œé‚£ä¹ˆ $dp(i, j) = dp(i â€“ 1, j)$ ï¼Œä¸å¤Ÿå†å®¹çº³ä¸œè¥¿äº† å¦‚æœ $j â‰¥ weights[i â€“ 1]$ï¼Œé‚£ä¹ˆ $dp(i, j) = max \{ dp(i â€“ 1, j), dp(i â€“ 1, j â€“ weights[i â€“ 1]) + values[i â€“ 1] \}$ï¼Œå¯ä»¥å†å®¹çº³ä¸œè¥¿ï¼Œæœ‰ä¸¤ç§é€‰æ‹©ï¼Œè£…è¿›èƒŒåŒ…ä¸ä¸è£…è¿›èƒŒåŒ… 0-1èƒŒåŒ… â€“ éé€’å½’å®ç°123456789101112131415161718int maxValue1(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[][] dp = new int[values.length + 1][capacity + 1]; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = 1; j &lt;= capacity; j++) &#123; if (j &lt; weights[i - 1]) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = Math.max( dp[i - 1][j], values[i - 1] + dp[i - 1][j - weights[i - 1]]); &#125; &#125; &#125; return dp[values.length][capacity];&#125; dp æ•°ç»„çš„è®¡ç®—ç»“æœåˆ†æ 0-1èƒŒåŒ… â€“ éé€’å½’å®ç° â€“ ä¸€ç»´æ•°ç»„$dp(i, j)$ éƒ½æ˜¯ç”± $dp(i â€“ 1, k)$ æ¨å¯¼å‡ºæ¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œç¬¬ $i$ è¡Œçš„æ•°æ®æ˜¯ç”±å®ƒçš„ä¸Šä¸€è¡Œç¬¬ $i â€“ 1$ è¡Œæ¨å¯¼å‡ºæ¥çš„ å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ç»´æ•°ç»„æ¥ä¼˜åŒ– å¦å¤–ï¼Œç”±äº $k â‰¤ j$ ï¼Œæ‰€ä»¥ $j$ çš„éå†åº”è¯¥ç”±å¤§åˆ°å°ï¼Œå¦åˆ™å¯¼è‡´æ•°æ®é”™ä¹±ï¼ˆæ¯è¡Œçš„åˆ—ç”±åå¾€å‰éå†ï¼‰ 1234567891011121314int maxValue2(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[] dp = new int[capacity + 1]; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = capacity; j &gt;= 1; j--) &#123; // j &lt; weights[i - 1] å¯ä»¥åˆå¹¶åˆ° for å¾ªç¯é‡Œåˆ¤æ–­ if (j &lt; weights[i - 1]) continue; dp[j] = Math.max(dp[j], values[i - 1] + dp[j - weights[i - 1]]); &#125; &#125; return dp[capacity];&#125; 0-1èƒŒåŒ… â€“ éé€’å½’å®ç° â€“ ä¸€ç»´æ•°ç»„ä¼˜åŒ–è§‚å¯ŸäºŒç»´æ•°ç»„è¡¨ï¼Œå¾—å‡ºç»“è®ºï¼š$j$ çš„ä¸‹ç•Œå¯ä»¥ä» $1$ æ”¹ä¸º $weights[i â€“ 1]$ 123456789101112int maxValue(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[] dp = new int[capacity + 1]; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = capacity; j &gt;= weights[i - 1]; j--) &#123; dp[j] = Math.max(dp[j], values[i - 1] + dp[j - weights[i - 1]]); &#125; &#125; return dp[capacity];&#125; 0-1èƒŒåŒ… â€“ æ°å¥½è£…æ»¡æœ‰ $n$ ä»¶ç‰©å“å’Œä¸€ä¸ªæœ€å¤§æ‰¿é‡ä¸º $W$ çš„èƒŒåŒ…ï¼Œæ¯ä»¶ç‰©å“çš„é‡é‡æ˜¯ $ğ‘¤i$ã€ä»·å€¼æ˜¯ $ğ‘£i$ åœ¨ä¿è¯æ€»é‡é‡æ°å¥½ç­‰äº $W$ çš„å‰æä¸‹ï¼Œé€‰æ‹©æŸäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼ŒèƒŒåŒ…çš„æœ€å¤§æ€»ä»·å€¼æ˜¯å¤šå°‘ï¼Ÿ æ³¨æ„ï¼šæ¯ä¸ªç‰©å“åªæœ‰ $1$ ä»¶ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªç‰©å“åªèƒ½é€‰æ‹© $0$ ä»¶æˆ–è€… $1$ ä»¶ $dp(i, j)$ åˆå§‹çŠ¶æ€è°ƒæ•´ $dp(i, 0) = 0$ï¼Œæ€»é‡é‡æ°å¥½ä¸º $0$ï¼Œæœ€å¤§æ€»ä»·å€¼å¿…ç„¶ä¹Ÿä¸º $0$ $dp(0, j) = â€“âˆ$ï¼ˆè´Ÿæ— ç©·ï¼‰ï¼Œ$j â‰¥ 1$ï¼Œè´Ÿæ•°åœ¨è¿™é‡Œä»£è¡¨æ— æ³•æ°å¥½è£…æ»¡ 0-1èƒŒåŒ… â€“ æ°å¥½è£…æ»¡ â€“ å®ç°12345678910111213141516// å¦‚æœè¿”å›-1ï¼Œä»£è¡¨æ²¡æ³•åˆšå¥½å‡‘åˆ°capacityè¿™ä¸ªå®¹é‡static int maxValueExactly(int[] values, int[] weights, int capacity) &#123; if (values == null || values.length == 0) return 0; if (weights == null || weights.length == 0) return 0; if (values.length != weights.length || capacity &lt;= 0) return 0; int[] dp = new int[capacity + 1]; for (int j = 1; j &lt;= capacity; j++) &#123; dp[j] = Integer.MIN_VALUE; &#125; for (int i = 1; i &lt;= values.length; i++) &#123; for (int j = capacity; j &gt;= weights[i - 1]; j--) &#123; dp[j] = Math.max(dp[j], values[i - 1] + dp[j - weights[i - 1]]); &#125; &#125; return dp[capacity] &lt; 0 ? -1 : dp[capacity];&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ†æ²»]]></title>
    <url>%2F2020%2F07%2F19%2F%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[åˆ†æ²»ï¼ˆDivide And Conquerï¼‰ä»€ä¹ˆæ˜¯åˆ†æ²»åˆ†æ²»ï¼Œä¹Ÿå°±æ˜¯åˆ†è€Œæ²»ä¹‹ã€‚å®ƒçš„ä¸€èˆ¬æ­¥éª¤æ˜¯ â‘  å°†åŸé—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªè§„æ¨¡è¾ƒå°çš„å­é—®é¢˜ï¼ˆå­é—®é¢˜å’ŒåŸé—®é¢˜çš„ç»“æ„ä¸€æ ·ï¼Œåªæ˜¯è§„æ¨¡ä¸ä¸€æ ·ï¼‰ â‘¡ å­é—®é¢˜åˆä¸æ–­åˆ†è§£æˆè§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œç›´åˆ°ä¸èƒ½å†åˆ†è§£ï¼ˆç›´åˆ°å¯ä»¥è½»æ˜“è®¡ç®—å‡ºå­é—®é¢˜çš„è§£ï¼‰ â‘¢ åˆ©ç”¨å­é—®é¢˜çš„è§£æ¨å¯¼å‡ºåŸé—®é¢˜çš„è§£ å› æ­¤ï¼Œåˆ†æ²»ç­–ç•¥éå¸¸é€‚åˆç”¨é€’å½’ éœ€è¦æ³¨æ„çš„æ˜¯ï¼šå­é—®é¢˜ä¹‹é—´æ˜¯ç›¸äº’ç‹¬ç«‹çš„ åˆ†æ²»çš„åº”ç”¨å¿«é€Ÿæ’åº å½’å¹¶æ’åº $Karatsuba$ ç®—æ³•ï¼ˆå¤§æ•°ä¹˜æ³•ï¼‰ ä¸»å®šç†ï¼ˆMaster Theoremï¼‰åˆ†æ²»ç­–ç•¥é€šå¸¸éµå®ˆä¸€ç§é€šç”¨æ¨¡å¼ è§£å†³è§„æ¨¡ä¸º $n$ çš„é—®é¢˜ï¼Œåˆ†è§£æˆ $a$ ä¸ªè§„æ¨¡ä¸º $\frac{n}{b}$ çš„å­é—®é¢˜ï¼Œç„¶ååœ¨ $O(n^d)$æ—¶é—´å†…å°†å­é—®é¢˜çš„è§£åˆå¹¶èµ·æ¥ ç®—æ³•è¿è¡Œæ—¶é—´ä¸ºï¼š$T(n)= aT(\frac{n}{b}) + O(n^d), a &gt; 0,b &gt; 1,d â‰¥ 0$ $d &gt; log_ba, T(n) = O(n^d)$ $d = log_ba, T(n) = O(n^dlogn)$ $d &lt; log_ba, T(n) = O(n^{log_ba})$ æ¯”å¦‚å½’å¹¶æ’åºçš„è¿è¡Œæ—¶é—´æ˜¯ï¼š$T(n) = 2T(\frac{n}{2}) + O(n), a = 2,b = 2,d = 1,$ æ‰€ä»¥$T(n) = O(nlogn)$ ç»ƒä¹ 1 â€“ æœ€å¤§è¿ç»­å­åºåˆ—å’ŒåŠ¨æ€è§„åˆ’å®ç°å­åºåˆ— LeetCodeåœ°å€ è¿™é“é¢˜ä¹Ÿå±äºæœ€å¤§åˆ‡ç‰‡é—®é¢˜ï¼ˆæœ€å¤§åŒºæ®µï¼Œ$Greatest Slice$ï¼‰ æ¦‚å¿µåŒºåˆ†ï¼šå­ä¸²ã€å­æ•°ç»„ã€å­åŒºé—´å¿…é¡»æ˜¯è¿ç»­çš„ï¼Œå­åºåˆ—æ˜¯å¯ä»¥ä¸è¿ç»­çš„ è§£æ³•1 â€“ æš´åŠ›å‡ºå¥‡è¿¹ç©·ä¸¾å‡ºæ‰€æœ‰å¯èƒ½çš„è¿ç»­å­åºåˆ—ï¼Œå¹¶è®¡ç®—å‡ºå®ƒä»¬çš„å’Œï¼Œæœ€åå–å®ƒä»¬ä¸­çš„æœ€å¤§å€¼ 123456789101112131415public int maxSubarray1(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int max = Integer.MIN_VALUE; for (int begin = 0; begin &lt; nums.length; begin++) &#123; for (int end = begin; end &lt; nums.length; end++) &#123; // sumæ˜¯[begin, end]çš„å’Œ int sum = 0; for (int i = begin; i &lt;= end; i++) &#123; sum += nums[i]; &#125; max = Math.max(max, sum); &#125; &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ ï¼Œæ—¶é—´å¤æ‚åº¦ï¼š$O(n^3)$ è§£æ³•1 â€“ æš´åŠ›å‡ºå¥‡è¿¹ â€“ ä¼˜åŒ–é‡å¤åˆ©ç”¨å‰é¢è®¡ç®—è¿‡çš„ç»“æœ 12345678910111213public int maxSubarray2(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int max = Integer.MIN_VALUE; for (int begin = 0; begin &lt; nums.length; begin++) &#123; int sum = 0; for (int end = begin; end &lt; nums.length; end++) &#123; // sumæ˜¯[begin, end]çš„å’Œ sum += nums[end]; max = Math.max(max, sum); &#125; &#125; return max;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ ï¼Œæ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ è§£æ³•2 â€“ åˆ†æ²»123456789101112131415161718192021222324252627282930313233343536static int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; return maxSubArray(nums, 0, nums.length);&#125;/** * æ±‚è§£[begin, end)ä¸­æœ€å¤§è¿ç»­å­åºåˆ—çš„å’Œ * T(n) = T(n/2) + T(n/2) + O(n) * T(n) = 2T(n/2) + O(n) * logba = 1 d = 1 */static int maxSubArray(int[] nums, int begin, int end) &#123; if (end - begin &lt; 2) return nums[begin]; int mid = (begin + end) &gt;&gt; 1; int leftMax = nums[mid - 1]; int leftSum = leftMax; for (int i = mid - 2; i &gt;= begin; i--) &#123; leftSum += nums[i]; leftMax = Math.max(leftMax, leftSum); &#125; int rightMax = nums[mid]; int rightSum = rightMax; for (int i = mid + 1; i &lt; end; i++) &#123; rightSum += nums[i]; rightMax = Math.max(rightMax, rightSum); &#125; return Math.max(leftMax + rightMax, Math.max( maxSubArray(nums, begin, mid), maxSubArray(nums, mid, end)) );&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(logn)$ æ—¶é—´å¤æ‚åº¦ï¼š$O(nlogn)$ è·Ÿå½’å¹¶æ’åºã€å¿«é€Ÿæ’åºä¸€æ · $T(n) = 2(T)(\frac{n}{2}) + O(n)$ ç»ƒä¹ 2 â€“ å¤§æ•°ä¹˜æ³•$2$ ä¸ªè¶…å¤§çš„æ•°ï¼ˆæ¯”å¦‚ $2$ ä¸ª $100$ ä½çš„æ•°ï¼‰ï¼Œå¦‚ä½•è¿›è¡Œä¹˜æ³•ï¼Ÿ æŒ‰ç…§å°å­¦æ—¶å­¦ä¹ çš„ä¹˜æ³•è¿ç®—ï¼Œåœ¨è¿›è¡Œ $n$ ä½æ•°ä¹‹é—´çš„ç›¸ä¹˜æ—¶ï¼Œéœ€è¦å¤§çº¦è¿›è¡Œ $n^2$ æ¬¡ä¸ªä½æ•°çš„ç›¸ä¹˜ æ¯”å¦‚è®¡ç®— $36 * 54$ $T(n) = 4T(\frac{n}{2}) + O(n) = O(n^2)$ $1960$ å¹´ $Anatolii Alexeevitch Karatsuba$ æå‡ºäº† $Karatsuba$ ç®—æ³•ï¼Œæé«˜äº†å¤§æ•°ä¹˜æ³•çš„æ•ˆç‡ $BC + AD = AC + BD âˆ’ (A âˆ’ B)(C âˆ’ D)$ $T(n) = 3T(\frac{n}{2}) + O(n) = O(n^{log_23}) = O(n^{1.585})$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>åˆ†æ²»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è´ªå¿ƒ]]></title>
    <url>%2F2020%2F07%2F19%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[è´ªå¿ƒï¼ˆGreedyï¼‰ä»€ä¹ˆæ˜¯è´ªå¿ƒç®—æ³•è´ªå¿ƒç­–ç•¥ï¼Œä¹Ÿç§°ä¸ºè´ªå©ªç­–ç•¥ æ¯ä¸€æ­¥éƒ½é‡‡å–å½“å‰çŠ¶æ€ä¸‹æœ€ä¼˜çš„é€‰æ‹©ï¼ˆå±€éƒ¨æœ€ä¼˜è§£ï¼‰ï¼Œä»è€Œå¸Œæœ›æ¨å¯¼å‡ºå…¨å±€æœ€ä¼˜è§£ è´ªå¿ƒçš„åº”ç”¨ å“ˆå¤«æ›¼æ ‘ æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ï¼š$Primã€Kruskal$ æœ€çŸ­è·¯å¾„ç®—æ³•ï¼š$Dijkstra$ ç»ƒä¹ 1 â€“ æœ€ä¼˜è£…è½½é—®é¢˜ï¼ˆåŠ å‹’æ¯”æµ·ç›—ï¼‰åœ¨åŒ—ç¾æ´²ä¸œå—éƒ¨ï¼Œæœ‰ä¸€ç‰‡ç¥ç§˜çš„æµ·åŸŸï¼Œæ˜¯æµ·ç›—æœ€æ´»è·ƒçš„åŠ å‹’æ¯”æµ· æœ‰ä¸€å¤©ï¼Œæµ·ç›—ä»¬æˆªè·äº†ä¸€è‰˜è£…æ»¡å„ç§å„æ ·å¤è‘£çš„è´§èˆ¹ï¼Œæ¯ä¸€ä»¶å¤è‘£éƒ½ä»·å€¼è¿åŸï¼Œä¸€æ—¦æ‰“ç¢å°±å¤±å»äº†å®ƒçš„ä»·å€¼ æµ·ç›—èˆ¹çš„è½½é‡é‡ä¸º $W$ï¼Œæ¯ä»¶å¤è‘£çš„é‡é‡ä¸º $ğ‘¤_i$ï¼Œæµ·ç›—ä»¬è¯¥å¦‚ä½•æŠŠå°½å¯èƒ½å¤šæ•°é‡çš„å¤è‘£è£…ä¸Šæµ·ç›—èˆ¹ï¼Ÿ æ¯”å¦‚ $W$ ä¸º $30$ï¼Œ$ğ‘¤_i$ åˆ†åˆ«ä¸º $3ã€ 5ã€ 4ã€ 10ã€ 7ã€ 14ã€ 2ã€ 11$ è´ªå¿ƒç­–ç•¥ï¼šæ¯ä¸€æ¬¡éƒ½ä¼˜å…ˆé€‰æ‹©é‡é‡æœ€å°çš„å¤è‘£ â‘  é€‰æ‹©é‡é‡ä¸º $2$ çš„å¤è‘£ï¼Œå‰©é‡é‡ $28$ â‘¡ é€‰æ‹©é‡é‡ä¸º $3$ çš„å¤è‘£ï¼Œå‰©é‡é‡ $25$ â‘¢ é€‰æ‹©é‡é‡ä¸º $4$ çš„å¤è‘£ï¼Œå‰©é‡é‡ $21$ â‘£ é€‰æ‹©é‡é‡ä¸º $5$ çš„å¤è‘£ï¼Œå‰©é‡é‡ $16$ â‘¤ é€‰æ‹©é‡é‡ä¸º $7$ çš„å¤è‘£ï¼Œå‰©é‡é‡ $9$ æœ€å¤šèƒ½è£…è½½ $5$ ä¸ªå¤è‘£ 123456789101112131415161718public class Pirate &#123; public static void main(String[] args) &#123; int[] weights = &#123;3, 5, 4, 10, 7, 14, 2, 11&#125;; Arrays.sort(weights); int capacity = 30, weight = 0, count = 0; for (int i = 0; i &lt; weights.length &amp;&amp; weight &lt; capacity; i++) &#123; int newWeight = weight + weights[i]; if (newWeight &lt;= capacity) &#123; weight = newWeight; count++; System.out.println(weights[i]); &#125; &#125; System.out.println("ä¸€å…±é€‰äº†" + count + "ä»¶å¤è‘£"); &#125;&#125; ç»ƒä¹ 2 â€“ é›¶é’±å…‘æ¢åŠ¨æ€è§„åˆ’å®ç°é›¶é’±å…‘æ¢ å‡è®¾æœ‰ $25$ åˆ†ã€$10$ åˆ†ã€$5$ åˆ†ã€$1$ åˆ†çš„ç¡¬å¸ï¼Œç°è¦æ‰¾ç»™å®¢æˆ· $41$ åˆ†çš„é›¶é’±ï¼Œå¦‚ä½•åŠåˆ°ç¡¬å¸ä¸ªæ•°æœ€å°‘ï¼Ÿ è´ªå¿ƒç­–ç•¥ï¼šæ¯ä¸€æ¬¡éƒ½ä¼˜å…ˆé€‰æ‹©é¢å€¼æœ€å¤§çš„ç¡¬å¸ â‘  é€‰æ‹© $25$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $16$ åˆ† â‘¡ é€‰æ‹© $10$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $6$ åˆ† â‘¢ é€‰æ‹© $5$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $1$ åˆ† â‘£ é€‰æ‹© $1$ åˆ†çš„ç¡¬å¸ æœ€ç»ˆçš„è§£æ˜¯å…± $4$ æšç¡¬å¸ $25$ åˆ†ã€$10$ åˆ†ã€$5$ åˆ†ã€$1$ åˆ†ç¡¬å¸å„ä¸€æš 12345678910111213Integer[] faces = &#123;25, 10, 5, 1&#125;Arrays.sort(faces);int coins = 0, money = 41;idx = faces.length - 1;while (idx &gt;= 0) &#123; while (money &gt;= faces[idx]) &#123; System.out.println(faces[idx]); money -= faces[idx]; coins++; &#125; idx--;&#125;System.out.println(coins); é›¶é’±å…‘æ¢çš„å¦ä¸€ä¸ªä¾‹å­å‡è®¾æœ‰ $25$ åˆ†ã€$20$ åˆ†ã€$5$ åˆ†ã€$1$ åˆ†çš„ç¡¬å¸ï¼Œç°è¦æ‰¾ç»™å®¢æˆ· $41$ åˆ†çš„é›¶é’±ï¼Œå¦‚ä½•åŠåˆ°ç¡¬å¸ä¸ªæ•°æœ€å°‘ï¼Ÿ è´ªå¿ƒç­–ç•¥ï¼šæ¯ä¸€æ­¥éƒ½ä¼˜å…ˆé€‰æ‹©é¢å€¼æœ€å¤§çš„ç¡¬å¸ â‘  é€‰æ‹© $25$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $16$ åˆ† â‘¡ é€‰æ‹© $5$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $11$ åˆ† â‘¢ é€‰æ‹© $5$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $6$ åˆ† â‘£ é€‰æ‹© $5$ åˆ†çš„ç¡¬å¸ï¼Œå‰© $1$ åˆ† â‘¤ é€‰æ‹© $1$ åˆ†çš„ç¡¬å¸ æœ€ç»ˆçš„è§£æ˜¯ $1$ æš $25$ åˆ†ã€$3$ æš $5$ åˆ†ã€$1$ æš $1$ åˆ†çš„ç¡¬å¸ï¼Œå…± $5$ æšç¡¬å¸ å®é™…ä¸Šæœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯ï¼š$2$ æš $20$ åˆ†ã€$1$ æš $1$ åˆ†çš„ç¡¬å¸ï¼Œå…± $3$ æšç¡¬å¸ æ³¨æ„è´ªå¿ƒç­–ç•¥å¹¶ä¸ä¸€å®šèƒ½å¾—åˆ°å…¨å±€æœ€ä¼˜è§£ å› ä¸ºä¸€èˆ¬æ²¡æœ‰æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„è§£ï¼Œå®¹æ˜“è¿‡æ—©åšå†³å®šï¼Œæ‰€ä»¥æ²¡æ³•è¾¾åˆ°æœ€ä½³è§£ è´ªå›¾çœ¼å‰å±€éƒ¨çš„åˆ©ç›Šæœ€å¤§åŒ–ï¼Œçœ‹ä¸åˆ°é•¿è¿œæœªæ¥ï¼Œèµ°ä¸€æ­¥çœ‹ä¸€æ­¥ ä¼˜ç‚¹ï¼šç®€å•ã€é«˜æ•ˆã€ä¸éœ€è¦ç©·ä¸¾æ‰€æœ‰å¯èƒ½ï¼Œé€šå¸¸ä½œä¸ºå…¶ä»–ç®—æ³•çš„è¾…åŠ©ç®—æ³•æ¥ä½¿ç”¨ ç¼ºç‚¹ï¼šé¼ ç›®å¯¸å…‰ï¼Œä¸ä»æ•´ä½“ä¸Šè€ƒè™‘å…¶ä»–å¯èƒ½ï¼Œæ¯æ¬¡é‡‡å–å±€éƒ¨æœ€ä¼˜è§£ï¼Œä¸ä¼šå†å›æº¯ï¼Œå› æ­¤å¾ˆå°‘æƒ…å†µä¼šå¾—åˆ°æœ€ä¼˜è§£ ç»ƒä¹ 3 â€“ 0-1èƒŒåŒ…åŠ¨æ€è§„åˆ’å®ç°0-1èƒŒåŒ… æœ‰ $n$ ä»¶ç‰©å“å’Œä¸€ä¸ªæœ€å¤§æ‰¿é‡ä¸º $W$ çš„èƒŒåŒ…ï¼Œæ¯ä»¶ç‰©å“çš„é‡é‡æ˜¯ $ğ‘¤_i$ã€ä»·å€¼æ˜¯ $ğ‘£_i$ åœ¨ä¿è¯æ€»é‡é‡ä¸è¶…è¿‡ $W$ çš„å‰æä¸‹ï¼Œå°†å“ªå‡ ä»¶ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä»¥ä½¿å¾—èƒŒåŒ…çš„æ€»ä»·å€¼æœ€å¤§ï¼Ÿ æ³¨æ„ï¼šæ¯ä¸ªç‰©å“åªæœ‰ $1$ ä»¶ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªç‰©å“åªèƒ½é€‰æ‹© $0$ ä»¶æˆ–è€… $1$ ä»¶ï¼Œå› æ­¤ç§°ä¸º $0-1$èƒŒåŒ…é—®é¢˜ å¦‚æœé‡‡å–è´ªå¿ƒç­–ç•¥ï¼Œæœ‰ $3$ ä¸ªæ–¹æ¡ˆ â‘  ä»·å€¼ä¸»å¯¼ï¼šä¼˜å…ˆé€‰æ‹©ä»·å€¼æœ€é«˜çš„ç‰©å“æ”¾è¿›èƒŒåŒ… â‘¡ é‡é‡ä¸»å¯¼ï¼šä¼˜å…ˆé€‰æ‹©é‡é‡æœ€è½»çš„ç‰©å“æ”¾è¿›èƒŒåŒ… â‘¢ ä»·å€¼å¯†åº¦ä¸»å¯¼ï¼šä¼˜å…ˆé€‰æ‹©ä»·å€¼å¯†åº¦æœ€é«˜çš„ç‰©å“æ”¾è¿›èƒŒåŒ…ï¼ˆä»·å€¼å¯†åº¦ = ä»·å€¼ Ã· é‡é‡ï¼‰ 0-1èƒŒåŒ… â€“ å®ä¾‹å‡è®¾èƒŒåŒ…æœ€å¤§æ‰¿é‡ $150$ï¼Œ$7$ ä¸ªç‰©å“å¦‚è¡¨æ ¼æ‰€ç¤º ç¼–å· 1 2 3 4 5 6 7 é‡é‡ 35 30 60 50 40 10 25 ä»·å€¼ 10 40 30 50 35 40 30 ä»·å€¼å¯†åº¦ 0.29 1.33 0.5 1.0 0.88 4.0 1.2 â‘  ä»·å€¼ä¸»å¯¼ï¼šæ”¾å…¥èƒŒåŒ…çš„ç‰©å“ç¼–å·æ˜¯ $4ã€2ã€6ã€5$ï¼Œæ€»é‡é‡ $130$ï¼Œæ€»ä»·å€¼ $165$ â‘¡ é‡é‡ä¸»å¯¼ï¼šæ”¾å…¥èƒŒåŒ…çš„ç‰©å“ç¼–å·æ˜¯ $6ã€7ã€2ã€1ã€5$ï¼Œæ€»é‡é‡ $140$ï¼Œæ€»ä»·å€¼ $155$ â‘¢ ä»·å€¼å¯†åº¦ä¸»å¯¼ï¼šæ”¾å…¥èƒŒåŒ…çš„ç‰©å“ç¼–å·æ˜¯ $6ã€2ã€7ã€4ã€1$ï¼Œæ€»é‡é‡ $150$ï¼Œæ€»ä»·å€¼ $170$ 0-1èƒŒåŒ… â€“ å®ç°123456789101112131415161718192021222324252627static void select(String title, Comparator&lt;Article&gt; cmp) &#123; Article[] articles = new Article[] &#123; new Article(35, 10), new Article(30, 40), new Article(60, 30), new Article(50, 50), new Article(40, 35), new Article(10, 40), new Article(25, 30) &#125;; Arrays.sort(articles, cmp); int capacity = 150, weight = 0, value = 0; List&lt;Article&gt; selectedArticles = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; articles.length &amp;&amp; weight &lt; capacity; i++) &#123; int newWeight = weight + articles[i].weight; if (newWeight &lt;= capacity) &#123; weight = newWeight; value += articles[i].value; selectedArticles.add(articles[i]); &#125; &#125; System.out.println("ã€" + title + "ã€‘"); System.out.println("æ€»ä»·å€¼ï¼š" + value); for (int i = 0; i &lt; selectedArticles.size(); i++) &#123; System.out.println(selectedArticles.get(i)); &#125; System.out.println("-----------------------------");&#125; 1234567891011public static void main(String[] args) &#123; select("ä»·å€¼ä¸»å¯¼", (Article a1, Article a2) -&gt; &#123; return a2.value - a1.value; &#125;); select("é‡é‡ä¸»å¯¼", (Article a1, Article a2) -&gt; &#123; return a1.weight - a2.weight; &#125;); select("ä»·å€¼å¯†åº¦ä¸»å¯¼", (Article a1, Article a2) -&gt; &#123; return Double.compare(a2.valueDensity, a1.valueDensity); &#125;);&#125; 1234567891011121314public class Article &#123; public int weight; public int value; public double valueDensity; public Article(int weight, int value) &#123; this.weight = weight; this.value = value; valueDensity = value * 1.0 / weight; &#125; @Override public String toString() &#123; return "Article [weight=" + weight + ", value=" + value + ", valueDensity=" + valueDensity + "]"; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›æº¯]]></title>
    <url>%2F2020%2F07%2F18%2F%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[å›æº¯ï¼ˆBack Trackingï¼‰ä»€ä¹ˆæ˜¯å›æº¯å›æº¯å¯ä»¥ç†è§£ä¸ºï¼šé€šè¿‡é€‰æ‹©ä¸åŒçš„å²”è·¯å£æ¥é€šå¾€ç›®çš„åœ°ï¼ˆæ‰¾åˆ°æƒ³è¦çš„ç»“æœï¼‰ æ¯ä¸€æ­¥éƒ½é€‰æ‹©ä¸€æ¡è·¯å‡ºå‘ï¼Œèƒ½è¿›åˆ™è¿›ï¼Œä¸èƒ½è¿›åˆ™é€€å›ä¸Šä¸€æ­¥ï¼ˆå›æº¯ï¼‰ï¼Œæ¢ä¸€æ¡è·¯å†è¯• æ ‘ã€å›¾çš„æ·±åº¦ä¼˜å…ˆæœç´¢ ($DFS$)ã€å…«çš‡åã€èµ°è¿·å®«éƒ½æ˜¯å…¸å‹çš„å›æº¯åº”ç”¨ å…«çš‡åé—®é¢˜ï¼ˆEight Queensï¼‰å…«çš‡åé—®é¢˜æ˜¯ä¸€ä¸ªå¤è€è€Œè‘—åçš„é—®é¢˜ åœ¨ $8*8$ æ ¼çš„å›½é™…è±¡æ£‹ä¸Šæ‘†æ”¾å…«ä¸ªçš‡åï¼Œä½¿å…¶ä¸èƒ½äº’ç›¸æ”»å‡»ï¼šä»»æ„ä¸¤ä¸ªçš‡åéƒ½ä¸èƒ½å¤„äºåŒä¸€è¡Œã€åŒä¸€åˆ—ã€åŒä¸€æ–œçº¿ä¸Š è¯·é—®æœ‰å¤šå°‘ç§æ‘†æ³•ï¼Ÿ å…«çš‡åé—®é¢˜çš„è§£å†³æ€è·¯æ€è·¯ä¸€ï¼šæš´åŠ›å‡ºå¥‡è¿¹ ä» $64$ ä¸ªæ ¼å­ä¸­é€‰å‡ºä»»æ„ $8$ ä¸ªæ ¼å­æ‘†æ”¾çš‡åï¼Œæ£€æŸ¥æ¯ä¸€ç§æ‘†æ³•çš„å¯è¡Œæ€§ ä¸€å…± $C^8_{64}$ ç§æ‘†æ³•ï¼ˆå¤§æ¦‚æ˜¯ $4.4 âˆ— 10^9$ ç§æ‘†æ³•ï¼‰ æ€è·¯äºŒï¼šæ ¹æ®é¢˜æ„å‡å°æš´åŠ›ç¨‹åº¦ å¾ˆæ˜¾ç„¶ï¼Œæ¯ä¸€è¡Œåªèƒ½æ”¾ä¸€ä¸ªçš‡åï¼Œæ‰€ä»¥å…±æœ‰ $88$ ç§æ‘†æ³•ï¼ˆ $16777216$ ç§ï¼‰ï¼Œæ£€æŸ¥æ¯ä¸€ç§æ‘†æ³•çš„å¯è¡Œæ€§ A^m_n = n(n-1) \cdots (n-m+1) = \frac{n!}{(n-m)!} \\ C^m_n = \frac{A^m_n}{m!} = \frac{n!}{m!(n-m)!} = C^{n-m}_næ€è·¯ä¸‰ï¼šå›æº¯æ³• å›æº¯ + å‰ªæ å››çš‡å â€“ å›æº¯æ³•åœ¨è§£å†³å…«çš‡åé—®é¢˜ä¹‹å‰ï¼Œå¯ä»¥å…ˆç¼©å°æ•°æ®è§„æ¨¡ï¼Œçœ‹çœ‹å¦‚ä½•è§£å†³å››çš‡åé—®é¢˜ å››çš‡å â€“ å‰ªæï¼ˆPruningï¼‰ å…«çš‡å â€“ å›æº¯æ³• å…«çš‡åå®ç° â€“ åˆæ³•æ€§æ£€æŸ¥123456789101112131415161718192021// æ•°ç»„ç´¢å¼•æ˜¯è¡Œå·ï¼Œæ•°ç»„å…ƒç´ æ˜¯åˆ—å·int[] cols;// ä¸€å…±æœ‰å¤šå°‘ç§æ‘†æ³•int ways;// åˆ¤æ–­ç¬¬rowè¡Œç¬¬colåˆ—æ˜¯å¦å¯ä»¥æ‘†æ”¾çš‡åboolean isValid(int row, int col) &#123; for (int i = 0; i &lt; row; i++) &#123; // ç¬¬colåˆ—å·²ç»æœ‰çš‡å if (cols[i] == col) &#123; return false; &#125; // ç¬¬iè¡Œçš„çš‡åè·Ÿç¬¬rowè¡Œç¬¬colåˆ—æ ¼å­å¤„åœ¨åŒä¸€æ–œçº¿ä¸Š // æ–œç‡ç­‰äº -1 æˆ– 1 if (row - i == Math.abs(col - cols[i])) &#123; return false; &#125; &#125; return true;&#125; å…«çš‡åå®ç° â€“ æ‰“å°12345678910111213void show() &#123; for (int row = 0; row &lt; cols.length; row++) &#123; for (int col = 0; col &lt; cols.length; col++) &#123; if (cols[row] == col) &#123; System.out.print("1 "); &#125; else &#123; System.out.print("0 "); &#125; &#125; System.out.println(); &#125; System.out.println("------------------------------");&#125; å…«çš‡åå®ç° â€“ ä»æŸä¸€è¡Œå¼€å§‹æ‘†æ”¾çš‡å123456789101112131415161718192021// ä»ç¬¬rowè¡Œå¼€å§‹æ‘†æ”¾çš‡åvoid place(int row) &#123; // colsçš„å¤§å°ä¸ºnï¼Œrow == nï¼Œnä¸ªéƒ½æ‘†å®Œï¼Œè¯æ˜è¿™æ¬¡çš„nä¸ªæ‘†æ”¾æ˜¯æ­£ç¡®çš„ // æ‘†æ³•++ï¼Œå±•ç¤ºæ‘†æ³•æ–¹å¼ if (row == cols.length) &#123; ways++; show(); // ç»§ç»­å¯»æ‰¾å…¶ä»–å¯èƒ½çš„æ‘†æ³•æ–¹å¼ return; &#125; // ä¸æ»¡è¶³æ—¶å›æº¯ï¼Œè¡Œrow--ï¼Œåˆ—col++ for (int col = 0; col &lt; cols.length; col++) &#123; if (isValid(row, col)) &#123; // åœ¨ç¬¬rowè¡Œç¬¬colåˆ—æ‘†æ”¾çš‡å cols[row] = col; // æ»¡è¶³æ—¶è¡Œrow++ï¼Œç»§ç»­å°è¯•åœ¨ä¸‹ä¸€è¡Œæ‘†æ”¾ï¼ˆé€’å½’ï¼‰ place(row + 1); &#125; &#125;&#125; å…«çš‡åå®ç° â€“ æ‘†æ”¾æ‰€æœ‰çš‡å123456void placeQueens(int n) &#123; if (n &lt; 1) return; cols = new int[n]; place(0); System.out.println(n + "çš‡åä¸€å…±æœ‰" + ways + "ç§æ‘†æ³•");&#125; å…«çš‡åä¼˜åŒ– â€“ æˆå‘˜å˜é‡12345678910111213141516// æ•°ç»„ç´¢å¼•æ˜¯è¡Œå·ï¼Œæ•°ç»„å…ƒç´ æ˜¯åˆ—å·// ä»…åœ¨æ‰“å°ä¸­ä½¿ç”¨int[] queens;// æ ‡è®°ç€æŸä¸€åˆ—æ˜¯å¦æœ‰çš‡åï¼Œè¡Œå·ä¸ç”¨è€ƒè™‘boolean[] cols;// æ ‡è®°ç€æŸä¸€æ–œçº¿ä¸Šæ˜¯å¦æœ‰çš‡åï¼ˆå·¦ä¸Šè§’ -&gt; å³ä¸‹è§’ï¼‰â†˜// ä¸¾ä¾‹ï¼šå½“nä¸º4æ—¶ï¼Œä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’æœ‰7æ¡æ–œçº¿ n^2 - 1boolean[] leftTop;// æ ‡è®°ç€æŸä¸€æ–œçº¿ä¸Šæ˜¯å¦æœ‰çš‡åï¼ˆå³ä¸Šè§’ -&gt; å·¦ä¸‹è§’ï¼‰â†™boolean[] rightTop;// ä¸€å…±æœ‰å¤šå°‘ç§æ‘†æ³•int ways; å…«çš‡åä¼˜åŒ– â€“ ä»æŸä¸€è¡Œå¼€å§‹æ‘†æ”¾çš‡å1234567891011121314151617181920212223242526272829303132void place(int row) &#123; if (row == cols.length) &#123; ways++; show(); return; &#125; for (int col = 0; col &lt; cols.length; col++) &#123; // å¦‚æœæˆç«‹ï¼Œæ„å‘³ç€colåˆ—å·²ç»æœ‰çš‡å if (cols[col]) continue; // ä¸¤æ¡æ–œçº¿æ˜¯å¦æœ‰çš‡å int ltIndex = row - col + cols.length - 1; if (leftTop[ltIndex]) continue; int rtIndex = row +col; if (rightTop[rtIndex]) continue; // colåˆ—ã€ä¸¤æ¡æ–œçº¿æ²¡çš‡å // queens å›æº¯æ—¶ä¸ç”¨ä¿®æ”¹ï¼Œä¼šè¢«åæ¥è¦†ç›– // queens åªåœ¨æ‰“å°æ—¶ä½¿ç”¨ queens[row] = col; cols[col] = true; leftTop[ltIndex] = true; rightTop[rtIndex] = true; place(row + 1); // å›æº¯ï¼ˆæ¢å¤ç°åœºï¼‰ cols[col] = false; leftTop[ltIndex] = false; rightTop[rtIndex] = false; &#125;&#125; å…«çš‡åä¼˜åŒ– â€“ æ‘†æ”¾æ‰€æœ‰çš‡å123456789void placeQueens(int n) &#123; if (n &lt; 1) return; queens = new int[n]; cols = new boolean[n]; leftTop = new boolean[(n &lt;&lt; 1) - 1]; rightTop = new boolean[leftTop.length]; place(0); System.out.println(n + "çš‡åä¸€å…±æœ‰" + ways + "ç§æ‘†æ³•");&#125; å…«çš‡åä¼˜åŒ– â€“ å¯¹è§’çº¿å·¦ä¸Šè§’ -&gt; å³ä¸‹è§’çš„å¯¹è§’çº¿ç´¢å¼•ï¼š$row â€“ col + 7$ å³ä¸Šè§’ -&gt; å·¦ä¸‹è§’çš„å¯¹è§’çº¿ç´¢å¼•ï¼š$row + col$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>ç®—æ³•å¯¹ç­–</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›æº¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€çŸ­è·¯å¾„]]></title>
    <url>%2F2020%2F07%2F15%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[æœ€çŸ­è·¯å¾„ï¼ˆShortest Pathï¼‰ä»€ä¹ˆæ˜¯æœ€çŸ­è·¯å¾„æœ€çŸ­è·¯å¾„æ˜¯æŒ‡ä¸¤é¡¶ç‚¹ä¹‹é—´æƒå€¼ä¹‹å’Œæœ€å°çš„è·¯å¾„ï¼ˆæœ‰å‘å›¾ã€æ— å‘å›¾å‡é€‚ç”¨ï¼Œä¸èƒ½æœ‰è´Ÿæƒç¯ï¼‰ æ— æƒå›¾ç›¸å½“äºæ˜¯å…¨éƒ¨è¾¹æƒå€¼ä¸º $1$ çš„æœ‰æƒå›¾ æœ€çŸ­è·¯å¾„ â€“ è´Ÿæƒè¾¹æœ‰è´Ÿæƒè¾¹ï¼Œä½†æ²¡æœ‰è´Ÿæƒç¯æ—¶ï¼Œå­˜åœ¨æœ€çŸ­è·¯å¾„ $A$ åˆ° $E$ çš„æœ€çŸ­è·¯å¾„æ˜¯ï¼š$A â†’ B â†’ E$ æœ€çŸ­è·¯å¾„ â€“ è´Ÿæƒç¯æœ‰è´Ÿæƒç¯æ—¶ï¼Œä¸å­˜åœ¨æœ€çŸ­è·¯å¾„ é€šè¿‡è´Ÿæƒç¯ï¼Œ $A$ åˆ° $E$ çš„è·¯å¾„å¯ä»¥æ— é™çŸ­ $A â†’ E â†’ D â†’ F â†’ E â†’ D â†’ F â†’ E â†’ D â†’ F â†’ E â†’ D â†’ F â†’ E â†’ â€¦â€¦$ æ±‚è§£æœ€çŸ­è·¯å¾„çš„3ä¸ªç»å…¸ç®—æ³•æœ€çŸ­è·¯å¾„çš„å…¸å‹åº”ç”¨ä¹‹ä¸€ï¼šè·¯å¾„è§„åˆ’é—®é¢˜ å•æºæœ€çŸ­è·¯å¾„ç®—æ³• $Dijkstra$ï¼ˆè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ï¼‰ $Bellman-Ford$ï¼ˆè´å°”æ›¼-ç¦ç‰¹ç®—æ³•ï¼‰ å¤šæºæœ€çŸ­è·¯å¾„ç®—æ³• $Floyd$ï¼ˆå¼—æ´›ä¼Šå¾·ç®—æ³•ï¼‰ Dijkstra$Dijkstra$ å±äºå•æºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œç”¨äºè®¡ç®—ä¸€ä¸ªé¡¶ç‚¹åˆ°å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ ä½¿ç”¨å‰æï¼šä¸èƒ½æœ‰è´Ÿæƒè¾¹ æ—¶é—´å¤æ‚åº¦ï¼šå¯ä¼˜åŒ–è‡³ $O(ElogV)$ ï¼Œ$E$ æ˜¯è¾¹æ•°é‡ï¼Œ$V$ æ˜¯èŠ‚ç‚¹æ•°é‡ ç”±è·å…°çš„ç§‘å­¦å®¶ $Edsger Wybe Dijkstra$ å‘æ˜ï¼Œæ›¾åœ¨ $1972$ å¹´è·å¾—å›¾çµå¥– Dijkstra â€“ ç­‰ä»·æ€è€ƒ$Dijkstra$ çš„åŸç†å…¶å®è·Ÿç”Ÿæ´»ä¸­çš„ä¸€äº›è‡ªç„¶ç°è±¡å®Œå…¨ä¸€æ · æŠŠæ¯ $1$ ä¸ªé¡¶ç‚¹æƒ³è±¡æˆæ˜¯ $1$ å—å°çŸ³å¤´ æ¯ $1$ æ¡è¾¹æƒ³è±¡æˆæ˜¯ $1$ æ¡ç»³å­ï¼Œæ¯ä¸€æ¡ç»³å­éƒ½è¿æ¥ç€ $2$ å—å°çŸ³å¤´ï¼Œè¾¹çš„æƒå€¼å°±æ˜¯ç»³å­çš„é•¿åº¦ å°†å°çŸ³å¤´å’Œç»³å­å¹³æ”¾åœ¨ä¸€å¼ æ¡Œå­ä¸Šï¼ˆä¸‹å›¾æ˜¯ä¸€å¼ ä¿¯è§†å›¾ï¼Œå›¾ä¸­é»„é¢œè‰²çš„æ˜¯æ¡Œå­ï¼‰ æ¥ä¸‹æ¥æƒ³è±¡ä¸€ä¸‹ï¼Œæ‰‹æ‹½ç€å°çŸ³å¤´ $A$ï¼Œæ…¢æ…¢åœ°å‘ä¸Šæèµ·æ¥ï¼Œè¿œç¦»æ¡Œé¢ $Bã€Dã€Cã€E$ä¼šä¾æ¬¡ç¦»å¼€æ¡Œé¢ æœ€åç»·ç›´çš„ç»³å­å°±æ˜¯ $A$ åˆ°å…¶ä»–å°çŸ³å¤´çš„æœ€çŸ­è·¯å¾„ æœ‰ä¸€ä¸ªå¾ˆå…³é”®çš„ä¿¡æ¯ åç¦»å¼€æ¡Œé¢çš„å°çŸ³å¤´ï¼Œéƒ½æ˜¯è¢«å…ˆç¦»å¼€æ¡Œé¢çš„å°çŸ³å¤´æ‹‰èµ·æ¥çš„ Dijkstra â€“ æ‰§è¡Œè¿‡ç¨‹ ç»¿è‰²ï¼šå·²ç»â€œç¦»å¼€æ¡Œé¢â€ï¼Œå·²ç»ç¡®å®šäº†æœ€ç»ˆçš„æœ€çŸ­è·¯å¾„ çº¢è‰²ï¼šæ›´æ–°äº†æœ€çŸ­è·¯å¾„ä¿¡æ¯ æ¾å¼›æ“ä½œ$ï¼ˆRelaxationï¼‰$ï¼šæ›´æ–° $2$ ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ è¿™é‡Œä¸€èˆ¬æ˜¯æŒ‡ï¼šæ›´æ–°æºç‚¹åˆ°å¦ä¸€ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„ æ¾å¼›æ“ä½œçš„æ„ä¹‰ï¼šå°è¯•æ‰¾å‡ºæ›´çŸ­çš„æœ€çŸ­è·¯å¾„ ç¡®å®š $A$ åˆ° $D$ çš„æœ€çŸ­è·¯å¾„åï¼Œå¯¹ $DCã€DE$ è¾¹è¿›è¡Œæ¾å¼›æ“ä½œï¼Œæ›´æ–°äº† $A$ åˆ° $C$ã€$A$ åˆ° $E$ çš„æœ€çŸ­è·¯å¾„ Dijkstra â€“ ä»£ç å®ç°è¾¹å’Œé¡¶ç‚¹çš„å®šä¹‰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static class Vertex&lt;V, E&gt; &#123; V value; Set&lt;Edge&lt;V, E&gt;&gt; inEdges = new HashSet&lt;&gt;(); Set&lt;Edge&lt;V, E&gt;&gt; outEdges = new HashSet&lt;&gt;(); Vertex(V value) &#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; return Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value); &#125; @Override public int hashCode() &#123; return value == null ? 0 : value.hashCode(); &#125; @Override public String toString() &#123; return value == null ? "null" : value.toString(); &#125;&#125;private static class Edge&lt;V, E&gt; &#123; Vertex&lt;V, E&gt; from; Vertex&lt;V, E&gt; to; E weight; Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123; this.from = from; this.to = to; &#125; EdgeInfo&lt;V, E&gt; info() &#123; return new EdgeInfo&lt;&gt;(from.value, to.value, weight); &#125; @Override public boolean equals(Object obj) &#123; Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj; return Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to); &#125; @Override public int hashCode() &#123; return from.hashCode() * 31 + to.hashCode(); &#125; @Override public String toString() &#123; return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125;private Map&lt;V, Vertex&lt;V, E&gt;&gt; vertices = new HashMap&lt;&gt;();private Set&lt;Edge&lt;V, E&gt;&gt; edges = new HashSet&lt;&gt;();private Comparator&lt;Edge&lt;V, E&gt;&gt; edgeComparator = (Edge&lt;V, E&gt; e1, Edge&lt;V, E&gt; e2) -&gt; &#123; return weightManager.compare(e1.weight, e2.weight);&#125;; è¾¹ä¿¡æ¯çš„å®šä¹‰1234567891011121314151617181920212223242526272829303132public static class EdgeInfo&lt;V, E&gt; &#123; private V from; private V to; private E weight; public EdgeInfo(V from, V to, E weight) &#123; this.from = from; this.to = to; this.weight = weight; &#125; public V getFrom() &#123; return from; &#125; public void setFrom(V from) &#123; this.from = from; &#125; public V getTo() &#123; return to; &#125; public void setTo(V to) &#123; this.to = to; &#125; public E getWeight() &#123; return weight; &#125; public void setWeight(E weight) &#123; this.weight = weight; &#125; @Override public String toString() &#123; return "EdgeInfo [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; è·¯å¾„ä¿¡æ¯çš„å®šä¹‰123456789101112131415161718192021222324public static class PathInfo&lt;V, E&gt; &#123; protected E weight; protected List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new LinkedList&lt;&gt;(); public PathInfo() &#123;&#125; public PathInfo(E weight) &#123; this.weight = weight; &#125; public E getWeight() &#123; return weight; &#125; public void setWeight(E weight) &#123; this.weight = weight; &#125; public List&lt;EdgeInfo&lt;V, E&gt;&gt; getEdgeInfos() &#123; return edgeInfos; &#125; public void setEdgeInfos(List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos) &#123; this.edgeInfos = edgeInfos; &#125; @Override public String toString() &#123; return "PathInfo [weight=" + weight + ", edgeInfos=" + edgeInfos + "]"; &#125;&#125; æƒå€¼çš„å®šä¹‰å’Œæ¯”è¾ƒ1234567891011121314static WeightManager&lt;Double&gt; weightManager = new WeightManager&lt;Double&gt;() &#123; public int compare(Double w1, Double w2) &#123; return w1.compareTo(w2); &#125; public Double add(Double w1, Double w2) &#123; return w1 + w2; &#125; @Override public Double zero() &#123; return 0.0; &#125;&#125;; ä»è·¯å¾„ä¸­æŒ‘ä¸€ä¸ªæœ€å°çš„è·¯å¾„å‡ºæ¥1234567891011private Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; getMinPath(Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123; Iterator&lt;Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt;&gt; it = paths.entrySet().iterator(); Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = it.next(); while (it.hasNext()) &#123; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; entry = it.next(); if (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) &lt; 0) &#123; minEntry = entry; &#125; &#125; return minEntry;&#125; dijkstraç®—æ³•123456789101112131415161718192021222324252627282930private Map&lt;V, PathInfo&lt;V, E&gt;&gt; dijkstra(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) return null; // å·²ç»æ˜¯æœ€çŸ­è·¯å¾„ å­˜å‚¨èµ·ç‚¹åˆ°æŸä¸ªç‚¹ï¼Œï¼ˆåŒ…æ‹¬è·¯å¾„ä¿¡æ¯ï¼‰ Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = new HashMap&lt;&gt;(); // è¿˜æœªç¡®å®šæ˜¯æœ€çŸ­è·¯å¾„ Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths = new HashMap&lt;&gt;(); // åˆå§‹åŒ–ä»èµ·ç‚¹å‡ºå‘ï¼Œç›´æ¥åˆ°çš„ç‚¹ï¼Œå­˜æ”¾åˆ°paths paths.put(beginVertex, new PathInfo&lt;&gt;(weightManager.zero())); while (!paths.isEmpty()) &#123; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = getMinPath(paths); // minVertexç¦»å¼€æ¡Œé¢ Vertex&lt;V, E&gt; minVertex = minEntry.getKey(); PathInfo&lt;V, E&gt; minPath = minEntry.getValue(); selectedPaths.put(minVertex.value, minPath); paths.remove(minVertex); // å¯¹å®ƒçš„minVertexçš„outEdgesè¿›è¡Œæ¾å¼›æ“ä½œ for (Edge&lt;V, E&gt; edge : minVertex.outEdges) &#123; // å¦‚æœedge.toå·²ç»ç¦»å¼€æ¡Œé¢ï¼Œå°±æ²¡å¿…è¦è¿›è¡Œæ¾å¼›æ“ä½œ if (selectedPaths.containsKey(edge.to.value)) continue; relaxForDijkstra(edge, minPath, paths); &#125; &#125; selectedPaths.remove(begin); return selectedPaths;&#125; æ¾å¼›æ“ä½œ123456789101112131415161718192021222324/** * æ¾å¼› * @param edge éœ€è¦è¿›è¡Œæ¾å¼›çš„è¾¹ * @param fromPath edgeçš„fromçš„æœ€çŸ­è·¯å¾„ä¿¡æ¯ * @param paths å­˜æ”¾ç€å…¶ä»–ç‚¹ï¼ˆå¯¹äºdijkstraæ¥è¯´ï¼Œå°±æ˜¯è¿˜æ²¡æœ‰ç¦»å¼€æ¡Œé¢çš„ç‚¹ï¼‰çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯ */private void relaxForDijkstra(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123; // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight E newWeight = weightManager.add(fromPath.weight, edge.weight); // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„ PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to); if (oldPath != null &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= 0) return; if (oldPath == null) &#123; oldPath = new PathInfo&lt;&gt;(); paths.put(edge.to, oldPath); &#125; else &#123; oldPath.edgeInfos.clear(); &#125; oldPath.weight = newWeight; oldPath.edgeInfos.addAll(fromPath.edgeInfos); oldPath.edgeInfos.add(edge.info());&#125; Dijkstra - ç®—æ³•æµ‹è¯•æ„å»ºæœ‰å‘å›¾1234567891011121314private static Graph&lt;Object, Double&gt; directedGraph(Object[][] data) &#123; Graph&lt;Object, Double&gt; graph = new ListGraph&lt;&gt;(weightManager); for (Object[] edge : data) &#123; if (edge.length == 1) &#123; graph.addVertex(edge[0]); &#125; else if (edge.length == 2) &#123; graph.addEdge(edge[0], edge[1]); &#125; else if (edge.length == 3) &#123; double weight = Double.parseDouble(edge[2].toString()); graph.addEdge(edge[0], edge[1], weight); &#125; &#125; return graph;&#125; æ— è´Ÿæƒå€¼æµ‹è¯• 1234567891011121314public static void main(String[] args) &#123; public static final Object[][] SP = &#123; &#123;"A", "B", 10&#125;, &#123;"A", "D", 30&#125;, &#123;"A", "E", 100&#125;, &#123;"B", "C", 50&#125;, &#123;"C", "E", 10&#125;, &#123;"D", "C", 20&#125;, &#123;"D", "E", 60&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.SP); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra("A"); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; æœ‰è´Ÿæƒå€¼æµ‹è¯•ï¼ˆdijkstraä¸èƒ½æœ‰è´Ÿæƒè¾¹ï¼‰ 1234567891011121314public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT1 = &#123; &#123;"A", "B", -1&#125;, &#123;"A", "C", 4&#125;, &#123;"B", "C", 3&#125;, &#123;"B", "D", 2&#125;, &#123;"B", "E", 2&#125;, &#123;"D", "B", 1&#125;, &#123;"D", "C", 5&#125;, &#123;"E", "D", -3&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.dijkstra("A"); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; $dijkstra$ ç®—æ³•ä¸èƒ½æœ‰è´Ÿæƒè¾¹ï¼Œä¸ç„¶ä¼šç®—é”™ Bellmanâˆ’FordBellmanâˆ’Ford - æ˜¯ä»€ä¹ˆ$Bellman-Ford$ ä¹Ÿå±äºå•æºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œæ”¯æŒè´Ÿæƒè¾¹ï¼Œè¿˜èƒ½æ£€æµ‹å‡ºæ˜¯å¦æœ‰è´Ÿæƒç¯ ç®—æ³•åŸç†ï¼šå¯¹æ‰€æœ‰çš„è¾¹è¿›è¡Œ $V â€“ 1$ æ¬¡æ¾å¼›æ“ä½œï¼ˆ $V$ æ˜¯èŠ‚ç‚¹æ•°é‡ï¼‰ï¼Œå¾—åˆ°æ‰€æœ‰å¯èƒ½çš„æœ€çŸ­è·¯å¾„ æ—¶é—´å¤æ‚åº¦ï¼š$O(EV)$ ï¼Œ$E$ æ˜¯è¾¹æ•°é‡ï¼Œ$V$ æ˜¯èŠ‚ç‚¹æ•°é‡ ä¸‹å›¾çš„æœ€å¥½æƒ…å†µæ˜¯æ°å¥½ä»å·¦åˆ°å³çš„é¡ºåºå¯¹è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ å¯¹æ‰€æœ‰è¾¹ä»…éœ€è¿›è¡Œ $1$ æ¬¡æ¾å¼›æ“ä½œå°±èƒ½è®¡ç®—å‡º $A$ åˆ°è¾¾å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ æœ€åæƒ…å†µæ˜¯æ°å¥½æ¯æ¬¡éƒ½ä»å³åˆ°å·¦çš„é¡ºåºå¯¹è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ å¯¹æ‰€æœ‰è¾¹éœ€è¿›è¡Œ $V â€“ 1$ æ¬¡æ¾å¼›æ“ä½œæ‰èƒ½è®¡ç®—å‡º $A$ åˆ°è¾¾å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ Bellman-Ford â€“ å®ä¾‹ä¸€å…± $8$ æ¡è¾¹ å‡è®¾æ¯æ¬¡æ¾å¼›æ“ä½œçš„é¡ºåºæ˜¯ï¼š$DCã€DFã€BCã€EDã€EFã€BEã€AEã€AB$ ä¸éš¾åˆ†æå‡ºï¼Œç»è¿‡ $4$ æ¬¡æ¾å¼›æ“ä½œä¹‹åï¼Œå·²ç»è®¡ç®—å‡ºäº† $A$ åˆ°å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ Bellman-Ford â€“ ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private Map&lt;V, PathInfo&lt;V, E&gt;&gt; bellmanFord(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) return null; Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = new HashMap&lt;&gt;(); // åˆå§‹åŒ–èµ·ç‚¹æƒå€¼ä¸º0ï¼Œï¼ˆA -&gt; A = 0ï¼‰åç»­æ¾å¼›æ“ä½œæ‰èƒ½è®¡ç®—ï¼Œæƒå€¼ç›¸åŠ å’Œæ¯”è¾ƒä¸èƒ½ä¸ºnull selectedPaths.put(begin, new PathInfo&lt;&gt;(weightManager.zero())); int count = vertices.size() - 1; for (int i = 0; i &lt; count; i++) &#123; // v - 1 æ¬¡ for (Edge&lt;V, E&gt; edge : edges) &#123; PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value); if (fromPath == null) continue; relax(edge, fromPath, selectedPaths); &#125; &#125; // åˆ¤æ–­æ˜¯å¦æœ‰ç¯ for (Edge&lt;V, E&gt; edge : edges) &#123; PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value); if (fromPath == null) continue; if (relax(edge, fromPath, selectedPaths)) &#123; System.out.println("æœ‰è´Ÿæƒç¯"); return null; &#125; &#125; selectedPaths.remove(begin); return selectedPaths;&#125;/** * æ¾å¼› * @param edge éœ€è¦è¿›è¡Œæ¾å¼›çš„è¾¹ * @param fromPath edgeçš„fromçš„æœ€çŸ­è·¯å¾„ä¿¡æ¯ * @param paths å­˜æ”¾ç€å…¶ä»–ç‚¹ï¼ˆå¯¹äºdijkstraæ¥è¯´ï¼Œå°±æ˜¯è¿˜æ²¡æœ‰ç¦»å¼€æ¡Œé¢çš„ç‚¹ï¼‰çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯ */private boolean relax(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;V, PathInfo&lt;V, E&gt;&gt; paths) &#123; // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight E newWeight = weightManager.add(fromPath.weight, edge.weight); // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„ PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to.value); if (oldPath != null &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= 0) return false; if (oldPath == null) &#123; oldPath = new PathInfo&lt;&gt;(); paths.put(edge.to.value, oldPath); &#125; else &#123; oldPath.edgeInfos.clear(); &#125; oldPath.weight = newWeight; oldPath.edgeInfos.addAll(fromPath.edgeInfos); oldPath.edgeInfos.add(edge.info()); return true;&#125; Bellman-Ford â€“ ç®—æ³•æµ‹è¯•æœ‰è´Ÿæƒå€¼æµ‹è¯• 1234567891011121314public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT1 = &#123; &#123;"A", "B", -1&#125;, &#123;"A", "C", 4&#125;, &#123;"B", "C", 3&#125;, &#123;"B", "D", 2&#125;, &#123;"B", "E", 2&#125;, &#123;"D", "B", 1&#125;, &#123;"D", "C", 5&#125;, &#123;"E", "D", -3&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord("A"); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; æœ‰è´Ÿæƒç¯æµ‹è¯• 12345678910111213public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT2 = &#123; &#123;0, 1, 1&#125;, &#123;1, 2, 7&#125;, &#123;1, 0, -2&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT2); Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; sp = graph.bellmanFord(0); if (sp == null) return; sp.forEach((Object v, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(v + " - " + path); &#125;);&#125; FloydFloyd - æ˜¯ä»€ä¹ˆ$Floyd$ å±äºå¤šæºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œèƒ½å¤Ÿæ±‚å‡ºä»»æ„ $2$ ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œæ”¯æŒè´Ÿæƒè¾¹ æ—¶é—´å¤æ‚åº¦ï¼š$O(V^3)$ï¼Œæ•ˆç‡æ¯”æ‰§è¡Œ $V$ æ¬¡ $Dijkstra$ ç®—æ³•è¦å¥½ï¼ˆ $V$ æ˜¯é¡¶ç‚¹æ•°é‡ï¼‰ ç®—æ³•åŸç† ä»ä»»æ„é¡¶ç‚¹ $i$ åˆ°ä»»æ„é¡¶ç‚¹ $j$ çš„æœ€çŸ­è·¯å¾„ä¸å¤–ä¹ä¸¤ç§å¯èƒ½ â‘  ç›´æ¥ä» $i$ åˆ° $j$ â‘¡ ä» $i$ ç»è¿‡è‹¥å¹²ä¸ªé¡¶ç‚¹åˆ° $j$ å‡è®¾ $dist(iï¼Œj)$ ä¸ºé¡¶ç‚¹ $i$ åˆ°é¡¶ç‚¹ $j$ çš„æœ€çŸ­è·¯å¾„çš„è·ç¦» å¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ $k$ï¼Œæ£€æŸ¥ $dist(iï¼Œk) + dist(kï¼Œj)ï¼œdist(iï¼Œj)$ æ˜¯å¦æˆç«‹ å¦‚æœæˆç«‹ï¼Œè¯æ˜ä» $i$ åˆ° $k$ å†åˆ° $j$ çš„è·¯å¾„æ¯” $i$ ç›´æ¥åˆ° $j$ çš„è·¯å¾„çŸ­ï¼Œè®¾ç½® $dist(iï¼Œj) = dist(iï¼Œk) + dist(kï¼Œj)$ å½“æˆ‘ä»¬éå†å®Œæ‰€æœ‰ç»“ç‚¹ $k$ï¼Œ$dist(iï¼Œj)$ ä¸­è®°å½•çš„ä¾¿æ˜¯ $i$ åˆ° $j$ çš„æœ€çŸ­è·¯å¾„çš„è·ç¦» 12345678910// ä¼ªä»£ç for (int k = 0; k &lt; V; k++) &#123; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (dist(i,k)) + dist(k,j) &lt; dist(i,j))&#123; dist(i,j) = dist(i,k) + dist(k,j); &#125; &#125; &#125;&#125; Floyd - ä»£ç å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; floyd() &#123; Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths = new HashMap&lt;&gt;(); // åˆå§‹åŒ– for (Edge&lt;V, E&gt; edge : edges) &#123; // æŠŠèƒ½ç›´æ¥èµ°çš„è·¯å¾„å­˜æ”¾åœ¨map Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(edge.from.value); if (map == null) &#123; map = new HashMap&lt;&gt;(); paths.put(edge.from.value, map); &#125; PathInfo&lt;V, E&gt; pathInfo = new PathInfo&lt;&gt;(edge.weight); pathInfo.edgeInfos.add(edge.info()); map.put(edge.to.value, pathInfo); &#125; vertices.forEach((V v2, Vertex&lt;V, E&gt; vertex2) -&gt; &#123; vertices.forEach((V v1, Vertex&lt;V, E&gt; vertex1) -&gt; &#123; vertices.forEach((V v3, Vertex&lt;V, E&gt; vertex3) -&gt; &#123; if (v1.equals(v2) || v2.equals(v3) || v1.equals(v3)) return; // v1 -&gt; v2 PathInfo&lt;V, E&gt; path12 = getPathInfo(v1, v2, paths); if (path12 == null) return; // v2 -&gt; v3 PathInfo&lt;V, E&gt; path23 = getPathInfo(v2, v3, paths); if (path23 == null) return; // v1 -&gt; v3 PathInfo&lt;V, E&gt; path13 = getPathInfo(v1, v3, paths); E newWeight = weightManager.add(path12.weight, path23.weight); if (path13 != null &amp;&amp; weightManager.compare(newWeight, path13.weight) &gt;= 0) return; if (path13 == null) &#123; path13 = new PathInfo&lt;V, E&gt;(); paths.get(v1).put(v3, path13); &#125; else &#123; path13.edgeInfos.clear(); &#125; path13.weight = newWeight; path13.edgeInfos.addAll(path12.edgeInfos); path13.edgeInfos.addAll(path23.edgeInfos); &#125;); &#125;); &#125;); return paths;&#125;// è·å–è·¯å¾„ä¿¡æ¯private PathInfo&lt;V, E&gt; getPathInfo(V from, V to, Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths) &#123; Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(from); return map == null ? null : map.get(to);&#125; Floyd - ç®—æ³•æµ‹è¯• 12345678910111213141516public static void main(String[] args) &#123; public static final Object[][] NEGATIVE_WEIGHT1 = &#123; &#123;"A", "B", -1&#125;, &#123;"A", "C", 4&#125;, &#123;"B", "C", 3&#125;, &#123;"B", "D", 2&#125;, &#123;"B", "E", 2&#125;, &#123;"D", "B", 1&#125;, &#123;"D", "C", 5&#125;, &#123;"E", "D", -3&#125; &#125;; Graph&lt;Object, Double&gt; graph = directedGraph(Data.NEGATIVE_WEIGHT1); Map&lt;Object, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt;&gt; sp = graph.shortestPath(); sp.forEach((Object from, Map&lt;Object, PathInfo&lt;Object, Double&gt;&gt; paths) -&gt; &#123; System.out.println(from + "---------------------"); paths.forEach((Object to, PathInfo&lt;Object, Double&gt; path) -&gt; &#123; System.out.println(to + " - " + path); &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>å›¾</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾</tag>
        <tag>Dijkstra</tag>
        <tag>è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•</tag>
        <tag>Bellman-Ford</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç”Ÿæˆæ ‘]]></title>
    <url>%2F2020%2F07%2F15%2F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ç”Ÿæˆæ ‘ï¼ˆSpanning Treeï¼‰ä»€ä¹ˆæ˜¯ç”Ÿæˆæ ‘ç”Ÿæˆæ ‘ $ï¼ˆ Spanning Tree ï¼‰$ï¼Œä¹Ÿç§°ä¸ºæ”¯æ’‘æ ‘ è¿é€šå›¾çš„æå°è¿é€šå­å›¾ï¼Œå®ƒå«æœ‰å›¾ä¸­å…¨éƒ¨çš„ $n$ ä¸ªé¡¶ç‚¹ï¼Œæ°å¥½åªæœ‰ $n â€“ 1$ æ¡è¾¹ æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼‰æœ€å°ç”Ÿæˆæ ‘$ï¼ˆMinimum Spanning Tree$ï¼Œç®€ç§°$MSTï¼‰$ ä¹Ÿç§°ä¸ºæœ€å°æƒé‡ç”Ÿæˆæ ‘$ï¼ˆMinimum Weight Spanning Treeï¼‰$ã€æœ€å°æ”¯æ’‘æ ‘ æ˜¯æ‰€æœ‰ç”Ÿæˆæ ‘ä¸­ï¼Œæ€»æƒå€¼æœ€å°çš„é‚£æ£µ é€‚ç”¨äºæœ‰æƒçš„è¿é€šå›¾ï¼ˆæ— å‘ï¼‰ æœ€å°ç”Ÿæˆæ ‘çš„åº”ç”¨æœ€å°ç”Ÿæˆæ ‘åœ¨è®¸å¤šé¢†åŸŸéƒ½æœ‰é‡è¦çš„ä½œç”¨ï¼Œä¾‹å¦‚ è¦åœ¨ $n$ ä¸ªåŸå¸‚ä¹‹é—´é“ºè®¾å…‰ç¼†ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥é€šä¿¡ é“ºè®¾å…‰ç¼†çš„è´¹ç”¨å¾ˆé«˜ï¼Œä¸”å„ä¸ªåŸå¸‚ä¹‹é—´å› ä¸ºè·ç¦»ä¸åŒç­‰å› ç´ ï¼Œé“ºè®¾å…‰ç¼†çš„è´¹ç”¨ä¹Ÿä¸åŒ å¦‚ä½•ä½¿é“ºè®¾å…‰ç¼†çš„æ€»è´¹ç”¨æœ€ä½ï¼Ÿ æœ€å°ç”Ÿæˆæ ‘çš„å®ç°ç®—æ³•å¦‚æœå›¾çš„æ¯ä¸€æ¡è¾¹çš„æƒå€¼éƒ½äº’ä¸ç›¸åŒï¼Œé‚£ä¹ˆæœ€å°ç”Ÿæˆæ ‘å°†åªæœ‰ä¸€ä¸ªï¼Œå¦åˆ™å¯èƒ½ä¼šæœ‰å¤šä¸ªæœ€å°ç”Ÿæˆæ ‘ æ±‚æœ€å°ç”Ÿæˆæ ‘çš„ $2$ ä¸ªç»å…¸ç®—æ³• $Prim$ï¼ˆæ™®é‡Œå§†ç®—æ³•ï¼‰ $Kruskal$ï¼ˆå…‹é²æ–¯å…‹å°”ç®—æ³•ï¼‰ åˆ‡åˆ†å®šç†åˆ‡åˆ†$ï¼ˆCutï¼‰$ï¼šæŠŠå›¾ä¸­çš„èŠ‚ç‚¹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç§°ä¸ºä¸€ä¸ªåˆ‡åˆ† ä¸‹å›¾æœ‰ä¸ªåˆ‡åˆ† $C = (S, T)ï¼ŒS = \{A, B, D\}ï¼ŒT = \{C, E\}$ æ¨ªåˆ‡è¾¹$ï¼ˆCrossing Edgeï¼‰$ï¼šå¦‚æœä¸€ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œåˆ†åˆ«å±äºåˆ‡åˆ†çš„ä¸¤éƒ¨åˆ†ï¼Œè¿™ä¸ªè¾¹ç§°ä¸ºæ¨ªåˆ‡è¾¹ æ¯”å¦‚ä¸Šå›¾çš„è¾¹ $BCã€BEã€DE$å°±æ˜¯æ¨ªåˆ‡è¾¹ åˆ‡åˆ†å®šç†ï¼šç»™å®šä»»æ„åˆ‡åˆ†ï¼Œæ¨ªåˆ‡è¾¹ä¸­æƒå€¼æœ€å°çš„è¾¹å¿…ç„¶å±äºæœ€å°ç”Ÿæˆæ ‘ è¾¹å’Œé¡¶ç‚¹çš„å®šä¹‰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private static class Vertex&lt;V, E&gt; &#123; V value; Set&lt;Edge&lt;V, E&gt;&gt; inEdges = new HashSet&lt;&gt;(); Set&lt;Edge&lt;V, E&gt;&gt; outEdges = new HashSet&lt;&gt;(); Vertex(V value) &#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; return Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value); &#125; @Override public int hashCode() &#123; return value == null ? 0 : value.hashCode(); &#125; @Override public String toString() &#123; return value == null ? "null" : value.toString(); &#125;&#125;private static class Edge&lt;V, E&gt; &#123; Vertex&lt;V, E&gt; from; Vertex&lt;V, E&gt; to; E weight; Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123; this.from = from; this.to = to; &#125; EdgeInfo&lt;V, E&gt; info() &#123; return new EdgeInfo&lt;&gt;(from.value, to.value, weight); &#125; @Override public boolean equals(Object obj) &#123; Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj; return Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to); &#125; @Override public int hashCode() &#123; return from.hashCode() * 31 + to.hashCode(); &#125; @Override public String toString() &#123; return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; è¾¹ä¿¡æ¯çš„å®šä¹‰1234567891011121314151617181920212223242526272829303132public static class EdgeInfo&lt;V, E&gt; &#123; private V from; private V to; private E weight; public EdgeInfo(V from, V to, E weight) &#123; this.from = from; this.to = to; this.weight = weight; &#125; public V getFrom() &#123; return from; &#125; public void setFrom(V from) &#123; this.from = from; &#125; public V getTo() &#123; return to; &#125; public void setTo(V to) &#123; this.to = to; &#125; public E getWeight() &#123; return weight; &#125; public void setWeight(E weight) &#123; this.weight = weight; &#125; @Override public String toString() &#123; return "EdgeInfo [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; Primç®—æ³• â€“ æ‰§è¡Œè¿‡ç¨‹å‡è®¾ $G = (Vï¼ŒE)$ æ˜¯æœ‰æƒçš„è¿é€šå›¾ï¼ˆæ— å‘ï¼‰ï¼Œ$A$ æ˜¯ $G$ ä¸­æœ€å°ç”Ÿæˆæ ‘çš„è¾¹é›† ç®—æ³•ä» $S = \{ u0 \}ï¼ˆu0 âˆˆ Vï¼‰ï¼ŒA = \{ \} $ å¼€å§‹ï¼Œé‡å¤æ‰§è¡Œä¸‹è¿°æ“ä½œï¼Œç›´åˆ° $S = V $ä¸ºæ­¢ æ‰¾åˆ°åˆ‡åˆ† $C = (Sï¼ŒV â€“ S)$ çš„æœ€å°æ¨ªåˆ‡è¾¹ $(u0ï¼Œv0) $å¹¶å…¥é›†åˆ $A$ï¼ŒåŒæ—¶å°† $v0$ å¹¶å…¥é›†åˆ $S$ Primç®—æ³• â€“ å®ç°MinHeapçš„å®ç°åŸç† 12345678910111213141516171819private Set&lt;EdgeInfo&lt;V, E&gt;&gt; prim() &#123; Iterator&lt;Vertex&lt;V, E&gt;&gt; it = vertices.values().iterator(); if (!it.hasNext()) return null; Vertex&lt;V, E&gt; vertex = it.next(); Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new HashSet&lt;&gt;(); Set&lt;Vertex&lt;V, E&gt;&gt; addedVertices = new HashSet&lt;&gt;(); addedVertices.add(vertex); MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = new MinHeap&lt;&gt;(vertex.outEdges, edgeComparator); int verticesSize = vertices.size(); while (!heap.isEmpty() &amp;&amp; addedVertices.size() &lt; verticesSize) &#123; Edge&lt;V, E&gt; edge = heap.remove(); if (addedVertices.contains(edge.to)) continue; edgeInfos.add(edge.info()); addedVertices.add(edge.to); heap.addAll(edge.to.outEdges); &#125; return edgeInfos;&#125; Kruskalç®—æ³• â€“ æ‰§è¡Œè¿‡ç¨‹æŒ‰ç…§è¾¹çš„æƒé‡é¡ºåºï¼ˆä»å°åˆ°å¤§ï¼‰å°†è¾¹åŠ å…¥ç”Ÿæˆæ ‘ä¸­ï¼Œç›´åˆ°ç”Ÿæˆæ ‘ä¸­å«æœ‰ $V â€“ 1$ æ¡è¾¹ä¸ºæ­¢ï¼ˆ $V$ æ˜¯é¡¶ç‚¹æ•°é‡ï¼‰ è‹¥åŠ å…¥è¯¥è¾¹ä¼šä¸ç”Ÿæˆæ ‘å½¢æˆç¯ï¼Œåˆ™ä¸åŠ å…¥è¯¥è¾¹ ä»ç¬¬ $3$ æ¡è¾¹å¼€å§‹ï¼Œå¯èƒ½ä¼šä¸ç”Ÿæˆæ ‘å½¢æˆç¯ Kruskalç®—æ³• â€“ å®ç°1234567891011121314151617private Set&lt;EdgeInfo&lt;V, E&gt;&gt; kruskal() &#123; int edgeSize = vertices.size() - 1; if (edgeSize == -1) return null; Set&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new HashSet&lt;&gt;(); MinHeap&lt;Edge&lt;V, E&gt;&gt; heap = new MinHeap&lt;&gt;(edges, edgeComparator); UnionFind&lt;Vertex&lt;V, E&gt;&gt; uf = new UnionFind&lt;&gt;(); vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123; uf.makeSet(vertex); &#125;); while (!heap.isEmpty() &amp;&amp; edgeInfos.size() &lt; edgeSize) &#123; Edge&lt;V, E&gt; edge = heap.remove(); if (uf.isSame(edge.from, edge.to)) continue; edgeInfos.add(edge.info()); uf.union(edge.from, edge.to); &#125; return edgeInfos;&#125; æ—¶é—´å¤æ‚åº¦ï¼š$O(ElogE)$ ç®—æ³•æµ‹è¯•æ„å»ºæ— å‘å›¾12345678910111213141516private static Graph&lt;Object, Double&gt; undirectedGraph(Object[][] data) &#123; Graph&lt;Object, Double&gt; graph = new ListGraph&lt;&gt;(weightManager); for (Object[] edge : data) &#123; if (edge.length == 1) &#123; graph.addVertex(edge[0]); &#125; else if (edge.length == 2) &#123; graph.addEdge(edge[0], edge[1]); graph.addEdge(edge[1], edge[0]); &#125; else if (edge.length == 3) &#123; double weight = Double.parseDouble(edge[2].toString()); graph.addEdge(edge[0], edge[1], weight); graph.addEdge(edge[1], edge[0], weight); &#125; &#125; return graph;&#125; æ„å»ºæœ‰å‘å›¾1234567891011121314private static Graph&lt;Object, Double&gt; directedGraph(Object[][] data) &#123; Graph&lt;Object, Double&gt; graph = new ListGraph&lt;&gt;(weightManager); for (Object[] edge : data) &#123; if (edge.length == 1) &#123; graph.addVertex(edge[0]); &#125; else if (edge.length == 2) &#123; graph.addEdge(edge[0], edge[1]); &#125; else if (edge.length == 3) &#123; double weight = Double.parseDouble(edge[2].toString()); graph.addEdge(edge[0], edge[1], weight); &#125; &#125; return graph;&#125; æµ‹è¯•æ— å‘å›¾ 12345678910111213141516public static void main(String[] args) &#123; public static final Object[][] MST_01 = &#123; &#123;0, 2, 2&#125;, &#123;0, 4, 7&#125;, &#123;1, 2, 3&#125;, &#123;1, 5, 1&#125;, &#123;1, 6, 7&#125;, &#123;2, 4, 4&#125;, &#123;2, 5, 3&#125;, &#123;2, 6, 6&#125;, &#123;3, 7, 9&#125;, &#123;4, 6, 8&#125;, &#123;5, 6, 4&#125;, &#123;5, 7, 5&#125; &#125;; Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_01); // Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim(); Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal(); for (EdgeInfo&lt;Object, Double&gt; info : infos) &#123; System.out.println(info); &#125;&#125; æµ‹è¯•æœ‰å‘å›¾ 123456789101112131415public static void main(String[] args) &#123; public static final Object[][] MST_02 = &#123; &#123;"A", "B", 17&#125;, &#123;"A", "F", 1&#125;, &#123;"A", "E", 16&#125;, &#123;"B", "C", 6&#125;, &#123;"B", "D", 5&#125;, &#123;"B", "F", 11&#125;, &#123;"C", "D", 10&#125;, &#123;"D", "E", 4&#125;, &#123;"D", "F", 14&#125;, &#123;"E", "F", 33&#125; &#125;; Graph&lt;Object, Double&gt; graph = undirectedGraph(MST_02); Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.prim(); // Set&lt;EdgeInfo&lt;Object, Double&gt;&gt; infos = graph.kruskal(); for (EdgeInfo&lt;Object, Double&gt; info : infos) &#123; System.out.println(info); &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>å›¾</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾</tag>
        <tag>Prim</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOVç½‘]]></title>
    <url>%2F2020%2F07%2F15%2FAOV%E7%BD%91%2F</url>
    <content type="text"><![CDATA[AOVç½‘ï¼ˆActivity On Vertex Networkï¼‰ä¸€é¡¹å¤§çš„å·¥ç¨‹å¸¸è¢«åˆ†ä¸ºå¤šä¸ªå°çš„å­å·¥ç¨‹ å­å·¥ç¨‹ä¹‹é—´å¯èƒ½å­˜åœ¨ä¸€å®šçš„å…ˆåé¡ºåºï¼Œå³æŸäº›å­å·¥ç¨‹å¿…é¡»åœ¨å…¶ä»–çš„ä¸€äº›å­å·¥ç¨‹å®Œæˆåæ‰èƒ½å¼€å§‹ åœ¨ç°ä»£åŒ–ç®¡ç†ä¸­ï¼Œäººä»¬å¸¸ç”¨æœ‰å‘å›¾æ¥æè¿°å’Œåˆ†æä¸€é¡¹å·¥ç¨‹çš„è®¡åˆ’å’Œå®æ–½è¿‡ç¨‹ï¼Œå­å·¥ç¨‹è¢«ç§°ä¸ºæ´»åŠ¨$ï¼ˆActivityï¼‰$ ä»¥é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ã€æœ‰å‘è¾¹è¡¨ç¤ºæ´»åŠ¨ä¹‹é—´çš„å…ˆåå…³ç³»ï¼Œè¿™æ ·çš„å›¾ç®€ç§°ä¸º $AOV$ ç½‘ æ ‡å‡†çš„ $AOV$ç½‘å¿…é¡»æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾$ï¼ˆDirected Acyclic Graph$ï¼Œç®€ç§° $DAG$ï¼‰ Bä¾èµ–äºAï¼›Cä¾èµ–äºBï¼›Dä¾èµ–äºBï¼›Eä¾èµ–äºBã€Cã€Dï¼›Fä¾èµ–äºE æ‹“æ‰‘æ’åºï¼ˆTopological Sortï¼‰å‰é©±æ´»åŠ¨ï¼šæœ‰å‘è¾¹èµ·ç‚¹çš„æ´»åŠ¨ç§°ä¸ºç»ˆç‚¹çš„å‰é©±æ´»åŠ¨ åªæœ‰å½“ä¸€ä¸ªæ´»åŠ¨çš„å‰é©±å…¨éƒ¨éƒ½å®Œæˆåï¼Œè¿™ä¸ªæ´»åŠ¨æ‰èƒ½è¿›è¡Œ åç»§æ´»åŠ¨ï¼šæœ‰å‘è¾¹ç»ˆç‚¹çš„æ´»åŠ¨ç§°ä¸ºèµ·ç‚¹çš„åç»§æ´»åŠ¨ å°† AOV ç½‘ä¸­æ‰€æœ‰æ´»åŠ¨æ’æˆä¸€ä¸ªåºåˆ—ï¼Œä½¿å¾—æ¯ä¸ªæ´»åŠ¨çš„å‰é©±æ´»åŠ¨éƒ½æ’åœ¨è¯¥æ´»åŠ¨çš„å‰é¢ æ¯”å¦‚ä¸Šå›¾çš„æ‹“æ‰‘æ’åºç»“æœæ˜¯ï¼šAã€Bã€Cã€Dã€Eã€F æˆ–è€… Aã€Bã€Dã€Cã€Eã€F ï¼ˆç»“æœå¹¶ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼‰ æ‹“æ‰‘æ’åº â€“ æ€è·¯å¯ä»¥ä½¿ç”¨å¡æ©ç®—æ³•ï¼ˆKahnäº1962å¹´æå‡ºï¼‰å®Œæˆæ‹“æ‰‘æ’åº å‡è®¾ L æ˜¯å­˜æ”¾æ‹“æ‰‘æ’åºç»“æœçš„åˆ—è¡¨ â‘  æŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹æ”¾å…¥ L ä¸­ï¼Œç„¶åæŠŠè¿™äº›é¡¶ç‚¹ä»å›¾ä¸­å»æ‰ â‘¡ é‡å¤æ“ä½œ â‘ ï¼Œç›´åˆ°æ‰¾ä¸åˆ°å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹ å¦‚æœæ­¤æ—¶ L ä¸­çš„å…ƒç´ ä¸ªæ•°å’Œé¡¶ç‚¹æ€»æ•°ç›¸åŒï¼Œè¯´æ˜æ‹“æ‰‘æ’åºå®Œæˆ å¦‚æœæ­¤æ—¶ L ä¸­çš„å…ƒç´ ä¸ªæ•°å°‘äºé¡¶ç‚¹æ€»æ•°ï¼Œè¯´æ˜åŸå›¾ä¸­å­˜åœ¨ç¯ï¼Œæ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº æ‹“æ‰‘æ’åº â€“ å®ç°12345678910111213141516171819202122232425262728293031public List&lt;V&gt; topologicalSort() &#123; List&lt;V&gt; list = new ArrayList&lt;&gt;(); Queue&lt;Vertex&lt;V, E&gt;&gt; queue = new LinkedList&lt;&gt;(); Map&lt;Vertex&lt;V, E&gt;, Integer&gt; ins = new HashMap&lt;&gt;(); // åˆå§‹åŒ–ï¼ˆå°†åº¦ä¸º0çš„èŠ‚ç‚¹éƒ½æ”¾å…¥é˜Ÿåˆ—ï¼‰ vertices.forEach((V v, Vertex&lt;V, E&gt; vertex) -&gt; &#123; int in = vertex.inEdges.size(); if (in == 0) &#123; queue.offer(vertex); &#125; else &#123; ins.put(vertex, in); &#125; &#125;); while (!queue.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = queue.poll(); // æ”¾å…¥è¿”å›ç»“æœä¸­ list.add(vertex.value); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; int toIn = ins.get(edge.to) - 1; if (toIn == 0) &#123; queue.offer(edge.to); &#125; else &#123; ins.put(edge.to, toIn); &#125; &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>å›¾</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›¾]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[å›¾ï¼ˆGraphï¼‰ä»€ä¹ˆæ˜¯å›¾å›¾ç”±é¡¶ç‚¹$ï¼ˆvertexï¼‰$å’Œè¾¹$ï¼ˆedgeï¼‰$ç»„æˆï¼Œé€šå¸¸è¡¨ç¤ºä¸º $G = (V, E)$ $G$ è¡¨ç¤ºä¸€ä¸ªå›¾ï¼Œ$V$ æ˜¯é¡¶ç‚¹é›†ï¼Œ$E$ æ˜¯è¾¹é›† é¡¶ç‚¹é›† $V$ æœ‰ç©·ä¸”éç©º ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å¯ä»¥ç”¨è¾¹æ¥è¡¨ç¤ºå®ƒä»¬ä¹‹é—´çš„å…³ç³»ï¼Œè¾¹é›† $E$ å¯ä»¥æ˜¯ç©ºçš„ æœ‰å‘å›¾ï¼ˆDirected Graphï¼‰æœ‰å‘å›¾çš„è¾¹æ˜¯æœ‰æ˜ç¡®æ–¹å‘çš„ æœ‰å‘æ— ç¯å›¾ï¼ˆDirected Acyclic Graphï¼Œç®€ç§° DAGï¼‰ å¦‚æœä¸€ä¸ªæœ‰å‘å›¾ï¼Œä»ä»»æ„é¡¶ç‚¹å‡ºå‘æ— æ³•ç»è¿‡è‹¥å¹²æ¡è¾¹å›åˆ°è¯¥é¡¶ç‚¹ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ å‡ºåº¦ã€å…¥åº¦å‡ºåº¦ã€å…¥åº¦é€‚ç”¨äºæœ‰å‘å›¾ å‡ºåº¦$ï¼ˆOut-degreeï¼‰$ ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ä¸º $x$ï¼Œæ˜¯æŒ‡æœ‰ $x$ æ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºèµ·ç‚¹ é¡¶ç‚¹ $11$ çš„å‡ºåº¦æ˜¯ $3$ å…¥åº¦$ï¼ˆIn-degreeï¼‰$ ä¸€ä¸ªé¡¶ç‚¹çš„å…¥åº¦ä¸º $x$ï¼Œæ˜¯æŒ‡æœ‰ $x$ æ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºç»ˆç‚¹ é¡¶ç‚¹ $11$ çš„å…¥åº¦æ˜¯ $2$ æ— å‘å›¾ï¼ˆUndirected Graphï¼‰æ— å‘å›¾çš„è¾¹æ˜¯æ— æ–¹å‘çš„ï¼Œæ•ˆæœç±»ä¼¼äºä¸‹é¢çš„æœ‰å‘å›¾ æ··åˆå›¾ï¼ˆMixed Graphï¼‰æ··åˆå›¾çš„è¾¹å¯èƒ½æ˜¯æ— å‘çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯æœ‰å‘çš„ ç®€å•å›¾ã€å¤šé‡å›¾å¹³è¡Œè¾¹ åœ¨æ— å‘å›¾ä¸­ï¼Œå…³è”ä¸€å¯¹é¡¶ç‚¹çš„æ— å‘è¾¹å¦‚æœå¤šäº $1$ æ¡ï¼Œåˆ™ç§°è¿™äº›è¾¹ä¸ºå¹³è¡Œè¾¹ åœ¨æœ‰å‘å›¾ä¸­ï¼Œå…³è”ä¸€å¯¹é¡¶ç‚¹çš„æœ‰å‘è¾¹å¦‚æœå¤šäº $1$ æ¡ï¼Œå¹¶ä¸”å®ƒä»¬çš„çš„æ–¹å‘ç›¸åŒï¼Œåˆ™ç§°è¿™äº›è¾¹ä¸ºå¹³è¡Œè¾¹ å¤šé‡å›¾ï¼ˆMultigraphï¼‰ æœ‰å¹³è¡Œè¾¹æˆ–è€…æœ‰è‡ªç¯çš„å›¾ ç®€å•å›¾ï¼ˆSimple Graphï¼‰ æ—¢æ²¡æœ‰å¹³è¡Œè¾¹ä¹Ÿä¸æ²¡æœ‰è‡ªç¯çš„å›¾ æ— å‘å®Œå…¨å›¾ï¼ˆUndirected Complete Graphï¼‰æ— å‘å®Œå…¨å›¾çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å­˜åœ¨è¾¹ $n$ ä¸ªé¡¶ç‚¹çš„æ— å‘å®Œå…¨å›¾æœ‰ $n(n âˆ’ 1)/2$ æ¡è¾¹ $n âˆ’ 1 + n âˆ’ 2 + n âˆ’ 3 + â‹¯ + 3 + 2 + 1$ æœ‰å‘å®Œå…¨å›¾ï¼ˆDirected Complete Graphï¼‰æœ‰å‘å®Œå…¨å›¾çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å­˜åœ¨æ–¹å‘ç›¸åçš„ä¸¤æ¡è¾¹ $n$ ä¸ªé¡¶ç‚¹çš„æœ‰å‘å®Œå…¨å›¾æœ‰ $n(n âˆ’ 1)$ æ¡è¾¹ ç¨ å¯†å›¾ï¼ˆDense Graphï¼‰ï¼šè¾¹æ•°æ¥è¿‘äºæˆ–ç­‰äºå®Œå…¨å›¾ ç¨€ç–å›¾ï¼ˆSparse Graphï¼‰ï¼šè¾¹æ•°è¿œè¿œå°‘äºå®Œå…¨å›¾ æœ‰æƒå›¾ï¼ˆWeighted Graphï¼‰æœ‰æƒå›¾çš„è¾¹å¯ä»¥æ‹¥æœ‰æƒå€¼$ï¼ˆWeightï¼‰$ è¿é€šå›¾ï¼ˆConnected Graphï¼‰å¦‚æœé¡¶ç‚¹ $x$ å’Œ $y$ ä¹‹é—´å­˜åœ¨å¯ç›¸äº’æŠµè¾¾çš„è·¯å¾„ï¼ˆç›´æ¥æˆ–é—´æ¥çš„è·¯å¾„ï¼‰ï¼Œåˆ™ç§° $x$ å’Œ $y$ æ˜¯è¿é€šçš„ å¦‚æœæ— å‘å›¾ $G$ ä¸­ä»»æ„ $2$ ä¸ªé¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ï¼Œåˆ™ç§° $G$ ä¸ºè¿é€šå›¾ è¿é€šåˆ†é‡ï¼ˆConnected Componentï¼‰è¿é€šåˆ†é‡ï¼šæ— å‘å›¾çš„æå¤§è¿é€šå­å›¾ è¿é€šå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«ï¼›éè¿é€šçš„æ— å‘å›¾æœ‰å¤šä¸ªè¿é€šåˆ†é‡ ä¸‹é¢çš„æ— å‘å›¾æœ‰ $3$ ä¸ªè¿é€šåˆ†é‡ å¼ºè¿é€šå›¾ï¼ˆStrongly Connected Graphï¼‰å¦‚æœæœ‰å‘å›¾ $G$ ä¸­ä»»æ„ $2$ ä¸ªé¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ï¼Œåˆ™ç§° $G$ ä¸ºå¼ºè¿é€šå›¾ å¼ºè¿é€šåˆ†é‡ï¼ˆStrongly Connected Componentï¼‰å¼ºè¿é€šåˆ†é‡ï¼šæœ‰å‘å›¾çš„æå¤§å¼ºè¿é€šå­å›¾ å¼ºè¿é€šå›¾åªæœ‰ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«ï¼›éå¼ºè¿é€šçš„æœ‰å‘å›¾æœ‰å¤šä¸ªå¼ºè¿é€šåˆ†é‡ å›¾çš„å®ç°æ–¹æ¡ˆå›¾æœ‰2ç§å¸¸è§çš„å®ç°æ–¹æ¡ˆ é‚»æ¥çŸ©é˜µï¼ˆAdjacency Matrixï¼‰ é‚»æ¥è¡¨ï¼ˆAdjacency Listï¼‰ é‚»æ¥çŸ©é˜µï¼ˆAdjacency Matrixï¼‰ é‚»æ¥çŸ©é˜µçš„å­˜å‚¨æ–¹å¼ ä¸€ç»´æ•°ç»„å­˜æ”¾é¡¶ç‚¹ä¿¡æ¯ äºŒç»´æ•°ç»„å­˜æ”¾è¾¹ä¿¡æ¯ é‚»æ¥çŸ©é˜µæ¯”è¾ƒé€‚åˆç¨ å¯†å›¾ ä¸ç„¶ä¼šæ¯”è¾ƒæµªè´¹å†…å­˜ é‚»æ¥çŸ©é˜µ â€“ æœ‰æƒå›¾ é‚»æ¥è¡¨ï¼ˆAdjacency Listï¼‰ é‚»æ¥è¡¨ â€“ æœ‰æƒå›¾ å›¾çš„åŸºç¡€æ¥å£12345678910111213// è¾¹çš„æ•°é‡public abstract int edgesSize();// é¡¶ç‚¹çš„æ•°é‡public abstract int verticesSize();// æ·»åŠ ã€åˆ é™¤é¡¶ç‚¹public abstract void addVertex(V v);public abstract void removeVertex(V v);public abstract void addEdge(V from, V to);// æ·»åŠ æœ‰æƒè¾¹public abstract void addEdge(V from, V to, E weight);public abstract void removeEdge(V from, V to); é¡¶ç‚¹çš„å®šä¹‰1234567891011121314151617181920private static class Vertex&lt;V, E&gt; &#123; V value; Set&lt;Edge&lt;V, E&gt;&gt; inEdges = new HashSet&lt;&gt;(); Set&lt;Edge&lt;V, E&gt;&gt; outEdges = new HashSet&lt;&gt;(); Vertex(V value) &#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; return Objects.equals(value, ((Vertex&lt;V, E&gt;)obj).value); &#125; @Override public int hashCode() &#123; return value == null ? 0 : value.hashCode(); &#125; @Override public String toString() &#123; return value == null ? "null" : value.toString(); &#125;&#125; è¾¹çš„å®šä¹‰12345678910111213141516171819202122232425private static class Edge&lt;V, E&gt; &#123; Vertex&lt;V, E&gt; from; Vertex&lt;V, E&gt; to; E weight; Edge(Vertex&lt;V, E&gt; from, Vertex&lt;V, E&gt; to) &#123; this.from = from; this.to = to; &#125; @Override public boolean equals(Object obj) &#123; Edge&lt;V, E&gt; edge = (Edge&lt;V, E&gt;) obj; return Objects.equals(from, edge.from) &amp;&amp; Objects.equals(to, edge.to); &#125; @Override public int hashCode() &#123; return from.hashCode() * 31 + to.hashCode(); &#125; @Override public String toString() &#123; return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]"; &#125;&#125; å›¾çš„éå†ä»å›¾ä¸­æŸä¸€é¡¶ç‚¹å‡ºå‘è®¿é—®å›¾ä¸­å…¶ä½™é¡¶ç‚¹ï¼Œä¸”æ¯ä¸€ä¸ªé¡¶ç‚¹ä»…è¢«è®¿é—®ä¸€æ¬¡ å›¾æœ‰ $2$ ç§å¸¸è§çš„éå†æ–¹å¼ï¼ˆæœ‰å‘å›¾ã€æ— å‘å›¾éƒ½é€‚ç”¨ï¼‰ å¹¿åº¦ä¼˜å…ˆæœç´¢$ï¼ˆBreadth First Searchï¼ŒBFSï¼‰$ï¼Œåˆç§°ä¸ºå®½åº¦ä¼˜å…ˆæœç´¢ã€æ¨ªå‘ä¼˜å…ˆæœç´¢ æ·±åº¦ä¼˜å…ˆæœç´¢$ï¼ˆDepth First Searchï¼ŒDFSï¼‰$ å‘æ˜â€œæ·±åº¦ä¼˜å…ˆæœç´¢â€ç®—æ³•çš„ $2$ ä½ç§‘å­¦å®¶åœ¨ $1986$å¹´å…±åŒè·å¾—è®¡ç®—æœºé¢†åŸŸçš„æœ€é«˜å¥–ï¼šå›¾çµå¥– å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBreadth First Searchï¼‰äºŒå‰æ ‘å±‚åºéå†ä¹Ÿæ˜¯ä¸€ç§å¹¿åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ â€“ æ€è·¯ å¹¿åº¦ä¼˜å…ˆæœç´¢ â€“ å®ç°1234567891011121314151617public void bfs(&lt;Vertex&lt;V, E&gt;&gt; beginVertex) &#123; Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = new HashSet&lt;&gt;(); Queue&lt;Vertex&lt;V, E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginVertex); visitedVertices.add(beginVertex); while (!queue.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = queue.poll(); System.out.println(vertex.value); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; if (visitedVertices.contains(edge.to)) continue; queue.offer(edge.to); visitedVertices.add(edge.to); &#125; &#125;&#125; æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDepth First Searchï¼‰äºŒå‰æ ‘å‰åºéå†ä¹Ÿæ˜¯ä¸€ç§æ·±åº¦ä¼˜å…ˆæœç´¢ æ·±åº¦ä¼˜å…ˆæœç´¢ â€“ é€’å½’å®ç°123456789101112131415public void dfs(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) return; dfs(beginVertex, new HashSet&lt;&gt;());&#125;private void dfs(Vertex&lt;V, E&gt; vertex, Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices) &#123; System.out.println(vertex.value); visitedVertices.add(vertex); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; if (visitedVertices.contains(edge.to)) continue; dfs(edge.to, visitedVertices); &#125;&#125; æ·±åº¦ä¼˜å…ˆæœç´¢ â€“ éé€’å½’å®ç° 1234567891011121314151617181920212223public void dfs(Vertex&lt;V, E&gt; beginVertex) &#123; Set&lt;Vertex&lt;V, E&gt;&gt; visitedVertices = new HashSet&lt;&gt;(); Stack&lt;Vertex&lt;V, E&gt;&gt; stack = new Stack&lt;&gt;(); // å…ˆè®¿é—®èµ·ç‚¹ stack.push(beginVertex); visitedVertices.add(beginVertex); System.out.println(beginVertex.value); while (!stack.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = stack.pop(); for (Edge&lt;V, E&gt; edge : vertex.outEdges) &#123; if (visitedVertices.contains(edge.to)) continue; stack.push(edge.from); stack.push(edge.to); visitedVertices.add(edge.to); System.out.println(edge.to.value); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>å›¾</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¹¶æŸ¥é›†]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[å¹¶æŸ¥é›†ï¼ˆUnion Findï¼‰éœ€æ±‚åˆ†æå‡è®¾æœ‰nä¸ªæ‘åº„ï¼Œæœ‰äº›æ‘åº„ä¹‹é—´æœ‰è¿æ¥çš„è·¯ï¼Œæœ‰äº›æ‘åº„ä¹‹é—´å¹¶æ²¡æœ‰è¿æ¥çš„è·¯ è®¾è®¡ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œèƒ½å¤Ÿå¿«é€Ÿæ‰§è¡Œ2ä¸ªæ“ä½œ æŸ¥è¯¢2ä¸ªæ‘åº„ä¹‹é—´æ˜¯å¦æœ‰è¿æ¥çš„è·¯ è¿æ¥2ä¸ªæ‘åº„ æ•°ç»„ã€é“¾è¡¨ã€å¹³è¡¡äºŒå‰æ ‘ã€é›†åˆï¼ˆSetï¼‰ï¼Ÿ æŸ¥è¯¢ã€è¿æ¥çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ï¼š$O(n)$ å¹¶æŸ¥é›†èƒ½å¤ŸåŠåˆ°æŸ¥è¯¢ã€è¿æ¥çš„å‡æ‘Šæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(Î±(n)),Î±(n) &lt; 5$ å¹¶æŸ¥é›†éå¸¸é€‚åˆè§£å†³è¿™ç±»â€œè¿æ¥â€ç›¸å…³çš„é—®é¢˜ ä»€ä¹ˆæ˜¯å¹¶æŸ¥é›†å¹¶æŸ¥é›†ä¹Ÿå«ä½œä¸ç›¸äº¤é›†åˆï¼ˆDisjoint Setï¼‰ å¹¶æŸ¥é›†æœ‰2ä¸ªæ ¸å¿ƒæ“ä½œ æŸ¥æ‰¾$ï¼ˆFindï¼‰$ï¼šæŸ¥æ‰¾å…ƒç´ æ‰€åœ¨çš„é›†åˆï¼ˆè¿™é‡Œçš„é›†åˆå¹¶ä¸æ˜¯ç‰¹æŒ‡Setè¿™ç§æ•°æ®ç»“æ„ï¼Œæ˜¯æŒ‡å¹¿ä¹‰çš„æ•°æ®é›†åˆï¼‰ åˆå¹¶$ï¼ˆUnionï¼‰$ï¼šå°†ä¸¤ä¸ªå…ƒç´ æ‰€åœ¨çš„é›†åˆåˆå¹¶ä¸ºä¸€ä¸ªé›†åˆ æœ‰2ç§å¸¸è§çš„å®ç°æ€è·¯ $Quick Find$ æŸ¥æ‰¾$ï¼ˆFindï¼‰$çš„æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$ åˆå¹¶$ï¼ˆUnionï¼‰$çš„æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ $Quick Union$ æŸ¥æ‰¾$ï¼ˆFindï¼‰$çš„æ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$ï¼Œå¯ä»¥ä¼˜åŒ–è‡³ $O(Î±(n)),Î±(n) &lt; 5$ åˆå¹¶$ï¼ˆUnionï¼‰$çš„æ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$ï¼Œå¯ä»¥ä¼˜åŒ–è‡³ $O(Î±(n)),Î±(n) &lt; 5$ å¦‚ä½•å­˜å‚¨æ•°æ®ï¼Ÿå‡è®¾å¹¶æŸ¥é›†å¤„ç†çš„æ•°æ®éƒ½æ˜¯æ•´å‹ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨æ•´å‹æ•°ç»„æ¥å­˜å‚¨æ•°æ® ä¸éš¾çœ‹å‡º $0ã€1ã€3$ å±äºåŒä¸€é›†åˆ $2$ å•ç‹¬å±äºä¸€ä¸ªé›†åˆ $4ã€5ã€6ã€7$ å±äºåŒä¸€é›†åˆ å› æ­¤ï¼Œå¹¶æŸ¥é›†æ˜¯å¯ä»¥ç”¨æ•°ç»„å®ç°çš„æ ‘å½¢ç»“æ„ï¼ˆäºŒå‰å †ã€ä¼˜å…ˆçº§é˜Ÿåˆ—ä¹Ÿæ˜¯å¯ä»¥ç”¨æ•°ç»„å®ç°çš„æ ‘å½¢ç»“æ„ï¼‰ æ¥å£å®šä¹‰12345678// æŸ¥æ‰¾væ‰€å±çš„é›†åˆï¼ˆæ ¹èŠ‚ç‚¹ï¼‰public abstract int find(int v);// åˆå¹¶v1ã€v2æ‰€åœ¨çš„é›†åˆpublic abstract void union(int v1, int v2);// æ£€æŸ¥v1ã€v2æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆpublic boolean isSame(int v1, int v2); 123public boolean isSame(int v1, int v2) &#123; return find(v1) == find(v2);&#125; åˆå§‹åŒ–åˆå§‹åŒ–æ—¶ï¼Œæ¯ä¸ªå…ƒç´ å„è‡ªå±äºä¸€ä¸ªå•å…ƒç´ é›†åˆ 1234567891011protected int[] parents;public UnionFind(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity must be &gt;= 1"); &#125; parents = new int[capacity]; for (int i = 0; i &lt; parents.length; i++) &#123; parents[i] = i; &#125;&#125; Quick FindQuick Find â€“ Union$Quick Find$ çš„ $union(v1, v2)$ï¼šè®© $v1$ æ‰€åœ¨é›†åˆçš„æ‰€æœ‰å…ƒç´ éƒ½æŒ‡å‘ $v2$ çš„æ ¹èŠ‚ç‚¹ 123456789101112// å°†v1æ‰€åœ¨é›†åˆçš„æ‰€æœ‰å…ƒç´ ï¼Œéƒ½å«æ¥åˆ°v2çš„çˆ¶èŠ‚ç‚¹ä¸Špublic void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; for (int i = 0; i &lt; parents.length; i++) &#123; if (parents[i] == p1) &#123; parents[i] = p2; &#125; &#125;&#125; æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ Quick Find â€“ Find 12345// çˆ¶èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹public int find(int v) &#123; rangeCheck(v); return parents[v];&#125; $find(0) == 2$ | $find(1) == 2$ | $find(3) == 4$ | $find(2) == 2$ æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$ Quick UnionQuick Union â€“ Union$Quick Union$ çš„ $union(v1, v2)$ï¼šè®© $v1$ çš„æ ¹èŠ‚ç‚¹æŒ‡å‘ $v2$ çš„æ ¹èŠ‚ç‚¹ 1234567// å°†v1çš„æ ¹èŠ‚ç‚¹å«æ¥åˆ°v2çš„æ ¹èŠ‚ç‚¹ä¸Špublic void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; parents[p1] = p2;&#125; æ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$ Quick Union â€“ Find 12345678// é€šè¿‡parenté“¾æ¡ä¸æ–­åœ°å‘ä¸Šæ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æ ¹èŠ‚ç‚¹public int find(int v) &#123; rangeCheck(v); while (v != parents[v]) &#123; v = parents[v]; &#125; return v;&#125; $find(0) == 2$ | $find(1) == 2$ | $find(3) == 2$ | $find(2) == 2$ æ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$ Quick Union â€“ ä¼˜åŒ–åœ¨ $Union$ çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šå‡ºç°æ ‘ä¸å¹³è¡¡çš„æƒ…å†µï¼Œç”šè‡³é€€åŒ–æˆé“¾è¡¨ æœ‰2ç§å¸¸è§çš„ä¼˜åŒ–æ–¹æ¡ˆ åŸºäº $size$ çš„ä¼˜åŒ–ï¼šå…ƒç´ å°‘çš„æ ‘å«æ¥åˆ°å…ƒç´ å¤šçš„æ ‘ åŸºäº $rank$ çš„ä¼˜åŒ–ï¼šçŸ®çš„æ ‘å«æ¥åˆ°é«˜çš„æ ‘ Quick Union â€“ åŸºäºsizeçš„ä¼˜åŒ– 1234sizes = new int[capacity];for (int i = 0; i &lt; sizes.length; i++) &#123; sizes[i] = 1;&#125; 1234567891011121314private int[] sizes;public void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; if (sizes[p1] &lt; sizes[p2]) &#123; parents[p1] = p2; sizes[p2] += sizes[p1]; &#125; else &#123; parents[p2] = p1; sizes[p1] += sizes[p2]; &#125;&#125; åŸºäº $size$ çš„ä¼˜åŒ–ï¼Œä¹Ÿå¯èƒ½ä¼šå­˜åœ¨æ ‘ä¸å¹³è¡¡çš„é—®é¢˜ Quick Union â€“ åŸºäºrankçš„ä¼˜åŒ– 12ranks = new int[capacity];Arrays.fill(ranks, 1); 123456789101112131415private int[] ranks;public void union(int v1, int v2) &#123; int p1 = find(v1); int p2 = find(v2); if (p1 == p2) return; if (ranks[p1] &lt; ranks[p2]) &#123; parents[p1] = p2; &#125; else if (ranks[p1] &gt; ranks[p2]) &#123; parents[p2] = p1; &#125; else &#123; parents[p1] = p2; ranks[p2]++; &#125;&#125; è·¯å¾„å‹ç¼©ï¼ˆPath Compressionï¼‰è™½ç„¶æœ‰äº†åŸºäº $rank$ çš„ä¼˜åŒ–ï¼Œæ ‘ä¼šç›¸å¯¹å¹³è¡¡ä¸€ç‚¹ ä½†æ˜¯éšç€ $Union$æ¬¡æ•°çš„å¢å¤šï¼Œæ ‘çš„é«˜åº¦ä¾ç„¶ä¼šè¶Šæ¥è¶Šé«˜ å¯¼è‡´ $find$ æ“ä½œå˜æ…¢ï¼Œå°¤å…¶æ˜¯åº•å±‚èŠ‚ç‚¹ï¼ˆå› ä¸º $find$ æ˜¯ä¸æ–­å‘ä¸Šæ‰¾åˆ°æ ¹èŠ‚ç‚¹) ä»€ä¹ˆæ˜¯è·¯å¾„å‹ç¼©ï¼Ÿ åœ¨ $find$ æ—¶ä½¿è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œä»è€Œé™ä½æ ‘çš„é«˜åº¦ 1234567public int find(int v) &#123; // v == 1, parents[v] == 2 rangeCheck(v); if (parents[v] != v) &#123; parents[v] = find(parents[v]); &#125; return parents[v];&#125; è·¯å¾„å‹ç¼©ä½¿è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥å®ç°æˆæœ¬ç¨é«˜ è¿˜æœ‰ $2$ ç§æ›´ä¼˜çš„åšæ³•ï¼Œä¸ä½†èƒ½é™ä½æ ‘é«˜ï¼Œå®ç°æˆæœ¬ä¹Ÿæ¯”è·¯å¾„å‹ç¼©ä½ è·¯å¾„åˆ†è£‚$ï¼ˆPath Splitingï¼‰$ è·¯å¾„å‡åŠ$ï¼ˆPath Halvingï¼‰$ è·¯å¾„åˆ†è£‚ã€è·¯å¾„å‡åŠçš„æ•ˆç‡å·®ä¸å¤šï¼Œä½†éƒ½æ¯”è·¯å¾„å‹ç¼©è¦å¥½ è·¯å¾„åˆ†è£‚ï¼ˆPath Splitingï¼‰è·¯å¾„åˆ†è£‚ï¼šä½¿è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æŒ‡å‘å…¶ç¥–çˆ¶èŠ‚ç‚¹$ï¼ˆparent$ çš„ $parentï¼‰$ 123456789public int find(int v) &#123; rangeCheck(v); while (v != parents[v]) &#123; int p = parents[v]; parents[v] = parents[parents[v]]; v = p; &#125; return v;&#125; è·¯å¾„å‡åŠï¼ˆPath Halvingï¼‰è·¯å¾„å‡åŠï¼šä½¿è·¯å¾„ä¸Šæ¯éš”ä¸€ä¸ªèŠ‚ç‚¹å°±æŒ‡å‘å…¶ç¥–çˆ¶èŠ‚ç‚¹$ï¼ˆparent$ çš„ $parentï¼‰$ 12345678public int find(int v) &#123; rangeCheck(v); while (v != parents[v]) &#123; parents[v] = parents[parents[v]]; v = parents[v]; &#125; return v;&#125; æ€»ç»“æ‘˜è‡ªã€Šç»´åŸºç™¾ç§‘ã€‹ å¤§æ¦‚æ„æ€æ˜¯ ä½¿ç”¨è·¯å¾„å‹ç¼©ã€åˆ†è£‚æˆ–å‡åŠ + åŸºäº $rank$ æˆ–è€… $size$ çš„ä¼˜åŒ– å¯ä»¥ç¡®ä¿æ¯ä¸ªæ“ä½œçš„å‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¸º $O(ğ›¼(ğ‘›)),Î±(ğ‘›) &lt; 5$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>å›¾</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¼‘çœ æ’åº]]></title>
    <url>%2F2020%2F07%2F15%2F%E4%BC%91%E7%9C%A0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å²ä¸Šâ€œæœ€å¼ºâ€æ’åº â€“ ä¼‘çœ æ’åº1234567891011121314151617181920public class SleepSort extends Thread&#123; private int value; public SleepSort(int value)&#123; this.value = value; &#125; public void run()&#123; try &#123; Thread.sleep(value); System.out.println(value); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; int[] array = &#123;10,100,50,30,60,2&#125;; for (int item : array) &#123; new SleepSort(item).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¡¶æ’åº]]></title>
    <url>%2F2020%2F07%2F15%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[æ¡¶æ’åºï¼ˆBucket Sortï¼‰ä»€ä¹ˆæ˜¯æ¡¶æ’åºæ‰§è¡Œæµç¨‹ â‘  åˆ›å»ºä¸€å®šæ•°é‡çš„æ¡¶ï¼ˆæ¯”å¦‚ç”¨æ•°ç»„ã€é“¾è¡¨ä½œä¸ºæ¡¶ï¼‰ â‘¡ æŒ‰ç…§ä¸€å®šçš„è§„åˆ™ï¼ˆä¸åŒç±»å‹çš„æ•°æ®ï¼Œè§„åˆ™ä¸åŒï¼‰ï¼Œå°†åºåˆ—ä¸­çš„å…ƒç´ å‡åŒ€åˆ†é…åˆ°å¯¹åº”çš„æ¡¶ â‘¢ åˆ†åˆ«å¯¹æ¯ä¸ªæ¡¶è¿›è¡Œå•ç‹¬æ’åº â‘£ å°†æ‰€æœ‰éç©ºæ¡¶çš„å…ƒç´ åˆå¹¶æˆæœ‰åºåºåˆ— å…ƒç´ åœ¨æ¡¶ä¸­çš„ç´¢å¼• å…ƒç´ å€¼ * å…ƒç´ æ•°é‡ æ¡¶æ’åº â€“ å®ç°12345678910111213141516171819202122double[] array = &#123;0.34,0.47,0.29,0.84,0.45,0.38,0.35,0.76&#125;;// æ¡¶æ’åºList&lt;Double&gt;[] buckets = new List[array.length];for (double v : array) &#123; int bucketIndex = (int) (v * array.length); List&lt;Double&gt; bucket = buckets[bucketIndex]; if (bucket == null) &#123; bucket = new LinkedList&lt;&gt;(); buckets[bucketIndex] = bucket; &#125; bucket.add(v);&#125;// å¯¹æ¯ä¸ªæ¡¶è¿›è¡Œæ’åºint index = 0;for (List&lt;Double&gt; bucket : buckets) &#123; if (bucket == null) continue; bucket.sort(null); for (Double d : bucket) &#123; array[index++] = d; &#125;&#125; ç©ºé—´å¤æ‚åº¦ï¼š$O(n + m)$ï¼Œ$m$ æ˜¯æ¡¶çš„æ•°é‡ æ—¶é—´å¤æ‚åº¦ï¼š$O(n) + m âˆ— O( \frac{n} {m} âˆ— log\frac{n}{m}) = O(n + n âˆ— log\frac{n}{m}) = O(n + n âˆ— logn âˆ’ n âˆ— logm)$ å›  æ­¤ ä¸º $O(n + k)$ ï¼Œ$k$ ä¸º $n âˆ— logn âˆ’ n âˆ— logm$ å±äºç¨³å®šæ’åº]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŸºæ•°æ’åº]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[åŸºæ•°æ’åºï¼ˆRadix Sortï¼‰ä»€ä¹ˆæ˜¯åŸºæ•°æ’åºåŸºæ•°æ’åºéå¸¸é€‚åˆç”¨äºæ•´æ•°æ’åºï¼ˆå°¤å…¶æ˜¯éè´Ÿæ•´æ•°ï¼‰ï¼Œå› æ­¤æœ¬è¯¾ç¨‹åªæ¼”ç¤ºå¯¹éè´Ÿæ•´æ•°è¿›è¡ŒåŸºæ•°æ’åº æ‰§è¡Œæµç¨‹ï¼šä¾æ¬¡å¯¹ä¸ªä½æ•°ã€åä½æ•°ã€ç™¾ä½æ•°ã€åƒä½æ•°ã€ä¸‡ä½æ•°â€¦è¿›è¡Œæ’åºï¼ˆä»ä½ä½åˆ°é«˜ä½ï¼‰ ä¸ªä½æ•°ã€åä½æ•°ã€ç™¾ä½æ•°çš„å–å€¼èŒƒå›´éƒ½æ˜¯å›ºå®šçš„ $0$ ~ $9$ï¼Œå¯ä»¥ä½¿ç”¨è®¡æ•°æ’åºå¯¹å®ƒä»¬è¿›è¡Œæ’åº å¦‚æœå…ˆå¯¹é«˜ä½æ’åºï¼Œå†å¯¹ä½ä½æ’åºï¼Œæ˜¯ä¸å¯è¡Œçš„ åŸºæ•°æ’åº â€“ å®ç°123456789101112131415161718protected void sort() &#123; // æ‰¾å‡ºæœ€å¤§å€¼ int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // ä¸ªä½æ•°: array[i] / 1 % 10 = 3 // åä½æ•°ï¼šarray[i] / 10 % 10 = 9 // ç™¾ä½æ•°ï¼šarray[i] / 100 % 10 = 5 // åƒä½æ•°ï¼šarray[i] / 1000 % 10 = ... for (int divider = 1; divider &lt;= max; divider *= 10) &#123; countingSort(divider); &#125;&#125; 1234567891011121314151617181920212223protected void countingSort(int divider) &#123; // å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¬¡æ•° int[] counts = new int[10]; // ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•° for (Integer integer : array) &#123; counts[integer / divider % 10]++; &#125; // ç´¯åŠ æ¬¡æ•° for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // ä»åå¾€å‰éå†å…ƒç´ ï¼Œå°†å®ƒæ”¾åˆ°æœ‰åºæ•°ç»„ä¸­çš„åˆé€‚ä½ç½® int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] / divider % 10]] = array[i]; &#125; // å°†æœ‰åºæ•°ç»„èµ‹å€¼åˆ°array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125;&#125; æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(d âˆ— (n + k))$ ï¼Œ$d$ æ˜¯æœ€å¤§å€¼çš„ä½æ•°ï¼Œ$k$ æ˜¯è¿›åˆ¶ã€‚å±äºç¨³å®šæ’åº ç©ºé—´å¤æ‚åº¦ï¼š$O(n + k)$ï¼Œ$k$ æ˜¯è¿›åˆ¶]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡æ•°æ’åº]]></title>
    <url>%2F2020%2F07%2F15%2F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[è®¡æ•°æ’åºï¼ˆCounting Sortï¼‰å†’æ³¡ã€é€‰æ‹©ã€æ’å…¥ã€å½’å¹¶ã€å¿«é€Ÿã€å¸Œå°”ã€å †æ’åºï¼Œéƒ½æ˜¯åŸºäºæ¯”è¾ƒçš„æ’åº å¹³å‡æ—¶é—´å¤æ‚åº¦ç›®å‰æœ€ä½æ˜¯ $O(nlogn)$ è®¡æ•°æ’åºã€æ¡¶æ’åºã€åŸºæ•°æ’åºï¼Œéƒ½ä¸æ˜¯åŸºäºæ¯”è¾ƒçš„æ’åº å®ƒä»¬æ˜¯å…¸å‹çš„ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œåœ¨æŸäº›æ—¶å€™ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦å¯ä»¥æ¯” $O(nlogn)$ æ›´ä½ ä»€ä¹ˆæ˜¯è®¡æ•°æ’åºè®¡æ•°æ’åºäº1954å¹´ç”±Harold H. Sewardæå‡ºï¼Œé€‚åˆå¯¹ä¸€å®šèŒƒå›´å†…çš„æ•´æ•°è¿›è¡Œæ’åº è®¡æ•°æ’åºçš„æ ¸å¿ƒæ€æƒ³ï¼š ç»Ÿè®¡æ¯ä¸ªæ•´æ•°åœ¨åºåˆ—ä¸­å‡ºç°çš„æ¬¡æ•°ï¼Œè¿›è€Œæ¨å¯¼å‡ºæ¯ä¸ªæ•´æ•°åœ¨æœ‰åºåºåˆ—ä¸­çš„ç´¢å¼• è®¡æ•°æ’åº â€“ æœ€ç®€å•çš„å®ç° 123456789101112131415161718192021222324protected void sort() &#123; // æ‰¾å‡ºæœ€å¤§å€¼ int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // O(n) // å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•° int[] counts = new int[1 + max]; // ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•° for (Integer integer : array) &#123; counts[integer]++; &#125; // O(n) // æ ¹æ®æ•´æ•°çš„å‡ºç°æ¬¡æ•°ï¼Œå¯¹æ•´æ•°è¿›è¡Œæ’åº int index = 0; for (int i = 0; i &lt; counts.length; i++) &#123; while (counts[i]-- &gt; 0) &#123; array[index++] = i; &#125; &#125; // O(n)&#125; è¿™ä¸ªç‰ˆæœ¬çš„å®ç°å­˜åœ¨ä»¥ä¸‹é—®é¢˜ æ— æ³•å¯¹è´Ÿæ•´æ•°è¿›è¡Œæ’åº æå…¶æµªè´¹å†…å­˜ç©ºé—´ æ˜¯ä¸ªä¸ç¨³å®šçš„æ’åº è®¡æ•°æ’åº â€“ æ”¹è¿›æ€è·¯å‡è®¾ $array$ ä¸­çš„æœ€å°å€¼æ˜¯ $min$ $array$ ä¸­çš„å…ƒç´  $k$ å¯¹åº”çš„ $counts$ ç´¢å¼•æ˜¯ $k â€“ min$ $array$ ä¸­çš„å…ƒç´  $k$ åœ¨æœ‰åºåºåˆ—ä¸­çš„ç´¢å¼• $counts[k â€“ min] â€“ p$ $p$ ä»£è¡¨ç€æ˜¯å€’æ•°ç¬¬å‡ ä¸ª $k$ è®¡æ•°æ’åº â€“ æ”¹è¿›å®ç°1234567891011121314151617181920212223242526272829303132333435protected void sort() &#123; // æ‰¾å‡ºæœ€å€¼ int max = array[0]; int min = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; // å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¬¡æ•° int[] counts = new int[max - min + 1]; // ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•° for (Integer integer : array) &#123; counts[integer - min]++; &#125; // ç´¯åŠ æ¬¡æ•° for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // ä»åå¾€å‰éå†å…ƒç´ ï¼Œå°†å®ƒæ”¾åˆ°æœ‰åºæ•°ç»„ä¸­çš„åˆé€‚ä½ç½® int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] - min]] = array[i]; &#125; // å°†æœ‰åºæ•°ç»„èµ‹å€¼åˆ°array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125;&#125; æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(n + k)$ ç©ºé—´å¤æ‚åº¦ï¼š$O(n + k)$ $k$ æ˜¯æ•´æ•°çš„å–å€¼èŒƒå›´ å±äºç¨³å®šæ’åº è®¡æ•°æ’åº â€“ å¯¹è‡ªå®šä¹‰å¯¹è±¡è¿›è¡Œæ’åºå¦‚æœè‡ªå®šä¹‰å¯¹è±¡å¯ä»¥æä¾›ç”¨ä»¥æ’åºçš„æ•´æ•°ç±»å‹ï¼Œä¾ç„¶å¯ä»¥ä½¿ç”¨è®¡æ•°æ’åº 12345678910111213private static class Person &#123; int age; String name; Person(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return "Person [age=" + age + ", name=" + name + "]"; &#125;&#125; 12345678Person[] persons = new Person[] &#123; new Person(20, "A"), new Person(-13, "B"), new Person(17, "C"), new Person(12, "D"), new Person(-13, "E"), new Person(20, "F")&#125;; 1234567891011// æ‰¾å‡ºæœ€å€¼int max = persons[0].age;int min = persons[0].age;for (int i = 1; i &lt; persons.length; i++) &#123; if (persons[i].age &gt; max) &#123; max = persons[i].age; &#125; if (persons[i].age &lt; min) &#123; min = persons[i].age; &#125;&#125; 1234567891011121314151617181920212223// å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¬¡æ•°int[] counts = new int[max - min + 1];// ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•°for (Person person : persons) &#123; counts[person.age - min]++;&#125;// ç´¯åŠ æ¬¡æ•°for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1];&#125;// ä»åå¾€å‰éå†å…ƒç´ ï¼Œå°†å®ƒæ”¾åˆ°æœ‰åºæ•°ç»„ä¸­çš„åˆé€‚ä½ç½®Person[] newArray = new Person[persons.length];for (int i = persons.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[persons[i].age - min]] = persons[i];&#125;// å°†æœ‰åºæ•°ç»„èµ‹å€¼åˆ°arraySystem.arraycopy(newArray, 0, persons, 0, newArray.length);for (Person person : persons) &#123; System.out.println(person);&#125; æ’åºä¹‹åçš„ç»“æœ â‘  $Person [age=-13, name=B]$ â‘¡ $Person [age=-13, name=E]$ â‘¢ $Person [age=12, name=D]$ â‘£ $Person [age=17, name=C]$ â‘¤ $Person [age=20, name=A]$ â‘¥ $Person [age=20, name=F]$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¸Œå°”æ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å¸Œå°”æ’åºï¼ˆShell Sortï¼‰ä»€ä¹ˆæ˜¯å¸Œå°”æ’åº 1959å¹´ç”±å”çº³å¾·Â·å¸Œå°”ï¼ˆDonald Shellï¼‰æå‡º å¸Œå°”æ’åºæŠŠåºåˆ—çœ‹ä½œæ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œåˆ†æˆ ğ‘š åˆ—ï¼Œé€åˆ—è¿›è¡Œæ’åº ğ‘š ä»æŸä¸ªæ•´æ•°é€æ¸å‡ä¸º1 å½“ ğ‘š ä¸º1æ—¶ï¼Œæ•´ä¸ªåºåˆ—å°†å®Œå…¨æœ‰åº å› æ­¤ï¼Œå¸Œå°”æ’åºä¹Ÿè¢«ç§°ä¸ºé€’å‡å¢é‡æ’åºï¼ˆDiminishing Increment Sortï¼‰ çŸ©é˜µçš„åˆ—æ•°å–å†³äºæ­¥é•¿åºåˆ—ï¼ˆstep sequenceï¼‰ æ¯”å¦‚ï¼Œå¦‚æœæ­¥é•¿åºåˆ—ä¸º ${1,5,19,41,109,â€¦}$ï¼Œå°±ä»£è¡¨ä¾æ¬¡åˆ†æˆ109åˆ—ã€41åˆ—ã€19åˆ—ã€5åˆ—ã€1åˆ—è¿›è¡Œæ’åº ä¸åŒçš„æ­¥é•¿åºåˆ—ï¼Œæ‰§è¡Œæ•ˆç‡ä¹Ÿä¸åŒ å¸Œå°”æ’åº â€“ å®ä¾‹å¸Œå°”æœ¬äººç»™å‡ºçš„æ­¥é•¿åºåˆ—æ˜¯ $ğ‘›/2^ğ‘˜$ï¼Œæ¯”å¦‚ $ğ‘›$ ä¸º $16$ æ—¶ï¼Œæ­¥é•¿åºåˆ—æ˜¯ {$1, 2, 4, 8$} åˆ†æˆ8åˆ—è¿›è¡Œæ’åº åˆ†æˆ4åˆ—è¿›è¡Œæ’åº åˆ†æˆ2åˆ—è¿›è¡Œæ’åº åˆ†æˆ1åˆ—è¿›è¡Œæ’åº ä¸éš¾çœ‹å‡ºæ¥ï¼Œä»8åˆ—å˜ä¸º1åˆ—çš„è¿‡ç¨‹ä¸­ï¼Œé€†åºå¯¹çš„æ•°é‡åœ¨é€æ¸å‡å°‘ å› æ­¤å¸Œå°”æ’åºåº•å±‚ä¸€èˆ¬ä½¿ç”¨æ’å…¥æ’åºå¯¹æ¯ä¸€åˆ—è¿›è¡Œæ’åºï¼Œå¾ˆå¤šèµ„æ–™è®¤ä¸ºå¸Œå°”æ’åºæ˜¯æ’å…¥æ’åºçš„æ”¹è¿›ç‰ˆ å‡è®¾æœ‰11ä¸ªå…ƒç´ ï¼Œæ­¥é•¿åºåˆ—æ˜¯{1, 2, 5} å‡è®¾å…ƒç´ åœ¨ç¬¬ $col$ åˆ—ã€ç¬¬ $row$ è¡Œï¼Œæ­¥é•¿ï¼ˆæ€»åˆ—æ•°ï¼‰æ˜¯ $step$ é‚£ä¹ˆè¿™ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•æ˜¯ $col + row * step$ æ¯”å¦‚ $9$ åœ¨æ’åºå‰æ˜¯ç¬¬ $2$ åˆ—ã€ç¬¬ $0$ è¡Œï¼Œé‚£ä¹ˆå®ƒæ’åºå‰çš„ç´¢å¼•æ˜¯ $2 + 0 * 5 = 2$ æ¯”å¦‚ $4$ åœ¨æ’åºå‰æ˜¯ç¬¬ $2$ åˆ—ã€ç¬¬ $1$ è¡Œï¼Œé‚£ä¹ˆå®ƒæ’åºå‰çš„ç´¢å¼•æ˜¯ $2 + 1 * 5 = 7$ å¸Œå°”æ’åº â€“ å®ç°1234567891011121314151617181920protected void sort() &#123; List&lt;Integer&gt; shellSequence = shellStepSequence(); for (Integer shell : shellSequence) &#123; sort(shell); &#125;&#125;// åˆ†æˆstepåˆ—è¿›è¡Œæ’åºprivate void sort(int step) &#123; // col : ç¬¬å‡ åˆ—ï¼Œcolumnçš„ç®€ç§° for (int col = 0; col &lt; step; col++) &#123; // å¯¹ç¬¬colåˆ—è¿›è¡Œæ’åº // colã€col+stepã€col+2*stepã€col+3*step for (int begin = col + step; begin &lt; array.length; begin += step) &#123; int cur = begin; while (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; 0) &#123; swap(cur, cur - step); cur -= step; &#125; &#125; &#125;&#125; æœ€å¥½æƒ…å†µæ˜¯æ­¥é•¿åºåˆ—åªæœ‰ $1$ï¼Œä¸”åºåˆ—å‡ ä¹æœ‰åºï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ ç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ï¼Œå±äºä¸ç¨³å®šæ’åº å¸Œå°”æ’åº â€“ æ­¥é•¿åºåˆ—å¸Œå°”æœ¬äººç»™å‡ºçš„æ­¥é•¿åºåˆ—ï¼Œæœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ 12345678private List&lt;Integer&gt; shellStepSequence() &#123; List&lt;Integer&gt; stepSequence = new ArrayList&lt;&gt;(); int step = array.length; while ((step &gt;&gt;= 1) &gt; 0) &#123; stepSequence.add(step); &#125; return stepSequence;&#125; ç›®å‰å·²çŸ¥çš„æœ€å¥½çš„æ­¥é•¿åºåˆ—ï¼Œæœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^{4/3})$ ï¼Œ1986å¹´ç”±Robert Sedgewickæå‡º \begin{cases} 9 \left(2^k - 2^{\frac{k}{2}}\right) +1, & \text {k even} \\ 8 \cdot 2^k - 6 \cdot 2^{\frac{(k+1)}{2}} + 1, & \text {k odd} \\ \end{cases} \\ 1,5,19,41,109,...123456789101112131415161718private List&lt;Integer&gt; SedgewickStepSequence() &#123; List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;(); int k = 0, step = 0; while (true) &#123; if (k % 2 == 0) &#123; int pow = (int) Math.pow(2, k &gt;&gt; 1); step = 1 + 9 * (pow * pow - pow); &#125; else &#123; int pow1 = (int) Math.pow(2, (k - 1) &gt;&gt; 1); int pow2 = (int) Math.pow(2, (k + 1) &gt;&gt; 1); step = 1 + 8 * pow1 * pow2 - 6 * pow2; &#125; if (step &gt;= array.length) break; stepSequence.add(0, step); k++; &#125; return stepSequence;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¿«é€Ÿæ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰ä»€ä¹ˆæ˜¯å¿«é€Ÿæ’åº1960å¹´ç”±æŸ¥å°”æ–¯Â·å®‰ä¸œå°¼Â·ç†æŸ¥å¾·Â·éœå°”ï¼ˆCharles Antony Richard Hoareï¼Œç¼©å†™ä¸ºC. A. R. Hoareï¼‰æå‡º æ˜µç§°ä¸ºä¸œå°¼Â·éœå°”ï¼ˆTony Hoareï¼‰ å¿«é€Ÿæ’åº â€“ æ‰§è¡Œæµç¨‹â‘  ä»åºåˆ—ä¸­é€‰æ‹©ä¸€ä¸ªè½´ç‚¹å…ƒç´ ï¼ˆpivotï¼‰ â€‹ å‡è®¾æ¯æ¬¡é€‰æ‹© 0 ä½ç½®çš„å…ƒç´ ä¸ºè½´ç‚¹å…ƒç´  â‘¡ åˆ©ç”¨ pivot å°†åºåˆ—åˆ†å‰²æˆ 2 ä¸ªå­åºåˆ— â€‹ å°†å°äº pivot çš„å…ƒç´ æ”¾åœ¨pivotå‰é¢ï¼ˆå·¦ä¾§ï¼‰ â€‹ å°†å¤§äº pivot çš„å…ƒç´ æ”¾åœ¨pivotåé¢ï¼ˆå³ä¾§ï¼‰ â€‹ ç­‰äºpivotçš„å…ƒç´ æ”¾å“ªè¾¹éƒ½å¯ä»¥ â‘¢ å¯¹å­åºåˆ—è¿›è¡Œ â‘  â‘¡ æ“ä½œ â€‹ ç›´åˆ°ä¸èƒ½å†åˆ†å‰²ï¼ˆå­åºåˆ—ä¸­åªå‰©ä¸‹1ä¸ªå…ƒç´ ï¼‰ å¿«é€Ÿæ’åºçš„æœ¬è´¨ é€æ¸å°†æ¯ä¸€ä¸ªå…ƒç´ éƒ½è½¬æ¢æˆè½´ç‚¹å…ƒç´  å¿«é€Ÿæ’åº â€“ è½´ç‚¹æ„é€  å¿«é€Ÿæ’åº â€“ æ—¶é—´å¤æ‚åº¦ åœ¨è½´ç‚¹å·¦å³å…ƒç´ æ•°é‡æ¯”è¾ƒå‡åŒ€çš„æƒ…å†µä¸‹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯æœ€å¥½çš„æƒ…å†µ $T(n) = 2 âˆ— T(n/2) + O(n) = O(nlogn)$ å¦‚æœè½´ç‚¹å·¦å³å…ƒç´ æ•°é‡æåº¦ä¸å‡åŒ€ï¼Œæœ€åæƒ…å†µ $T(n) = T(n âˆ’ 1) + O(n) = O(n^2)$ ä¸ºäº†é™ä½æœ€åæƒ…å†µçš„å‡ºç°æ¦‚ç‡ï¼Œä¸€èˆ¬é‡‡å–çš„åšæ³•æ˜¯ éšæœºé€‰æ‹©è½´ç‚¹å…ƒç´  æœ€å¥½ã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(nlogn)$ æœ€åæ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ ç”±äºé€’å½’è°ƒç”¨çš„ç¼˜æ•…ï¼Œç©ºé—´å¤æ‚åº¦ï¼š$O(logn)$ å±äºä¸ç¨³å®šæ’åº å¿«é€Ÿæ’åº â€“ å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051protected void sort() &#123; sort(0, array.length);&#125;// å¯¹ [begin, end) èŒƒå›´çš„å…ƒç´ è¿›è¡Œå¿«é€Ÿæ’åºprivate void sort(int begin, int end) &#123; if (end - begin &lt; 2) return; // ç¡®å®šè½´ç‚¹ä½ç½® O(n) int mid = pivotIndex(begin, end); // å¯¹å­åºåˆ—è¿›è¡Œå¿«é€Ÿæ’åº sort(begin, mid); sort(mid + 1, end); &#125; /** * æ„é€ å‡º [begin, end) èŒƒå›´çš„è½´ç‚¹å…ƒç´  * @return è½´ç‚¹å…ƒç´ çš„æœ€ç»ˆä½ç½® */private int pivotIndex(int begin, int end) &#123; // éšæœºé€‰æ‹©ä¸€ä¸ªå…ƒç´ è·Ÿbeginä½ç½®è¿›è¡Œäº¤æ¢ swap(begin, begin + (int)(Math.random() * (end - begin))); // å¤‡ä»½beginä½ç½®çš„å…ƒç´  T pivot = array[begin]; // endæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´  end--; while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt; 0) &#123; // å³è¾¹å…ƒç´  &gt; è½´ç‚¹å…ƒç´  end--; &#125; else &#123; // å³è¾¹å…ƒç´  &lt;= è½´ç‚¹å…ƒç´  array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt; 0) &#123; // å·¦è¾¹å…ƒç´  &lt; è½´ç‚¹å…ƒç´  begin++; &#125; else &#123; // å·¦è¾¹å…ƒç´  &gt;= è½´ç‚¹å…ƒç´  array[end--] = array[begin]; break; &#125; &#125; &#125; // å°†è½´ç‚¹å…ƒç´ æ”¾å…¥æœ€ç»ˆçš„ä½ç½® array[begin] = pivot; // è¿”å›è½´ç‚¹å…ƒç´ çš„ä½ç½® return begin;&#125; å¿«é€Ÿæ’åº â€“ ä¸è½´ç‚¹ç›¸ç­‰çš„å…ƒç´  å¦‚æœåºåˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½ä¸è½´ç‚¹å…ƒç´ ç›¸ç­‰ï¼Œåˆ©ç”¨ç›®å‰çš„ç®—æ³•å®ç°ï¼Œè½´ç‚¹å…ƒç´ å¯ä»¥å°†åºåˆ—åˆ†å‰²æˆ 2 ä¸ªå‡åŒ€çš„å­åºåˆ— æ€è€ƒï¼šcmp ä½ç½®çš„åˆ¤æ–­åˆ†åˆ«æ”¹ä¸º â‰¤ã€â‰¥ ä¼šèµ·åˆ°ä»€ä¹ˆæ•ˆæœï¼Ÿ 123456789101112131415161718while (begin &lt; end) &#123; while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt;= 0) &#123; // å³è¾¹å…ƒç´  &gt; è½´ç‚¹å…ƒç´  end--; &#125; else &#123; // å³è¾¹å…ƒç´  &lt;= è½´ç‚¹å…ƒç´  array[begin++] = array[end]; break; &#125; &#125; while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt;= 0) &#123; // å·¦è¾¹å…ƒç´  &lt; è½´ç‚¹å…ƒç´  begin++; &#125; else &#123; // å·¦è¾¹å…ƒç´  &gt;= è½´ç‚¹å…ƒç´  array[end--] = array[begin]; break; &#125; &#125;&#125; è½´ç‚¹å…ƒç´ åˆ†å‰²å‡ºæ¥çš„å­åºåˆ—æåº¦ä¸å‡åŒ€ å¯¼è‡´å‡ºç°æœ€åæ—¶é—´å¤æ‚åº¦ $O(n^2)$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å½’å¹¶æ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å½’å¹¶æ’åºï¼ˆMerge Sortï¼‰ä»€ä¹ˆæ˜¯å½’å¹¶æ’åº1945å¹´ç”±çº¦ç¿°Â·å†¯Â·è¯ºä¼Šæ›¼ï¼ˆJohn von Neumannï¼‰é¦–æ¬¡æå‡º æ‰§è¡Œæµç¨‹ â‘  ä¸æ–­åœ°å°†å½“å‰åºåˆ—å¹³å‡åˆ†å‰²æˆ2ä¸ªå­åºåˆ— â€‹ ç›´åˆ°ä¸èƒ½å†åˆ†å‰²ï¼ˆåºåˆ—ä¸­åªå‰©1ä¸ªå…ƒç´ ï¼‰ â‘¡ ä¸æ–­åœ°å°†2ä¸ªå­åºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ‰åºåºåˆ— â€‹ ç›´åˆ°æœ€ç»ˆåªå‰©ä¸‹1ä¸ªæœ‰åºåºåˆ— å½’å¹¶æ’åº â€“ divideå®ç°12345protected void sort() &#123; // å‡†å¤‡ä¸€æ®µä¸´æ—¶çš„æ•°ç»„ç©ºé—´ï¼Œåœ¨mergeæ“ä½œä¸­ä½¿ç”¨ leftArray = (T[]) new Comparable[array.length &gt;&gt; 1]; sort(0, array.length);&#125; 12345678private void sort(int begin, int end) &#123; if (end - begin &lt; 2) return; int mid = (begin + end) &gt;&gt; 1; sort(begin, mid); sort(mid, end); merge(begin, mid, end);&#125; å½’å¹¶æ’åº â€“ mergeå½’å¹¶æ’åº â€“ mergeç»†èŠ‚ éœ€è¦ merge çš„ 2 ç»„åºåˆ—å­˜åœ¨äºåŒä¸€ä¸ªæ•°ç»„ä¸­ï¼Œå¹¶ä¸”æ˜¯æŒ¨åœ¨ä¸€èµ·çš„ ä¸ºäº†æ›´å¥½åœ°å®Œæˆ merge æ“ä½œï¼Œæœ€å¥½å°†å…¶ä¸­ 1 ç»„åºåˆ—å¤‡ä»½å‡ºæ¥ï¼Œæ¯”å¦‚ $[begin, mid)$ $li == 0ï¼Œle == mid â€“ begin$ $ri == midï¼Œre == end$ å½’å¹¶æ’åº â€“ merge â€“ å·¦è¾¹å…ˆç»“æŸ å½’å¹¶æ’åº â€“ merge â€“ å³è¾¹å…ˆç»“æŸ å½’å¹¶æ’åº â€“ mergeå®ç°1234567891011121314151617181920// å°† [begin, mid) å’Œ [mid, end) èŒƒå›´çš„åºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ‰åºåºåˆ—private void merge(int begin, int mid, int end) &#123; int li = 0, le = mid - begin; int ri = mid, re = end; int ai = begin; // å¤‡ä»½å·¦è¾¹æ•°ç»„ for (int i = li; i &lt; le; i++) &#123; leftArray[i] = array[begin + i]; &#125; // å¦‚æœå·¦è¾¹è¿˜æ²¡æœ‰ç»“æŸ while (li &lt; le) &#123; if (ri &lt; re &amp;&amp; cmp(array[ri], leftArray[li]) &lt; 0) &#123; array[ai++] = array[ri++]; &#125; else &#123; array[ai++] = leftArray[li++]; &#125; &#125;&#125; å½’å¹¶æ’åº â€“ å¤æ‚åº¦åˆ†æå½’å¹¶æ’åºèŠ±è´¹çš„æ—¶é—´ $T(n) = 2 âˆ— T (n/2) + O(n)$ $T(1) = O(1)$ $T(n) /n = T(n/2) / (n/2) + O(1)$ ä»¤ $S(n) = T(n) /n$ $S(1) = O(1)$ $S(n) = S(n/2) + O(1) = S(n/4)+ O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)$ $T(n) = n âˆ— S(n) = O(nlogn)$ ç”±äºå½’å¹¶æ’åºæ€»æ˜¯å¹³å‡åˆ†å‰²å­åºåˆ—ï¼Œæ‰€ä»¥æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(nlogn)$ ï¼Œå±äºç¨³å®šæ’åº ä»ä»£ç ä¸­ä¸éš¾çœ‹å‡ºï¼šå½’å¹¶æ’åºçš„ç©ºé—´å¤æ‚åº¦æ˜¯ $O(n/2 + logn) = O(n)$ $n/2$ ç”¨äºä¸´æ—¶å­˜æ”¾å·¦ä¾§æ•°ç»„ï¼Œ$logn$ æ˜¯å› ä¸ºé€’å½’è°ƒç”¨ å¸¸è§çš„é€’æ¨å¼ä¸å¤æ‚åº¦ é€’æ¨å¼ å¤æ‚åº¦ $T(n) = T(n/2) + O(1)$ $O(logn)$ $T(n) = T(n âˆ’ 1) + O(1)$ $O(n)$ $T(n) = T(n/2) + O(n)$ $O(n)$ $T(n) = 2 âˆ— T(n/2) + O(1) $ $O(n)$ $T(n) = 2 âˆ— T(n/2) + O(n)$ $O(nlogn)$ $T(n) = T(n âˆ’ 1) + O(n)$ $O(n^2)$ $T(n) = 2 âˆ— T(n âˆ’ 1) + O(1)$ $O(2^n)$ $T(n) = 2 âˆ— T(n âˆ’ 1) + O(n)$ $O(2^n)$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ’å…¥æ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[æ’å…¥æ’åºï¼ˆInsertion Sortï¼‰ä»€ä¹ˆæ˜¯æ’å…¥æ’åºæ’å…¥æ’åºéå¸¸ç±»ä¼¼äºæ‰‘å…‹ç‰Œçš„æ’åº æ‰§è¡Œæµç¨‹ â‘  åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæ’å…¥æ’åºä¼šå°†åºåˆ—åˆ†ä¸º2éƒ¨åˆ† â€‹ å¤´éƒ¨æ˜¯å·²ç»æ’å¥½åºçš„ï¼Œå°¾éƒ¨æ˜¯å¾…æ’åºçš„ â‘¡ ä»å¤´å¼€å§‹æ‰«ææ¯ä¸€ä¸ªå…ƒç´  â€‹ æ¯å½“æ‰«æåˆ°ä¸€ä¸ªå…ƒç´ ï¼Œå°±å°†å®ƒæ’å…¥åˆ°å¤´éƒ¨åˆé€‚çš„ä½ç½®ï¼Œä½¿å¾—å¤´éƒ¨æ•°æ®ä¾ç„¶ä¿æŒæœ‰åº æ’å…¥æ’åº - å®ç°(æ— ä¼˜åŒ–)1234567for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; while (cur &gt; 0 &amp;&amp; cmp(cur, cur - 1) &lt; 0) &#123; swap(cur, cur - 1); cur--; &#125;&#125; æ’å…¥æ’åº â€“ é€†åºå¯¹ï¼ˆInversionï¼‰ ä»€ä¹ˆæ˜¯é€†åºå¯¹ï¼Ÿ æ•°ç»„ çš„é€†åºå¯¹ä¸ºï¼š ï¼Œå…±5ä¸ªé€†åºå¯¹ æ’å…¥æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸é€†åºå¯¹çš„æ•°é‡æˆæ­£æ¯”å…³ç³» é€†åºå¯¹çš„æ•°é‡è¶Šå¤šï¼Œæ’å…¥æ’åºçš„æ—¶é—´å¤æ‚åº¦è¶Šé«˜ æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ å±äºç¨³å®šæ’åº å½“é€†åºå¯¹çš„æ•°é‡æå°‘æ—¶ï¼Œæ’å…¥æ’åºçš„æ•ˆç‡ç‰¹åˆ«é«˜ ç”šè‡³é€Ÿåº¦æ¯” $O(nlogn)$çº§åˆ«çš„å¿«é€Ÿæ’åºè¿˜è¦å¿« æ•°æ®é‡ä¸æ˜¯ç‰¹åˆ«å¤§çš„æ—¶å€™ï¼Œæ’å…¥æ’åºçš„æ•ˆç‡ä¹Ÿæ˜¯éå¸¸å¥½çš„ æ’å…¥æ’åº â€“ ä¼˜åŒ–æ€è·¯æ˜¯å°†ã€äº¤æ¢ã€‘è½¬ä¸ºã€æŒªåŠ¨ã€‘ â‘  å…ˆå°†å¾…æ’å…¥çš„å…ƒç´ å¤‡ä»½ â‘¡ å¤´éƒ¨æœ‰åºæ•°æ®ä¸­æ¯”å¾…æ’å…¥å…ƒç´ å¤§çš„ï¼Œéƒ½æœå°¾éƒ¨æ–¹å‘æŒªåŠ¨1ä¸ªä½ç½® â‘¢ å°†å¾…æ’å…¥å…ƒç´ æ”¾åˆ°æœ€ç»ˆçš„åˆé€‚ä½ç½® 123456789for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; T v = array[cur]; while (cur &gt; 0 &amp;&amp; cmp(v, array[cur - 1]) &lt; 0) &#123; array[cur] = array[cur - 1]; cur--; &#125; array[cur] = v;&#125; æ’å…¥æ’åº â€“ äºŒåˆ†æœç´¢ä¼˜åŒ–äºŒåˆ†æœç´¢ï¼ˆBinary Searchï¼‰å¦‚ä½•ç¡®å®šä¸€ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼Ÿï¼ˆå‡è®¾æ•°ç»„é‡Œé¢å…¨éƒ½æ˜¯æ•´æ•°ï¼‰ å¦‚æœæ˜¯æ— åºæ•°ç»„ï¼Œä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹éå†æœç´¢ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 å¦‚æœæ˜¯æœ‰åºæ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æœç´¢ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ï¼š$O(logn)$ 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 äºŒåˆ†æœç´¢ â€“ æ€è·¯å‡è®¾åœ¨ $[begin, end)$ èŒƒå›´å†…æœç´¢æŸä¸ªå…ƒç´  vï¼Œ$mid == (begin + end) /2$ å¦‚æœ $v &lt; m$ï¼Œå» $[begin, mid)$ èŒƒå›´å†…äºŒåˆ†æœç´¢ å¦‚æœ $v &gt; m$ï¼Œå» $[mid + 1, end)$ èŒƒå›´å†…äºŒåˆ†æœç´¢ å¦‚æœ $v == m$ï¼Œç›´æ¥è¿”å› mid äºŒåˆ†æœç´¢ â€“ å®ä¾‹ äºŒåˆ†æœç´¢ â€“ å®ç°1234567891011121314public static int search(int[] array, int v) &#123; if (array == null || array.length == 0) return -1; int begin = 0; int end = array.length; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &lt; array[mid]) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; return begin;&#125; æ’å…¥æ’åº â€“ äºŒåˆ†æœç´¢ä¼˜åŒ–åœ¨å…ƒç´  v çš„æ’å…¥è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥å…ˆäºŒåˆ†æœç´¢å‡ºåˆé€‚çš„æ’å…¥ä½ç½®ï¼Œç„¶åå†å°†å…ƒç´  v æ’å…¥ è¦æ±‚äºŒåˆ†æœç´¢è¿”å›çš„æ’å…¥ä½ç½®ï¼šç¬¬1ä¸ªå¤§äº v çš„å…ƒç´ ä½ç½® å¦‚æœ v æ˜¯ 5ï¼Œè¿”å› 2 å¦‚æœ v æ˜¯ 1ï¼Œè¿”å› 0 å¦‚æœ v æ˜¯ 15ï¼Œè¿”å› 7 å¦‚æœ v æ˜¯ 8ï¼Œè¿”å› 5 æ’å…¥æ’åº â€“ äºŒåˆ†æœç´¢ä¼˜åŒ– â€“ æ€è·¯å‡è®¾åœ¨ $[begin, end)$ èŒƒå›´å†…æœç´¢æŸä¸ªå…ƒç´  $v$ï¼Œ$mid == (begin + end) /2$ å¦‚æœ $v &lt; m$ï¼Œå» $[begin, mid)$ èŒƒå›´å†…äºŒåˆ†æœç´¢ å¦‚æœ $v â‰¥ m$ï¼Œå» $[mid + 1, end)$ èŒƒå›´å†…äºŒåˆ†æœç´¢ æ’å…¥æ’åº â€“ äºŒåˆ†æœç´¢ä¼˜åŒ– â€“ å®ä¾‹ æ’å…¥æ’åº â€“ äºŒåˆ†æœç´¢ä¼˜åŒ– â€“ å®ç°12345678910111213141516171819202122232425262728for (int begin = 1; begin &lt; array.length; begin++) &#123; insert(begin, search(begin));&#125;// å°†sourceä½ç½®çš„å…ƒç´ æ’å…¥åˆ°destä½ç½®private void insert(int source, int dest) &#123; T v = array[source]; for (int i = source; i &gt; dest; i--) &#123; array[i] = array[i - 1]; &#125; array[dest] = v;&#125;// åˆ©ç”¨äºŒåˆ†æœç´¢æ‰¾åˆ° index ä½ç½®å…ƒç´ çš„å¾…æ’å…¥ä½ç½®// å·²ç»æ’å¥½åºæ•°ç»„çš„åŒºé—´èŒƒå›´æ˜¯ [0, index)private int search(int index) &#123; int begin = 0; int end = index; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (cmp(array[index], array[mid]) &lt; 0) &#123; end = mid; &#125; else &#123; begin = mid + 1; &#125; &#125; return begin;&#125; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨äº†äºŒåˆ†æœç´¢åï¼Œåªæ˜¯å‡å°‘äº†æ¯”è¾ƒæ¬¡æ•°ï¼Œä½†æ’å…¥æ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯ $O(n^2)$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å †æ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å †æ’åºï¼ˆHeap Sortï¼‰ä»€ä¹ˆæ˜¯å †æ’åºå †æ’åºå¯ä»¥è®¤ä¸ºæ˜¯å¯¹é€‰æ‹©æ’åºçš„ä¸€ç§ä¼˜åŒ– é€‰æ‹©æ’åºçš„å®ç° / äºŒå‰å †çš„å®ç° æ‰§è¡Œæµç¨‹ â‘  å¯¹åºåˆ—è¿›è¡ŒåŸåœ°å»ºå †ï¼ˆheapifyï¼‰ â‘¡ é‡å¤æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œç›´åˆ°å †çš„å…ƒç´ æ•°é‡ä¸º 1 â€‹ äº¤æ¢å †é¡¶å…ƒç´ ä¸å°¾å…ƒç´  â€‹ å †çš„å…ƒç´ æ•°é‡å‡ 1 â€‹ å¯¹ 0 ä½ç½®è¿›è¡Œ 1 æ¬¡ siftDown æ“ä½œ å †æ’åº - å®ç°12345678910111213// åŸåœ°å»ºå †heapSize = array.length;for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i);&#125;while (heapSize &gt; 1) &#123; // äº¤æ¢å †é¡¶å…ƒç´ å’Œå°¾éƒ¨å…ƒç´  swap(0, --heapSize); // å¯¹0ä½ç½®è¿›è¡ŒsiftDownï¼ˆæ¢å¤å †çš„æ€§è´¨ï¼‰ siftDown(0);&#125; 123456789101112131415161718192021222324private void siftDown(int index) &#123; T element = array[index]; int half = heapSize &gt;&gt; 1; while (index &lt; half) &#123; // indexå¿…é¡»æ˜¯éå¶å­èŠ‚ç‚¹ // é»˜è®¤æ˜¯å·¦è¾¹è·Ÿçˆ¶èŠ‚ç‚¹æ¯” int childIndex = (index &lt;&lt; 1) + 1; T child = array[childIndex]; int rightIndex = childIndex + 1; // å³å­èŠ‚ç‚¹æ¯”å·¦å­èŠ‚ç‚¹å¤§ if (rightIndex &lt; heapSize &amp;&amp; cmp(array[rightIndex], child) &gt; 0) &#123; child = array[childIndex = rightIndex]; &#125; // å¤§äºç­‰äºå­èŠ‚ç‚¹ if (cmp(element, child) &gt;= 0) break; array[index] = child; index = childIndex; &#125; array[index] = element;&#125; æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(1)ï¼Œå±äºä¸ç¨³å®šæ’åº]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é€‰æ‹©æ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[é€‰æ‹©æ’åºï¼ˆSelection Sortï¼‰æ‰§è¡Œæµç¨‹ â‘  ä»åºåˆ—ä¸­æ‰¾å‡ºæœ€å¤§çš„é‚£ä¸ªå…ƒç´ ï¼Œç„¶åä¸æœ€æœ«å°¾çš„å…ƒç´ äº¤æ¢ä½ç½® â€‹ æ‰§è¡Œå®Œä¸€è½®åï¼Œæœ€æœ«å°¾çš„é‚£ä¸ªå…ƒç´ å°±æ˜¯æœ€å¤§çš„å…ƒç´  â‘¡ å¿½ç•¥ â‘  ä¸­æ›¾ç»æ‰¾åˆ°çš„æœ€å¤§å…ƒç´ ï¼Œé‡å¤æ‰§è¡Œæ­¥éª¤ â‘  123456789for (int end = array.length - 1; end &gt; 0; end--) &#123; int max = 0; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(max, begin) &lt; 0) &#123; max = begin; &#125; &#125; swap(max, end);&#125; é€‰æ‹©æ’åºçš„äº¤æ¢æ¬¡æ•°è¦è¿œè¿œå°‘äºå†’æ³¡æ’åºï¼Œå¹³å‡æ€§èƒ½ä¼˜äºå†’æ³¡æ’åº æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ï¼Œç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ï¼Œå±äºä¸ç¨³å®šæ’åº]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å†’æ³¡æ’åº]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å†’æ³¡æ’åºï¼ˆBubble Sortï¼‰å†’æ³¡æ’åºï¼ˆæ— ä¼˜åŒ–å®ç°ï¼‰å†’æ³¡æ’åºä¹Ÿå«åšèµ·æ³¡æ’åº æ‰§è¡Œæµç¨‹ï¼ˆç»Ÿä¸€ä»¥å‡åºä¸ºä¾‹å­ï¼‰ â‘  ä»å¤´å¼€å§‹æ¯”è¾ƒæ¯ä¸€å¯¹ç›¸é‚»å…ƒç´ ï¼Œå¦‚æœç¬¬1ä¸ªæ¯”ç¬¬2ä¸ªå¤§ï¼Œå°±äº¤æ¢å®ƒä»¬çš„ä½ç½® â€‹ æ‰§è¡Œå®Œä¸€è½®åï¼Œæœ€æœ«å°¾é‚£ä¸ªå…ƒç´ å°±æ˜¯æœ€å¤§çš„å…ƒç´  â‘¡ å¿½ç•¥ â‘  ä¸­æ›¾ç»æ‰¾åˆ°çš„æœ€å¤§å…ƒç´ ï¼Œé‡å¤æ‰§è¡Œæ­¥éª¤ â‘ ï¼Œç›´åˆ°å…¨éƒ¨å…ƒç´ æœ‰åº 123456789for (int end = array.length - 1; end &gt; 0; end--) &#123; for (int begin = 1; begin &lt;= end; begin++) &#123; // æ¯”å¤§å° if (cmp(begin, begin - 1) &lt; 0) &#123; // äº¤æ¢ swap(begin, begin - 1); &#125; &#125;&#125; å†’æ³¡æ’åº â€“ ä¼˜åŒ–â‘ å¦‚æœåºåˆ—å·²ç»å®Œå…¨æœ‰åºï¼Œå¯ä»¥æå‰ç»ˆæ­¢å†’æ³¡æ’åº 12345678910for (int end = array.length - 1; end &gt; 0; end--) &#123; boolean sorted = true; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sorted = false; &#125; &#125; if (sorted) break;&#125; å†’æ³¡æ’åº â€“ ä¼˜åŒ–â‘¡å¦‚æœåºåˆ—å°¾éƒ¨å·²ç»å±€éƒ¨æœ‰åºï¼Œå¯ä»¥è®°å½•æœ€å1æ¬¡äº¤æ¢çš„ä½ç½®ï¼Œå‡å°‘æ¯”è¾ƒæ¬¡æ•° æœ€å1æ¬¡äº¤æ¢çš„ä½ç½®æ˜¯ 6 1234567891011for (int end = array.length - 1; end &gt; 0; end--) &#123; int sortedIndex = 1; for (int begin = 1; begin &lt;= end; begin++) &#123; // if (array[begin] &lt; array[begin - 1]) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sortedIndex = begin; &#125; &#125; end = sortedIndex;&#125; æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10å¤§æ’åºç®—æ³•]]></title>
    <url>%2F2020%2F07%2F14%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[10å¤§æ’åºç®—æ³•ä»¥ä¸‹è¡¨æ ¼æ˜¯åŸºäºæ•°ç»„è¿›è¡Œæ’åºçš„ä¸€èˆ¬æ€§ç»“è®º å†’æ³¡ã€é€‰æ‹©ã€æ’å…¥ã€å½’å¹¶ã€å¿«é€Ÿã€å¸Œå°”ã€å †æ’åºï¼Œå±äºæ¯”è¾ƒæ’åºï¼ˆComparison Sortingï¼‰ æ’åºç®—æ³•çš„ç¨³å®šæ€§ï¼ˆStabilityï¼‰å¦‚æœç›¸ç­‰çš„2ä¸ªå…ƒç´ ï¼Œåœ¨æ’åºå‰åçš„ç›¸å¯¹ä½ç½®ä¿æŒä¸å˜ï¼Œé‚£ä¹ˆè¿™æ˜¯ç¨³å®šçš„æ’åºç®—æ³• æ’åºå‰ï¼š5, 1, 3ğ‘, 4, 7, 3ğ‘ ç¨³å®šçš„æ’åºï¼š 1, 3ğ‘, 3ğ‘, 4, 5, 7 ä¸ç¨³å®šçš„æ’åºï¼š1, 3ğ‘, 3ğ‘, 4, 5, 7 åŸåœ°ç®—æ³•ï¼ˆIn-place Algorithmï¼‰ä¸ä¾èµ–é¢å¤–çš„èµ„æºæˆ–è€…ä¾èµ–å°‘æ•°çš„é¢å¤–èµ„æºï¼Œä»…ä¾é è¾“å‡ºæ¥è¦†ç›–è¾“å…¥ ç©ºé—´å¤æ‚åº¦ä¸ºğ‘‚(1) çš„éƒ½å¯ä»¥è®¤ä¸ºæ˜¯åŸåœ°ç®—æ³• éåŸåœ°ç®—æ³•ï¼Œç§°ä¸º Not-in-place æˆ–è€… Out-of-place]]></content>
      <categories>
        <category>ç®—æ³•</category>
        <category>æ’åº</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2020%2F07%2F14%2FTrie%2F</url>
    <content type="text"><![CDATA[TrieTrie ä¹Ÿå«åšå­—å…¸æ ‘ã€å‰ç¼€æ ‘ï¼ˆPrefix Treeï¼‰ã€å•è¯æŸ¥æ‰¾æ ‘ Trie æœç´¢å­—ç¬¦ä¸²çš„æ•ˆç‡ä¸»è¦è·Ÿå­—ç¬¦ä¸²çš„é•¿åº¦æœ‰å…³ å‡è®¾ä½¿ç”¨ Trie å­˜å‚¨ catã€dogã€doggyã€doesã€castã€add å…­ä¸ªå•è¯ Trieä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class Trie&lt;V&gt; &#123; private int size; private Node&lt;V&gt; root; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; size = 0; root = null; &#125; public V get(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.word ? node.value : null; &#125; public boolean contains(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.word; &#125; public V add(String key, V value) &#123; keyCheck(key); // åˆ›å»ºæ ¹èŠ‚ç‚¹ if (root == null) &#123; root = new Node&lt;&gt;(null); &#125; Node&lt;V&gt; node = root; int len = key.length(); for (int i = 0; i &lt; len; i++) &#123; char c = key.charAt(i); boolean emptyChildren = node.children == null; Node&lt;V&gt; childNode = emptyChildren ? null : node.children.get(c); if (childNode == null) &#123; childNode = new Node&lt;&gt;(node); childNode.character = c; node.children = emptyChildren ? new HashMap&lt;&gt;() : node.children; node.children.put(c, childNode); &#125; node = childNode; &#125; if (node.word) &#123; // å·²ç»å­˜åœ¨è¿™ä¸ªå•è¯ V oldValue = node.value; node.value = value; return oldValue; &#125; // æ–°å¢ä¸€ä¸ªå•è¯ node.word = true; node.value = value; size++; return null; &#125; public V remove(String key) &#123; // æ‰¾åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹ Node&lt;V&gt; node = node(key); // å¦‚æœä¸æ˜¯å•è¯ç»“å°¾ï¼Œä¸ç”¨ä½œä»»ä½•å¤„ç† if (node == null || !node.word) return null; size--; V oldValue = node.value; // å¦‚æœè¿˜æœ‰å­èŠ‚ç‚¹ if (node.children != null &amp;&amp; !node.children.isEmpty()) &#123; node.word = false; node.value = null; return oldValue; &#125; // å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ Node&lt;V&gt; parent = null; while ((parent = node.parent) != null) &#123; parent.children.remove(node.character); if (parent.word || !parent.children.isEmpty()) break; node = parent; &#125; return oldValue; &#125; public boolean startsWith(String prefix) &#123; return node(prefix) != null; &#125; private Node&lt;V&gt; node(String key) &#123; keyCheck(key); Node&lt;V&gt; node = root; int len = key.length(); for (int i = 0; i &lt; len; i++) &#123; if (node == null || node.children == null || node.children.isEmpty()) return null; char c = key.charAt(i); node = node.children.get(c); &#125; return node; &#125; private void keyCheck(String key) &#123; if (key == null || key.length() == 0) &#123; throw new IllegalArgumentException("key must not be empty"); &#125; &#125; private static class Node&lt;V&gt; &#123; Node&lt;V&gt; parent; HashMap&lt;Character, Node&lt;V&gt;&gt; children; Character character; V value; boolean word; // æ˜¯å¦ä¸ºå•è¯çš„ç»“å°¾ï¼ˆæ˜¯å¦ä¸ºä¸€ä¸ªå®Œæ•´çš„å•è¯ï¼‰ public Node(Node&lt;V&gt; parent) &#123; this.parent = parent; &#125; &#125;&#125; æ€»ç»“Trie çš„ä¼˜ç‚¹ï¼šæœç´¢å‰ç¼€çš„æ•ˆç‡ä¸»è¦è·Ÿå‰ç¼€çš„é•¿åº¦æœ‰å…³ Trie çš„ç¼ºç‚¹ï¼šéœ€è¦è€—è´¹å¤§é‡çš„å†…å­˜ï¼Œå› æ­¤è¿˜æœ‰å¾…æ”¹è¿› æ›´å¤šTrie ç›¸å…³çš„æ•°æ®ç»“æ„å’Œç®—æ³• Double-array Trieã€Suffix Treeã€Patricia Treeã€Crit-bit Treeã€ACè‡ªåŠ¨æœº]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å“ˆå¤«æ›¼æ ‘]]></title>
    <url>%2F2020%2F07%2F14%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%2F</url>
    <content type="text"><![CDATA[å“ˆå¤«æ›¼ç¼–ç ï¼ˆHuffman Codingï¼‰å“ˆå¤«æ›¼ç¼–ç ï¼Œåˆç§°ä¸ºéœå¤«æ›¼ç¼–ç ï¼Œå®ƒæ˜¯ç°ä»£å‹ç¼©ç®—æ³•çš„åŸºç¡€ å‡è®¾è¦æŠŠå­—ç¬¦ä¸²ã€ABBBCCCCCCCCDDDDDDEEã€‘è½¬æˆäºŒè¿›åˆ¶ç¼–ç è¿›è¡Œä¼ è¾“ å¯ä»¥è½¬æˆASCIIç¼–ç ï¼ˆ65 ~ 69ï¼Œ1000001~1000101ï¼‰ï¼Œä½†æ˜¯æœ‰ç‚¹å†—é•¿ï¼Œå¦‚æœå¸Œæœ›ç¼–ç æ›´çŸ­å‘¢ï¼Ÿ å¯ä»¥å…ˆçº¦å®š5ä¸ªå­—æ¯å¯¹åº”çš„äºŒè¿›åˆ¶ A B C D E 000 001 010 011 100 å¯¹åº”çš„äºŒè¿›åˆ¶ç¼–ç ï¼š000001001001010010010010010010010010011011011011011011100100 ä¸€å…±20ä¸ªå­—æ¯ï¼Œè½¬æˆäº†60ä¸ªäºŒè¿›åˆ¶ä½ å¦‚æœä½¿ç”¨å“ˆå¤«æ›¼ç¼–ç ï¼Œå¯ä»¥å‹ç¼©è‡³41ä¸ªäºŒè¿›åˆ¶ä½ï¼Œçº¦ä¸ºåŸæ¥é•¿åº¦çš„68.3% å“ˆå¤«æ›¼æ ‘å…ˆè®¡ç®—å‡ºæ¯ä¸ªå­—æ¯çš„å‡ºç°é¢‘ç‡ï¼ˆæƒå€¼ï¼Œè¿™é‡Œç›´æ¥ç”¨å‡ºç°æ¬¡æ•°ï¼‰ï¼Œã€ABBBCCCCCCCCDDDDDDEEã€‘ A B C D E 1 3 8 6 2 åˆ©ç”¨è¿™äº›æƒå€¼ï¼Œæ„å»ºä¸€æ£µå“ˆå¤«æ›¼æ ‘ï¼ˆåˆç§°ä¸ºéœå¤«æ›¼æ ‘ã€æœ€ä¼˜äºŒå‰æ ‘ï¼‰ å¦‚ä½•æ„å»ºä¸€æ£µå“ˆå¤«æ›¼æ ‘ï¼Ÿï¼ˆå‡è®¾æœ‰ n ä¸ªæƒå€¼ï¼‰ ä»¥æƒå€¼ä½œä¸ºæ ¹èŠ‚ç‚¹æ„å»º n æ£µäºŒå‰æ ‘ï¼Œç»„æˆæ£®æ— åœ¨æ£®æ—ä¸­é€‰å‡º 2 ä¸ªæ ¹èŠ‚ç‚¹æœ€å°çš„æ ‘åˆå¹¶ï¼Œä½œä¸ºä¸€æ£µæ–°æ ‘çš„å·¦å³å­æ ‘ï¼Œä¸”æ–°æ ‘çš„æ ¹èŠ‚ç‚¹ä¸ºå…¶å·¦å³å­æ ‘æ ¹èŠ‚ç‚¹ä¹‹å’Œ ä»æ£®æ—ä¸­åˆ é™¤åˆšæ‰é€‰å–çš„ 2 æ£µæ ‘ï¼Œå¹¶å°†æ–°æ ‘åŠ å…¥æ£®æ— é‡å¤ 2ã€3 æ­¥éª¤ï¼Œç›´åˆ°æ£®æ—åªå‰©ä¸€æ£µæ ‘ä¸ºæ­¢ï¼Œè¯¥æ ‘å³ä¸ºå“ˆå¤«æ›¼æ ‘ æ„å»ºå“ˆå¤«æ›¼æ ‘ leftä¸º0ï¼Œrightä¸º1ï¼Œå¯ä»¥å¾—å‡º5ä¸ªå­—æ¯å¯¹åº”çš„å“ˆå¤«æ›¼ç¼–ç  A B C D E 1110 110 0 10 1111 ã€ABBBCCCCCCCCDDDDDDEEã€‘çš„å“ˆå¤«æ›¼ç¼–ç æ˜¯ 1110110110110000000001010101010101111 æ€»ç»“n ä¸ªæƒå€¼æ„å»ºå‡ºæ¥çš„å“ˆå¤«æ›¼æ ‘æ‹¥æœ‰ n ä¸ªå¶å­èŠ‚ç‚¹ æ¯ä¸ªå“ˆå¤«æ›¼ç¼–ç éƒ½ä¸æ˜¯å¦ä¸€ä¸ªå“ˆå¤«æ›¼ç¼–ç çš„å‰ç¼€ å“ˆå¤«æ›¼æ ‘æ˜¯å¸¦æƒè·¯å¾„é•¿åº¦æœ€çŸ­çš„æ ‘ï¼Œæƒå€¼è¾ƒå¤§çš„èŠ‚ç‚¹ç¦»æ ¹èŠ‚ç‚¹è¾ƒè¿‘ å¸¦æƒè·¯å¾„é•¿åº¦ï¼šæ ‘ä¸­æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹çš„æƒå€¼ä¹˜ä¸Šå…¶åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ã€‚ä¸æœ€ç»ˆçš„å“ˆå¤«æ›¼ç¼–ç æ€»é•¿åº¦æˆæ­£æ¯”å…³ç³»ã€‚]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¼˜å…ˆçº§é˜Ÿåˆ—]]></title>
    <url>%2F2020%2F07%2F14%2F%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆPriority Queueï¼‰é˜Ÿåˆ—å®ç° ä¼˜å…ˆçº§é˜Ÿåˆ—çš„æ¥å£è®¾è®¡æ™®é€šçš„é˜Ÿåˆ—æ˜¯ FIFO åŸåˆ™ï¼Œä¹Ÿå°±æ˜¯å…ˆè¿›å…ˆå‡º ä¼˜å…ˆçº§é˜Ÿåˆ—åˆ™æ˜¯æŒ‰ç…§ä¼˜å…ˆçº§é«˜ä½è¿›è¡Œå‡ºé˜Ÿï¼Œæ¯”å¦‚å°†ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ä½œä¸ºé˜Ÿå¤´ä¼˜å…ˆå‡ºé˜Ÿ 1234567891011121314151617181920212223242526272829303132333435public class PriorityQueue&lt;E&gt; &#123; private BinaryHeap&lt;E&gt; heap; public PriorityQueue(Comparator&lt;E&gt; comparator) &#123; heap = new BinaryHeap&lt;&gt;(comparator); &#125; public PriorityQueue() &#123; this(null); &#125; public int size() &#123; return heap.size(); &#125; public boolean isEmpty() &#123; return heap.isEmpty(); &#125; public void clear() &#123; heap.clear(); &#125; public void enQueue(E element) &#123; heap.add(element); &#125; public E deQueue() &#123; return heap.remove(); &#125; public E front() &#123; return heap.get(); &#125;&#125; ä¼˜å…ˆçº§é˜Ÿåˆ—çš„åº”ç”¨åœºæ™¯ä¸¾ä¾‹ åŒ»é™¢çš„å¤œé—´é—¨è¯Š é˜Ÿåˆ—å…ƒç´ æ˜¯ç—…äºº ä¼˜å…ˆçº§æ˜¯ç—…æƒ…çš„ä¸¥é‡æƒ…å†µã€æŒ‚å·æ—¶é—´ æ“ä½œç³»ç»Ÿçš„å¤šä»»åŠ¡è°ƒåº¦ é˜Ÿåˆ—å…ƒç´ æ˜¯ä»»åŠ¡ ä¼˜å…ˆçº§æ˜¯ä»»åŠ¡ç±»å‹ ä¼˜å…ˆé˜Ÿåˆ—çš„åº•å±‚å®ç°æ ¹æ®ä¼˜å…ˆé˜Ÿåˆ—çš„ç‰¹ç‚¹ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ï¼šå¯ä»¥ç›´æ¥åˆ©ç”¨äºŒå‰å †ä½œä¸ºä¼˜å…ˆé˜Ÿåˆ—çš„åº•å±‚å®ç° äºŒå‰å †å®ç° å¯ä»¥é€šè¿‡ Comparator æˆ– Comparable å»è‡ªå®šä¹‰ä¼˜å…ˆçº§é«˜ä½ 123456789101112131415161718public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int boneBreak; public Person(String name, int boneBreak) &#123; this.name = name; this.boneBreak = boneBreak; &#125; @Override public int compareTo(Person person) &#123; return this.boneBreak - person.boneBreak; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", boneBreak=" + boneBreak + "]"; &#125;&#125; 12345678910111213public class Main &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Person&gt; queue = new PriorityQueue&lt;&gt;(); queue.enQueue(new Person("Jack", 2)); queue.enQueue(new Person("Rose", 10)); queue.enQueue(new Person("Jake", 5)); queue.enQueue(new Person("James", 15)); while (!queue.isEmpty()) &#123; System.out.println(queue.deQueue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>é˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[äºŒå‰å †]]></title>
    <url>%2F2020%2F07%2F14%2F%E4%BA%8C%E5%8F%89%E5%A0%86%2F</url>
    <content type="text"><![CDATA[äºŒå‰å †æ€è€ƒè®¾è®¡ä¸€ç§æ•°æ®ç»“æ„ï¼Œç”¨æ¥å­˜æ”¾æ•´æ•°ï¼Œè¦æ±‚æä¾› 3 ä¸ªæ¥å£ æ·»åŠ å…ƒç´  è·å–æœ€å¤§å€¼ åˆ é™¤æœ€å¤§å€¼ æœ‰æ²¡æœ‰æ›´ä¼˜çš„æ•°æ®ç»“æ„ï¼Ÿ å †ï¼šè·å–æœ€å¤§å€¼ï¼šO(1)ã€åˆ é™¤æœ€å¤§å€¼ï¼šO(logn)ã€æ·»åŠ å…ƒç´ ï¼šO(logn) å †ï¼ˆHeapï¼‰å †ï¼ˆHeapï¼‰ä¹Ÿæ˜¯ä¸€ç§æ ‘çŠ¶çš„æ•°æ®ç»“æ„ï¼ˆä¸è¦è·Ÿå†…å­˜æ¨¡å‹ä¸­çš„â€œå †ç©ºé—´â€æ··æ·†ï¼‰ï¼Œå¸¸è§çš„å †å®ç°æœ‰ äºŒå‰å †ï¼ˆBinary Heapï¼Œå®Œå…¨äºŒå‰å †ï¼‰ å¤šå‰å †ï¼ˆD-heapã€D-ary Heapï¼‰ ç´¢å¼•å †ï¼ˆIndex Heapï¼‰ äºŒé¡¹å †ï¼ˆBinomial Heapï¼‰ æ–æ³¢é‚£å¥‘å †ï¼ˆFibonacci Heapï¼‰ å·¦å€¾å †ï¼ˆLeftist Heapï¼Œå·¦å¼å †ï¼‰ æ–œå †ï¼ˆSkew Heapï¼‰ å †çš„ä¸€ä¸ªé‡è¦æ€§è´¨ï¼šä»»æ„èŠ‚ç‚¹çš„å€¼æ€»æ˜¯ â‰¥ï¼ˆ â‰¤ ï¼‰å­èŠ‚ç‚¹çš„å€¼ å¦‚æœä»»æ„èŠ‚ç‚¹çš„å€¼æ€»æ˜¯ â‰¥ å­èŠ‚ç‚¹çš„å€¼ï¼Œç§°ä¸ºï¼šæœ€å¤§å †ã€å¤§æ ¹å †ã€å¤§é¡¶å † å¦‚æœä»»æ„èŠ‚ç‚¹çš„å€¼æ€»æ˜¯ â‰¤ å­èŠ‚ç‚¹çš„å€¼ï¼Œç§°ä¸ºï¼šæœ€å°å †ã€å°æ ¹å †ã€å°é¡¶å † ç”±æ­¤å¯è§ï¼Œå †ä¸­çš„å…ƒç´ å¿…é¡»å…·å¤‡å¯æ¯”è¾ƒæ€§ï¼ˆè·ŸäºŒå‰æœç´¢æ ‘ä¸€æ ·ï¼‰ å †çš„åŸºæœ¬æ¥å£è®¾è®¡123456789public interface Heap&lt;E&gt; &#123; int size(); // å…ƒç´ çš„æ•°é‡ boolean isEmpty(); // æ˜¯å¦ä¸ºç©º void clear(); // æ¸…ç©º void add(E element); // æ·»åŠ å…ƒç´  E get(); // è·å¾—å †é¡¶å…ƒç´  E remove(); // åˆ é™¤å †é¡¶å…ƒç´  E replace(E element); // åˆ é™¤å †é¡¶å…ƒç´ çš„åŒæ—¶æ’å…¥ä¸€ä¸ªæ–°å…ƒç´ &#125; 12345678910111213141516171819202122232425262728public abstract class AbstractHeap&lt;E&gt; implements Heap&lt;E&gt; &#123; protected int size; protected Comparator&lt;E&gt; comparator; public AbstractHeap(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator; &#125; public AbstractHeap() &#123; this(null); &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; // æ¯”è¾ƒå™¨ protected int compare(E e1, E e2) &#123; return comparator != null ? comparator.compare(e1, e2) : ((Comparable&lt;E&gt;)e1).compareTo(e2); &#125;&#125; äºŒå‰å †ï¼ˆBinary Heapï¼‰äºŒå‰å †çš„é€»è¾‘ç»“æ„å°±æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥ä¹Ÿå«å®Œå…¨äºŒå‰å † é‰´äºå®Œå…¨äºŒå‰æ ‘çš„ä¸€äº›ç‰¹æ€§ï¼ŒäºŒå‰å †çš„åº•å±‚ï¼ˆç‰©ç†ç»“æ„ï¼‰ä¸€èˆ¬ç”¨æ•°ç»„å®ç°å³å¯ ç´¢å¼• i çš„è§„å¾‹ï¼ˆ n æ˜¯å…ƒç´ æ•°é‡ï¼‰ å¦‚æœ i = 0 ï¼Œå®ƒæ˜¯æ ¹èŠ‚ç‚¹ å¦‚æœ i &gt; 0 ï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•ä¸º floor( (i â€“ 1) / 2 ) å¦‚æœ 2i + 1 â‰¤ n â€“ 1ï¼Œå®ƒçš„å·¦å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º 2i + 1 å¦‚æœ 2i + 1 &gt; n â€“ 1 ï¼Œå®ƒæ— å·¦å­èŠ‚ç‚¹ å¦‚æœ 2i + 2 â‰¤ n â€“ 1 ï¼Œå®ƒçš„å³å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º 2i + 2 å¦‚æœ 2i + 2 &gt; n â€“ 1 ï¼Œå®ƒæ— å³å­èŠ‚ç‚¹ äºŒå‰å †è·å–æœ€å¤§å€¼123456789public E get() &#123; emptyCheck(); return elements[0];&#125;private void emptyCheck() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("Heap is empty"); &#125;&#125; æœ€å¤§å † â€“ æ·»åŠ  å¾ªç¯æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼ˆå›¾ä¸­çš„ 80 ç®€ç§°ä¸º nodeï¼‰ å¦‚æœ node ï¼ çˆ¶èŠ‚ç‚¹ ä¸çˆ¶èŠ‚ç‚¹äº¤æ¢ä½ç½® å¦‚æœ node â‰¤ çˆ¶èŠ‚ç‚¹ï¼Œæˆ–è€… node æ²¡æœ‰çˆ¶èŠ‚ç‚¹ é€€å‡ºå¾ªç¯ è¿™ä¸ªè¿‡ç¨‹ï¼Œå«åšä¸Šæ»¤ï¼ˆSift Upï¼‰ æ—¶é—´å¤æ‚åº¦ï¼šO(logn) 1234567891011121314151617181920212223public void add(E element) &#123; elementNotNullCheck(element); ensureCapacity(size + 1); elements[size++] = element; siftUp(size - 1);&#125;private void siftUp(int index) &#123; E e = elements[index]; while (index &gt; 0) &#123; int pindex = (index - 1) &gt;&gt; 1; E p = elements[pindex]; if (compare(e, p) &lt;= 0) return; // äº¤æ¢indexã€pindexä½ç½®çš„å†…å®¹ E tmp = elements[index]; elements[index] = elements[pindex]; elements[pindex] = tmp; // é‡æ–°èµ‹å€¼index index = pindex; &#125;&#125; æœ€å¤§å † â€“ æ·»åŠ  â€“ äº¤æ¢ä½ç½®çš„ä¼˜åŒ–ä¸€èˆ¬äº¤æ¢ä½ç½®éœ€è¦3è¡Œä»£ç ï¼Œå¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ– å°†æ–°æ·»åŠ èŠ‚ç‚¹å¤‡ä»½ï¼Œç¡®å®šæœ€ç»ˆä½ç½®æ‰æ‘†æ”¾ä¸Šå» ä»…ä»äº¤æ¢ä½ç½®çš„ä»£ç è§’åº¦çœ‹ å¯ä»¥ç”±å¤§æ¦‚çš„ 3 O(logn) ä¼˜åŒ–åˆ° 1 O(logn) + 1 1234567891011121314private void siftUp(int index) &#123; E element = elements[index]; while (index &gt; 0) &#123; int parentIndex = (index - 1) &gt;&gt; 1; E parent = elements[parentIndex]; if (compare(element, parent) &lt;= 0) break; // å°†çˆ¶å…ƒç´ å­˜å‚¨åœ¨indexä½ç½® elements[index] = parent; // é‡æ–°èµ‹å€¼index index = parentIndex; &#125; elements[index] = element;&#125; æœ€å¤§å † â€“ åˆ é™¤ ç”¨æœ€åä¸€ä¸ªèŠ‚ç‚¹è¦†ç›–æ ¹èŠ‚ç‚¹ åˆ é™¤æœ€åä¸€ä¸ªèŠ‚ç‚¹ å¾ªç¯æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼ˆå›¾ä¸­çš„ 43 ç®€ç§°ä¸º nodeï¼‰ å¦‚æœ node &lt; æœ€å¤§çš„å­èŠ‚ç‚¹ï¼Œä¸æœ€å¤§çš„å­èŠ‚ç‚¹äº¤æ¢ä½ç½® å¦‚æœ node â‰¥ æœ€å¤§çš„å­èŠ‚ç‚¹ï¼Œ æˆ–è€… node æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œé€€å‡ºå¾ªç¯ è¿™ä¸ªè¿‡ç¨‹ï¼Œå«åšä¸‹æ»¤ï¼ˆSift Downï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ï¼šO(logn) åŒæ ·çš„ï¼Œäº¤æ¢ä½ç½®çš„æ“ä½œå¯ä»¥åƒæ·»åŠ é‚£æ ·è¿›è¡Œä¼˜åŒ– 1234567891011121314151617181920212223242526272829303132333435363738394041424344public E remove() &#123; emptyCheck(); int lastIndex = --size; E root = elements[0]; elements[0] = elements[lastIndex]; elements[lastIndex] = null; siftDown(0); return root;&#125;private void siftDown(int index) &#123; E element = elements[index]; int half = size &gt;&gt; 1; // ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„ç´¢å¼• == éå¶å­èŠ‚ç‚¹çš„æ•°é‡ // index &lt; ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„ç´¢å¼• // å¿…é¡»ä¿è¯indexä½ç½®æ˜¯éå¶å­èŠ‚ç‚¹ while (index &lt; half) &#123; // indexçš„èŠ‚ç‚¹æœ‰2ç§æƒ…å†µ // 1.åªæœ‰å·¦å­èŠ‚ç‚¹ // 2.åŒæ—¶æœ‰å·¦å³å­èŠ‚ç‚¹ // é»˜è®¤ä¸ºå·¦å­èŠ‚ç‚¹è·Ÿå®ƒè¿›è¡Œæ¯”è¾ƒ int childIndex = (index &lt;&lt; 1) + 1; E child = elements[childIndex]; // å³å­èŠ‚ç‚¹ int rightIndex = childIndex + 1; // é€‰å‡ºå·¦å³å­èŠ‚ç‚¹æœ€å¤§çš„é‚£ä¸ª if (rightIndex &lt; size &amp;&amp; compare(elements[rightIndex], child) &gt; 0) &#123; child = elements[childIndex = rightIndex]; &#125; if (compare(element, child) &gt;= 0) break; // å°†å­èŠ‚ç‚¹å­˜æ”¾åˆ°indexä½ç½® elements[index] = child; // é‡æ–°è®¾ç½®index index = childIndex; &#125; elements[index] = element;&#125; æœ€å¤§å † - æ›¿æ¢å †é¡¶1234567891011121314public E replace(E element) &#123; elementNotNullCheck(element); E root = null; if (size == 0) &#123; elements[0] = element; size++; &#125; else &#123; root = elements[0]; elements[0] = element; siftDown(0); &#125; return root;&#125; æœ€å¤§å † â€“ æ‰¹é‡å»ºå †ï¼ˆHeapifyï¼‰æ‰¹é‡å»ºå †ï¼Œæœ‰ 2 ç§åšæ³• è‡ªä¸Šè€Œä¸‹çš„ä¸Šæ»¤ è‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤ æœ€å¤§å † â€“ æ‰¹é‡å»ºå † â€“ è‡ªä¸Šè€Œä¸‹çš„ä¸Šæ»¤ 123456private void heapify() &#123; // è‡ªä¸Šè€Œä¸‹çš„ä¸Šæ»¤ for (int i = 1; i &lt; size; i++) &#123; siftUp(i); &#125;&#125; æœ€å¤§å † â€“ æ‰¹é‡å»ºå † â€“ è‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤ 123456private void heapify() &#123; // è‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤ for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125;&#125; æœ€å¤§å † â€“ æ‰¹é‡å»ºå † â€“ æ•ˆç‡å¯¹æ¯”æ‰€æœ‰èŠ‚ç‚¹çš„æ·±åº¦ä¹‹å’Œ ä»…ä»…æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå°±æœ‰è¿‘ n/2 ä¸ªï¼Œè€Œä¸”æ¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„æ·±åº¦éƒ½æ˜¯ O(logn) çº§åˆ«çš„ å› æ­¤ï¼Œåœ¨å¶å­èŠ‚ç‚¹è¿™ä¸€å—ï¼Œå°±è¾¾åˆ°äº† O(nlogn) çº§åˆ« O(nlogn) çš„æ—¶é—´å¤æ‚åº¦è¶³ä»¥åˆ©ç”¨æ’åºç®—æ³•å¯¹æ‰€æœ‰èŠ‚ç‚¹è¿›è¡Œå…¨æ’åº æ‰€æœ‰èŠ‚ç‚¹çš„é«˜åº¦ä¹‹å’Œ å‡è®¾æ˜¯æ»¡æ ‘ï¼ŒèŠ‚ç‚¹æ€»ä¸ªæ•°ä¸º $n$ï¼Œæ ‘é«˜ä¸º $h$ï¼Œé‚£ä¹ˆ $n = 2h âˆ’ 1$ æ‰€æœ‰èŠ‚ç‚¹çš„æ ‘é«˜ä¹‹å’Œ $H(n) = 2^0 âˆ— (h âˆ’ 0) + 2^1 âˆ— (h âˆ’ 1) + 2^2 âˆ— (h âˆ’ 2) + â‹¯ + 2^{h âˆ’1} âˆ— [h âˆ’ (h âˆ’ 1)]$ $H(n) = h âˆ— (2^0 + 2^1 + 2^2 + â‹¯ + 2^{h âˆ’1}) âˆ’ [1 âˆ— 2^1 + 2 âˆ— 2^2 + 3 âˆ— 2^3 + â‹¯ + (h âˆ’ 1)âˆ— 2^{hâˆ’1}]$ $H(n) = h âˆ— (2^h âˆ’ 1) âˆ’ [(h âˆ’ 2) âˆ— 2^h + 2]$ $H(n) = h âˆ— 2^h âˆ’ h âˆ’ h âˆ— 2^h + 2^{h+1} âˆ’ 2$ $H(n) = 2^{h+1} âˆ’ h âˆ’ 2 = 2 âˆ— (2^h âˆ’ 1) âˆ’ h = 2n âˆ’ h = 2n âˆ’ log_2(n + 1) = O(n)$ å…¬å¼æ¨å¯¼ $S(h) = 1 âˆ— 2^1 + 2 âˆ— 2^2 + 3 âˆ— 2^3 + â‹¯ + (h âˆ’ 2) âˆ— 2^{hâˆ’2} + (h âˆ’ 1) * 2^{hâˆ’1}$ $2S(h) = 1 âˆ— 2^2 + 2 âˆ— 2^3 + 3 âˆ— 2^4 + â‹¯ + (h âˆ’ 2) âˆ— 2^{hâˆ’1} +(h âˆ’ 1) âˆ— 2^h$ $S(h) â€“ 2S(h) = [2^1 + 2^2 + 2^3 + â‹¯ + 2^{hâˆ’1}] âˆ’ (h âˆ’ 1) âˆ— 2^h = (2^h âˆ’ 2) âˆ’ (h âˆ’ 1) âˆ— 2^h$ $S(h) = (h âˆ’ 1) âˆ— 2^h âˆ’ (2^h âˆ’ 2) = (h âˆ’ 2) âˆ— 2^h + 2$ æ‰¹é‡å»ºå †12345678910111213141516171819202122public BinaryHeap(E[] elements, Comparator&lt;E&gt; comparator) &#123; super(comparator); if (elements == null || elements.length == 0) &#123; this.elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; else &#123; size = elements.length; int capacity = Math.max(elements.length, DEFAULT_CAPACITY); this.elements = (E[]) new Object[capacity]; for (int i = 0; i &lt; elements.length; i++) &#123; this.elements[i] = elements[i]; &#125; heapify(); &#125;&#125;private void heapify() &#123; // è‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤ for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; siftDown(i); &#125;&#125; å¦‚ä½•æ„å»ºä¸€ä¸ªå°é¡¶å †ï¼Ÿ1234567Integer[] data = &#123;88, 44, 53, 41, 16, 6, 70, 18, 85, 98, 81, 23, 36, 43, 37&#125;;BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(data, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125;&#125;);BinaryTrees.println(heap); Top Ké—®é¢˜ä» n ä¸ªæ•´æ•°ä¸­ï¼Œæ‰¾å‡ºæœ€å¤§çš„å‰ k ä¸ªæ•°ï¼ˆ k è¿œè¿œå°äº n ï¼‰ å¦‚æœä½¿ç”¨æ’åºç®—æ³•è¿›è¡Œå…¨æ’åºï¼Œéœ€è¦ O(nlogn) çš„æ—¶é—´å¤æ‚åº¦ å¦‚æœä½¿ç”¨äºŒå‰å †æ¥è§£å†³ï¼Œå¯ä»¥ä½¿ç”¨ O(nlogk) çš„æ—¶é—´å¤æ‚åº¦æ¥è§£å†³ æ–°å»ºä¸€ä¸ªå°é¡¶å † æ‰«æ n ä¸ªæ•´æ•° å…ˆå°†éå†åˆ°çš„å‰ k ä¸ªæ•°æ”¾å…¥å †ä¸­ ä»ç¬¬ k + 1 ä¸ªæ•°å¼€å§‹ï¼Œå¦‚æœå¤§äºå †é¡¶å…ƒç´ ï¼Œå°±ä½¿ç”¨ replace æ“ä½œï¼ˆåˆ é™¤å †é¡¶å…ƒç´ ï¼Œå°†ç¬¬ k + 1 ä¸ªæ•°æ·»åŠ åˆ°å †ä¸­ï¼‰ æ‰«æå®Œæ¯•åï¼Œå †ä¸­å‰©ä¸‹çš„å°±æ˜¯æœ€å¤§çš„å‰ k ä¸ªæ•° å¦‚æœæ˜¯æ‰¾å‡ºæœ€å°çš„å‰ k ä¸ªæ•°å‘¢ï¼Ÿ ç”¨å¤§é¡¶å † å¦‚æœå°äºå †é¡¶å…ƒç´ ï¼Œå°±ä½¿ç”¨ replace æ“ä½œ 1234567891011121314151617181920212223static void test() &#123; // æ–°å»ºä¸€ä¸ªå°é¡¶å † BinaryHeap&lt;Integer&gt; heap = new BinaryHeap&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); // æ‰¾å‡ºæœ€å¤§çš„å‰kä¸ªæ•° int k = 3; Integer[] data = &#123;51, 30, 39, 92, 74, 25, 16, 93, 91, 19, 54, 47, 73, 62, 76, 63, 35, 18, 90, 6, 65, 49, 3, 26, 61, 21, 48&#125;; for (int i = 0; i &lt; data.length; i++) &#123; if (heap.size() &lt; k) &#123; // å‰kä¸ªæ•°æ·»åŠ åˆ°å°é¡¶å † heap.add(data[i]); // logk &#125; else if (data[i] &gt; heap.get()) &#123; // å¦‚æœæ˜¯ç¬¬k + 1ä¸ªæ•°ï¼Œå¹¶ä¸”å¤§äºå †é¡¶å…ƒç´  heap.replace(data[i]); // logk &#125; &#125; // O(nlogk) BinaryTrees.println(heap);&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>äºŒå‰å †</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å“ˆå¸Œè¡¨]]></title>
    <url>%2F2020%2F07%2F13%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[å“ˆå¸Œè¡¨ï¼ˆHashTableï¼‰å…ˆæ¥åˆ†æTreeMapï¼ˆçº¢é»‘æ ‘æ˜ å°„å®ç°ï¼‰ æ—¶é—´å¤æ‚åº¦ï¼ˆå¹³å‡ï¼‰ æ·»åŠ ã€åˆ é™¤ã€æœç´¢ï¼šO(logn) ç‰¹ç‚¹ Key å¿…é¡»å…·å¤‡å¯æ¯”è¾ƒæ€§ å…ƒç´ çš„åˆ†å¸ƒæ˜¯æœ‰é¡ºåºçš„ åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¾ˆå¤šæ—¶å€™çš„éœ€æ±‚ Map ä¸­å­˜å‚¨çš„å…ƒç´ ä¸éœ€è¦è®²ç©¶é¡ºåº Map ä¸­çš„ Key ä¸éœ€è¦å…·å¤‡å¯æ¯”è¾ƒæ€§ ä¸è€ƒè™‘é¡ºåºã€ä¸è€ƒè™‘ Key çš„å¯æ¯”è¾ƒæ€§ï¼ŒMap æœ‰æ›´å¥½çš„å®ç°æ–¹æ¡ˆï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ° O(1)ï¼Œé‚£å°±æ˜¯é‡‡å–å“ˆå¸Œè¡¨æ¥å®ç° Map ä»€ä¹ˆæ˜¯å“ˆå¸Œè¡¨ï¼ˆHashTableï¼‰å“ˆå¸Œè¡¨ä¹Ÿå«åšæ•£åˆ—è¡¨ï¼ˆ hash æœ‰â€œå‰ç¢â€çš„æ„æ€ï¼‰ æ·»åŠ ã€æœç´¢ã€åˆ é™¤çš„æµç¨‹éƒ½æ˜¯ç±»ä¼¼çš„ åˆ©ç”¨å“ˆå¸Œå‡½æ•°ç”Ÿæˆ key å¯¹åº”çš„ indexã€O(1)ã€‘ æ ¹æ® index æ“ä½œå®šä½æ•°ç»„å…ƒç´ ã€O(1)ã€‘ å“ˆå¸Œè¡¨æ˜¯ã€ç©ºé—´æ¢æ—¶é—´ã€‘çš„å…¸å‹åº”ç”¨ å“ˆå¸Œå‡½æ•°ï¼Œä¹Ÿå«åšæ•£åˆ—å‡½æ•° å“ˆå¸Œè¡¨å†…éƒ¨çš„æ•°ç»„å…ƒç´ ï¼Œå¾ˆå¤šåœ°æ–¹ä¹Ÿå« Bucketï¼ˆæ¡¶ï¼‰ï¼Œæ•´ä¸ªæ•°ç»„å« Buckets æˆ–è€… Bucket Array å“ˆå¸Œå†²çªï¼ˆHash Collisionï¼‰å“ˆå¸Œå†²çªä¹Ÿå«åšå“ˆå¸Œç¢°æ’ 2 ä¸ªä¸åŒçš„ keyï¼Œç»è¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºç›¸åŒçš„ç»“æœ key1 â‰  key2 ï¼Œhash(key1) = hash(key2) è§£å†³å“ˆå¸Œå†²çªçš„å¸¸è§æ–¹æ³• å¼€æ”¾å®šå€æ³•ï¼ˆOpen Addressingï¼‰ æŒ‰ç…§ä¸€å®šè§„åˆ™å‘å…¶ä»–åœ°å€æ¢æµ‹ï¼Œç›´åˆ°é‡åˆ°ç©ºæ¡¶ å†å“ˆå¸Œæ³•ï¼ˆRe-Hashingï¼‰ è®¾è®¡å¤šä¸ªå“ˆå¸Œå‡½æ•° é“¾åœ°å€æ³•ï¼ˆSeparate Chainingï¼‰ æ¯”å¦‚é€šè¿‡é“¾è¡¨å°†åŒä¸€indexçš„å…ƒç´ ä¸²èµ·æ¥ JDK1.8çš„å“ˆå¸Œå†²çªè§£å†³æ–¹æ¡ˆJDK1.8ä¸­çš„å“ˆå¸Œè¡¨æ˜¯ä½¿ç”¨é“¾è¡¨+çº¢é»‘æ ‘è§£å†³å“ˆå¸Œå†²çª é»˜è®¤ä½¿ç”¨å•å‘é“¾è¡¨å°†å…ƒç´ ä¸²èµ·æ¥ åœ¨æ·»åŠ å…ƒç´ æ—¶ï¼Œå¯èƒ½ä¼šç”±å•å‘é“¾è¡¨è½¬ä¸ºçº¢é»‘æ ‘æ¥å­˜å‚¨å…ƒç´  æ¯”å¦‚å½“å“ˆå¸Œè¡¨å®¹é‡ â‰¥ 64 ä¸” å•å‘é“¾è¡¨çš„èŠ‚ç‚¹æ•°é‡å¤§äº 8 æ—¶ å½“çº¢é»‘æ ‘èŠ‚ç‚¹æ•°é‡å°‘åˆ°ä¸€å®šç¨‹åº¦æ—¶ï¼Œåˆä¼šè½¬ä¸ºå•å‘é“¾è¡¨ å“ˆå¸Œå‡½æ•°å“ˆå¸Œè¡¨ä¸­å“ˆå¸Œå‡½æ•°çš„å®ç°æ­¥éª¤å¤§æ¦‚å¦‚ä¸‹ å…ˆç”Ÿæˆ key çš„å“ˆå¸Œå€¼ï¼ˆå¿…é¡»æ˜¯æ•´æ•°ï¼‰ å†è®© key çš„å“ˆå¸Œå€¼è·Ÿæ•°ç»„çš„å¤§å°è¿›è¡Œç›¸å…³è¿ç®—ï¼Œç”Ÿæˆä¸€ä¸ªç´¢å¼•å€¼ 123private int hash(K key) &#123; return hash_code(key) % table.length;&#125; ä¸ºäº†æé«˜æ•ˆç‡ï¼Œå¯ä»¥ä½¿ç”¨ &amp; ä½è¿ç®—å–ä»£ % è¿ç®—ã€å‰æï¼šå°†æ•°ç»„çš„é•¿åº¦è®¾è®¡ä¸º 2 çš„å¹‚ï¼ˆ2nï¼‰ã€‘ 1100 1010 1011 1100 &amp; 1111 &amp; 1111 1010 1100 123private int hash(K key) &#123; return hash_code(key) % (table.length - 1);&#125; è‰¯å¥½çš„å“ˆå¸Œå‡½æ•° è®©å“ˆå¸Œå€¼æ›´åŠ å‡åŒ€åˆ†å¸ƒ â†’ å‡å°‘å“ˆå¸Œå†²çªæ¬¡æ•° â†’ æå‡å“ˆå¸Œè¡¨çš„æ€§èƒ½ å¦‚ä½•ç”Ÿæˆkeyçš„å“ˆå¸Œå€¼key çš„å¸¸è§ç§ç±»å¯èƒ½æœ‰ æ•´æ•°ã€æµ®ç‚¹æ•°ã€å­—ç¬¦ä¸²ã€è‡ªå®šä¹‰å¯¹è±¡ ä¸åŒç§ç±»çš„ keyï¼Œå“ˆå¸Œå€¼çš„ç”Ÿæˆæ–¹å¼ä¸ä¸€æ ·ï¼Œä½†ç›®æ ‡æ˜¯ä¸€è‡´çš„ å°½é‡è®©æ¯ä¸ª key çš„å“ˆå¸Œå€¼æ˜¯å”¯ä¸€çš„ å°½é‡è®© key çš„æ‰€æœ‰ä¿¡æ¯å‚ä¸è¿ç®— åœ¨Javaä¸­ï¼ŒHashMap çš„ key å¿…é¡»å®ç° hashCodeã€equals æ–¹æ³•ï¼Œä¹Ÿå…è®¸ key ä¸º null æ•´æ•°çš„å“ˆå¸Œå€¼æ•´æ•°å€¼å½“åšå“ˆå¸Œå€¼ æ¯”å¦‚ 10 çš„å“ˆå¸Œå€¼å°±æ˜¯ 10 123public static int hashCode(int value)&#123; return value;&#125; æµ®ç‚¹æ•°çš„å“ˆå¸Œå€¼å°†å­˜å‚¨çš„äºŒè¿›åˆ¶æ ¼å¼è½¬ä¸ºæ•´æ•°å€¼ 123public static int hashCode(float value)&#123; return floatToIntBits(value);&#125; Longå’ŒDoubleçš„å“ˆå¸Œå€¼123public static int hashCode(long value)&#123; return (int)(value ^ (value &gt;&gt;&gt; 32));&#125; 1234public static int hashCode(double value)&#123; long bits = doubleToLongBits(value); return (int)(bits ^ (bits &gt;&gt;&gt; 32));&#125; >&gt;&gt; å’Œ ^ çš„ä½œç”¨æ˜¯ï¼Ÿ é«˜32bit å’Œ ä½32bit æ··åˆè®¡ç®—å‡º 32bit çš„å“ˆå¸Œå€¼ å……åˆ†åˆ©ç”¨æ‰€æœ‰ä¿¡æ¯è®¡ç®—å‡ºå“ˆå¸Œå€¼ å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼å­—ç¬¦ä¸²æ˜¯ç”±è‹¥å¹²ä¸ªå­—ç¬¦ç»„æˆçš„ æ¯”å¦‚å­—ç¬¦ä¸² jackï¼Œç”± jã€aã€cã€k å››ä¸ªå­—ç¬¦ç»„æˆï¼ˆå­—ç¬¦çš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ªæ•´æ•°ï¼‰ å› æ­¤ï¼Œjack çš„å“ˆå¸Œå€¼å¯ä»¥è¡¨ç¤ºä¸º $ j âˆ— n^3 + a âˆ— n^2 + c âˆ— n^1 + k âˆ— n^0$ï¼Œç­‰ä»·äº $[ ( j âˆ— n + a ) âˆ— n + c ] âˆ— n + k$ åœ¨JDKä¸­ï¼Œä¹˜æ•° n ä¸º 31ï¼Œä¸ºä»€ä¹ˆä½¿ç”¨ 31ï¼Ÿ 31 æ˜¯ä¸€ä¸ªå¥‡ç´ æ•°ï¼ŒJVMä¼šå°† 31 * i ä¼˜åŒ–æˆ (i &lt;&lt; 5) â€“ i 31 * i = (2^5 - 1) * i = i * 2^5 - i = (i < 5) -i]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ˜ å°„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ˜ å°„</tag>
        <tag>çº¢é»‘æ ‘</tag>
        <tag>å“ˆå¸Œè¡¨</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ˜ å°„]]></title>
    <url>%2F2020%2F07%2F13%2F%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[æ˜ å°„ï¼ˆMapï¼‰Map åœ¨æœ‰äº›ç¼–ç¨‹è¯­è¨€ä¸­ä¹Ÿå«åšå­—å…¸ï¼ˆdictionaryï¼Œæ¯”å¦‚ Pythonã€Objective-Cã€Swift ç­‰ï¼‰ Map çš„æ¯ä¸€ä¸ª key æ˜¯å”¯ä¸€çš„ Mapçš„æ¥å£è®¾è®¡12345678910111213141516public interface Map&lt;K, V&gt; &#123; int size(); boolean isEmpty(); void clear(); V put(K key, V value); V get(K key); V remove(K key); boolean containsKey(K key); boolean containsValue(V value); void traversal(Visitor&lt;K, V&gt; visitor); public static abstract class Visitor&lt;K, V&gt; &#123; boolean stop; public abstract boolean visit(K key, V value); &#125;&#125; ç±»ä¼¼ Setï¼ŒMap å¯ä»¥ç›´æ¥åˆ©ç”¨ä¹‹å‰å­¦ä¹ çš„é“¾è¡¨ã€äºŒå‰æœç´¢æ ‘ï¼ˆAVLæ ‘ã€çº¢é»‘æ ‘ï¼‰ç­‰æ•°æ®ç»“æ„æ¥å®ç° Mapåˆ©ç”¨çº¢é»‘æ ‘å®ç°çº¢é»‘æ ‘çš„å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479public class TreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private static final boolean RED = false; private static final boolean BLACK = true; private int size; private Node&lt;K, V&gt; root; private Comparator&lt;K&gt; comparator; public TreeMap() &#123; this(null); &#125; public TreeMap(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; root = null; size = 0; &#125; @Override public V put(K key, V value) &#123; keyNotNullCheck(key); // æ·»åŠ ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ if (root == null) &#123; root = new Node&lt;&gt;(key, value, null); size++; // æ–°æ·»åŠ èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterPut(root); return null; &#125; // æ·»åŠ çš„ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ Node&lt;K, V&gt; parent = root; Node&lt;K, V&gt; node = root; int cmp = 0; do &#123; cmp = compare(key, node.key); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // ç›¸ç­‰ node.key = key; V oldValue = node.value; node.value = value; return oldValue; &#125; &#125; while (node != null); // çœ‹çœ‹æ’å…¥åˆ°çˆ¶èŠ‚ç‚¹çš„å“ªä¸ªä½ç½® Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // æ–°æ·»åŠ èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterPut(newNode); return null; &#125; @Override public V get(K key) &#123; Node&lt;K, V&gt; node = node(key); return node != null ? node.value : null; &#125; @Override public V remove(K key) &#123; return remove(node(key)); &#125; @Override public boolean containsKey(K key) &#123; return node(key) != null; &#125; @Override public boolean containsValue(V value) &#123; if (root == null) return false; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;K, V&gt; node = queue.poll(); if (valEquals(value, node.value)) return true; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return false; &#125; @Override public void traversal(Visitor&lt;K, V&gt; visitor) &#123; if (visitor == null) return; traversal(root, visitor); &#125; private void traversal(Node&lt;K, V&gt; node, Visitor&lt;K, V&gt; visitor) &#123; if (node == null || visitor.stop) return; traversal(node.left, visitor); if (visitor.stop) return; visitor.visit(node.key, node.value); traversal(node.right, visitor); &#125; private boolean valEquals(V v1, V v2) &#123; return v1 == null ? v2 == null : v1.equals(v2); &#125; private V remove(Node&lt;K, V&gt; node) &#123; if (node == null) return null; size--; V oldValue = node.value; if (node.hasTwoChildren()) &#123; // åº¦ä¸º2çš„èŠ‚ç‚¹ // æ‰¾åˆ°åç»§èŠ‚ç‚¹ Node&lt;K, V&gt; s = successor(node); // ç”¨åç»§èŠ‚ç‚¹çš„å€¼è¦†ç›–åº¦ä¸º2çš„èŠ‚ç‚¹çš„å€¼ node.key = s.key; node.value = s.value; // åˆ é™¤åç»§èŠ‚ç‚¹ node = s; &#125; // åˆ é™¤nodeèŠ‚ç‚¹ï¼ˆnodeçš„åº¦å¿…ç„¶æ˜¯1æˆ–è€…0ï¼‰ Node&lt;K, V&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // nodeæ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹ // æ›´æ”¹parent replacement.parent = node.parent; // æ›´æ”¹parentçš„leftã€rightçš„æŒ‡å‘ if (node.parent == null) &#123; // nodeæ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹å¹¶ä¸”æ˜¯æ ¹èŠ‚ç‚¹ root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // åˆ é™¤èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterRemove(replacement); &#125; else if (node.parent == null) &#123; // nodeæ˜¯å¶å­èŠ‚ç‚¹å¹¶ä¸”æ˜¯æ ¹èŠ‚ç‚¹ root = null; &#125; else &#123; // nodeæ˜¯å¶å­èŠ‚ç‚¹ï¼Œä½†ä¸æ˜¯æ ¹èŠ‚ç‚¹ if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // åˆ é™¤èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterRemove(node); &#125; return oldValue; &#125; private void afterRemove(Node&lt;K, V&gt; node) &#123; // å¦‚æœåˆ é™¤çš„èŠ‚ç‚¹æ˜¯çº¢è‰² // æˆ–è€… ç”¨ä»¥å–ä»£åˆ é™¤èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ˜¯çº¢è‰² if (isRed(node)) &#123; black(node); return; &#125; Node&lt;K, V&gt; parent = node.parent; if (parent == null) return; // åˆ é™¤çš„æ˜¯é»‘è‰²å¶å­èŠ‚ç‚¹ã€ä¸‹æº¢ã€‘ // åˆ¤æ–­è¢«åˆ é™¤çš„nodeæ˜¯å·¦è¿˜æ˜¯å³ boolean left = parent.left == null || node.isLeftChild(); Node&lt;K, V&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å·¦è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å³è¾¹ if (isRed(sibling)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰² black(sibling); red(parent); rotateLeft(parent); // æ›´æ¢å…„å¼Ÿ sibling = parent.right; &#125; // å…„å¼ŸèŠ‚ç‚¹å¿…ç„¶æ˜¯é»‘è‰² if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ²¡æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹è¦å‘ä¸‹è·Ÿå…„å¼ŸèŠ‚ç‚¹åˆå¹¶ boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // å…„å¼ŸèŠ‚ç‚¹è‡³å°‘æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œå‘å…„å¼ŸèŠ‚ç‚¹å€Ÿå…ƒç´  // å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯é»‘è‰²ï¼Œå…„å¼Ÿè¦å…ˆæ—‹è½¬ if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å³è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å·¦è¾¹ if (isRed(sibling)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰² black(sibling); red(parent); rotateRight(parent); // æ›´æ¢å…„å¼Ÿ sibling = parent.left; &#125; // å…„å¼ŸèŠ‚ç‚¹å¿…ç„¶æ˜¯é»‘è‰² if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ²¡æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹è¦å‘ä¸‹è·Ÿå…„å¼ŸèŠ‚ç‚¹åˆå¹¶ boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // å…„å¼ŸèŠ‚ç‚¹è‡³å°‘æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œå‘å…„å¼ŸèŠ‚ç‚¹å€Ÿå…ƒç´  // å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯é»‘è‰²ï¼Œå…„å¼Ÿè¦å…ˆæ—‹è½¬ if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125; private Node&lt;K, V&gt; predecessor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // å‰é©±èŠ‚ç‚¹åœ¨å·¦å­æ ‘å½“ä¸­ï¼ˆleft.right.right.right....ï¼‰ Node&lt;K, V&gt; p = node.left; if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // ä»çˆ¶èŠ‚ç‚¹ã€ç¥–çˆ¶èŠ‚ç‚¹ä¸­å¯»æ‰¾å‰é©±èŠ‚ç‚¹ while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.parent == null // node == node.parent.right return node.parent; &#125; private Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node) &#123; if (node == null) return null; // å‰é©±èŠ‚ç‚¹åœ¨å·¦å­æ ‘å½“ä¸­ï¼ˆright.left.left.left....ï¼‰ Node&lt;K, V&gt; p = node.right; if (p != null) &#123; while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // ä»çˆ¶èŠ‚ç‚¹ã€ç¥–çˆ¶èŠ‚ç‚¹ä¸­å¯»æ‰¾å‰é©±èŠ‚ç‚¹ while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; private Node&lt;K, V&gt; node(K key) &#123; Node&lt;K, V&gt; node = root; while (node != null) &#123; int cmp = compare(key, node.key); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null; &#125; private void afterPut(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; // æ·»åŠ çš„æ˜¯æ ¹èŠ‚ç‚¹ æˆ–è€… ä¸Šæº¢åˆ°è¾¾äº†æ ¹èŠ‚ç‚¹ if (parent == null) &#123; black(node); return; &#125; // å¦‚æœçˆ¶èŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œç›´æ¥è¿”å› if (isBlack(parent)) return; // å”çˆ¶èŠ‚ç‚¹ Node&lt;K, V&gt; uncle = parent.sibling(); // ç¥–çˆ¶èŠ‚ç‚¹ Node&lt;K, V&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // å”çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²ã€Bæ ‘èŠ‚ç‚¹ä¸Šæº¢ã€‘ black(parent); black(uncle); // æŠŠç¥–çˆ¶èŠ‚ç‚¹å½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹ afterPut(grand); return; &#125; // å”çˆ¶èŠ‚ç‚¹ä¸æ˜¯çº¢è‰² if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125; &#125; private void rotateLeft(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.right; Node&lt;K, V&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void rotateRight(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.left; Node&lt;K, V&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child) &#123; // è®©parentç§°ä¸ºå­æ ‘çš„æ ¹èŠ‚ç‚¹ parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grandæ˜¯rootèŠ‚ç‚¹ root = parent; &#125; // æ›´æ–°childçš„parent if (child != null) &#123; child.parent = grand; &#125; // æ›´æ–°grandçš„parent grand.parent = parent; &#125; private Node&lt;K, V&gt; color(Node&lt;K, V&gt; node, boolean color) &#123; if (node == null) return node; node.color = color; return node; &#125; private Node&lt;K, V&gt; red(Node&lt;K, V&gt; node) &#123; return color(node, RED); &#125; private Node&lt;K, V&gt; black(Node&lt;K, V&gt; node) &#123; return color(node, BLACK); &#125; private boolean colorOf(Node&lt;K, V&gt; node) &#123; return node == null ? BLACK : node.color; &#125; private boolean isBlack(Node&lt;K, V&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean isRed(Node&lt;K, V&gt; node) &#123; return colorOf(node) == RED; &#125; private int compare(K e1, K e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;K&gt;)e1).compareTo(e2); &#125; private void keyNotNullCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null"); &#125; &#125; private static class Node&lt;K, V&gt; &#123; K key; V value; boolean color = RED; Node&lt;K, V&gt; left; Node&lt;K, V&gt; right; Node&lt;K, V&gt; parent; public Node(K key, V value, Node&lt;K, V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; public Node&lt;K, V&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ˜ å°„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ˜ å°„</tag>
        <tag>çº¢é»‘æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é›†åˆ]]></title>
    <url>%2F2020%2F07%2F13%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[é›†åˆï¼ˆSetï¼‰é›†åˆçš„ç‰¹ç‚¹ä¸å­˜æ”¾é‡å¤çš„å…ƒç´ ï¼Œå¸¸ç”¨äºå»é‡ å­˜æ”¾æ–°å¢ IPï¼Œç»Ÿè®¡æ–°å¢ IP é‡ å­˜æ”¾è¯æ±‡ï¼Œç»Ÿè®¡è¯æ±‡é‡ é›†åˆæ¥å£å®šä¹‰1234567891011121314public interface Set&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(E element); void add(E element); void remove(E element); void traversal(Visitor&lt;E&gt; visitor); public static abstract class Visitor&lt;E&gt; &#123; boolean stop; public abstract boolean visit(E element); &#125;&#125; é›†åˆçš„å†…éƒ¨å®ç°ç›´æ¥åˆ©ç”¨å­¦è¿‡çš„æ•°æ®ç»“æ„å®ç°ï¼ˆé“¾è¡¨ï¼ŒåŠ¨æ€æ•°ç»„ï¼Œçº¢é»‘æ ‘ã€AVLæ ‘ï¼‰ é›†åˆåˆ©ç”¨é“¾è¡¨å®ç°é“¾è¡¨çš„å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041public class ListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); @Override public int size() &#123; return list.size(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public void clear() &#123; list.clear(); &#125; @Override public boolean contains(E element) &#123; return list.contains(element); &#125; @Override public void add(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; // å­˜åœ¨å°±è¦†ç›– list.set(index, element); &#125; else &#123; // ä¸å­˜åœ¨å°±æ·»åŠ  list.add(element); &#125; &#125; @Override public void remove(E element) &#123; int index = list.indexOf(element); if (index != List.ELEMENT_NOT_FOUND) &#123; list.remove(index); &#125; &#125;&#125; é›†åˆåˆ©ç”¨çº¢é»‘æ ‘å®ç°çº¢é»‘æ ‘çš„å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142public class TreeSet&lt;E&gt; implements Set&lt;E&gt; &#123; private RBTree&lt;E&gt; tree; public TreeSet() &#123; this(null); &#125; public TreeSet(Comparator&lt;E&gt; comparator) &#123; tree = new RBTree&lt;&gt;(comparator); &#125; @Override public int size() &#123; return tree.size(); &#125; @Override public boolean isEmpty() &#123; return tree.isEmpty(); &#125; @Override public void clear() &#123; tree.clear(); &#125; @Override public boolean contains(E element) &#123; return tree.contains(element); &#125; @Override public void add(E element) &#123; tree.add(element); &#125; @Override public void remove(E element) &#123; tree.remove(element); &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>çº¢é»‘æ ‘</tag>
        <tag>é“¾è¡¨</tag>
        <tag>é›†åˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çº¢é»‘æ ‘]]></title>
    <url>%2F2020%2F07%2F12%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[çº¢é»‘æ ‘ï¼ˆRed Black Treeï¼‰ä»€ä¹ˆæ˜¯çº¢é»‘æ ‘çº¢é»‘æ ‘ä¹Ÿæ˜¯ä¸€ç§è‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ ä»¥å‰ä¹Ÿå«åšå¹³è¡¡äºŒå‰Bæ ‘ï¼ˆSymmetric Binary B-treeï¼‰ çº¢é»‘æ ‘å¿…é¡»æ»¡è¶³ä»¥ä¸‹ 5 æ¡æ€§è´¨ èŠ‚ç‚¹æ˜¯ RED æˆ–è€… BLACK æ ¹èŠ‚ç‚¹æ˜¯ BLACK å¶å­èŠ‚ç‚¹ï¼ˆå¤–éƒ¨èŠ‚ç‚¹ï¼Œç©ºèŠ‚ç‚¹ï¼‰éƒ½æ˜¯ BLACK RED èŠ‚ç‚¹çš„å­èŠ‚ç‚¹éƒ½æ˜¯ BLACK RED èŠ‚ç‚¹çš„ parent éƒ½æ˜¯ BLACK ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„ä¸Šä¸èƒ½æœ‰ 2 ä¸ªè¿ç»­çš„ RED èŠ‚ç‚¹ ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„ BLACK èŠ‚ç‚¹ çº¢é»‘æ ‘çš„ç­‰ä»·å˜æ¢çº¢é»‘æ ‘ å’Œ 4é˜¶Bæ ‘ï¼ˆ2-3-4æ ‘ï¼‰å…·æœ‰ç­‰ä»·æ€§ BLACK èŠ‚ç‚¹ä¸å®ƒçš„ RED å­èŠ‚ç‚¹èåˆåœ¨ä¸€èµ·ï¼Œå½¢æˆ1ä¸ªBæ ‘èŠ‚ç‚¹ çº¢é»‘æ ‘çš„ BLACK èŠ‚ç‚¹ä¸ªæ•° ä¸ 4é˜¶Bæ ‘çš„èŠ‚ç‚¹æ€»ä¸ªæ•°ç›¸ç­‰ æ³¨æ„ï¼šåé¢å±•ç¤ºçš„çº¢é»‘æ ‘éƒ½ä¼šçœç•¥ NULL èŠ‚ç‚¹ çº¢é»‘æ ‘ vs 2-3-4æ ‘ å¦‚æœä¸Šå›¾æœ€åº•å±‚çš„ BLACK èŠ‚ç‚¹æ˜¯ä¸å­˜åœ¨çš„ï¼Œåœ¨Bæ ‘ä¸­æ˜¯ä»€ä¹ˆæ ·çš„æƒ…å½¢ï¼Ÿ æ•´æ£µBæ ‘åªæœ‰1ä¸ªèŠ‚ç‚¹ï¼Œè€Œä¸”æ˜¯è¶…çº§èŠ‚ç‚¹ ä¸€äº›è¾…åŠ©å‡½æ•°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// parentï¼šçˆ¶èŠ‚ç‚¹// siblingï¼šå…„å¼ŸèŠ‚ç‚¹// uncleï¼šå”çˆ¶èŠ‚ç‚¹ï¼ˆparent çš„å…„å¼ŸèŠ‚ç‚¹ï¼‰// grandï¼šç¥–çˆ¶èŠ‚ç‚¹ï¼ˆparent çš„çˆ¶èŠ‚ç‚¹ï¼‰// æŒ‡å®šé¢œè‰²private Node&lt;E&gt; color(Node&lt;E&gt; node, boolean color) &#123; if (node == null) return node; ((RBNode&lt;E&gt;)node).color = color; return node;&#125;// æŸ“çº¢private Node&lt;E&gt; red(Node&lt;E&gt; node) &#123; return color(node, RED);&#125;// æŸ“é»‘private Node&lt;E&gt; black(Node&lt;E&gt; node) &#123; return color(node, BLACK);&#125;// æŸ¥çœ‹é¢œè‰²private boolean colorOf(Node&lt;E&gt; node) &#123; return node == null ? BLACK : ((RBNode&lt;E&gt;)node).color;&#125;// åˆ¤æ–­æ˜¯å¦æ˜¯é»‘è‰²private boolean isBlack(Node&lt;E&gt; node) &#123; return colorOf(node) == BLACK;&#125;// åˆ¤æ–­æ˜¯å¦æ˜¯çº¢è‰²private boolean isRed(Node&lt;E&gt; node) &#123; return colorOf(node) == RED;&#125;// æŸ¥çœ‹æ˜¯å¦æœ‰å…„å¼ŸèŠ‚ç‚¹public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null;&#125; çº¢é»‘æ ‘çš„æ·»åŠ å·²çŸ¥ Bæ ‘ä¸­ï¼Œæ–°å…ƒç´ å¿…å®šæ˜¯æ·»åŠ åˆ°å¶å­èŠ‚ç‚¹ä¸­ 4é˜¶Bæ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å…ƒç´ ä¸ªæ•° x éƒ½ç¬¦åˆ 1 â‰¤ x â‰¤ 3 å»ºè®®æ–°æ·»åŠ çš„èŠ‚ç‚¹é»˜è®¤ä¸º REDï¼Œè¿™æ ·èƒ½å¤Ÿè®©çº¢é»‘æ ‘çš„æ€§è´¨å°½å¿«æ»¡è¶³ï¼ˆæ€§è´¨ 1ã€2ã€3ã€5 éƒ½æ»¡è¶³ï¼Œæ€§è´¨ 4 ä¸ä¸€å®šï¼‰ æœ‰ 4 ç§æƒ…å†µæ»¡è¶³çº¢é»‘æ ‘çš„æ€§è´¨ 4 ï¼šparent ä¸ºBLACKåŒæ ·ä¹Ÿæ»¡è¶³4é˜¶Bæ ‘çš„æ€§è´¨ å› æ­¤ä¸ç”¨åšä»»ä½•é¢å¤–å¤„ç† 12// å¦‚æœçˆ¶èŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œç›´æ¥è¿”å›if (isBlack(parent)) return; æœ‰ 8 ç§æƒ…å†µä¸æ»¡è¶³çº¢é»‘æ ‘çš„æ€§è´¨ 4 ï¼šparent ä¸º REDï¼ˆ Double Red ï¼‰å…¶ä¸­å‰ 4 ç§å±äºBæ ‘èŠ‚ç‚¹ä¸Šæº¢çš„æƒ…å†µ æ·»åŠ  â€“ ä¿®å¤æ€§è´¨4 â€“ LL\RRåˆ¤å®šæ¡ä»¶ï¼šuncle ä¸æ˜¯ RED 1.parent æŸ“æˆ BLACKï¼Œgrand æŸ“æˆ RED 2.grand è¿›è¡Œå•æ—‹æ“ä½œ LLï¼šå³æ—‹è½¬ RRï¼šå·¦æ—‹è½¬ 123456789101112131415161718192021// å”çˆ¶èŠ‚ç‚¹Node&lt;E&gt; uncle = parent.sibling();// ç¥–çˆ¶èŠ‚ç‚¹æŸ“æˆçº¢è‰²Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // å”çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²ã€Bæ ‘èŠ‚ç‚¹ä¸Šæº¢ã€‘ return;&#125;// å”çˆ¶èŠ‚ç‚¹ä¸æ˜¯çº¢è‰²if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (!node.isLeftChild()) &#123; // RR black(parent); &#125; rotateLeft(grand);&#125; æ·»åŠ  â€“ ä¿®å¤æ€§è´¨4 â€“ LR\RLåˆ¤å®šæ¡ä»¶ï¼šuncle ä¸æ˜¯ RED è‡ªå·±æŸ“æˆ BLACKï¼Œgrand æŸ“æˆ RED è¿›è¡ŒåŒæ—‹æ“ä½œ LRï¼šparent å·¦æ—‹è½¬ï¼Œ grand å³æ—‹è½¬ RLï¼šparent å³æ—‹è½¬ï¼Œ grand å·¦æ—‹è½¬ 1234567891011121314151617181920212223// å”çˆ¶èŠ‚ç‚¹Node&lt;E&gt; uncle = parent.sibling();// ç¥–çˆ¶èŠ‚ç‚¹æŸ“æˆçº¢è‰²Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // å”çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²ã€Bæ ‘èŠ‚ç‚¹ä¸Šæº¢ã€‘ return;&#125;// å”çˆ¶èŠ‚ç‚¹ä¸æ˜¯çº¢è‰²if (parent.isLeftChild()) &#123; // L if (!node.isLeftChild()) &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand);&#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; rotateLeft(grand);&#125; æ·»åŠ  â€“ ä¿®å¤æ€§è´¨4 â€“ ä¸Šæº¢ â€“ LLåˆ¤å®šæ¡ä»¶ï¼šuncle æ˜¯ RED parentã€uncle æŸ“æˆ BLACK grand å‘ä¸Šåˆå¹¶ grandæŸ“æˆ REDï¼Œå½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹è¿›è¡Œå¤„ç† grand å‘ä¸Šåˆå¹¶æ—¶ï¼Œå¯èƒ½ç»§ç»­å‘ç”Ÿä¸Šæº¢ è‹¥ä¸Šæº¢æŒç»­åˆ°æ ¹èŠ‚ç‚¹ï¼Œåªéœ€å°†æ ¹èŠ‚ç‚¹æŸ“æˆ BLACK 12345678910111213141516// æ·»åŠ çš„æ˜¯æ ¹èŠ‚ç‚¹ æˆ–è€… ä¸Šæº¢åˆ°è¾¾äº†æ ¹èŠ‚ç‚¹if (parent == null) &#123; black(node); return;&#125;// å”çˆ¶èŠ‚ç‚¹Node&lt;E&gt; uncle = parent.sibling();// ç¥–çˆ¶èŠ‚ç‚¹Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // å”çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²ã€Bæ ‘èŠ‚ç‚¹ä¸Šæº¢ã€‘ black(parent); black(uncle); // æŠŠç¥–çˆ¶èŠ‚ç‚¹å½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹ afterAdd(grand); return;&#125; æ·»åŠ  â€“ ä¿®å¤æ€§è´¨4 â€“ ä¸Šæº¢ â€“ RRåˆ¤å®šæ¡ä»¶ï¼šuncle æ˜¯ RED parentã€uncle æŸ“æˆ BLACK grand å‘ä¸Šåˆå¹¶ grandæŸ“æˆ REDï¼Œå½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹è¿›è¡Œå¤„ç† 123456789101112// å”çˆ¶èŠ‚ç‚¹Node&lt;E&gt; uncle = parent.sibling();// ç¥–çˆ¶èŠ‚ç‚¹Node&lt;E&gt; grand = red(parent.parent);if (isRed(uncle)) &#123; // å”çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²ã€Bæ ‘èŠ‚ç‚¹ä¸Šæº¢ã€‘ black(parent); black(uncle); // æŠŠç¥–çˆ¶èŠ‚ç‚¹å½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹ afterAdd(grand); return;&#125; æ·»åŠ  â€“ ä¿®å¤æ€§è´¨4 â€“ ä¸Šæº¢ â€“ LRåˆ¤å®šæ¡ä»¶ï¼šuncle æ˜¯ RED parentã€uncle æŸ“æˆ BLACK grand å‘ä¸Šåˆå¹¶ grandæŸ“æˆ REDï¼Œå½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹è¿›è¡Œå¤„ç† æ·»åŠ  â€“ ä¿®å¤æ€§è´¨4 â€“ ä¸Šæº¢ â€“ RLåˆ¤å®šæ¡ä»¶ï¼šuncle æ˜¯ RED parentã€uncle æŸ“æˆ BLACK grand å‘ä¸Šåˆå¹¶ grandæŸ“æˆ REDï¼Œå½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹è¿›è¡Œå¤„ç† çº¢é»‘æ ‘æ·»åŠ åå®Œæ•´ä¿®å¤çš„ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243protected void afterAdd(Node&lt;E&gt; node) &#123; Node&lt;E&gt; parent = node.parent; // æ·»åŠ çš„æ˜¯æ ¹èŠ‚ç‚¹ æˆ–è€… ä¸Šæº¢åˆ°è¾¾äº†æ ¹èŠ‚ç‚¹ if (parent == null) &#123; black(node); return; &#125; // å¦‚æœçˆ¶èŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œç›´æ¥è¿”å› if (isBlack(parent)) return; // å”çˆ¶èŠ‚ç‚¹ Node&lt;E&gt; uncle = parent.sibling(); // ç¥–çˆ¶èŠ‚ç‚¹ Node&lt;E&gt; grand = red(parent.parent); if (isRed(uncle)) &#123; // å”çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²ã€Bæ ‘èŠ‚ç‚¹ä¸Šæº¢ã€‘ black(parent); black(uncle); // æŠŠç¥–çˆ¶èŠ‚ç‚¹å½“åšæ˜¯æ–°æ·»åŠ çš„èŠ‚ç‚¹ afterAdd(grand); return; &#125; // å”çˆ¶èŠ‚ç‚¹ä¸æ˜¯çº¢è‰² if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL black(parent); &#125; else &#123; // LR black(node); rotateLeft(parent); &#125; rotateRight(grand); &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL black(node); rotateRight(parent); &#125; else &#123; // RR black(parent); &#125; rotateLeft(grand); &#125;&#125; çº¢é»‘æ ‘çš„åˆ é™¤Bæ ‘ä¸­ï¼Œæœ€åçœŸæ­£è¢«åˆ é™¤çš„å…ƒç´ éƒ½åœ¨å¶å­èŠ‚ç‚¹ä¸­ åˆ é™¤ â€“ REDèŠ‚ç‚¹ç›´æ¥åˆ é™¤ï¼Œä¸ç”¨ä½œä»»ä½•è°ƒæ•´ 1234protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // å¦‚æœåˆ é™¤çš„èŠ‚ç‚¹æ˜¯çº¢è‰² if (isRed(node)) return;&#125; åˆ é™¤ â€“ BLACKèŠ‚ç‚¹æœ‰ 3 ç§æƒ…å†µ æ‹¥æœ‰ 2 ä¸ª RED å­èŠ‚ç‚¹çš„ BLACK èŠ‚ç‚¹ ä¸å¯èƒ½è¢«ç›´æ¥åˆ é™¤ï¼Œå› ä¸ºä¼šæ‰¾å®ƒçš„å­èŠ‚ç‚¹æ›¿ä»£åˆ é™¤ å› æ­¤ä¸ç”¨è€ƒè™‘è¿™ç§æƒ…å†µ æ‹¥æœ‰ 1 ä¸ª RED å­èŠ‚ç‚¹çš„ BLACK èŠ‚ç‚¹ BLACK å¶å­èŠ‚ç‚¹ ä¸‹æ–‡ä¸¾ä¾‹é‡‡ç”¨: è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å³è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å·¦è¾¹ï¼Œï¼ˆåä¹‹äº¤æ¢å·¦å³æ–¹å‘å³å¯ï¼‰ åˆ é™¤ - æ‹¥æœ‰ 1 ä¸ª RED å­èŠ‚ç‚¹çš„ BLACK èŠ‚ç‚¹åˆ¤å®šæ¡ä»¶ï¼šç”¨ä»¥æ›¿ä»£çš„å­èŠ‚ç‚¹æ˜¯ RED å°†æ›¿ä»£çš„å­èŠ‚ç‚¹æŸ“æˆ BLACK å³å¯ä¿æŒçº¢é»‘æ ‘æ€§è´¨ 1234567protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; // ç”¨ä»¥å–ä»£nodeçš„å­èŠ‚ç‚¹æ˜¯çº¢è‰² if (isRed(replacement)) &#123; black(replacement); return; &#125;&#125; åˆ é™¤ - BLACK å¶å­èŠ‚ç‚¹ - siblingä¸ºBLACK - sibling è‡³å°‘æœ‰ 1 ä¸ª RED å­èŠ‚ç‚¹BLACK å¶å­èŠ‚ç‚¹è¢«åˆ é™¤åï¼Œä¼šå¯¼è‡´Bæ ‘èŠ‚ç‚¹ä¸‹æº¢ï¼ˆæ¯”å¦‚åˆ é™¤88ï¼‰ å¦‚æœ sibling è‡³å°‘æœ‰ 1 ä¸ª RED å­èŠ‚ç‚¹ï¼ˆä¸€ä¸ªæˆ–ä¸¤ä¸ªREDå­èŠ‚ç‚¹ï¼‰ å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯é»‘è‰²ï¼Œ(æ²¡æœ‰å­èŠ‚ç‚¹ä¹Ÿç®—æ˜¯é»‘è‰²) å…„å¼ŸèŠ‚ç‚¹å·¦æ—‹ æ”¹å˜å…„å¼ŸèŠ‚ç‚¹ä¸ºparentçš„å·¦è¾¹ åç»­å†æŒ‰å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯çº¢è‰²æ‰§è¡Œå³å¯ å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯çº¢è‰² å…„å¼ŸèŠ‚ç‚¹ç»§æ‰¿ parent çš„é¢œè‰² å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹å˜æˆé»‘è‰² parentèŠ‚ç‚¹å˜æˆé»‘è‰² parentå³æ—‹ 1234567891011121314151617181920212223242526272829303132protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ if (parent == null) return; // åˆ é™¤çš„æ˜¯é»‘è‰²å¶å­èŠ‚ç‚¹ã€ä¸‹æº¢ã€‘ // åˆ¤æ–­è¢«åˆ é™¤çš„nodeæ˜¯å·¦è¿˜æ˜¯å³ boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å·¦è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å³è¾¹ // .... ä»£ç çœç•¥ï¼Œå¯æŸ¥çœ‹æœ€åå®Œæ•´ä»£ç  &#125;else &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å³è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å·¦è¾¹ if (isBlack(sibling)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰² // å…„å¼ŸèŠ‚ç‚¹è‡³å°‘æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œå‘å…„å¼ŸèŠ‚ç‚¹å€Ÿå…ƒç´  if (isRed(sibling.left) || isRed(sibling.right)) &#123; // å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯é»‘è‰²ï¼Œå…„å¼Ÿè¦å…ˆæ—‹è½¬ if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; // å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯çº¢è‰²æˆ–å…„å¼Ÿæ—‹è½¬å color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125;&#125; åˆ é™¤ - BLACK å¶å­èŠ‚ç‚¹ - siblingä¸ºBLACK - sibling æ²¡æœ‰ 1 ä¸ª RED å­èŠ‚ç‚¹åˆ¤å®šæ¡ä»¶ï¼šsibling æ²¡æœ‰ 1 ä¸ª RED å­èŠ‚ç‚¹ å°† sibling æŸ“æˆ REDã€parent æŸ“æˆ BLACK å³å¯ä¿®å¤çº¢é»‘æ ‘æ€§è´¨ å¦‚æœ parent æ˜¯ BLACK ä¼šå¯¼è‡´ parent ä¹Ÿä¸‹æº¢ è¿™æ—¶åªéœ€è¦æŠŠ parent å½“åšè¢«åˆ é™¤çš„èŠ‚ç‚¹å¤„ç†å³å¯ 123456789101112131415161718192021222324252627protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ if (parent == null) return; // åˆ é™¤çš„æ˜¯é»‘è‰²å¶å­èŠ‚ç‚¹ã€ä¸‹æº¢ã€‘ // åˆ¤æ–­è¢«åˆ é™¤çš„nodeæ˜¯å·¦è¿˜æ˜¯å³ boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å·¦è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å³è¾¹ // .... ä»£ç çœç•¥ï¼Œå¯æŸ¥çœ‹æœ€åå®Œæ•´ä»£ç  &#125; else &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å³è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å·¦è¾¹ // å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰² if(isBlack(sibling))&#123; if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ²¡æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹è¦å‘ä¸‹è·Ÿå…„å¼ŸèŠ‚ç‚¹åˆå¹¶ boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent, null); &#125; &#125; &#125; &#125;&#125; åˆ é™¤ - BLACK å¶å­èŠ‚ç‚¹ - siblingä¸ºREDå¦‚æœ sibling æ˜¯ RED sibling æŸ“æˆ BLACKï¼Œparent æŸ“æˆ REDï¼Œè¿›è¡Œæ—‹è½¬ äºæ˜¯åˆå›åˆ° sibling æ˜¯ BLACK çš„æƒ…å†µ 1234567891011121314151617181920protected void afterRemove(Node&lt;E&gt; node, Node&lt;E&gt; replacement) &#123; Node&lt;E&gt; parent = node.parent; // åˆ é™¤çš„æ˜¯é»‘è‰²å¶å­èŠ‚ç‚¹ã€ä¸‹æº¢ã€‘ // åˆ¤æ–­è¢«åˆ é™¤çš„nodeæ˜¯å·¦è¿˜æ˜¯å³ boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å·¦è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å³è¾¹ // .... ä»£ç çœç•¥ï¼Œå¯æŸ¥çœ‹æœ€åå®Œæ•´ä»£ç  &#125; else &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å³è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å·¦è¾¹ if (isRed(sibling)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰² black(sibling); red(parent); rotateRight(parent); // æ›´æ¢å…„å¼Ÿ sibling = parent.left; &#125; &#125;&#125; çº¢é»‘æ ‘åˆ é™¤åå®Œæ•´ä¿®å¤çš„ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void afterRemove(Node&lt;E&gt; node) &#123; // å¦‚æœåˆ é™¤çš„èŠ‚ç‚¹æ˜¯çº¢è‰² // æˆ–è€… ç”¨ä»¥å–ä»£åˆ é™¤èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ˜¯çº¢è‰² if (isRed(node)) &#123; black(node); return; &#125; Node&lt;E&gt; parent = node.parent; // åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ if (parent == null) return; // åˆ é™¤çš„æ˜¯é»‘è‰²å¶å­èŠ‚ç‚¹ã€ä¸‹æº¢ã€‘ // åˆ¤æ–­è¢«åˆ é™¤çš„nodeæ˜¯å·¦è¿˜æ˜¯å³ boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å·¦è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å³è¾¹ if (isRed(sibling)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰² black(sibling); red(parent); rotateLeft(parent); // æ›´æ¢å…„å¼Ÿ sibling = parent.right; &#125; // å…„å¼ŸèŠ‚ç‚¹å¿…ç„¶æ˜¯é»‘è‰² if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ²¡æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹è¦å‘ä¸‹è·Ÿå…„å¼ŸèŠ‚ç‚¹åˆå¹¶ boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // å…„å¼ŸèŠ‚ç‚¹è‡³å°‘æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œå‘å…„å¼ŸèŠ‚ç‚¹å€Ÿå…ƒç´  // å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯é»‘è‰²ï¼Œå…„å¼Ÿè¦å…ˆæ—‹è½¬ if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // è¢«åˆ é™¤çš„èŠ‚ç‚¹åœ¨å³è¾¹ï¼Œå…„å¼ŸèŠ‚ç‚¹åœ¨å·¦è¾¹ if (isRed(sibling)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰² black(sibling); red(parent); rotateRight(parent); // æ›´æ¢å…„å¼Ÿ sibling = parent.left; &#125; // å…„å¼ŸèŠ‚ç‚¹å¿…ç„¶æ˜¯é»‘è‰² if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // å…„å¼ŸèŠ‚ç‚¹æ²¡æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹è¦å‘ä¸‹è·Ÿå…„å¼ŸèŠ‚ç‚¹åˆå¹¶ boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // å…„å¼ŸèŠ‚ç‚¹è‡³å°‘æœ‰1ä¸ªçº¢è‰²å­èŠ‚ç‚¹ï¼Œå‘å…„å¼ŸèŠ‚ç‚¹å€Ÿå…ƒç´  // å…„å¼ŸèŠ‚ç‚¹çš„å·¦è¾¹æ˜¯é»‘è‰²ï¼Œå…„å¼Ÿè¦å…ˆæ—‹è½¬ if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125;&#125; çº¢é»‘æ ‘çš„å¹³è¡¡ä¸ºä½•é‚£5æ¡æ€§è´¨ï¼Œå°±èƒ½ä¿è¯çº¢é»‘æ ‘æ˜¯å¹³è¡¡çš„ï¼Ÿ é‚£5æ¡æ€§è´¨ï¼Œå¯ä»¥ä¿è¯çº¢é»‘æ ‘ç­‰ä»·äº4é˜¶Bæ ‘ ç›¸æ¯”AVLæ ‘ï¼Œçº¢é»‘æ ‘çš„å¹³è¡¡æ ‡å‡†æ¯”è¾ƒå®½æ¾ï¼šæ²¡æœ‰ä¸€æ¡è·¯å¾„ä¼šå¤§äºå…¶ä»–è·¯å¾„çš„2å€ æ˜¯ä¸€ç§å¼±å¹³è¡¡ã€é»‘é«˜åº¦å¹³è¡¡ çº¢é»‘æ ‘çš„æœ€å¤§é«˜åº¦æ˜¯ 2 âˆ— log2(n + 1) ï¼Œä¾ç„¶æ˜¯ O(logn) çº§åˆ« å¹³å‡æ—¶é—´å¤æ‚åº¦æœç´¢ï¼šO(logn) æ·»åŠ ï¼šO(logn)ï¼ŒO(1) æ¬¡çš„æ—‹è½¬æ“ä½œ åˆ é™¤ï¼šO(logn)ï¼ŒO(1) æ¬¡çš„æ—‹è½¬æ“ä½œ AVLæ ‘ vs çº¢é»‘æ ‘AVLæ ‘ AVLæ ‘çš„å®ç° å¹³è¡¡æ ‡å‡†æ¯”è¾ƒä¸¥æ ¼ï¼šæ¯ä¸ªå·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1 æœ€å¤§é«˜åº¦æ˜¯ 1.44 âˆ— log2 n + 2 âˆ’ 1.328ï¼ˆ100Wä¸ªèŠ‚ç‚¹ï¼ŒAVLæ ‘æœ€å¤§æ ‘é«˜28ï¼‰ æœç´¢ã€æ·»åŠ ã€åˆ é™¤éƒ½æ˜¯ O(logn) å¤æ‚åº¦ï¼Œå…¶ä¸­æ·»åŠ ä»…éœ€ O(1) æ¬¡æ—‹è½¬è°ƒæ•´ã€åˆ é™¤æœ€å¤šéœ€è¦ O(logn) æ¬¡æ—‹è½¬è°ƒæ•´ çº¢é»‘æ ‘ å¹³è¡¡æ ‡å‡†æ¯”è¾ƒå®½æ¾ï¼šæ²¡æœ‰ä¸€æ¡è·¯å¾„ä¼šå¤§äºå…¶ä»–è·¯å¾„çš„2å€ æœ€å¤§é«˜åº¦æ˜¯ 2 âˆ— log2(n + 1)ï¼ˆ 100Wä¸ªèŠ‚ç‚¹ï¼Œçº¢é»‘æ ‘æœ€å¤§æ ‘é«˜40ï¼‰ æœç´¢ã€æ·»åŠ ã€åˆ é™¤éƒ½æ˜¯ O(logn) å¤æ‚åº¦ï¼Œå…¶ä¸­æ·»åŠ ã€åˆ é™¤éƒ½ä»…éœ€ O(1) æ¬¡æ—‹è½¬è°ƒæ•´ æ€»ç»“ æœç´¢çš„æ¬¡æ•°è¿œè¿œå¤§äºæ’å…¥å’Œåˆ é™¤ï¼Œé€‰æ‹©AVLæ ‘ï¼›æœç´¢ã€æ’å…¥ã€åˆ é™¤æ¬¡æ•°å‡ ä¹å·®ä¸å¤šï¼Œé€‰æ‹©çº¢é»‘æ ‘ ç›¸å¯¹äºAVLæ ‘æ¥è¯´ï¼Œçº¢é»‘æ ‘ç‰ºç‰²äº†éƒ¨åˆ†å¹³è¡¡æ€§ä»¥æ¢å–æ’å…¥/åˆ é™¤æ“ä½œæ—¶å°‘é‡çš„æ—‹è½¬æ“ä½œï¼Œæ•´ä½“æ¥è¯´æ€§èƒ½è¦ä¼˜äºAVLæ ‘ çº¢é»‘æ ‘çš„å¹³å‡ç»Ÿè®¡æ€§èƒ½ä¼˜äºAVLæ ‘ï¼Œå®é™…åº”ç”¨ä¸­æ›´å¤šé€‰æ‹©ä½¿ç”¨çº¢é»‘æ ‘ BST vs AVL Tree vs Red Black Tree10, 35, 47, 11, 5, 57, 39, 14, 27, 26, 84, 75, 63, 41, 37, 24, 96]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bæ ‘]]></title>
    <url>%2F2020%2F07%2F12%2FB%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Bæ ‘ï¼ˆB - treeã€B - æ ‘ï¼‰â€‹ Bæ ‘æ˜¯ä¸€ç§å¹³è¡¡çš„å¤šè·¯æœç´¢æ ‘ï¼Œå¤šç”¨äºæ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“çš„å®ç° Bæ ‘ç‰¹ç‚¹ 1ä¸ªèŠ‚ç‚¹å¯ä»¥å­˜å‚¨è¶…è¿‡ 2 ä¸ªå…ƒç´ ã€å¯ä»¥æ‹¥æœ‰è¶…è¿‡ 2 ä¸ªå­èŠ‚ç‚¹ æ‹¥æœ‰äºŒå‰æœç´¢æ ‘çš„ä¸€äº›æ€§è´¨ å¹³è¡¡ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­æ ‘é«˜åº¦ä¸€è‡´ æ¯”è¾ƒçŸ® mé˜¶Bæ ‘çš„æ€§è´¨ï¼ˆmâ‰¥2ï¼‰å‡è®¾ä¸€ä¸ªèŠ‚ç‚¹å­˜å‚¨çš„å…ƒç´ ä¸ªæ•°ä¸º x æ ¹èŠ‚ç‚¹ï¼š1 â‰¤ x â‰¤ m âˆ’ 1 éæ ¹èŠ‚ç‚¹ï¼šâ”Œ m/2 â” âˆ’ 1 â‰¤ x â‰¤ m âˆ’ 1 å¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œå­èŠ‚ç‚¹ä¸ªæ•° y = x + 1 æ ¹èŠ‚ç‚¹ï¼š2 â‰¤ y â‰¤ m éæ ¹èŠ‚ç‚¹ï¼šâ”Œ m/2 â” â‰¤ y â‰¤ m æ¯”å¦‚ m = 3ï¼Œ2 â‰¤ y â‰¤ 3ï¼Œå› æ­¤å¯ä»¥ç§°ä¸ºï¼ˆ2, 3ï¼‰æ ‘ã€2-3æ ‘ æ¯”å¦‚ m = 4ï¼Œ2 â‰¤ y â‰¤ 4ï¼Œå› æ­¤å¯ä»¥ç§°ä¸ºï¼ˆ2, 4ï¼‰æ ‘ã€2-3-4æ ‘ æ¯”å¦‚ m = 5ï¼Œ3 â‰¤ y â‰¤ 5ï¼Œå› æ­¤å¯ä»¥ç§°ä¸ºï¼ˆ3, 5ï¼‰æ ‘ æ¯”å¦‚ m = 6ï¼Œ3 â‰¤ y â‰¤ 6ï¼Œå› æ­¤å¯ä»¥ç§°ä¸ºï¼ˆ3, 6ï¼‰æ ‘ æ¯”å¦‚ m = 7ï¼Œ4 â‰¤ y â‰¤ 7ï¼Œå› æ­¤å¯ä»¥ç§°ä¸ºï¼ˆ4, 7ï¼‰æ ‘ Bæ ‘ VS äºŒå‰æœç´¢æ ‘Bæ ‘å’ŒäºŒå‰æœç´¢æ ‘ï¼Œåœ¨é€»è¾‘ä¸Šæ˜¯ç­‰ä»·çš„ å¤šä»£èŠ‚ç‚¹åˆå¹¶ï¼Œå¯ä»¥è·å¾—ä¸€ä¸ªè¶…çº§èŠ‚ç‚¹ 2ä»£åˆå¹¶çš„è¶…çº§èŠ‚ç‚¹ï¼Œæœ€å¤šæ‹¥æœ‰ 4 ä¸ªå­èŠ‚ç‚¹ï¼ˆè‡³å°‘æ˜¯ 4é˜¶Bæ ‘ï¼‰ 3ä»£åˆå¹¶çš„è¶…çº§èŠ‚ç‚¹ï¼Œæœ€å¤šæ‹¥æœ‰ 8 ä¸ªå­èŠ‚ç‚¹ï¼ˆè‡³å°‘æ˜¯ 8é˜¶Bæ ‘ï¼‰ nä»£åˆå¹¶çš„è¶…çº§èŠ‚ç‚¹ï¼Œæœ€å¤šæ‹¥æœ‰ 2nä¸ªå­èŠ‚ç‚¹ï¼ˆ è‡³å°‘æ˜¯ 2né˜¶Bæ ‘ï¼‰ mé˜¶Bæ ‘ï¼Œæœ€å¤šéœ€è¦ log2m ä»£åˆå¹¶ Bæ ‘çš„æœç´¢è·ŸäºŒå‰æœç´¢æ ‘çš„æœç´¢ç±»ä¼¼ å…ˆåœ¨èŠ‚ç‚¹å†…éƒ¨ä»å°åˆ°å¤§å¼€å§‹æœç´¢å…ƒç´  å¦‚æœå‘½ä¸­ï¼Œæœç´¢ç»“æŸ å¦‚æœæœªå‘½ä¸­ï¼Œå†å»å¯¹åº”çš„å­èŠ‚ç‚¹ä¸­æœç´¢å…ƒç´ ï¼Œé‡å¤æ­¥éª¤ 1 Bæ ‘çš„æ·»åŠ æ–°æ·»åŠ çš„å…ƒç´ å¿…å®šæ˜¯æ·»åŠ åˆ°å¶å­èŠ‚ç‚¹ æ’å…¥55 æ’å…¥95 å†æ’å…¥ 98 å‘¢ï¼Ÿï¼ˆå‡è®¾è¿™æ˜¯ä¸€æ£µ 4é˜¶Bæ ‘ï¼‰ æœ€å³ä¸‹è§’çš„å¶å­èŠ‚ç‚¹çš„å…ƒç´ ä¸ªæ•°å°†è¶…è¿‡é™åˆ¶ è¿™ç§ç°è±¡å¯ä»¥ç§°ä¹‹ä¸ºï¼šä¸Šæº¢ï¼ˆoverflowï¼‰ æ·»åŠ  â€“ ä¸Šæº¢çš„è§£å†³(å‡è®¾5é˜¶)ä¸Šæº¢èŠ‚ç‚¹çš„å…ƒç´ ä¸ªæ•°å¿…ç„¶ç­‰äºm å‡è®¾ä¸Šæº¢èŠ‚ç‚¹æœ€ä¸­é—´å…ƒç´ çš„ä½ç½®ä¸ºk å°† k ä½ç½®çš„å…ƒç´ å‘ä¸Šä¸çˆ¶èŠ‚ç‚¹åˆå¹¶ å°† [0, k-1] å’Œ [k + 1, m - 1] ä½ç½®çš„å…ƒç´ åˆ†è£‚æˆ 2 ä¸ªå­èŠ‚ç‚¹ è¿™ 2 ä¸ªå­èŠ‚ç‚¹çš„å…ƒç´ ä¸ªæ•°ï¼Œå¿…ç„¶éƒ½ä¸ä¼šä½äºæœ€ä½é™åˆ¶ï¼ˆâ”Œ m/2 â” âˆ’ 1ï¼‰ ä¸€æ¬¡åˆ†è£‚å®Œæ¯•åï¼Œæœ‰å¯èƒ½å¯¼è‡´çˆ¶èŠ‚ç‚¹ä¸Šæº¢ï¼Œä¾ç„¶æŒ‰ç…§ä¸Šè¿°æ–¹æ³•è§£å†³ æœ€æç«¯çš„æƒ…å†µï¼Œæœ‰å¯èƒ½ä¸€ç›´åˆ†è£‚åˆ°æ ¹èŠ‚ç‚¹ Bæ ‘çš„åˆ é™¤åˆ é™¤ â€“ å¶å­èŠ‚ç‚¹å‡å¦‚éœ€è¦åˆ é™¤çš„å…ƒç´ åœ¨å¶å­èŠ‚ç‚¹ä¸­ï¼Œé‚£ä¹ˆç›´æ¥åˆ é™¤å³å¯ åˆ é™¤ â€“ éå¶å­èŠ‚ç‚¹å‡å¦‚éœ€è¦åˆ é™¤çš„å…ƒç´ åœ¨éå¶å­èŠ‚ç‚¹ä¸­ å…ˆæ‰¾åˆ°å‰é©±æˆ–åç»§å…ƒç´ ï¼Œè¦†ç›–æ‰€éœ€åˆ é™¤å…ƒç´ çš„å€¼ å†æŠŠå‰é©±æˆ–åç»§å…ƒç´ åˆ é™¤ éå¶å­èŠ‚ç‚¹çš„å‰é©±æˆ–åç»§å…ƒç´ ï¼Œå¿…å®šåœ¨å¶å­èŠ‚ç‚¹ä¸­ æ‰€ä»¥è¿™é‡Œçš„åˆ é™¤å‰é©±æˆ–åç»§å…ƒç´  ï¼Œå°±æ˜¯æœ€å¼€å§‹æåˆ°çš„æƒ…å†µï¼šåˆ é™¤çš„å…ƒç´ åœ¨å¶å­èŠ‚ç‚¹ä¸­ çœŸæ­£çš„åˆ é™¤å…ƒç´ éƒ½æ˜¯å‘ç”Ÿåœ¨å¶å­èŠ‚ç‚¹ä¸­ åˆ é™¤ â€“ ä¸‹æº¢åˆ é™¤ 22 ï¼Ÿï¼ˆå‡è®¾è¿™æ˜¯ä¸€æ£µ 5é˜¶Bæ ‘ï¼‰ å¶å­èŠ‚ç‚¹è¢«åˆ æ‰ä¸€ä¸ªå…ƒç´ åï¼Œå…ƒç´ ä¸ªæ•°å¯èƒ½ä¼šä½äºæœ€ä½é™åˆ¶ï¼ˆ â‰¥ â”Œ m/2 â” âˆ’ 1 ï¼‰ è¿™ç§ç°è±¡ç§°ä¸ºï¼šä¸‹æº¢ï¼ˆunderflowï¼‰ åˆ é™¤ â€“ ä¸‹æº¢çš„è§£å†³ä¸‹æº¢èŠ‚ç‚¹çš„å…ƒç´ æ•°é‡å¿…ç„¶ç­‰äº â”Œ m/2 â” âˆ’ 2 å¦‚æœä¸‹æº¢èŠ‚ç‚¹ä¸´è¿‘çš„å…„å¼ŸèŠ‚ç‚¹ï¼Œæœ‰è‡³å°‘ â”Œ m/2 â” ä¸ªå…ƒç´ ï¼Œå¯ä»¥å‘å…¶å€Ÿä¸€ä¸ªå…ƒç´  å°†çˆ¶èŠ‚ç‚¹çš„å…ƒç´  b æ’å…¥åˆ°ä¸‹æº¢èŠ‚ç‚¹çš„ 0 ä½ç½®ï¼ˆæœ€å°ä½ç½®ï¼‰ ç”¨å…„å¼ŸèŠ‚ç‚¹çš„å…ƒç´  aï¼ˆæœ€å¤§çš„å…ƒç´ ï¼‰æ›¿ä»£çˆ¶èŠ‚ç‚¹çš„å…ƒç´  b è¿™ç§æ“ä½œå…¶å®å°±æ˜¯ï¼šæ—‹è½¬ å¦‚æœä¸‹æº¢èŠ‚ç‚¹ä¸´è¿‘çš„å…„å¼ŸèŠ‚ç‚¹ï¼Œåªæœ‰ â”Œ m/2 â” âˆ’ 1 ä¸ªå…ƒç´  å°†çˆ¶èŠ‚ç‚¹çš„å…ƒç´  b æŒªä¸‹æ¥è·Ÿå·¦å³å­èŠ‚ç‚¹è¿›è¡Œåˆå¹¶ åˆå¹¶åçš„èŠ‚ç‚¹å…ƒç´ ä¸ªæ•°ç­‰äºâ”Œ m/2 â” + â”Œ m/2 â” âˆ’ 2ï¼Œä¸è¶…è¿‡ m âˆ’ 1 è¿™ä¸ªæ“ä½œå¯èƒ½ä¼šå¯¼è‡´çˆ¶èŠ‚ç‚¹ä¸‹æº¢ï¼Œä¾ç„¶æŒ‰ç…§ä¸Šè¿°æ–¹æ³•è§£å†³ï¼Œä¸‹æº¢ç°è±¡å¯èƒ½ä¼šä¸€ç›´å¾€ä¸Šä¼ æ’­ æ€»ç»“äº†è§£Bæ ‘çš„æ€§è´¨åï¼Œå°±å¯ä»¥æ¥å­¦ä¹ çº¢é»‘æ ‘äº† çº¢é»‘æ ‘çš„å®ç°]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVLæ ‘]]></title>
    <url>%2F2020%2F07%2F12%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVLæ ‘èµ·æºAVLæ ‘æ˜¯æœ€æ—©å‘æ˜çš„è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ä¹‹ä¸€ AVL å–åäºä¸¤ä½å‘æ˜è€…çš„åå­— G. M. Adelson-Velsky å’Œ E. M. Landisï¼ˆæ¥è‡ªè‹è”çš„ç§‘å­¦å®¶ï¼‰ AVLæ ‘ç‰¹ç‚¹å¹³è¡¡å› å­ï¼ˆBalance Factorï¼‰ï¼šæŸç»“ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦å·® æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 1ã€0ã€-1ï¼ˆç»å¯¹å€¼ â‰¤ 1ï¼Œå¦‚æœè¶…è¿‡ 1ï¼Œç§°ä¹‹ä¸ºâ€œå¤±è¡¡â€ï¼‰ æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡ 1 æœç´¢ã€æ·»åŠ ã€åˆ é™¤çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn) å¹³è¡¡å¯¹æ¯”è¾“å…¥æ•°æ®ï¼š35, 37, 34, 56, 25, 62, 57, 9, 74, 32, 94, 80, 75, 100, 16, 82 ç®€å•çš„ç»§æ‰¿ç»“æ„äºŒå‰æ ‘çš„å®ç° äºŒå‰æœç´¢æ ‘çš„å®ç° å¹³è¡¡ä¿®å¤æ·»åŠ å¯¼è‡´çš„å¤±è¡¡ç¤ºä¾‹ï¼šå¾€ä¸‹é¢è¿™æ£µå­æ ‘ä¸­æ·»åŠ  13 æœ€åæƒ…å†µï¼šå¯èƒ½ä¼šå¯¼è‡´æ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹éƒ½å¤±è¡¡ çˆ¶èŠ‚ç‚¹ã€éç¥–å…ˆèŠ‚ç‚¹ï¼Œéƒ½ä¸å¯èƒ½å¤±è¡¡ LL â€“ å³æ—‹è½¬ï¼ˆRå•æ—‹ï¼‰â€”â€”- LLï¼ˆnåœ¨gçš„LLï¼‰ g.left = p.right p.right = g è®©pæˆä¸ºè¿™æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹ ä»ç„¶æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼šT0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3ï¼Œæ•´æ£µæ ‘éƒ½è¾¾åˆ°å¹³è¡¡ è¿˜éœ€è¦æ³¨æ„ç»´æŠ¤çš„å†…å®¹ï¼ŒT2ã€pã€g çš„ parent å±æ€§ï¼Œå…ˆåæ›´æ–° gã€p çš„é«˜åº¦ 123456789protected void rotateRight(Node&lt;E&gt; grand) &#123; // äº¤æ¢å­æ ‘ Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; // ç»´æŠ¤parentå’Œheight afterRotate(grand, parent, child);&#125; RR â€“ å·¦æ—‹è½¬ï¼ˆLå•æ—‹ï¼‰â€”â€”- RRï¼ˆnåœ¨gçš„RRï¼‰ g.right = p.left p.left = g è®©pæˆä¸ºè¿™æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹ ä»ç„¶æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼šT0 &lt; g &lt; T1 &lt; p &lt; T2 &lt; n &lt; T3ï¼Œæ•´æ£µæ ‘éƒ½è¾¾åˆ°å¹³è¡¡ è¿˜éœ€è¦æ³¨æ„ç»´æŠ¤çš„å†…å®¹ï¼ŒT1ã€pã€g çš„ parent å±æ€§ï¼Œå…ˆåæ›´æ–° gã€p çš„é«˜åº¦ 123456789protected void rotateLeft(Node&lt;E&gt; grand) &#123; // äº¤æ¢å­æ ‘ Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; // ç»´æŠ¤parentå’Œheight afterRotate(grand, parent, child);&#125; LR â€“ RRå·¦æ—‹è½¬ï¼ŒLLå³æ—‹è½¬ï¼ˆåŒæ—‹ï¼‰â€”â€”- LRï¼ˆnåœ¨gçš„LRï¼‰ RL â€“ LLå³æ—‹è½¬ï¼ŒRRå·¦æ—‹è½¬ï¼ˆåŒæ—‹ï¼‰â€”â€”- RLï¼ˆnåœ¨gçš„RLï¼‰ æ—‹è½¬ä¹‹åçš„ä¿®å¤12345678910111213141516171819202122232425/** * å…¬å…±ä»£ç ï¼šä¸ç®¡æ˜¯å·¦æ—‹è½¬ã€å³æ—‹è½¬ï¼Œéƒ½è¦æ‰§è¡Œ * @param grand å¤±è¡¡èŠ‚ç‚¹ * @param parent å¤±è¡¡èŠ‚ç‚¹çš„tallerChild * @param child gå’Œp éœ€è¦äº¤æ¢çš„å­æ ‘ï¼ˆæœ¬æ¥æ˜¯pçš„å­æ ‘ï¼Œåé¢ä¼šå˜æˆgçš„å­æ ‘ */protected void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; // è®©parentç§°ä¸ºå­æ ‘çš„æ ¹èŠ‚ç‚¹ parent.parent = grand.parent; if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else &#123; // grandæ˜¯rootèŠ‚ç‚¹ root = parent; &#125; // æ›´æ–°childçš„parent if (child != null) &#123; child.parent = grand; &#125; // æ›´æ–°grandçš„parent grand.parent = parent;&#125; èŠ‚ç‚¹çš„å®šä¹‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// äºŒå‰æ ‘çš„èŠ‚ç‚¹protected static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; left; Node&lt;E&gt; right; Node&lt;E&gt; parent; public Node(E element, Node&lt;E&gt; parent) &#123; this.element = element; this.parent = parent; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; // æ˜¯å¦æœ‰å…„å¼ŸèŠ‚ç‚¹ public Node&lt;E&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125;&#125;// AVLæ ‘èŠ‚ç‚¹private static class AVLNode&lt;E&gt; extends Node&lt;E&gt; &#123; int height = 1; public AVLNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; // æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 1ã€0ã€-1 public int balanceFactor() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; return leftHeight - rightHeight; &#125; // æ›´æ–°æ ‘é«˜ public void updateHeight() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; height = 1 + Math.max(leftHeight, rightHeight); &#125; // è¿”å›æ ‘é«˜çš„å­èŠ‚ç‚¹ public Node&lt;E&gt; tallerChild() &#123; int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;)right).height; if (leftHeight &gt; rightHeight) return left; if (leftHeight &lt; rightHeight) return right; return isLeftChild() ? left : right; &#125;&#125; æ·»åŠ ä¹‹åçš„ä¿®å¤12345678910111213protected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // æ›´æ–°é«˜åº¦ updateHeight(node); &#125; else &#123; // æ¢å¤å¹³è¡¡ rebalance(node); // æ•´æ£µæ ‘æ¢å¤å¹³è¡¡ break; &#125; &#125;&#125; åˆ¤æ–­æ˜¯å¦å¹³è¡¡123private boolean isBalanced(Node&lt;E&gt; node) &#123; return Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= 1;&#125; æŸ¥çœ‹æ ‘çš„é«˜åº¦123private void updateHeight(Node&lt;E&gt; node) &#123; ((AVLNode&lt;E&gt;)node).updateHeight();&#125; æ¢å¤å¹³è¡¡1234567891011121314151617181920// grand é«˜åº¦æœ€ä½çš„ä¸å¹³è¡¡èŠ‚ç‚¹private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotateRight(grand); &#125; else &#123; // LR rotateLeft(parent); rotateRight(grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotateRight(parent); rotateLeft(grand); &#125; else &#123; // RR rotateLeft(grand); &#125; &#125;&#125; ç¤ºä¾‹è¾“å…¥æ•°æ®ï¼š13, 14, 15, 12, 11, 17, 16, 8, 9,1 ç»Ÿä¸€æ‰€æœ‰æ—‹è½¬æ“ä½œçš„å®ç° 123456789101112131415161718192021222324252627282930313233protected void rotate( Node&lt;E&gt; r, // å­æ ‘çš„æ ¹èŠ‚ç‚¹ Node&lt;E&gt; b, Node&lt;E&gt; c, Node&lt;E&gt; d, Node&lt;E&gt; e, Node&lt;E&gt; f) &#123; // è®©dæˆä¸ºè¿™æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹ d.parent = r.parent; if (r.isLeftChild()) &#123; r.parent.left = d; &#125; else if (r.isRightChild()) &#123; r.parent.right = d; &#125; else &#123; root = d; &#125; //b-c b.right = c; if (c != null) &#123; c.parent = b; &#125; // e-f f.left = e; if (e != null) &#123; e.parent = f; &#125; // b-d-f d.left = b; d.right = f; b.parent = d; f.parent = d;&#125; 123456789101112131415161718192021/** * æ¢å¤å¹³è¡¡ * @param grand é«˜åº¦æœ€ä½çš„é‚£ä¸ªä¸å¹³è¡¡èŠ‚ç‚¹ */private void rebalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; // L if (node.isLeftChild()) &#123; // LL rotate(grand, node, node.right, parent, parent.right, grand); &#125; else &#123; // LR rotate(grand, parent, node.left, node, node.right, grand); &#125; &#125; else &#123; // R if (node.isLeftChild()) &#123; // RL rotate(grand, grand, node.left, node, node.right, parent); &#125; else &#123; // RR rotate(grand, grand, parent.left, parent, node.left, node); &#125; &#125;&#125; åˆ é™¤å¯¼è‡´çš„å¤±è¡¡ç¤ºä¾‹ï¼šåˆ é™¤å­æ ‘ä¸­çš„ 16 å¯èƒ½ä¼šå¯¼è‡´çˆ¶èŠ‚ç‚¹æˆ–ç¥–å…ˆèŠ‚ç‚¹å¤±è¡¡ï¼ˆåªæœ‰1ä¸ªèŠ‚ç‚¹ä¼šå¤±è¡¡ï¼‰ï¼Œå…¶ä»–èŠ‚ç‚¹ï¼Œéƒ½ä¸å¯èƒ½å¤±è¡¡ LL â€“ å³æ—‹è½¬ï¼ˆå•æ—‹ï¼‰å¦‚æœç»¿è‰²èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œæ›´é«˜å±‚çš„ç¥–å…ˆèŠ‚ç‚¹å¯èƒ½ä¹Ÿä¼šå¤±è¡¡ï¼Œéœ€è¦å†æ¬¡æ¢å¤å¹³è¡¡ï¼Œç„¶ååˆå¯èƒ½å¯¼è‡´æ›´é«˜å±‚çš„ç¥–å…ˆèŠ‚ç‚¹å¤±è¡¡â€¦ æç«¯æƒ…å†µä¸‹ï¼Œæ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹éƒ½éœ€è¦è¿›è¡Œæ¢å¤å¹³è¡¡çš„æ“ä½œï¼Œå…± O(logn) æ¬¡è°ƒæ•´ RR â€“ å·¦æ—‹è½¬ï¼ˆå•æ—‹ï¼‰ LR â€“ RRå·¦æ—‹è½¬ï¼ŒLLå³æ—‹è½¬ï¼ˆåŒæ—‹ï¼‰ RL â€“ LLå³æ—‹è½¬ï¼ŒRRå·¦æ—‹è½¬ï¼ˆåŒæ—‹ï¼‰ åˆ é™¤ä¹‹åçš„ä¿®å¤1234567891011protected void afterRemove(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalanced(node)) &#123; // æ›´æ–°é«˜åº¦ updateHeight(node); &#125; else &#123; // æ¢å¤å¹³è¡¡ rebalance(node); &#125; &#125;&#125; æ€»ç»“ æ·»åŠ  å¯èƒ½ä¼šå¯¼è‡´æ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹éƒ½å¤±è¡¡ åªè¦è®©é«˜åº¦æœ€ä½çš„å¤±è¡¡èŠ‚ç‚¹æ¢å¤å¹³è¡¡ï¼Œæ•´æ£µæ ‘å°±æ¢å¤å¹³è¡¡ã€ä»…éœ€ O(1) æ¬¡è°ƒæ•´ã€‘ åˆ é™¤ å¯èƒ½ä¼šå¯¼è‡´çˆ¶èŠ‚ç‚¹æˆ–ç¥–å…ˆèŠ‚ç‚¹å¤±è¡¡ï¼ˆåªæœ‰1ä¸ªèŠ‚ç‚¹ä¼šå¤±è¡¡ï¼‰ æ¢å¤å¹³è¡¡åï¼Œå¯èƒ½ä¼šå¯¼è‡´æ›´é«˜å±‚çš„ç¥–å…ˆèŠ‚ç‚¹å¤±è¡¡ã€æœ€å¤šéœ€è¦ O(logn) æ¬¡è°ƒæ•´ã€‘ å¹³å‡æ—¶é—´å¤æ‚åº¦ æœç´¢ï¼šO(logn) æ·»åŠ ï¼šO(logn)ï¼Œä»…éœ€ O(1) æ¬¡çš„æ—‹è½¬æ“ä½œ åˆ é™¤ï¼šO(logn)ï¼Œæœ€å¤šéœ€è¦ O(logn) æ¬¡çš„æ—‹è½¬æ“ä½œ]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[äºŒå‰æœç´¢æ ‘]]></title>
    <url>%2F2020%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[äºŒå‰æœç´¢æ ‘æ€è€ƒ åœ¨ n ä¸ªåŠ¨æ€çš„æ•´æ•°ä¸­æœç´¢æŸä¸ªæ•´æ•°ï¼Ÿï¼ˆæŸ¥çœ‹å…¶æ˜¯å¦å­˜åœ¨ï¼‰ å‡è®¾ä½¿ç”¨åŠ¨æ€æ•°ç»„å­˜æ”¾å…ƒç´ ï¼Œä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹éå†æœç´¢ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n) 0 1 2 3 4 5 6 7 8 9 31 66 17 15 28 20 59 88 45 56 å¦‚æœç»´æŠ¤ä¸€ä¸ªæœ‰åºçš„åŠ¨æ€æ•°ç»„ï¼Œä½¿ç”¨äºŒåˆ†æœç´¢ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ï¼šO(logn) ä½†æ˜¯æ·»åŠ ã€åˆ é™¤çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ O(n) 0 1 2 3 4 5 6 7 8 9 15 17 20 28 31 45 56 59 66 88 é’ˆå¯¹è¿™ä¸ªéœ€æ±‚ï¼Œæœ‰æ²¡æœ‰æ›´å¥½çš„æ–¹æ¡ˆï¼Ÿ ä½¿ç”¨äºŒå‰æœç´¢æ ‘ï¼Œæ·»åŠ ã€åˆ é™¤ã€æœç´¢çš„æœ€åæ—¶é—´å¤æ‚åº¦å‡å¯ä¼˜åŒ–è‡³ï¼šO(logn)â€‹ ä»€ä¹ˆæ˜¯äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰ äºŒå‰æœç´¢æ ‘æ˜¯äºŒå‰æ ‘çš„ä¸€ç§ï¼Œæ˜¯åº”ç”¨éå¸¸å¹¿æ³›çš„ä¸€ç§äºŒå‰æ ‘ï¼Œè‹±æ–‡ç®€ç§°ä¸º BSTï¼Œåˆè¢«ç§°ä¸ºï¼šäºŒå‰æŸ¥æ‰¾æ ‘ã€äºŒå‰æ’åºæ ‘ ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºå…¶å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å°äºå…¶å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ å®ƒçš„å·¦å³å­æ ‘ä¹Ÿæ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ äºŒå‰æœç´¢æ ‘å¯ä»¥å¤§å¤§æé«˜æœç´¢æ•°æ®çš„æ•ˆç‡ äºŒå‰æœç´¢æ ‘å­˜å‚¨çš„å…ƒç´ å¿…é¡»å…·å¤‡å¯æ¯”è¾ƒæ€§ æ¯”å¦‚ intã€double ç­‰ å¦‚æœæ˜¯è‡ªå®šä¹‰ç±»å‹ï¼Œéœ€è¦æŒ‡å®šæ¯”è¾ƒæ–¹å¼ ä¸å…è®¸ä¸º null äºŒå‰æœç´¢æ ‘çš„æ¥å£è®¾è®¡123456int size() // å…ƒç´ çš„æ•°é‡boolean isEmpty() // æ˜¯å¦ä¸ºç©ºvoid clear() // æ¸…ç©ºæ‰€æœ‰å…ƒç´ void add(E element) // æ·»åŠ å…ƒç´ void remove(E element) // åˆ é™¤å…ƒç´ boolean contains(E element) // æ˜¯å¦åŒ…å«æŸå…ƒç´  éœ€è¦æ³¨æ„çš„æ˜¯ å¯¹äºæˆ‘ä»¬ç°åœ¨ä½¿ç”¨çš„äºŒå‰æ ‘æ¥è¯´ï¼Œå®ƒçš„å…ƒç´ æ²¡æœ‰ç´¢å¼•çš„æ¦‚å¿µ å…ƒç´ çš„æ¯”è¾ƒæ–¹æ¡ˆè®¾è®¡ å…è®¸å¤–ç•Œä¼ å…¥ä¸€ä¸ª Comparator è‡ªå®šä¹‰æ¯”è¾ƒæ–¹æ¡ˆ å¦‚æœæ²¡æœ‰ä¼ å…¥ Comparatorï¼Œå¼ºåˆ¶è®¤å®šå…ƒç´ å®ç°äº† Comparable æ¥å£ 12345678910111213141516private Comparator&lt;E&gt; comparator;public BST() &#123; this(null);&#125;public BST(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator;&#125;private int compare(E e1, E e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable&lt;E&gt;)e1).compareTo(e2);&#125; æ ¹æ®å…ƒç´ å†…å®¹è·å–èŠ‚ç‚¹12345678910111213private Node&lt;E&gt; node(E element) &#123; Node&lt;E&gt; node = root; while (node != null) &#123; int cmp = compare(element, node.element); if (cmp == 0) return node; if (cmp &gt; 0) &#123; node = node.right; &#125; else &#123; // cmp &lt; 0 node = node.left; &#125; &#125; return null;&#125; æ·»åŠ èŠ‚ç‚¹12345678910111213141516171819202122232425262728293031323334353637383940414243public void add(E element) &#123; elementNotNullCheck(element); // æ·»åŠ ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ if (root == null) &#123; root = createNode(element, null); size++; // æ–°æ·»åŠ èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterAdd(root); return; &#125; // æ·»åŠ çš„ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ Node&lt;E&gt; parent = root; Node&lt;E&gt; node = root; int cmp = 0; do &#123; cmp = compare(element, node.element); parent = node; if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp &lt; 0) &#123; node = node.left; &#125; else &#123; // ç›¸ç­‰ node.element = element; return; &#125; &#125; while (node != null); // çœ‹çœ‹æ’å…¥åˆ°çˆ¶èŠ‚ç‚¹çš„å“ªä¸ªä½ç½® Node&lt;E&gt; newNode = createNode(element, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; // æ–°æ·»åŠ èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterAdd(newNode);&#125; åˆ é™¤èŠ‚ç‚¹åˆ é™¤èŠ‚ç‚¹ â€“ å¶å­èŠ‚ç‚¹ï¼ˆåˆ†æï¼‰ 123456789// ç›´æ¥åˆ é™¤1. node == node.parent.left node.parent.left = null2. node == node.parent.right node.parent.right = null3. node.parent == null root = null åˆ é™¤èŠ‚ç‚¹ - åº¦ä¸º1çš„èŠ‚ç‚¹ï¼ˆåˆ†æï¼‰ 123456789101112131415// ç”¨å­èŠ‚ç‚¹æ›¿ä»£åŸèŠ‚ç‚¹çš„ä½ç½®child æ˜¯ node.left æˆ– è€… child æ˜¯ node.rightç”¨ child æ›¿ä»£ node çš„ä½ç½®1. å¦‚æœ node æ˜¯å·¦å­èŠ‚ç‚¹ child.parent = node.parent node.parent.left = child2. å¦‚æœ node æ˜¯å³å­èŠ‚ç‚¹ child.parent = node.parent node.parent.right = child3. å¦‚æœ node æ˜¯æ ¹èŠ‚ç‚¹ root = child child.parent = null åˆ é™¤èŠ‚ç‚¹ - åº¦ä¸º2çš„èŠ‚ç‚¹ï¼ˆåˆ†æï¼‰ ä¸¾ä¾‹ï¼šå…ˆåˆ é™¤ 5ã€å†åˆ é™¤ 4 å…ˆç”¨å‰é©±æˆ–è€…åç»§èŠ‚ç‚¹çš„å€¼è¦†ç›–åŸèŠ‚ç‚¹çš„å€¼ ç„¶ååˆ é™¤ç›¸åº”çš„å‰é©±æˆ–è€…åç»§èŠ‚ç‚¹ å¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åº¦ä¸º 2ï¼Œé‚£ä¹ˆï¼Œå®ƒçš„å‰é©±ã€åç»§èŠ‚ç‚¹çš„åº¦åªå¯èƒ½æ˜¯ 1 å’Œ 0 äºŒå‰æ ‘çš„å‰é©±ã€åç»§å®ç° åˆ é™¤èŠ‚ç‚¹ï¼ˆä»£ç å®ç°ï¼‰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦æœ‰ä¸¤ä¸ªå¶å­èŠ‚ç‚¹public boolean hasTwoChildren() &#123; return left != null &amp;&amp; right != null;&#125;private void remove(Node&lt;E&gt; node) &#123; if (node == null) return; size--; // æ‰¾åˆ°åº¦ä¸ºäºŒèŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹è¦†ç›–åï¼Œå°†åç»§èŠ‚ç‚¹sä½œä¸ºåº¦ä¸º1çš„èŠ‚ç‚¹æ‰§è¡Œåé¢çš„æ“ä½œ if (node.hasTwoChildren()) &#123; // åº¦ä¸º2çš„èŠ‚ç‚¹ // æ‰¾åˆ°åç»§èŠ‚ç‚¹ Node&lt;E&gt; s = successor(node); // ç”¨åç»§èŠ‚ç‚¹çš„å€¼è¦†ç›–åº¦ä¸º2çš„èŠ‚ç‚¹çš„å€¼ node.element = s.element; // åˆ é™¤åç»§èŠ‚ç‚¹,ä½¿ç”¨åé¢çš„ä»£ç åˆ é™¤åº¦ä¸º1çš„èŠ‚ç‚¹ node = s; &#125; // åˆ é™¤nodeèŠ‚ç‚¹ï¼ˆnodeçš„åº¦å¿…ç„¶æ˜¯1æˆ–è€…0ï¼‰ // åˆ¤æ–­nodeèŠ‚ç‚¹æœ‰å·¦èŠ‚ç‚¹è¿˜æ˜¯å³èŠ‚ç‚¹ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰èŠ‚ç‚¹ Node&lt;E&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; // nodeæ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹ // æ›´æ”¹parent replacement.parent = node.parent; // æ›´æ”¹parentçš„leftã€rightçš„æŒ‡å‘ if (node.parent == null) &#123; // nodeæ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹å¹¶ä¸”æ˜¯æ ¹èŠ‚ç‚¹ root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; // node == node.parent.right node.parent.right = replacement; &#125; // åˆ é™¤èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterRemove(replacement); &#125; else if (node.parent == null) &#123; // nodeæ˜¯å¶å­èŠ‚ç‚¹å¹¶ä¸”æ˜¯æ ¹èŠ‚ç‚¹ root = null; // åˆ é™¤èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterRemove(node); &#125; else &#123; // nodeæ˜¯å¶å­èŠ‚ç‚¹ï¼Œä½†ä¸æ˜¯æ ¹èŠ‚ç‚¹ if (node == node.parent.left) &#123; node.parent.left = null; &#125; else &#123; // node == node.parent.right node.parent.right = null; &#125; // åˆ é™¤èŠ‚ç‚¹ä¹‹åçš„å¤„ç† afterRemove(node); &#125;&#125; äºŒå‰æœç´¢æ ‘çš„å¤æ‚åº¦åˆ†æå½“ n æ¯”è¾ƒå¤§æ—¶ï¼Œä¸¤è€…çš„æ€§èƒ½å·®å¼‚æ¯”è¾ƒå¤§ æ¯”å¦‚ n = 1000000 æ—¶ï¼ŒäºŒå‰æœç´¢æ ‘çš„æœ€ä½é«˜åº¦æ˜¯ 20 é€€åŒ–æˆé“¾è¡¨çš„å¦ä¸€ç§æƒ…å†µ æœ‰æ²¡æœ‰åŠæ³•é˜²æ­¢äºŒå‰æœç´¢æ ‘é€€åŒ–æˆé“¾è¡¨ï¼Ÿ è®©æ·»åŠ ã€åˆ é™¤ã€æœç´¢çš„å¤æ‚åº¦ç»´æŒåœ¨ O(logn) å¹³è¡¡ï¼ˆBalanceï¼‰å¹³è¡¡ï¼šå½“èŠ‚ç‚¹æ•°é‡å›ºå®šæ—¶ï¼Œå·¦å³å­æ ‘çš„é«˜åº¦è¶Šæ¥è¿‘ï¼Œè¿™æ£µäºŒå‰æ ‘å°±è¶Šå¹³è¡¡ï¼ˆé«˜åº¦è¶Šä½ï¼‰ ç†æƒ³å¹³è¡¡æœ€ç†æƒ³çš„å¹³è¡¡ï¼Œå°±æ˜¯åƒå®Œå…¨äºŒå‰æ ‘ã€æ»¡äºŒå‰æ ‘é‚£æ ·ï¼Œé«˜åº¦æ˜¯æœ€å°çš„ å¦‚ä½•æ”¹è¿›äºŒå‰æœç´¢æ ‘ï¼Ÿé¦–å…ˆï¼ŒèŠ‚ç‚¹çš„æ·»åŠ ã€åˆ é™¤é¡ºåºæ˜¯æ— æ³•é™åˆ¶çš„ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯éšæœºçš„ æ‰€ä»¥ï¼Œæ”¹è¿›æ–¹æ¡ˆæ˜¯ï¼šåœ¨èŠ‚ç‚¹çš„æ·»åŠ ã€åˆ é™¤æ“ä½œä¹‹åï¼Œæƒ³åŠæ³•è®©äºŒå‰æœç´¢æ ‘æ¢å¤å¹³è¡¡ï¼ˆå‡å°æ ‘çš„é«˜åº¦ï¼‰ å¦‚æœæ¥ç€ç»§ç»­è°ƒæ•´èŠ‚ç‚¹çš„ä½ç½®ï¼Œå®Œå…¨å¯ä»¥è¾¾åˆ°ç†æƒ³å¹³è¡¡ï¼Œä½†æ˜¯ä»˜å‡ºçš„ä»£ä»·å¯èƒ½ä¼šæ¯”è¾ƒå¤§ æ¯”å¦‚è°ƒæ•´çš„æ¬¡æ•°ä¼šæ¯”è¾ƒå¤šï¼Œåè€Œå¢åŠ äº†æ—¶é—´å¤æ‚åº¦ æ€»ç»“æ¥è¯´ï¼Œæ¯”è¾ƒåˆç†çš„æ”¹è¿›æ–¹æ¡ˆæ˜¯ï¼šç”¨å°½é‡å°‘çš„è°ƒæ•´æ¬¡æ•°è¾¾åˆ°é€‚åº¦å¹³è¡¡å³å¯ ä¸€æ£µè¾¾åˆ°é€‚åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼Œå¯ä»¥ç§°ä¹‹ä¸ºï¼šå¹³è¡¡äºŒå‰æœç´¢æ ‘ å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆBalanced Binary Search Treeï¼‰è‹±æ–‡ç®€ç§°ä¸ºï¼šBBST ç»å…¸å¸¸è§çš„å¹³è¡¡äºŒå‰æœç´¢æ ‘æœ‰ AVLæ ‘ Windows NT å†…æ ¸ä¸­å¹¿æ³›ä½¿ç”¨ çº¢é»‘æ ‘ C++ STLï¼ˆæ¯”å¦‚ mapã€set ï¼‰ Java çš„ TreeMapã€TreeSetã€HashMapã€HashSet Linux çš„è¿›ç¨‹è°ƒåº¦ Ngix çš„ timer ç®¡ç† ä¸€èˆ¬ä¹Ÿç§°å®ƒä»¬ä¸ºï¼šè‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼ˆSelf-balancing Binary Search Treeï¼‰ AVLæ ‘çš„å®ç° çº¢é»‘æ ‘çš„å®ç°]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[äºŒå‰æ ‘]]></title>
    <url>%2F2020%2F07%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[äºŒå‰æ ‘æ ‘ï¼ˆTreeï¼‰çš„åŸºæœ¬æ¦‚å¿µ èŠ‚ç‚¹ã€æ ¹èŠ‚ç‚¹ã€çˆ¶èŠ‚ç‚¹ã€å­èŠ‚ç‚¹ã€å…„å¼ŸèŠ‚ç‚¹ ä¸€æ£µæ ‘å¯ä»¥æ²¡æœ‰ä»»ä½•èŠ‚ç‚¹ï¼Œç§°ä¸ºç©ºæ ‘ ä¸€æ£µæ ‘å¯ä»¥åªæœ‰ 1 ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯åªæœ‰æ ¹èŠ‚ç‚¹ å­æ ‘ã€å·¦å­æ ‘ã€å³å­æ ‘ èŠ‚ç‚¹çš„åº¦ï¼ˆdegreeï¼‰ï¼šå­æ ‘çš„ä¸ªæ•° æ ‘çš„åº¦ï¼šæ‰€æœ‰èŠ‚ç‚¹åº¦ä¸­çš„æœ€å¤§å€¼ å¶å­èŠ‚ç‚¹ï¼ˆleafï¼‰ï¼šåº¦ä¸º 0 çš„èŠ‚ç‚¹ éå¶å­èŠ‚ç‚¹ï¼šåº¦ä¸ä¸º 0 çš„èŠ‚ç‚¹ å±‚æ•°ï¼ˆlevelï¼‰ï¼šæ ¹èŠ‚ç‚¹åœ¨ç¬¬ 1 å±‚ï¼Œæ ¹èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åœ¨ç¬¬ 2 å±‚ï¼Œä»¥æ­¤ç±»æ¨ï¼ˆæœ‰äº›æ•™ç¨‹ä¹Ÿä»ç¬¬ 0 å±‚å¼€å§‹è®¡ç®—ï¼‰ èŠ‚ç‚¹çš„æ·±åº¦ï¼ˆdepthï¼‰ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å”¯ä¸€è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•° èŠ‚ç‚¹çš„é«˜åº¦ï¼ˆheightï¼‰ï¼šä»å½“å‰èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•° æ ‘çš„æ·±åº¦ï¼šæ‰€æœ‰èŠ‚ç‚¹æ·±åº¦ä¸­çš„æœ€å¤§å€¼ æ ‘çš„é«˜åº¦ï¼šæ‰€æœ‰èŠ‚ç‚¹é«˜åº¦ä¸­çš„æœ€å¤§å€¼ æ ‘çš„æ·±åº¦ ç­‰äº æ ‘çš„é«˜åº¦ æœ‰åºæ ‘ã€æ— åºæ ‘ã€æ£®æ— æœ‰åºæ ‘ æ ‘ä¸­ä»»æ„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä¹‹é—´æœ‰é¡ºåºå…³ç³» æ— åºæ ‘ï¼Œä¹Ÿç§°ä¸ºâ€œè‡ªç”±æ ‘â€ æ ‘ä¸­ä»»æ„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä¹‹é—´æ²¡æœ‰é¡ºåºå…³ç³» æ£®æ— ç”± mï¼ˆm â‰¥ 0ï¼‰æ£µäº’ä¸ç›¸äº¤çš„æ ‘ç»„æˆçš„é›†åˆ äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰äºŒå‰æ ‘çš„ç‰¹ç‚¹ æ¯ä¸ªèŠ‚ç‚¹çš„åº¦æœ€å¤§ä¸º 2ï¼ˆæœ€å¤šæ‹¥æœ‰ 2 æ£µå­æ ‘ï¼‰ å·¦å­æ ‘å’Œå³å­æ ‘æ˜¯æœ‰é¡ºåºçš„ å³ä½¿æŸèŠ‚ç‚¹åªæœ‰ä¸€æ£µå­æ ‘ï¼Œä¹Ÿè¦åŒºåˆ†å·¦å³å­æ ‘ äºŒå‰æ ‘çš„æ€§è´¨ éç©ºäºŒå‰æ ‘çš„ç¬¬ $i$ å±‚ï¼Œæœ€å¤šæœ‰ $2^{i âˆ’ 1}$ä¸ªèŠ‚ç‚¹ ï¼ˆ $i \geq 1$ï¼‰ åœ¨é«˜åº¦ä¸º h çš„äºŒå‰æ ‘ä¸Šæœ€å¤šæœ‰ $2^h âˆ’ 1 $ä¸ªç»“ç‚¹ï¼ˆ$h \geq 1$ ï¼‰ å¯¹äºä»»ä½•ä¸€æ£µéç©ºäºŒå‰æ ‘ï¼Œå¦‚æœå¶å­èŠ‚ç‚¹ä¸ªæ•°ä¸º $n0$ï¼Œåº¦ä¸º $2$ çš„èŠ‚ç‚¹ä¸ªæ•°ä¸º $ n2$ï¼Œåˆ™æœ‰: $n0 = n2 + 1$ å‡è®¾åº¦ä¸º$ 1 $çš„èŠ‚ç‚¹ä¸ªæ•°ä¸º $n1$ï¼Œé‚£ä¹ˆäºŒå‰æ ‘çš„èŠ‚ç‚¹æ€»æ•° $ n = n0 + n1 + n2$ äºŒå‰æ ‘çš„è¾¹æ•° $ T = n1 + 2 * n2 = n â€“ 1 = n0 + n1 + n2 â€“ 1$ å› æ­¤ $ n0 = n2 + 1$ çœŸäºŒå‰æ ‘ï¼ˆProper Binary Treeï¼‰çœŸäºŒå‰æ ‘ï¼šæ‰€æœ‰èŠ‚ç‚¹çš„åº¦éƒ½è¦ä¹ˆä¸º 0ï¼Œè¦ä¹ˆä¸º 2 æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰æœ€åä¸€å±‚èŠ‚ç‚¹çš„åº¦éƒ½ä¸º $0$ï¼Œå…¶ä»–èŠ‚ç‚¹çš„åº¦éƒ½ä¸º $2$ åœ¨åŒæ ·é«˜åº¦çš„äºŒå‰æ ‘ä¸­ï¼Œæ»¡äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹æ•°é‡æœ€å¤šã€æ€»èŠ‚ç‚¹æ•°é‡æœ€å¤š æ»¡äºŒå‰æ ‘ä¸€å®šæ˜¯çœŸäºŒå‰æ ‘ï¼ŒçœŸäºŒå‰æ ‘ä¸ä¸€å®šæ˜¯æ»¡äºŒå‰æ ‘ å‡è®¾æ»¡äºŒå‰æ ‘çš„é«˜åº¦ä¸º $hï¼ˆ h â‰¥ 1 ï¼‰$ï¼Œé‚£ä¹ˆ ç¬¬ i å±‚çš„èŠ‚ç‚¹æ•°é‡ï¼š$ 2i âˆ’ 1$ ï¼Œ å¶å­èŠ‚ç‚¹æ•°é‡ï¼š $2h âˆ’ 1$ ï¼Œ æ€»èŠ‚ç‚¹æ•°é‡$ n$ $n = 2h âˆ’ 1 = 20 + 21 + 22 + â‹¯ + 2hâˆ’1$ $h = log2(n + 1)$ å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰å¯¹èŠ‚ç‚¹ä»ä¸Šè‡³ä¸‹ã€å·¦è‡³å³å¼€å§‹ç¼–å·ï¼Œå…¶æ‰€æœ‰ç¼–å·éƒ½èƒ½ä¸ç›¸åŒé«˜åº¦çš„æ»¡äºŒå‰æ ‘ä¸­çš„ç¼–å·å¯¹åº” å¶å­èŠ‚ç‚¹åªä¼šå‡ºç°æœ€å 2 å±‚ï¼Œæœ€å 1 å±‚çš„å¶å­ç»“ç‚¹éƒ½é å·¦å¯¹é½ å®Œå…¨äºŒå‰æ ‘ä»æ ¹ç»“ç‚¹è‡³å€’æ•°ç¬¬ 2 å±‚æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘ æ»¡äºŒå‰æ ‘ä¸€å®šæ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œå®Œå…¨äºŒå‰æ ‘ä¸ä¸€å®šæ˜¯æ»¡äºŒå‰æ ‘ å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ åº¦ä¸º 1 çš„èŠ‚ç‚¹åªæœ‰å·¦å­æ ‘ åº¦ä¸º 1 çš„èŠ‚ç‚¹è¦ä¹ˆæ˜¯ 1 ä¸ªï¼Œè¦ä¹ˆæ˜¯ 0 ä¸ª åŒæ ·èŠ‚ç‚¹æ•°é‡çš„äºŒå‰æ ‘ï¼Œå®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦æœ€å° å‡è®¾å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦ä¸º $hï¼ˆ h â‰¥ 1 ï¼‰$ï¼Œé‚£ä¹ˆ â€‹ è‡³å°‘æœ‰ $2h âˆ’ 1$ ä¸ªèŠ‚ç‚¹ $ï¼ˆ 2^0 + 2^1 + 2^2 + â‹¯ + 2^{hâˆ’2} + 1 ï¼‰$ â€‹ æœ€å¤šæœ‰ $2h âˆ’ 1$ ä¸ªèŠ‚ç‚¹ï¼ˆ$ 2^0 + 2^1 + 2^2 + â‹¯ + 2^{hâˆ’1}$ï¼Œæ»¡äºŒå‰æ ‘ ï¼‰ â€‹ æ€»èŠ‚ç‚¹æ•°é‡ä¸º $n$ â€‹ $2^{h âˆ’ 1} â‰¤ n &lt; 2^h $ â€‹ $h âˆ’ 1 â‰¤ log_2n &lt; h$ â€‹ $h = floor( log_2n ) + 1$ â€‹ $floor $æ˜¯å‘ä¸‹å–æ•´ï¼Œå¦å¤–ï¼Œ$ceiling $æ˜¯å‘ä¸Šå–æ•´ ä¸€æ£µæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘$ï¼ˆn &gt; 0ï¼‰$ï¼Œä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³å¯¹èŠ‚ç‚¹ä» $ 1$ å¼€å§‹è¿›è¡Œç¼–å·ï¼Œå¯¹ä»»æ„ç¬¬ $ i $ ä¸ªèŠ‚ç‚¹ â€‹ å¦‚æœ $i = 1$ï¼Œå®ƒæ˜¯æ ¹èŠ‚ç‚¹ â€‹ å¦‚æœ $i &gt; 1$ ï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹ç¼–å·ä¸º $floor( i / 2 )$ â€‹ å¦‚æœ $2i â‰¤ n$ ï¼Œå®ƒçš„å·¦å­èŠ‚ç‚¹ç¼–å·ä¸º $2i$ â€‹ å¦‚æœ $2i &gt; n$ ï¼Œå®ƒæ— å·¦å­èŠ‚ç‚¹ â€‹ å¦‚æœ $2i + 1 â‰¤ n$ ï¼Œå®ƒçš„å³å­èŠ‚ç‚¹ç¼–å·ä¸º $2i + 1$ â€‹ å¦‚æœ $2i + 1 &gt; n$ ï¼Œå®ƒæ— å³å­èŠ‚ç‚¹ ä¸€æ£µæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘$ï¼ˆn &gt; 0ï¼‰$ï¼Œä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³å¯¹èŠ‚ç‚¹ä» $0$ å¼€å§‹è¿›è¡Œç¼–å·ï¼Œå¯¹ä»»æ„ç¬¬ $i$ ä¸ªèŠ‚ç‚¹ â€‹ å¦‚æœ $i = 0$ ï¼Œå®ƒæ˜¯æ ¹èŠ‚ç‚¹ â€‹ å¦‚æœ $i &gt; 0$ ï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹ç¼–å·ä¸º $floor( (i â€“ 1) / 2 )$ â€‹ å¦‚æœ $2i + 1 â‰¤ n â€“ 1$ ï¼Œå®ƒçš„å·¦å­èŠ‚ç‚¹ç¼–å·ä¸º $2i + 1$ â€‹ å¦‚æœ $2i + 1 &gt; n â€“ 1$ ï¼Œå®ƒæ— å·¦å­èŠ‚ç‚¹ â€‹ å¦‚æœ $2i + 2 â‰¤ n â€“ 1$ ï¼Œå®ƒçš„å³å­èŠ‚ç‚¹ç¼–å·ä¸º $2i + 2$ â€‹ å¦‚æœ $2i + 2 &gt; n â€“ 1$ ï¼Œå®ƒæ— å³å­èŠ‚ç‚¹ é¢è¯•é¢˜å¦‚æœä¸€æ£µå®Œå…¨äºŒå‰æ ‘æœ‰ $768$ ä¸ªèŠ‚ç‚¹ï¼Œæ±‚å¶å­èŠ‚ç‚¹çš„ä¸ªæ•° å‡è®¾å¶å­èŠ‚ç‚¹ä¸ªæ•°ä¸º $n0$ï¼Œåº¦ä¸º $1$ çš„èŠ‚ç‚¹ä¸ªæ•°ä¸º $n1$ï¼Œåº¦ä¸º $2$ çš„èŠ‚ç‚¹ä¸ªæ•°ä¸º $n2$ æ€»ç»“ç‚¹ä¸ªæ•° $n = n0 + n1 + n2$ï¼Œè€Œä¸” $n0 = n2 + 1$ $n = 2n0 + n1 â€“ 1$ å®Œå…¨äºŒå‰æ ‘çš„ $n1$ è¦ä¹ˆä¸º $0$ï¼Œè¦ä¹ˆä¸º $1$ $n1$ä¸º $1$ æ—¶ï¼Œ$n = 2n0$ï¼Œ$n$ å¿…ç„¶æ˜¯å¶æ•° å¶å­èŠ‚ç‚¹ä¸ªæ•° $n0 = n / 2$ï¼Œéå¶å­èŠ‚ç‚¹ä¸ªæ•° $n1 + n2 = n / 2$ $n1$ä¸º $0$ æ—¶ï¼Œ$n = 2n0 â€“ 1$ï¼Œ$n$ å¿…ç„¶æ˜¯å¥‡æ•° å¶å­èŠ‚ç‚¹ä¸ªæ•° $n0 = (n + 1) / 2$ï¼Œéå¶å­èŠ‚ç‚¹ä¸ªæ•° $n1 + n2 = (n â€“ 1) / 2$ å¶å­èŠ‚ç‚¹ä¸ªæ•° $n0 = floor( (n + 1) / 2 ) = ceiling( n / 2 )$ éå¶å­èŠ‚ç‚¹ä¸ªæ•° $n1 + n2 = floor( n / 2 ) = ceiling( (n â€“ 1) / 2 )$ å› æ­¤å¶å­èŠ‚ç‚¹ä¸ªæ•°ä¸º $384$ äºŒå‰æ ‘çš„éå†äºŒå‰æ ‘çš„å¸¸è§éå†æ–¹å¼æœ‰4ç§ å‰åºéå†ï¼ˆPreorder Traversalï¼‰ ä¸­åºéå†ï¼ˆInorder Traversalï¼‰ ååºéå†ï¼ˆPostorder Traversalï¼‰ å±‚åºéå†ï¼ˆLevel Order Traversalï¼‰ å‰åºéå†ï¼ˆPreorder Traversalï¼‰è®¿é—®é¡ºåº æ ¹èŠ‚ç‚¹ã€å‰åºéå†å·¦å­æ ‘ã€å‰åºéå†å³å­æ ‘ 7ã€4ã€2ã€1ã€3ã€5ã€9ã€8ã€11ã€10ã€12 é€’å½’å®ç° 123456private void preorder(Node&lt;E&gt; node) &#123; if (node == null) return; System.out.println(node.element); preorder(node.left); preorder(node.right);&#125; éé€’å½’ï¼Œåˆ©ç”¨æ ˆå®ç° 123456789101112131415161718192021public void preorder() &#123; if (root == null) return; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // å°† root å…¥ æ ˆ stack.push(root); // å¾ªç¯æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œç›´åˆ°æ ˆä¸ºç©º while (!stack.isEmpty()) &#123; // å¼¹å‡ºæ ˆé¡¶èŠ‚ç‚¹ topï¼Œè¿›è¡Œè®¿é—® Node&lt;E&gt; node = stack.pop(); // è®¿é—®nodeèŠ‚ç‚¹ System.out.println(node.element); if (node.right != null) &#123; // å°† top.right å…¥ æ ˆ stack.push(node.right); &#125; // å°† top.left å…¥ æ ˆ if (node.left != null) &#123; stack.push(node.left); &#125; &#125;&#125; ä¸­åºéå†ï¼ˆInorder Traversalï¼‰è®¿é—®é¡ºåº ä¸­åºéå†å·¦å­æ ‘ã€æ ¹èŠ‚ç‚¹ã€ä¸­åºéå†å³å­æ ‘ 1ã€2ã€3ã€4ã€5ã€7ã€8ã€9ã€10ã€11ã€12 é€’å½’å®ç° 123456private void inorder(Node&lt;E&gt; node) &#123; if (node == null) return; inorder(node.left); System.out.println(node.element); inorder(node.right);&#125; éé€’å½’ï¼Œåˆ©ç”¨æ ˆå®ç° 12345678910111213141516171819202122public void inorder(Visitor&lt;E&gt; visitor) &#123; if (root == null) return; // è®¾ç½® node = root Node&lt;E&gt; node = root; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); while (true) &#123; if (node != null) &#123; stack.push(node); // å‘å·¦èµ° node = node.left; &#125; else if (stack.isEmpty()) &#123; // å¦‚æœæ ˆä¸ºç©ºï¼Œç»“æŸéå† return; &#125; else &#123; // å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå¼¹å‡ºæ ˆé¡¶å…ƒç´ å¹¶èµ‹å€¼ç»™ node node = stack.pop(); // è®¿é—®nodeèŠ‚ç‚¹ System.out.println(node.element); // è®©å³èŠ‚ç‚¹è¿›è¡Œä¸­åºéå† node = node.right; &#125; &#125;&#125; ååºéå†ï¼ˆPostorder Traversalï¼‰è®¿é—®é¡ºåº ååºéå†å·¦å­æ ‘ã€ååºéå†å³å­æ ‘ã€æ ¹èŠ‚ç‚¹ 1ã€3ã€2ã€5ã€4ã€8ã€10ã€12ã€11ã€9ã€7 é€’å½’å®ç° 123456private void postorder(Node&lt;E&gt; node) &#123; if (node == null) return; postorder(node.left); postorder(node.right); System.out.println(node.element);&#125; éé€’å½’ï¼Œåˆ©ç”¨æ ˆå®ç°123456789101112131415161718192021222324252627282930public boolean isLeaf() &#123; return left == null &amp;&amp; right == null;&#125;public void postorder() &#123; if (root == null) return; // è®°å½•ä¸Šä¸€æ¬¡å¼¹å‡ºè®¿é—®çš„èŠ‚ç‚¹ Node&lt;E&gt; prev = null; Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;(); // å°† root å…¥ æ ˆ stack.push(root); // å¾ªç¯æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œç›´åˆ°æ ˆä¸ºç©º while (!stack.isEmpty()) &#123; // æŸ¥çœ‹æ ˆé¡¶å…ƒç´ ï¼Œä¸åˆ é™¤ Node&lt;E&gt; top = stack.peek(); // å¦‚æœæ ˆé¡¶èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ æˆ–è€… ä¸Šä¸€æ¬¡è®¿é—®çš„èŠ‚ç‚¹æ˜¯æ ˆé¡¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ if (top.isLeaf() || (prev != null &amp;&amp; prev.parent == top)) &#123; // å®šä¹‰prevï¼Œä¸‹æ¬¡å†é‡åˆ°ï¼Œä¸ä¼šå†å…¥æ ˆï¼Œé¿å…é‡å¤è®¿é—® prev = stack.pop(); // è®¿é—®èŠ‚ç‚¹ System.out.println(prev.element); &#125; else &#123; if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125; &#125;&#125; å±‚åºéå†ï¼ˆLevel Order Traversalï¼‰è®¿é—®é¡ºåº ä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³ä¾æ¬¡è®¿é—®æ¯ä¸€ä¸ªèŠ‚ç‚¹ 7ã€4ã€9ã€2ã€5ã€8ã€11ã€1ã€3ã€10ã€12 éé€’å½’ï¼Œåˆ©ç”¨é˜Ÿåˆ—å®ç° 123456789101112131415161718192021222324public void levelOrder() &#123; if (root == null) return; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); // å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ queue.offer(root); // å¾ªç¯æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©º while (!queue.isEmpty()) &#123; // å°†é˜Ÿå¤´èŠ‚ç‚¹ A å‡ºé˜Ÿï¼Œè¿›è¡Œè®¿é—® Node&lt;E&gt; node = queue.poll(); System.out.println(node.element); // å°†å·¦å­èŠ‚ç‚¹å…¥é˜Ÿ if (node.left != null) &#123; queue.offer(node.left); &#125; // å°†å³å­èŠ‚ç‚¹å…¥é˜Ÿ if (node.right != null) &#123; queue.offer(node.right); &#125; &#125;&#125; éå†çš„åº”ç”¨ å‰åºéå† æ ‘çŠ¶ç»“æ„å±•ç¤ºï¼ˆæ³¨æ„å·¦å³å­æ ‘çš„é¡ºåºï¼‰ ä¸­åºéå† äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æŒ‰å‡åºæˆ–è€…é™åºå¤„ç†èŠ‚ç‚¹ ååºéå† é€‚ç”¨äºä¸€äº›å…ˆå­åçˆ¶çš„æ“ä½œ å±‚åºéå† è®¡ç®—äºŒå‰æ ‘çš„é«˜åº¦ åˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ æ ¹æ®éå†ç»“æœé‡æ„äºŒå‰æ ‘ä»¥ä¸‹ç»“æœå¯ä»¥ä¿è¯é‡æ„å‡ºå”¯ä¸€çš„ä¸€æ£µäºŒå‰æ ‘ å‰åºéå† + ä¸­åºéå† ååºéå† + ä¸­åºéå† å‰åºéå† + ååºéå† â€‹ å¦‚æœå®ƒæ˜¯ä¸€æ£µçœŸäºŒå‰æ ‘ï¼ˆProper Binary Treeï¼‰ï¼Œç»“æœæ˜¯å”¯ä¸€çš„ï¼Œä¸ç„¶ç»“æœä¸å”¯ä¸€ å‰åºéå†+ä¸­åºéå†é‡æ„äºŒå‰æ ‘å‰åºéå†ï¼š4 2 1 3 6 5 ä¸­åºéå†ï¼š1 2 3 4 5 6 å‰é©±ã€åç»§èŠ‚ç‚¹å‰é©±èŠ‚ç‚¹ï¼ˆpredecessorï¼‰å‰é©±èŠ‚ç‚¹ï¼šä¸­åºéå†æ—¶çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ å¦‚æœæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå‰é©±èŠ‚ç‚¹å°±æ˜¯å‰ä¸€ä¸ªæ¯”å®ƒå°çš„èŠ‚ç‚¹ 123456789101112131415161718192021222324252627282930protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123; if (node == null) return null; // å‰é©±èŠ‚ç‚¹åœ¨å·¦å­æ ‘å½“ä¸­ï¼ˆleft.right.right.right....ï¼‰ // node.left != nullæ—¶ // ä¸¾ä¾‹ï¼š6-ã€‹5ã€13-ã€‹12ã€8-ã€‹7 // predecessor = node.left.right.right.right... Node&lt;E&gt; p = node.left; // ç»ˆæ­¢æ¡ä»¶ï¼šright ä¸º null if (p != null) &#123; while (p.right != null) &#123; p = p.right; &#125; return p; &#125; // ä»çˆ¶èŠ‚ç‚¹ã€ç¥–çˆ¶èŠ‚ç‚¹ä¸­å¯»æ‰¾å‰é©±èŠ‚ç‚¹ // node.left == null &amp;&amp; node.parent != null // ä¸¾ä¾‹ï¼š7-ã€‹6ã€11-ã€‹10ã€9-ã€‹8 // predecessor = node.parent.parent.parent... // ç»ˆæ­¢æ¡ä»¶ï¼šnode åœ¨ parent çš„å³å­æ ‘ä¸­ while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.left == null &amp;&amp; node.parent == null // é‚£å°±æ²¡æœ‰å‰é©±èŠ‚ç‚¹ // ä¸¾ä¾‹ï¼šæ²¡æœ‰å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ 1 return node.parent;&#125; åç»§èŠ‚ç‚¹ï¼ˆsuccessorï¼‰åç»§èŠ‚ç‚¹ï¼šä¸­åºéå†æ—¶çš„åä¸€ä¸ªèŠ‚ç‚¹ å¦‚æœæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œåç»§èŠ‚ç‚¹å°±æ˜¯åä¸€ä¸ªæ¯”å®ƒå¤§çš„èŠ‚ç‚¹ 1234567891011121314151617181920212223242526272829protected Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123; if (node == null) return null; // å‰é©±èŠ‚ç‚¹åœ¨å·¦å­æ ‘å½“ä¸­ï¼ˆright.left.left.left....ï¼‰ // node.right != null // ä¸¾ä¾‹ï¼š1ã€8ã€4ã€10 // successor = node.right.left.left.left... Node&lt;E&gt; p = node.right; if (p != null) &#123; // ç»ˆæ­¢æ¡ä»¶ï¼šleft ä¸º null while (p.left != null) &#123; p = p.left; &#125; return p; &#125; // node.right == null &amp;&amp; node.parent != null // ä¸¾ä¾‹ï¼š6ã€3ã€11 // successor = node.parent.parent.parent... // ç»ˆæ­¢æ¡ä»¶ï¼šnode åœ¨ parent çš„å·¦å­æ ‘ä¸­ while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; // node.right == null &amp;&amp; node.parent == null // é‚£å°±æ²¡æœ‰å‰é©±èŠ‚ç‚¹ // ä¸¾ä¾‹ï¼šæ²¡æœ‰å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ return node.parent;&#125; è®¡ç®—äºŒå‰æ ‘çš„é«˜åº¦éé€’å½’ï¼Œåˆ©ç”¨é˜Ÿåˆ—å®ç°123456789101112131415161718192021222324252627282930public int height() &#123; if (root == null) return 0; // æ ‘çš„é«˜åº¦ int height = 0; // å­˜å‚¨ç€æ¯ä¸€å±‚çš„å…ƒç´ æ•°é‡ int levelSize = 1; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; Node&lt;E&gt; node = queue.poll(); levelSize--; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; if (levelSize == 0) &#123; // æ„å‘³ç€å³å°†è¦è®¿é—®ä¸‹ä¸€å±‚ levelSize = queue.size(); height++; &#125; &#125; return height;&#125; é€’å½’1234567public int height() &#123; return height(root);&#125;private int height(Node&lt;E&gt; node) &#123; if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right));&#125; ç»ƒä¹ ç¿»è½¬äºŒå‰æ ‘leetcodeåœ°å€ 1234567891011121314class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
        <category>æ ‘</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é˜Ÿåˆ—]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[é˜Ÿåˆ—ï¼ˆQueueï¼‰ä»€ä¹ˆæ˜¯é˜Ÿåˆ—é˜Ÿåˆ—æ˜¯ä¸€ç§ç‰¹æ®Šçš„çº¿æ€§è¡¨ï¼Œåªèƒ½åœ¨å¤´å°¾ä¸¤ç«¯è¿›è¡Œæ“ä½œ é˜Ÿå°¾ï¼ˆrearï¼‰ï¼šåªèƒ½ä»é˜Ÿå°¾æ·»åŠ å…ƒç´ ï¼Œä¸€èˆ¬å«åš enQueueï¼Œå…¥é˜Ÿ é˜Ÿå¤´ï¼ˆfrontï¼‰ï¼šåªèƒ½ä»é˜Ÿå¤´ç§»é™¤å…ƒç´ ï¼Œä¸€èˆ¬å«åš deQueueï¼Œå‡ºé˜Ÿ å…ˆè¿›å…ˆå‡ºçš„åŸåˆ™ï¼ŒFirst In First Outï¼ŒFIFO é˜Ÿåˆ—çš„ä»£ç å®ç°é˜Ÿåˆ—çš„å†…éƒ¨å®ç°å¯ä»¥ç›´æ¥åˆ©ç”¨åŠ¨æ€æ•°ç»„ã€é“¾è¡¨å®ç°ã€‚ 123456789101112131415161718192021222324252627public class Queue&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // å…ƒç´ çš„æ•°é‡ return list.size(); &#125; public boolean isEmpty() &#123; // æ˜¯å¦ä¸ºç©º return list.isEmpty(); &#125; public void clear() &#123; // æ¸…ç©º list.clear(); &#125; public void enQueue(E element) &#123; //å…¥é˜Ÿ list.add(element); &#125; public E deQueue() &#123; // å‡ºé˜Ÿ return list.remove(0); &#125; public E front() &#123; // è·å–é˜Ÿé¦–å…ƒç´ ï¼Œä¸åˆ é™¤ return list.get(0); &#125;&#125; åŒç«¯é˜Ÿåˆ—ï¼ˆDequeï¼‰åŒç«¯é˜Ÿåˆ—æ˜¯èƒ½åœ¨å¤´å°¾ä¸¤ç«¯æ·»åŠ ã€åˆ é™¤çš„é˜Ÿåˆ—ï¼Œè‹±æ–‡ deque æ˜¯ double ended queue çš„ç®€ç§° 123456789101112131415161718192021222324252627282930313233343536373839public class Deque&lt;E&gt; &#123; private List&lt;E&gt; list = new LinkedList&lt;&gt;(); public int size() &#123; // å…ƒç´ çš„æ•°é‡ return list.size(); &#125; public boolean isEmpty() &#123; // æ˜¯å¦ä¸ºç©º return list.isEmpty(); &#125; public void clear() &#123; // æ¸…ç©º list.clear(); &#125; public void enQueueRear(E element) &#123; // ä»é˜Ÿå°¾å…¥é˜Ÿ list.add(element); &#125; public E deQueueFront() &#123; // ä»é˜Ÿå¤´å‡ºé˜Ÿ return list.remove(0); &#125; public void enQueueFront(E element) &#123; // ä»é˜Ÿå¤´å…¥é˜Ÿ list.add(0, element); &#125; public E deQueueRear() &#123; // ä»é˜Ÿå°¾å‡ºé˜Ÿ return list.remove(list.size() - 1); &#125; public E front() &#123; // è·å–é˜Ÿåˆ—çš„å¤´å…ƒç´  return list.get(0); &#125; public E rear() &#123; // è·å–é˜Ÿåˆ—çš„å°¾å…ƒç´  return list.get(list.size() - 1); &#125;&#125; å¾ªç¯é˜Ÿåˆ—ï¼ˆCircle Queueï¼‰å¯ä»¥è¿›è¡Œä¸¤ç«¯æ·»åŠ ã€åˆ é™¤æ“ä½œçš„å¾ªç¯é˜Ÿåˆ— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CircleQueue&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleQueue() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; public void enQueue(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; public E deQueue() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; public E front() &#123; return elements[front]; &#125; private int index(int index) &#123; index += front; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // ä¿è¯è¦æœ‰capacityçš„å®¹é‡ private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // æ–°å®¹é‡ä¸ºæ—§å®¹é‡çš„1.5å€ int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // é‡ç½®front front = 0; &#125;&#125; å¾ªç¯åŒç«¯é˜Ÿåˆ—12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class CircleDeque&lt;E&gt; &#123; private int front; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; public CircleDeque() &#123; elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; front = 0; size = 0; &#125; // ä»å°¾éƒ¨å…¥é˜Ÿ public void enQueueRear(E element) &#123; ensureCapacity(size + 1); elements[index(size)] = element; size++; &#125; // ä»å¤´éƒ¨å‡ºé˜Ÿ public E deQueueFront() &#123; E frontElement = elements[front]; elements[front] = null; front = index(1); size--; return frontElement; &#125; // ä»å¤´éƒ¨å…¥é˜Ÿ public void enQueueFront(E element) &#123; ensureCapacity(size + 1); front = index(-1); elements[front] = element; size++; &#125; // ä»å°¾éƒ¨å‡ºé˜Ÿ public E deQueueRear() &#123; int rearIndex = index(size - 1); E rear = elements[rearIndex]; elements[rearIndex] = null; size--; return rear; &#125; public E front() &#123; return elements[front]; &#125; public E rear() &#123; return elements[index(size - 1)]; &#125; private int index(int index) &#123; index += front; if (index &lt; 0) &#123; return index + elements.length; &#125; return index - (index &gt;= elements.length ? elements.length : 0); &#125; // ä¿è¯è¦æœ‰capacityçš„å®¹é‡ private void ensureCapacity(int capacity) &#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // æ–°å®¹é‡ä¸ºæ—§å®¹é‡çš„1.5å€ int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; // é‡ç½®front front = 0; &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>é˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ ˆ]]></title>
    <url>%2F2020%2F07%2F11%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[æ ˆï¼ˆstackï¼‰ä»€ä¹ˆæ˜¯æ ˆæ ˆæ˜¯ä¸€ç§ç‰¹æ®Šçš„çº¿æ€§è¡¨ï¼Œåªèƒ½åœ¨ä¸€ç«¯è¿›è¡Œæ“ä½œ å¾€æ ˆä¸­æ·»åŠ å…ƒç´ çš„æ“ä½œï¼Œä¸€èˆ¬å«åš pushï¼Œå…¥æ ˆ ä»æ ˆä¸­ç§»é™¤å…ƒç´ çš„æ“ä½œï¼Œä¸€èˆ¬å«åš popï¼Œå‡ºæ ˆï¼ˆåªèƒ½ç§»é™¤æ ˆé¡¶å…ƒç´ ï¼Œä¹Ÿå«åšï¼šå¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼‰ åè¿›å…ˆå‡ºçš„åŸåˆ™ï¼ŒLast In First Outï¼ŒLIFO æ³¨æ„ï¼šè¿™é‡Œè¯´çš„â€œæ ˆâ€ä¸å†…å­˜ä¸­çš„â€œæ ˆç©ºé—´â€æ˜¯ä¸¤ä¸ªä¸åŒçš„æ¦‚å¿µ æ ˆçš„ä»£ç å®ç°æ ˆçš„å†…éƒ¨å®ç°å¯ä»¥ç›´æ¥åˆ©ç”¨åŠ¨æ€æ•°ç»„ã€é“¾è¡¨å®ç°ã€‚ 123456789101112131415161718192021222324252627public class Stack&lt;E&gt; &#123; private List&lt;E&gt; list = new ArrayList&lt;&gt;(); public void clear() &#123; // æ¸…ç©º list.clear(); &#125; public int size() &#123; // å…ƒç´ çš„æ•°é‡ return list.size(); &#125; public boolean isEmpty() &#123; // æ˜¯å¦ä¸ºç©º return list.isEmpty(); &#125; public void push(E element) &#123; // å…¥æ ˆ list.add(element); &#125; public E pop() &#123; // å‡ºæ ˆ return list.remove(list.size() - 1); &#125; public E top() &#123; // è·å–æ ˆé¡¶å…ƒç´ ï¼Œä¸åˆ é™¤ return list.get(list.size() - 1); &#125;&#125; ç»ƒä¹ æœ‰æ•ˆçš„æ‹¬å·leetcodeåœ°å€ 123456789101112131415161718192021222324class Solution &#123; private static HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); static &#123; map.put('(', ')'); map.put('&#123;', '&#125;'); map.put('[', ']'); &#125; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; char c = s.charAt(i); // åˆ¤æ–­æ˜¯å¦æ˜¯å·¦è¾¹ï¼Œæ˜¯å°±å…¥æ ˆ if (map.containsKey(c))&#123; stack.push(c); &#125;else &#123; // å·¦è¾¹å‡ºæ ˆï¼Œè¿›è¡Œæ¯”è¾ƒ if (stack.isEmpty()) return false; char left = stack.pop(); if (c != map.get(left)) return false; &#125; &#125; return stack.isEmpty(); &#125;&#125; ç”¨æ ˆå®ç°é˜Ÿåˆ—leetcodeåœ°å€ 123456789101112131415161718192021222324252627282930313233343536373839class MyQueue &#123; private Stack&lt;Integer&gt; inStack; private Stack&lt;Integer&gt; outStack; public MyQueue() &#123; inStack = new Stack&lt;&gt;(); outStack = new Stack&lt;&gt;(); &#125; /** å…¥æ ˆ */ public void push(int x) &#123; inStack.push(x); &#125; /** å‡ºæ ˆ */ public int pop() &#123; checkOutStack(); return outStack.pop(); &#125; /** å¾—åˆ°æ ˆé¡¶å…ƒç´ ï¼Œä¸åˆ é™¤ */ public int peek() &#123; checkOutStack(); return outStack.peek(); &#125; /** åˆ¤æ–­æ˜¯å¦ä¸ºç©º */ public boolean empty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; private void checkOutStack()&#123; if (outStack.isEmpty())&#123; while (!inStack.isEmpty())&#123; outStack.push(inStack.pop()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é“¾è¡¨]]></title>
    <url>%2F2020%2F07%2F11%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[é“¾è¡¨ï¼ˆLinked Listï¼‰ä¸ºä»€ä¹ˆæœ‰é“¾è¡¨åŠ¨æ€æ•°ç»„æœ‰ä¸ªæ˜æ˜¾çš„ç¼ºç‚¹ï¼Œå¯èƒ½ä¼šé€ æˆå†…å­˜ç©ºé—´çš„å¤§é‡æµªè´¹ èƒ½å¦ç”¨åˆ°å¤šå°‘å°±ç”³è¯·å¤šå°‘å†…å­˜ï¼Ÿ é“¾è¡¨å¯ä»¥åŠåˆ°è¿™ä¸€ç‚¹ é“¾è¡¨æ˜¯ä¸€ç§é“¾å¼å­˜å‚¨çš„çº¿æ€§è¡¨ï¼Œæ‰€æœ‰å…ƒç´ çš„å†…å­˜åœ°å€ä¸ä¸€å®šæ˜¯è¿ç»­çš„ é“¾è¡¨çš„è®¾è®¡ æ¥å£è®¾è®¡é“¾è¡¨çš„å¤§éƒ¨åˆ†æ¥å£å’ŒåŠ¨æ€æ•°ç»„æ˜¯ä¸€è‡´çš„ 1234567891011121314151617181920212223242526272829303132333435// æ¥å£å®šä¹‰public interface List&lt;E&gt; &#123; // å…ƒç´ ä¸å­˜åœ¨åœ¨è¿”å›-1 static final int ELEMENT_NOT_FOUND = -1; // æ¸…é™¤æ‰€æœ‰å…ƒç´  void clear(); // å…ƒç´ çš„æ•°é‡ int size(); // æ˜¯å¦ä¸ºç©º boolean isEmpty(); // æ˜¯å¦åŒ…å«æŸä¸ªå…ƒç´  boolean contains(E element); // æ·»åŠ å…ƒç´ åˆ°å°¾éƒ¨ void add(E element); // è·å–indexä½ç½®çš„å…ƒç´  E get(int index); // è®¾ç½®indexä½ç½®çš„å…ƒç´  E set(int index, E element); // åœ¨indexä½ç½®æ’å…¥ä¸€ä¸ªå…ƒç´  void add(int index, E element); // åˆ é™¤indexä½ç½®çš„å…ƒç´  E remove(int index); // æŸ¥çœ‹å…ƒç´ çš„ç´¢å¼• int indexOf(E element);&#125; æ£€æµ‹ä¼ å…¥çš„ä¸‹æ ‡æ˜¯å¦åˆæ³•123456789101112131415protected void outOfBounds(int index) &#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);&#125;protected void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125;&#125;protected void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125;&#125; nodeæ–¹æ³•ç”¨äºè·å–indexä½ç½®çš„èŠ‚ç‚¹12345678private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node;&#125; åˆ›å»ºèŠ‚ç‚¹123456789private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; next; // elementæ–°èŠ‚ç‚¹çš„å€¼ï¼Œnextæ–°èŠ‚ç‚¹æŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125;&#125; æ·»åŠ å…ƒç´ -add(int index,E element) 1234567891011121314151617// æ·»åŠ å…ƒç´ åˆ°å°¾éƒ¨public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; // åœ¨ç¼–å†™é“¾è¡¨è¿‡ç¨‹ä¸­ï¼Œè¦æ³¨æ„è¾¹ç•Œæµ‹è¯•ï¼Œæ¯”å¦‚ index ä¸º 0 ã€size â€“ 0 ã€size æ—¶ rangeCheckForAdd(index); if (index == 0)&#123; first = new Node&lt;&gt;(element,first); &#125;else&#123; // æ‰¾åˆ°æ’å…¥ä¸‹æ ‡çš„ä¸Šä¸€ä¸ªå…ƒç´  Node&lt;E&gt; prev = node(index - 1); // æ–°åˆ›å»ºçš„èŠ‚ç‚¹æŒ‡å‘åŸå…ˆprev.nextï¼ˆå¦‚ä¸Šå›¾ï¼š1æŒ‡å‘2ï¼‰,å†å°†prev.nextæŒ‡å‘æ–°èŠ‚ç‚¹ï¼ˆå¦‚ä¸Šå›¾ï¼š0æŒ‡å‘1ï¼‰ prev.next = new Node&lt;&gt;(element,prev.next); &#125; size++;&#125; åˆ é™¤å…ƒç´  12345678910111213141516public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = first; // æ³¨æ„0ä½ç½® if (index == 0)&#123; first = first.next; &#125;else&#123; // æ‰¾åˆ°å¾…åˆ é™¤å…ƒç´ ä¸Šä¸€ä¸ªå…ƒç´ çš„ä¸‹æ ‡ Node&lt;E&gt; prev = node(index - 1); // nodeå¾…åˆ é™¤çš„å…ƒç´  node = prev.next; prev.next = node.next; &#125; size--; return node.element;&#125; æ¸…ç©ºé“¾è¡¨12345public void clear() &#123; size = 0; // nextä¸éœ€è¦è®¾ç½®ä¸ºnull first = null;&#125; åˆ¤æ–­é“¾è¡¨ä¸­æŸä¸ªå…ƒç´ çš„ä¸‹æ ‡1234567891011121314151617public int indexOf(E element) &#123; // é“¾è¡¨ä¸­å…è®¸æœ‰nullå€¼å…ƒç´  if (element == null)&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) return i; node = node.next; &#125; &#125;else&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) return i; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND;&#125; åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦åŒ…å«æŸä¸ªå…ƒç´ 123public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND;&#125; åŒå‘é“¾è¡¨ä½¿ç”¨åŒå‘é“¾è¡¨å¯ä»¥æå‡é“¾è¡¨çš„ç»¼åˆæ€§èƒ½ nodeæ–¹æ³•ç”¨äºè·å–indexä½ç½®çš„èŠ‚ç‚¹1234567891011121314151617private Node&lt;E&gt; node(int index)&#123; rangeCheck(index); // åˆ†ä¸¤æ¡è·¯å¯»æ‰¾èŠ‚ç‚¹ if (index &lt; (size &gt;&gt; 1))&#123; Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node; &#125;else &#123; Node&lt;E&gt; node = last; for (int i = size - 1; i &gt; index; i--) &#123; node = node.prev; &#125; return node; &#125;&#125; åˆ›å»ºèŠ‚ç‚¹1234567891011private static class Node&lt;E&gt;&#123; E element; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev,E element, Node&lt;E&gt; next) &#123; this.prev = prev; this.element = element; this.next = next; &#125;&#125; æ·»åŠ å…ƒç´ -add(int index,E element) 12345678910111213141516171819202122// æ·»åŠ å…ƒç´ åˆ°å°¾éƒ¨public void add(E element) &#123; add(size, element);&#125;public void add(int index, E element) &#123; rangeCheckForAdd(index); if (index == size)&#123; Node&lt;E&gt; oldLast = last; last = new Node&lt;&gt;(oldLast,element,null); oldLast.next = last; &#125;else&#123; Node&lt;E&gt; next = node(index); Node&lt;E&gt; prev = next.prev; Node&lt;E&gt; node = new Node&lt;&gt;(prev,element,next); next.prev = node; if (prev == null)&#123; first = node; &#125;else&#123; prev.next = node; &#125; &#125;&#125; åˆ é™¤å…ƒç´  â€“ remove(int index) 1234567891011121314151617181920public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = node(index); Node&lt;E&gt; prev = node.prev; Node&lt;E&gt; next = node.next; if (prev == null)&#123; first = next; &#125;else&#123; prev.next = next; &#125; if (next == null)&#123; last = prev; &#125;else&#123; next.prev = prev; &#125; size--; return node.element;&#125; åŒå‘é“¾è¡¨ vs å•å‘é“¾è¡¨ç²—ç•¥å¯¹æ¯”ä¸€ä¸‹åˆ é™¤çš„æ“ä½œæ•°é‡ å•å‘é“¾è¡¨ï¼š $1+2+3+â€¦+n=$ $ {(1+n)\ast n} \over {2}$ $=$ ${n} \over {2}$ $+$ ${n^2} \over {2}$ï¼Œ é™¤ä»¥$n$ å¹³å‡ä¸€ä¸‹æ˜¯ ${1} \over {2}$ + ${n} \over {2}$ åŒå‘é“¾è¡¨ï¼š$(1+2+3+â€¦+$ ${n} \over {2} $ $) \ast 2=$ $\frac{(1+\frac{n}{2})\ast \frac{n}{2}}{2}\ast 2$ = $\frac{n}{2}+\frac{n^2}{2} $ ï¼Œé™¤ä»¥$n$å¹³å‡ä¸€ä¸‹æ˜¯ ${1} \over {2}$ + ${n} \over{4}$ æ“ä½œæ•°é‡ç¼©å‡äº†è¿‘ä¸€åŠ ç»ƒä¹ åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹leetcodeåœ°å€ 123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; åè½¬ä¸€ä¸ªé“¾è¡¨leetcodeåœ°å€ é€’å½’å®ç° 12345678910// é€’å½’public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; // å®šä¹‰æ–°çš„å¤´èŠ‚ç‚¹ ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; éé€’å½’ â€“ å¤´æ’æ³• 1234567891011121314// è¿­ä»£public ListNode reverseList2(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode newHead = null; while (head != null)&#123; ListNode tmp = head.next; // æ¯æ¬¡éå†è®©head.nextæˆä¸ºå¤´èŠ‚ç‚¹ head.next = newHead; newHead = head; // headé‡æ–°æŒ‡å‘tmpï¼Œä½¿å¾ªç¯æŒ‰é¡ºåºç»§ç»­éå† head = tmp; &#125; return newHead;&#125; åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰ç¯leetcodeåœ°å€ 123456789101112131415// å¿«æ…¢æŒ‡é’ˆï¼Œç›¸é‡åˆ™æœ‰ç¯public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; // æ…¢æŒ‡é’ˆï¼Œæ¯æ¬¡èµ°ä¸€æ­¥ ListNode slow = head; // å¿«æŒ‡é’ˆï¼Œæ¯æ¬¡èµ°ä¸¤æ­¥ ListNode fast = head.next; while (fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>é“¾è¡¨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ¨æ€æ•°ç»„]]></title>
    <url>%2F2020%2F07%2F09%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[åŠ¨æ€æ•°ç»„æ•°ç»„æ•°ç»„æ˜¯ä¸€ç§é¡ºåºå­˜å‚¨çš„çº¿æ€§è¡¨ï¼Œæ‰€æœ‰å…ƒç´ çš„å†…å­˜åœ°å€æ˜¯è¿ç»­çš„ 1int[] array = new int[]&#123;11,22,33&#125;; åœ¨å¾ˆå¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ•°ç»„éƒ½æœ‰ä¸ªè‡´å‘½çš„ç¼ºç‚¹ï¼Œæ— æ³•åŠ¨æ€ä¿®æ”¹å®¹é‡ å®é™…å¼€å‘ä¸­ï¼Œæˆ‘ä»¬æ›´å¸Œæœ›æ•°ç»„çš„å®¹é‡æ˜¯å¯ä»¥åŠ¨æ€æ”¹å˜çš„ åŠ¨æ€æ•°ç»„ï¼ˆDynamic Arrayï¼‰æ¥å£è®¾è®¡12345678910int size(); // å…ƒç´ çš„æ•°é‡boolean isEmpty(); // æ˜¯å¦ä¸ºç©ºboolean contains(E element); // æ˜¯å¦åŒ…å«æŸä¸ªå…ƒç´ void add(E element); // æ·»åŠ å…ƒç´ åˆ°æœ€åE get(int index); // è¿”å›indextä½ç½®å¯¹åº”çš„å…ƒç´ E set(int index,E element); // è®¾ç½®indextä½ç½®å¯¹åº”çš„å…ƒç´ void add(int index,E element); // å¾€indexä½ç½®æ·»åŠ å…ƒç´ E remove(int index); // åˆ é™¤indexä½ç½®å¯¹åº”çš„å…ƒç´ int indexOf(E element); // æŸ¥çœ‹å…ƒç´ çš„ä½ç½®void clear(); //æ¸…é™¤æ‰€æœ‰å…ƒç´  åŠ¨æ€æ•°ç»„çš„è®¾è®¡ åœ¨Javaä¸­ï¼Œæˆå‘˜å˜é‡ä¼šè‡ªåŠ¨åˆå§‹åŒ–ï¼Œæ¯”å¦‚ int ç±»å‹è‡ªåŠ¨åˆå§‹åŒ–ä¸º 0 å¯¹è±¡ç±»å‹è‡ªåŠ¨åˆå§‹åŒ–ä¸º null æ·»åŠ å…ƒç´  - add(E element) 12345678910111213141516171819//æ²¡æœ‰ç´¢å¼•ä¸‹æ ‡ï¼Œé»˜è®¤æ”¾åœ¨æ•°ç»„æœ€åpublic void add(E element)&#123; add(size,element);&#125;// å‘æ•°ç»„æŸä¸ªä½ç½®æ’å…¥å…ƒç´ public void add(int index,E element)&#123; // æ£€æµ‹ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ rangeCheckForAdd(index); // æ‰©å®¹ ensureCapacity(size + 1); // ä»æœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹ï¼Œåˆ°indexä¸‹æ ‡ï¼ˆé€†åºï¼‰ï¼Œæ•°ç»„å…ƒç´ å‘åè¦†ç›– for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++;&#125; åˆ é™¤å…ƒç´  - remove(int index) 1234567891011public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; // ä»indexä¸‹æ ‡å¼€å§‹ï¼Œæ•°ç»„å…ƒç´ å‘å‰æŒªåŠ¨ for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old;&#125; å¦‚ä½•æ‰©å®¹ - ensureCapacity(int capacity) 1234567891011// æ•°ç»„å®¹é‡ä¸å¤Ÿæ—¶ï¼Œæ‰©å®¹private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // å®¹é‡æ·»åŠ 1.5å€ int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// å·¦ç§»ï¼Œç¼©å°ä¸€åŠ(å†åŠ ä¸ŠåŸæ¥çš„å®¹é‡) E[] newElements = (E[]) new Object[newCapacity]; // å°†æ—§æ•°ç»„çš„å…ƒç´ æ‹·è´åˆ°æ–°æ•°ç»„ if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements;&#125; ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import org.omg.CORBA.Object;import java.util.Arrays;@SuppressWarnings("unchecked")public class dynamicArray&lt;E&gt;&#123; /** * å…ƒç´ çš„æ•°é‡ */ private int size; /** * æ‰€ä»¥çš„å…ƒç´  */ private E[] elements; private static final int DEFAULT_CAPATICY = 10; //åˆå§‹å®¹é‡ private static final int ELEMENT_NOT_FOUND = -1; //æ‰¾ä¸åˆ°æŸ¥æ‰¾çš„å…ƒç´  public dynamicArray(int capaticy)&#123; capaticy = Math.max(capaticy, DEFAULT_CAPATICY); elements = (E[]) new Object[capaticy]; //åˆå§‹åŒ–æ•°ç»„å®¹é‡ &#125; public dynamicArray()&#123; this(DEFAULT_CAPATICY); &#125; /** * æ¸…é™¤æ‰€æœ‰å…ƒç´  */ public void clear()&#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; public void add(E element)&#123; add(size,element); &#125; // å‘æ•°ç»„æŸä¸ªä½ç½®æ’å…¥å…ƒç´  public void add(int index,E element)&#123; rangeCheckForAdd(index); ensureCapacity(size + 1); // æ•°ç»„å…ƒç´ å‘å‰è¦†ç›– for (int i = size; i &gt; index; i--) &#123; elements[i] = elements[i-1]; &#125; elements[index] = element; size++; &#125; // æ•°ç»„å®¹é‡ä¸å¤Ÿæ—¶ï¼Œæ‰©å®¹ private void ensureCapacity(int capacity)&#123; int oldCapacity = elements.length; if (oldCapacity &gt;= capacity) return; // å®¹é‡æ·»åŠ 1.5å€ int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// å·¦ç§»ï¼Œç¼©å°ä¸€åŠ E[] newElements = (E[]) new Object[newCapacity]; // å°†æ—§æ•°ç»„çš„å…ƒç´ æ‹·è´åˆ°æ–°æ•°ç»„ if (size &gt;= 0) System.arraycopy(elements, 0, newElements, 0, size); elements = newElements; &#125; public E remove(int index)&#123; rangeCheck(index); E old = elements[index]; for (int i = index + 1; i &lt; size; i++) &#123; elements[i - 1] = elements[i]; &#125; elements[--size] = null; return old; &#125; public boolean contains(E element)&#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; public E get(int index)&#123; rangeCheck(index); return elements[index]; &#125; public E set(int index,E element)&#123; rangeCheck(index); E old = elements[index]; elements[index] = element; return old; &#125; public int indexOf(E element)&#123; if (element == null)&#123; for (int i = 0; i &lt; size; i++) &#123; if (elements[i] == null) return i; &#125; &#125;else&#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(elements[i])) return i; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private void outOfBounds(int index)&#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size); &#125; // æ£€æµ‹ä¼ å…¥çš„ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ private void rangeCheck(int index)&#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125; &#125; private void rangeCheckForAdd(int index)&#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125; &#125; @Override public String toString() &#123; return "dynamicArray&#123;" + "size=" + size + ", elements=" + Arrays.toString(elements) + '&#125;'; &#125;&#125;]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>æ•°ç»„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°æ®ç»“æ„]]></title>
    <url>%2F2020%2F07%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[æ•°æ®ç»“æ„ä»€ä¹ˆæ˜¯æ•°æ®ç»“æ„ï¼Ÿæ•°æ®ç»“æ„æ˜¯è®¡ç®—æœºå­˜å‚¨ã€ç»„ç»‡æ•°æ®çš„æ–¹å¼ çº¿æ€§è¡¨ äºŒå‰æ ‘ é‚»æ¥çŸ©é˜µ æ•°ç»„ã€é“¾è¡¨ AVLæ ‘ã€çº¢é»‘æ ‘ é‚»æ¥è¡¨ æ ˆã€é˜Ÿåˆ— Bæ ‘ã€å †ã€Trie å“ˆå¸Œè¡¨ å“ˆå¤«æ›¼æ ‘ã€å¹¶æŸ¥é›† åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæ ¹æ®ä½¿ç”¨åœºæ™¯æ¥é€‰æ‹©æœ€åˆé€‚çš„æ•°æ®ç»“æ„]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å¤æ‚åº¦]]></title>
    <url>%2F2020%2F07%2F09%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[å¤æ‚åº¦å¦‚ä½•è¯„åˆ¤ä¸€ä¸ªç®—æ³•çš„å¥½åï¼Ÿä¸€èˆ¬ä»ä»¥ä¸‹ç»´åº¦æ¥è¯„ä¼°ç®—æ³•çš„ä¼˜åŠ£ æ­£ç¡®æ€§ã€å¯è¯»æ€§ã€å¥å£®æ€§ï¼ˆå¯¹ä¸åˆç†è¾“å…¥çš„ååº”èƒ½åŠ›å’Œå¤„ç†èƒ½åŠ›ï¼‰ æ—¶é—´å¤æ‚åº¦ï¼ˆtime complexityï¼‰ï¼šä¼°ç®—ç¨‹åºæŒ‡ä»¤çš„æ‰§è¡Œæ¬¡æ•°ï¼ˆæ‰§è¡Œæ—¶é—´ï¼‰ ç©ºé—´å¤æ‚åº¦ï¼ˆspace complexityï¼‰ï¼šä¼°ç®—æ‰€éœ€å ç”¨çš„å­˜å‚¨ç©ºé—´ å¤§Oè¡¨ç¤ºæ³•ï¼ˆBig Oï¼‰ä¸€èˆ¬ç”¨å¤§Oè¡¨ç¤ºæ³•æ¥æè¿°å¤æ‚åº¦ï¼Œå®ƒè¡¨ç¤ºçš„æ˜¯æ•°æ®è§„æ¨¡ n å¯¹åº”çš„å¤æ‚åº¦ï¼Œå¿½ç•¥å¸¸æ•°ã€ç³»æ•°ã€ä½é˜¶$9 &gt;&gt; O(1)$ $2n + 3 &gt;&gt; O(n)$ $n^2 + 2n + 6 &gt;&gt; O(n^2)$ $4n^3 + 3n^2 + 22n + 100 &gt;&gt; O(n^3)$ æ³¨æ„ï¼šå¤§Oè¡¨ç¤ºæ³•ä»…ä»…æ˜¯ä¸€ç§ç²—ç•¥çš„åˆ†ææ¨¡å‹ï¼Œæ˜¯ä¸€ç§ä¼°ç®—ï¼Œèƒ½å¸®åŠ©æˆ‘ä»¬çŸ­æ—¶é—´å†…äº†è§£ä¸€ä¸ªç®—æ³•çš„æ‰§è¡Œæ•ˆç‡ å¯¹æ•°é˜¶çš„ç»†èŠ‚å¯¹æ•°é˜¶ä¸€èˆ¬çœç•¥åº•æ•° $log_2n = log_29 âˆ— log_9n$ æ‰€ä»¥ $log_2n$ ã€$log_9n$ ç»Ÿç§°ä¸º$logn$ å¸¸è§çš„å¤æ‚åº¦ æ‰§è¡Œæ¬¡æ•° å¤æ‚åº¦ éæ­£å¼æœ¯è¯­ $12$ $O(1)$ å¸¸æ•°é˜¶ $2n + 3$ $O(n)$ çº¿æ€§é˜¶ $4n^2 + 2n + 6$ $O(n^2)$ å¹³æ–¹é˜¶ $4log_2n + 25$ $O(logn)$ å¯¹æ•°é˜¶ $3n + 2nlog_3n + 15$ $O(nlogn)$ $nlogn$é˜¶ $4n^3 + 3n^2 + 22n + 100$ $O(n^3)$ ç«‹æ–¹é˜¶ $2^n$ $O(2n)$ æŒ‡æ•°é˜¶ $O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n_n)$ ç®—æ³•çš„ä¼˜åŒ–æ–¹å‘ç”¨å°½é‡å°‘çš„å­˜å‚¨ç©ºé—´ ç”¨å°½é‡å°‘çš„æ‰§è¡Œæ­¥éª¤ï¼ˆæ‰§è¡Œæ—¶é—´ï¼‰ æ ¹æ®æƒ…å†µï¼Œå¯ä»¥ ç©ºé—´æ¢æ—¶é—´ æ—¶é—´æ¢ç©ºé—´]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAå­¦ä¹ è·¯çº¿]]></title>
    <url>%2F2019%2F09%2F17%2FJAVA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[JAVAå­¦ä¹ è·¯çº¿1. è¯­è¨€çš„å…¥é—¨å’Œè¿›é˜¶ JavaåŸºç¡€è¯­æ³•,OOç¼–ç¨‹æ€æƒ³, é›†åˆ, IO, å¼‚å¸¸, æ³›å‹, åå°„, å¤šçº¿ç¨‹, å‡½æ•°å¼ 2. WebåŸºç¡€å’Œå·¥å…· å‰ç«¯åŸºç¡€(html/javascript/css) jquery, ajax, jsp , cookie, session httpåŸºç¡€ servletåŸºç¡€ git, svn ä»£ç ç®¡ç†å·¥å…· 3. ä¼ä¸šçº§åº”ç”¨æ¡†æ¶ maven/gradleé¡¹ç›®ç®¡ç†å·¥å…· Springå…¨å®¶æ¡¶(Spring, Spring MVC, Spring Boot) å…³ç³»å‹æ•°æ®åº“ç›¸å…³(MySQL, jdbc, MyBatis, Hibernate) éå…³ç³»å‹æ•°æ®åº“(Redis) æ¨¡æ¿å¼•æ“(thymeleaf, freemarker) 4. é«˜çº§åº”ç”¨æ¡†æ¶ æœç´¢å¼•æ“(elastic search) RPCkæ¡†æ¶(Dubbo, Spring Cloud) ä¸­é—´ä»¶æŠ€æœ¯(RabbitMQ, RocketMQ, ActiveMQ, Kafka) è™šæ‹ŸåŒ–æŠ€æœ¯(Docker, Kubernetes) 5. é«˜çº§è¯é¢˜ jvmä¼˜åŒ–å’Œæ’é”™, GCåˆ†æ, æ•°æ®åº“é«˜çº§ä¼˜åŒ–]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>å­¦ä¹ è·¯çº¿</tag>
      </tags>
  </entry>
</search>
